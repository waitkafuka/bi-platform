/**
 * xui
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:   工程基础
 * @author:  sushuang(sushuang@baidu.com)
 */

/**
 * @namespace
 */
var xui = {};
/**
 * xui.XPorject
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    一种Javascript工程组织方法
 *          [功能]
 *              (1) 各级名空间建立
 *              (2) 交叉引用/文件依赖的一种解决方案（闭包变量注入）
 * @author:  sushuang(sushuang@baidu.com)
 * @version: 1.0.1
 */

/**
 * @usage [引入XProject]
 *          为了在代码中方便使用XProject提供的方法，
 *          可以在工程开始时在全局定义方法的别名。
 *
 *          例如：
 *          window.$ns = xui.XProject.namespace;
 *          window.$link = xui.XProject.link;
 *          （下文中为书写简便假设已经做了如上别名定义）
 * 
 * @usage [名空间建立]
 *          假设准备建立一个类：
 *
 *          // 直接建立了名空间
 *          $ns('aaa.bbb.ccc');
 *  
 *          // 类的构造函数
 *          aaa.bbb.ccc.SomeClass = function () {
 *              // do something ...
 *          }
 *
 *          或者直接：
 *          // 类的构造函数
 *          $ns('aaa.bbb.ccc').SomeClass = function () { 
 *              // do something ...
 *          }
 *
 *          或者这种风格：
 *          // 文件开头声明名空间
 *          $ns('aaa.bbb.ccc'); 
 *          (function () {
 *              // $ns()会返回最近一次声明名空间的结果
 *              $ns().SomeClass = function () { 
 *                  // do something ...
 *              }
 *          })();
 *        
 * @usage [依赖/交叉引用/link]
 *          工程中对象的交叉引用不在这里考虑，
 *          这里考虑的是类型/全局结构定义阶段的交叉引用，
 *          如下例类型定义时：
 *
 *          (function () {
 *              // 在闭包中定义外部引用的类，
 *              // 这么做的好处至少有：方便压缩，易适应路径改动，代码简洁。
 *              var OTHER_CONTROL1 = aaa.bbb.SomeClass;
 *              var OTHER_SERVICE2 = tt.ee.SomeService;
 *              var OTHER_MODEL3 = qq.uu.ii.SomeModel;
 *              
 *              // 构造函数，定义本类
 *              $ns('aaa.bb').MyControl = function () { 
 *                  this.otherControl = new OTHER_CONTROL();
 *                  ...
 *              }
 *              ...
 *          })();
 *          这种情况下，如果多个类互相有引用（形成闭环），
 *          则不知道如何排文件顺序，来使闭包中的类型/函数引用OK，
 *          而C++/Java等常用的编译型面向对象语言都默认支持不需关心这些问题。
 * 
 *          这里使用这种解决方式：
 *          (function () {
 *              // 先在闭包中声明
 *              var OTHER_CONTROL1, OTHER_SERVICE2, OTHER_MODEL3;
 *              // 连接
 *              $link(function () {
 *                  OTHER_CONTROL1 = aaa.bbb.SomeClass;
 *                  OTHER_SERVICE2 = tt.ee.SomeService;
 *                  OTHER_MODEL3 = qq.uu.ii.SomeModel;
 *              });
 *              //构造函数，定义本类
 *              $ns('aa.bb').MyControl = function () { 
 *                  this.otherControl = new OTHER_CONTROL();
 *                  // ...
 *              }
 *              // ...
 *          })();
 *            
 *          在所有文件的最后，调用xui.XProject.doLink()，则实际注入所有的引用。
 */

(function () {
    
    var XPROJECT = xui.XProject = {};
    var NS_BASE = window;
    var TRIMER = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );

    /**
     * 延迟执行函数的集合
     *
     * @type {Array.<Function>}
     * @private
     */
    var linkSet = [];
    /**
     * 最终执行的函数集合
     *
     * @type {Array.<Function>}
     * @private
     */
    var endSet = [];
    /**
     * 最近一次的名空间
     *
     * @type {Object}
     * @private
     */
    var lastNameSpace;
    
    /**
     * (1) 创建名空间：如调用namespace("aaa.bbb.ccc")，如果不存在，则建立。
     * (2) 获得指定名空间：如上，如果存在NS_BASE.aaa.bbb.ccc，则返回。
     * (3) 获得最近一次声明的名空间：调用namespace()，不传参数，
     *      则返回最近一次调用namespace（且isRecord参数不为false）得到的结果
     * 
     * NS_BASE默认是window (@see setNamespaceBase)。 
     *
     * @public
     * @param {string=} namespacePath 名空间路径，
     *              以"."分隔，如"aaa.bbb.ccc"，
     *              如果不传参，则返回最近一次调用结果。
     * @param {boolean} isRecord 是否记录此次调用结果，缺省则表示true
     * @return {Object} 名空间对象
     */
    XPROJECT.namespace = function (namespacePath, isRecord) {
        if (arguments.length == 0) {
            return lastNameSpace;
        }
        
        var context = NS_BASE;
        var pathArr = parseInput(namespacePath).split('.');
        for (var i = 0 ;i < pathArr.length; i ++) {
            context = getOrCreateObj(context, parseInput(pathArr[i]));
        }
        
        if (isRecord !== false) {
            lastNameSpace = context
        }
        
        return context;
    };
    
    /**
     * 注册一个连接
     *
     * @public
     * @param {Function} func 链接函数
     */
    XPROJECT.link = function (func) {
        if (!isFunction(func)) {
            throw new Error (
                'Input of link must be a function but not ' + func
            );
        }
        linkSet.push(func);
    };
    
    /**
     * 执行所有连接并清空注册
     *
     * @public
     */
    XPROJECT.doLink = function () {
        for(var i = 0, o; o = linkSet[i]; i++) {
            o.call(null);
        }
        linkSet = []; 
    };
    
    /**
     * 注册一个最后执行的函数
     *
     * @public
     * @param {Function} func 链接函数
     */
    XPROJECT.end = function (func) {
        if (!isFunction(func)) {
            throw new Error (
                'Input of link must be a function but not ' + func
            );
        }
        endSet.push(func);
    };
    
    /**
     * 执行所有最后执行的注册并清空注册
     *
     * @public
     */
    XPROJECT.doEnd = function () {
        for(var i = 0, o; o = endSet[i]; i++) {
            o.call(null);
        }
        endSet = []; 
    };
    
    /**
     * 设置名空间查找根基，默认是window
     *
     * @public
     * @param {Object} namespaceBase 名空间根基
     */
    XPROJECT.setNamespaceBase = function (namespaceBase) {
        namespaceBase && (NS_BASE = namespaceBase);
    };

    /**
     * 得到名空间查找根基，默认是window
     *
     * @public
     * @return {Object} 名空间根基
     */
    XPROJECT.getNamespaceBase = function () {
        return NS_BASE;
    };
    
    /**
     * Parse输入
     *
     * @private
     * @param {string} input 输入
     * @return {boolean} parse结果
     */
    function parseInput(input) {
        var o;
        if ((o = trim(input)) == '') {
            throw new Error('Error input: ' + str);   
        } 
        else {
            return o;
        }
    }
    
    /**
     * 创建及获得路径对象
     *
     * @private
     * @param {Object} context 上下文
     * @param {string} attrName 属性名
     * @return {Object} 得到的对象
     */
    function getOrCreateObj(context, attrName) {
        var o = context[attrName];
        return o != null ? o : (context[attrName] = {});
    }
    
    /**
     * 是否函数
     *
     * @private
     * @param {*} variable 输入
     * @return {boolean} 是否函数
     */
    function isFunction(variable) {
        return Object.prototype.toString.call(variable) == '[object Function]';
    }
    
    /**
     * 字符串trim
     *
     * @private
     * @param {string} 输入
     * @return {string} 结果
     */
    function trim(source) {
        return source == null ? '' : String(source).replace(TRIMER, '');
    }
    
})();

// Copyright (c) 2009, Baidu Inc. All rights reserved.
// 
// Licensed under the BSD License
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//      http:// tangram.baidu.com/license.html
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
 /**
 * @namespace T Tangram七巧板
 * @name T
 * @version 1.5.2.2
*/

/**
 * 修改点：
 * ajax加入 charset=UTF-8
 */

/**
 * 声明baidu包
 * @author: allstar, erik, meizz, berg
 */
var T,
    baidu = T = baidu || {version: "1.5.2.2"}; 

//提出guid，防止在与老版本Tangram混用时
//在下一行错误的修改window[undefined]
baidu.guid = "$BAIDU$";

//Tangram可能被放在闭包中
//一些页面级别唯一的属性，需要挂载在window[baidu.guid]上
baidu.$$ = window[baidu.guid] = window[baidu.guid] || {global:{}};

/**
 * 对XMLHttpRequest请求的封装
 * @namespace baidu.ajax
 */
baidu.ajax = baidu.ajax || {};

/**
 * 对方法的操作，解决内存泄露问题
 * @namespace baidu.fn
 */
baidu.fn = baidu.fn || {};


/**
 * 这是一个空函数，用于需要排除函数作用域链干扰的情况.
 * @author rocy
 * @name baidu.fn.blank
 * @function
 * @grammar baidu.fn.blank()
 * @meta standard
 * @return {Function} 一个空函数
 * @version 1.3.3
 */
baidu.fn.blank = function () {};


/**
 * 发送一个ajax请求
 * @author: allstar, erik, berg
 * @name baidu.ajax.request
 * @function
 * @grammar baidu.ajax.request(url[, options])
 * @param {string} 	url 发送请求的url
 * @param {Object} 	options 发送请求的选项参数
 * @config {String} 	[method] 			请求发送的类型。默认为GET
 * @config {Boolean}  [async] 			是否异步请求。默认为true（异步）
 * @config {String} 	[data] 				需要发送的数据。如果是GET请求的话，不需要这个属性
 * @config {Object} 	[headers] 			要设置的http request header
 * @config {number}   [timeout]       超时时间，单位ms
 * @config {String} 	[username] 			用户名
 * @config {String} 	[password] 			密码
 * @config {Function} [onsuccess] 		请求成功时触发，function(XMLHttpRequest xhr, string responseText)。
 * @config {Function} [onfailure] 		请求失败时触发，function(XMLHttpRequest xhr)。
 * @config {Function} [onbeforerequest]	发送请求之前触发，function(XMLHttpRequest xhr)。
 * @config {Function} [on{STATUS_CODE}] 	当请求为相应状态码时触发的事件，如on302、on404、on500，function(XMLHttpRequest xhr)。3XX的状态码浏览器无法获取，4xx的，可能因为未知问题导致获取失败。
 * @config {Boolean}  [noCache] 			是否需要缓存，默认为false（缓存），1.1.1起支持。
 * 
 * @meta standard
 * @see baidu.ajax.get,baidu.ajax.post,baidu.ajax.form
 *             
 * @returns {XMLHttpRequest} 发送请求的XMLHttpRequest对象
 */
baidu.ajax.request = function (url, opt_options) {
    var options     = opt_options || {},
        data        = options.data || "",
        async       = !(options.async === false),
        username    = options.username || "",
        password    = options.password || "",
        method      = (options.method || "GET").toUpperCase(),
        headers     = options.headers || {},
        // 基本的逻辑来自lili同学提供的patch
        timeout     = options.timeout || 0,
        eventHandlers = {},
        tick, key, xhr;

    /**
     * readyState发生变更时调用
     * 
     * @ignore
     */
    function stateChangeHandler() {
        if (xhr.readyState == 4) {
            try {
                var stat = xhr.status;
            } catch (ex) {
                // 在请求时，如果网络中断，Firefox会无法取得status
                fire('failure');
                return;
            }
            
            fire(stat);
            
            // http://www.never-online.net/blog/article.asp?id=261
            // case 12002: // Server timeout      
            // case 12029: // dropped connections
            // case 12030: // dropped connections
            // case 12031: // dropped connections
            // case 12152: // closed by server
            // case 13030: // status and statusText are unavailable
            
            // IE error sometimes returns 1223 when it 
            // should be 204, so treat it as success
            if ((stat >= 200 && stat < 300)
                || stat == 304
                || stat == 1223) {
                fire('success');
            } else {
                fire('failure');
            }
            
            /*
             * NOTE: Testing discovered that for some bizarre reason, on Mozilla, the
             * JavaScript <code>XmlHttpRequest.onreadystatechange</code> handler
             * function maybe still be called after it is deleted. The theory is that the
             * callback is cached somewhere. Setting it to null or an empty function does
             * seem to work properly, though.
             * 
             * On IE, there are two problems: Setting onreadystatechange to null (as
             * opposed to an empty function) sometimes throws an exception. With
             * particular (rare) versions of jscript.dll, setting onreadystatechange from
             * within onreadystatechange causes a crash. Setting it from within a timeout
             * fixes this bug (see issue 1610).
             * 
             * End result: *always* set onreadystatechange to an empty function (never to
             * null). Never set onreadystatechange from within onreadystatechange (always
             * in a setTimeout()).
             */
            window.setTimeout(
                function() {
                    // 避免内存泄露.
                    // 由new Function改成不含此作用域链的 baidu.fn.blank 函数,
                    // 以避免作用域链带来的隐性循环引用导致的IE下内存泄露. By rocy 2011-01-05 .
                    xhr.onreadystatechange = baidu.fn.blank;
                    if (async) {
                        xhr = null;
                    }
                }, 0);
        }
    }
    
    /**
     * 获取XMLHttpRequest对象
     * 
     * @ignore
     * @return {XMLHttpRequest} XMLHttpRequest对象
     */
    function getXHR() {
        if (window.ActiveXObject) {
            try {
                return new ActiveXObject("Msxml2.XMLHTTP");
            } catch (e) {
                try {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                } catch (e) {}
            }
        }
        if (window.XMLHttpRequest) {
            return new XMLHttpRequest();
        }
    }
    
    /**
     * 触发事件
     * 
     * @ignore
     * @param {String} type 事件类型
     */
    function fire(type) {
        type = 'on' + type;
        var handler = eventHandlers[type],
            globelHandler = baidu.ajax[type];
        
        // 不对事件类型进行验证
        if (handler) {
            if (tick) {
              clearTimeout(tick);
            }

            if (type != 'onsuccess') {
                handler(xhr);
            } else {
                //处理获取xhr.responseText导致出错的情况,比如请求图片地址.
                try {
                    xhr.responseText;
                } catch(error) {
                    return handler(xhr);
                }
                handler(xhr, xhr.responseText);
            }
        } else if (globelHandler) {
            //onsuccess不支持全局事件
            if (type == 'onsuccess') {
                return;
            }
            globelHandler(xhr);
        }
    }
    
    
    for (key in options) {
        // 将options参数中的事件参数复制到eventHandlers对象中
        // 这里复制所有options的成员，eventHandlers有冗余
        // 但是不会产生任何影响，并且代码紧凑
        eventHandlers[key] = options[key];
    }
    
    headers['X-Requested-With'] = 'XMLHttpRequest';
    
    
    try {
        xhr = getXHR();
        
        if (method == 'GET') {
            if (data) {
                url += (url.indexOf('?') >= 0 ? '&' : '?') + data;
                data = null;
            }
            if(options['noCache'])
                url += (url.indexOf('?') >= 0 ? '&' : '?') + 'b' + (+ new Date) + '=1';
        }
        
        if (username) {
            xhr.open(method, url, async, username, password);
        } else {
            xhr.open(method, url, async);
        }
        
        if (async) {
            xhr.onreadystatechange = stateChangeHandler;
        }
        
        // 在open之后再进行http请求头设定
        // FIXME 是否需要添加; charset=UTF-8呢
        if (method == 'POST') {
            xhr.setRequestHeader("Content-Type",
                (headers['Content-Type'] || "application/x-www-form-urlencoded; charset=UTF-8"));
        }
        
        for (key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
        
        fire('beforerequest');

        if (timeout) {
          tick = setTimeout(function(){
            xhr.onreadystatechange = baidu.fn.blank;
            xhr.abort();
            fire("timeout");
          }, timeout);
        }
        xhr.send(data);
        
        if (!async) {
            stateChangeHandler();
        }
    } catch (ex) {
        fire('failure');
    }
    
    return xhr;
};


/**
 * 发送一个get请求
 * @name baidu.ajax.get
 * @function
 * @grammar baidu.ajax.get(url[, onsuccess])
 * @param {string} 	url 		发送请求的url地址
 * @param {Function} [onsuccess] 请求成功之后的回调函数，function(XMLHttpRequest xhr, string responseText)
 * @meta standard
 * @see baidu.ajax.post,baidu.ajax.request
 *             
 * @returns {XMLHttpRequest} 	发送请求的XMLHttpRequest对象
 */
baidu.ajax.get = function (url, onsuccess) {
    return baidu.ajax.request(url, {'onsuccess': onsuccess});
};

/**
 * 发送一个post请求
 * @name baidu.ajax.post
 * @function
 * @grammar baidu.ajax.post(url, data[, onsuccess])
 * @param {string} 	url 		发送请求的url地址
 * @param {string} 	data 		发送的数据
 * @param {Function} [onsuccess] 请求成功之后的回调函数，function(XMLHttpRequest xhr, string responseText)
 * @meta standard
 * @see baidu.ajax.get,baidu.ajax.request
 *             
 * @returns {XMLHttpRequest} 	发送请求的XMLHttpRequest对象
 */
baidu.ajax.post = function (url, data, onsuccess) {
    return baidu.ajax.request(
        url, 
        {
            'onsuccess': onsuccess,
            'method': 'POST',
            'data': data
        }
    );
};

/**
 * 操作json对象的方法
 * @namespace baidu.json
 */
baidu.json = baidu.json || {};


/**
 * 将json对象序列化
 * @name baidu.json.stringify
 * @function
 * @grammar baidu.json.stringify(value)
 * @param {JSON} value 需要序列化的json对象
 * @remark
 * 该方法的实现与ecma-262第五版中规定的JSON.stringify不同，暂时只支持传入一个参数。后续会进行功能丰富。
 * @meta standard
 * @see baidu.json.parse,baidu.json.encode
 *             
 * @returns {string} 序列化后的字符串
 */
baidu.json.stringify = (function () {
    /**
     * 字符串处理时需要转义的字符表
     * @private
     */
    var escapeMap = {
        "\b": '\\b',
        "\t": '\\t',
        "\n": '\\n',
        "\f": '\\f',
        "\r": '\\r',
        '"' : '\\"',
        "\\": '\\\\'
    };
    
    /**
     * 字符串序列化
     * @private
     */
    function encodeString(source) {
        if (/["\\\x00-\x1f]/.test(source)) {
            source = source.replace(
                /["\\\x00-\x1f]/g, 
                function (match) {
                    var c = escapeMap[match];
                    if (c) {
                        return c;
                    }
                    c = match.charCodeAt();
                    return "\\u00" 
                            + Math.floor(c / 16).toString(16) 
                            + (c % 16).toString(16);
                });
        }
        return '"' + source + '"';
    }
    
    /**
     * 数组序列化
     * @private
     */
    function encodeArray(source) {
        var result = ["["], 
            l = source.length,
            preComma, i, item;
            
        for (i = 0; i < l; i++) {
            item = source[i];
            
            switch (typeof item) {
            case "undefined":
            case "function":
            case "unknown":
                break;
            default:
                if(preComma) {
                    result.push(',');
                }
                result.push(baidu.json.stringify(item));
                preComma = 1;
            }
        }
        result.push("]");
        return result.join("");
    }
    
    /**
     * 处理日期序列化时的补零
     * @private
     */
    function pad(source) {
        return source < 10 ? '0' + source : source;
    }
    
    /**
     * 日期序列化
     * @private
     */
    function encodeDate(source){
        return '"' + source.getFullYear() + "-" 
                + pad(source.getMonth() + 1) + "-" 
                + pad(source.getDate()) + "T" 
                + pad(source.getHours()) + ":" 
                + pad(source.getMinutes()) + ":" 
                + pad(source.getSeconds()) + '"';
    }
    
    return function (value) {
        switch (typeof value) {
        case 'undefined':
            return 'undefined';
            
        case 'number':
            return isFinite(value) ? String(value) : "null";
            
        case 'string':
            return encodeString(value);
            
        case 'boolean':
            return String(value);
            
        default:
            if (value === null) {
                return 'null';
            } else if (value instanceof Array) {
                return encodeArray(value);
            } else if (value instanceof Date) {
                return encodeDate(value);
            } else {
                var result = ['{'],
                    encode = baidu.json.stringify,
                    preComma,
                    item;
                    
                for (var key in value) {
                    if (Object.prototype.hasOwnProperty.call(value, key)) {
                        item = value[key];
                        switch (typeof item) {
                        case 'undefined':
                        case 'unknown':
                        case 'function':
                            break;
                        default:
                            if (preComma) {
                                result.push(',');
                            }
                            preComma = 1;
                            result.push(encode(key) + ':' + encode(item));
                        }
                    }
                }
                result.push('}');
                return result.join('');
            }
        }
    };
})();

/**
 * 将字符串解析成json对象。注：不会自动祛除空格
 * @name baidu.json.parse
 * @function
 * @grammar baidu.json.parse(data)
 * @param {string} source 需要解析的字符串
 * @remark
 * 该方法的实现与ecma-262第五版中规定的JSON.parse不同，暂时只支持传入一个参数。后续会进行功能丰富。
 * @meta standard
 * @see baidu.json.stringify,baidu.json.decode
 *             
 * @returns {JSON} 解析结果json对象
 */
baidu.json.parse = function (data) {
    //2010/12/09：更新至不使用原生parse，不检测用户输入是否正确
    return (new Function("return (" + data + ")"))();
};

/**
 * 将json对象序列化，为过时接口，今后会被baidu.json.stringify代替
 * @name baidu.json.encode
 * @function
 * @grammar baidu.json.encode(value)
 * @param {JSON} value 需要序列化的json对象
 * @meta out
 * @see baidu.json.decode,baidu.json.stringify
 *             
 * @returns {string} 序列化后的字符串
 */
baidu.json.encode = baidu.json.stringify;

/**
 * 将字符串解析成json对象，为过时接口，今后会被baidu.json.parse代替
 * @name baidu.json.decode
 * @function
 * @grammar baidu.json.decode(source)
 * @param {string} source 需要解析的字符串
 * @meta out
 * @see baidu.json.encode,baidu.json.parse
 *             
 * @returns {JSON} 解析结果json对象
 */
baidu.json.decode = baidu.json.parse;

/**
 * 判断浏览器类型和特性的属性
 * @namespace baidu.browser
 */
baidu.browser = baidu.browser || {};


(function(){
    var ua = navigator.userAgent;
    /*
     * 兼容浏览器为safari或ipad,其中,一段典型的ipad UA 如下:
     * Mozilla/5.0(iPad; U; CPU iPhone OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Version/4.0.4 Mobile/7B314 Safari/531.21.10
     */
    
    /**
     * 判断是否为safari浏览器, 支持ipad
     * @property safari safari版本号
     * @grammar baidu.browser.safari
     * @meta standard
     * @see baidu.browser.ie,baidu.browser.firefox,baidu.browser.opera,baidu.browser.chrome   
     */
    baidu.browser.safari = /(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(ua) && !/chrome/i.test(ua) ? + (RegExp['\x241'] || RegExp['\x242']) : undefined;
})();

//IE 8下，以documentMode为准
//在百度模板中，可能会有$，防止冲突，将$1 写成 \x241
/**
 * 判断是否为ie浏览器
 * @name baidu.browser.ie
 * @field
 * @grammar baidu.browser.ie
 * @returns {Number} IE版本号
 */
baidu.browser.ie = baidu.ie = /msie (\d+\.\d+)/i.test(navigator.userAgent) ? (document.documentMode || + RegExp['\x241']) : undefined;

/**
 * 判断是否为opera浏览器
 * @property opera opera版本号
 * @grammar baidu.browser.opera
 * @meta standard
 * @see baidu.browser.ie,baidu.browser.firefox,baidu.browser.safari,baidu.browser.chrome
 * @returns {Number} opera版本号
 */

/**
 * opera 从10开始不是用opera后面的字符串进行版本的判断
 * 在Browser identification最后添加Version + 数字进行版本标识
 * opera后面的数字保持在9.80不变
 */
baidu.browser.opera = /opera(\/| )(\d+(\.\d+)?)(.+?(version\/(\d+(\.\d+)?)))?/i.test(navigator.userAgent) ?  + ( RegExp["\x246"] || RegExp["\x242"] ) : undefined;

/**
 * 操作dom的方法
 * @namespace baidu.dom 
 */
baidu.dom = baidu.dom || {};


/**
 * 使函数在页面dom节点加载完毕时调用
 * @author allstar
 * @name baidu.dom.ready
 * @function
 * @grammar baidu.dom.ready(callback)
 * @param {Function} callback 页面加载完毕时调用的函数.
 * @remark
 * 如果有条件将js放在页面最底部, 也能达到同样效果，不必使用该方法。
 * @meta standard
 */
(function() {

    var ready = baidu.dom.ready = function() {
        var readyBound = false,
            readyList = [],
            DOMContentLoaded;

        if (document.addEventListener) {
            DOMContentLoaded = function() {
                document.removeEventListener('DOMContentLoaded', DOMContentLoaded, false);
                ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function() {
                if (document.readyState === 'complete') {
                    document.detachEvent('onreadystatechange', DOMContentLoaded);
                    ready();
                }
            };
        }
        /**
         * @private
         */
        function ready() {
            if (!ready.isReady) {
                ready.isReady = true;
                for (var i = 0, j = readyList.length; i < j; i++) {
                    readyList[i]();
                }
            }
        }
        /**
         * @private
         */
        function doScrollCheck(){
            try {
                document.documentElement.doScroll("left");
            } catch(e) {
                setTimeout( doScrollCheck, 1 );
                return;
            }   
            ready();
        }
        /**
         * @private
         */
        function bindReady() {
            if (readyBound) {
                return;
            }
            readyBound = true;

            if (document.readyState === 'complete') {
                ready.isReady = true;
            } else {
                if (document.addEventListener) {
                    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);
                    window.addEventListener('load', ready, false);
                } else if (document.attachEvent) {
                    document.attachEvent('onreadystatechange', DOMContentLoaded);
                    window.attachEvent('onload', ready);

                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) {}

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            }
        }
        bindReady();

        return function(callback) {
            ready.isReady ? callback() : readyList.push(callback);
        };
    }();

    ready.isReady = false;
})();
;T.undope=true;
/*
 * e-json
 * Copyright 2010 Baidu Inc. All rights reserved.
 * 
 * path:          e-json.js
 * desc:          提供E-JSON标准格式的请求与解析功能
 * author:        erik
 * depend:        baidu.ajax.request, baidu.json.parse
 * modification:  (1) 修改status在fail时可能为0的bug
 *                (2) 返回值非json而是各种html页面时不抛异常，这样就可以使后台统一定制失效页面，不同json非json分别处理 
 *                (by sushuang)
 */

/**
 * E-JSON标准格式的请求与解析功能
 */
baidu.ejson = function () {

    DEFAULT_ERROR_STATUS = 99999;

    /**
     * 发送一个数据格式为E-JSON标准的请求
     *
     * @inner
     */
    function request(url, options) {
        var onsuccess = options.onsuccess;
        var onfailure = options.onfailure;

        // 包装baidu.ajax.request的success回调
        options.onsuccess = function (xhr) {
            process(xhr.responseText, onsuccess, onfailure);
            options = null;
        };

        // 状态码异常时，触发e-json的proccess，status为请求返回的状态码
        options.onfailure = function (xhr) {
            process({
                    status: (xhr.status || DEFAULT_ERROR_STATUS), // 当abort时，以及一些浏览器302时，xhr.stauts为0且tangram会走onfailure, 故此处也应强制走onfailure
                    statusInfo: xhr.statusText,
                    data: xhr.responseText
                },
                onsuccess,
                onfailure);
            options = null;
        };

        return baidu.ajax.request(url, options);
    }

    /**
     * 解析处理E-JSON标准的数据
     *
     * @inner
     */ 
    function process(source, onsuccess, onfailure) {
        onfailure = onfailure || new Function();
        onsuccess = onsuccess || new Function();

//        //测试用，防止自定义用例不符合json规范，正式联调时去掉
//        baidu.json.parse = function(source){
//            return eval("(" + source + ")");
//        };
//        
        var obj;
        try { 
            obj = typeof source == 'string' ? baidu.json.parse(source) : source;
        } catch (e) { 
            // source可能为异常页面的HTML，用catch处理这类情况
            obj = source;
        }
        
        // 不存在值或不为Object时，认为是failure状态，状态码为普通异常
        if (!obj || typeof obj != 'object') {
            onfailure(1, obj);
            return;
        }

        // 请求状态正常
        if (!obj.status) {
            onsuccess(obj.data, obj);
        } else {
            onfailure(obj.status, obj);
        }
    }
 
    return {        
        DEFAULT_ERROR_STATUS: DEFAULT_ERROR_STATUS,

        /**
         * 发送一个数据格式为E-JSON标准的请求
         * 
         * @public
         * @param {string} url 发送请求的url
         * @param {Object} options 发送请求的可选参数
         */
        request: request,
        
        /**
         * 通过get的方式请求E-JSON标准的数据
         * 
         * @public
         * @param {string}   url 发送请求的url
         * @param {Function} onsuccess 状态正常的处理函数，(data字段值，整体数据)
         * @param {Function} onfailure 状态异常的处理函数，(异常状态码，整体数据)
         */
        get: function (url, onsuccess, onfailure) {
            request(url, 
                {
                    method      : 'get', 
                    onsuccess   : onsuccess, 
                    onfailure   : onfailure
                });
        },
        
        /**
         * 通过post的方式请求E-JSON标准的数据
         *
         * @public
         * @param {string} url         发送请求的url
         * @param {string} postData    post发送的数据
         * @param {Function} onsuccess 状态正常的处理函数，(data字段值，整体数据)
         * @param {Function} onfailure 状态异常的处理函数，(异常状态码，整体数据)
         */
        post: function (url, postData, onsuccess, onfailure) {
            return request(url, 
                {
                    method      : 'post', 
                    data        : postData, 
                    onsuccess   : onsuccess, 
                    onfailure   : onfailure
                });
        },

        /**
         * 解析处理E-JSON标准的数据
         *
         * @public
         * @param {string|Object}   source    数据对象或字符串形式
         * @param {Function}        onsuccess 状态正常的处理函数，(data字段值，整体数据)
         * @param {Function}        onfailure 状态异常的处理函数，(异常状态码，整体数据)
         */
        process: process
    };
}();



/**
 * xutil
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    工程直接使用的工具集
 *          在基础提供的工具函数之外，可根据每个工程需要添加工具函数
 * @author:  sushuang(sushuang@baidu.com)
 */

/**
 * @namespace
 */
var xutil = {
    lang: {},
    number: {},
    string: {},
    fn: {},
    object: {},
    date: {},
    url: {},
    collection: {},
    file: {},
    dom: {},
    uid: {},
    graphic: {},
    ajax: {}
};
/**
 * xutil.LinkedHashMap
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    节点有序的哈希表
 *           为哈希表提供线性表能力，适合管理有唯一性id的数据集合，
 *           做为队列、链表等结构使用
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

/**
 * @usage 
 *    (1) 作为HashMap
 *        var h1 = new LinkedHashMap();
 *        h1.set('name', 'ss');
 *        h1.set('age', 123);
 *        var name = h1.get('name');
 * 
 *    (2) 作为数组、链表（支持环链表，见next、previous方法）、队列
 *        // 从id字段中取值做为HashMap的key
 *        var h2 = new LinkedHashMap(null, 'id'); 
 *        h2.addLast({ id: 23, name: 'ss' });
 *        h2.addFirst({ id: 34, name: 'bbb' });
 *        h2.appendAll(
 *          [
 *              { id: 99, name: 'xx' }, 
 *              { id: 543, name: 'trr' }
 *          ]
 *        );
 *        // 得到{id:23, name: 'ss'}
 *        var data1 = h2.get(23); 
 *        // 得到{id: 23, name: 'ss'}，按index取值
 *        var data2 = h2.getAt(1); 
 *        // 得到{id: 34, name: 'bbb'}
 *        var data3 = h2.first(); 
 *        // 遍历
 *        foreach(function(key, item, index) { ... }) 
 * 
 *    (3) 从list中自动取得key，value初始化
 *        // 如下设置为自动从'id'字段中取值做为HashMap的key，
 *        // 以{id: 55, name: 'aa'}整个为数据项
 *        var h3 = new LinkedHashMap([{ id: 55, name: 'aa' }], 'id');
 *        h3.addLast({ id: 23, name: 'ss' });
 *        // 如下设置为自动从id字段中取值做为HashMap的key，
 *        // 以name字段值做为数据项
 *        var h4 = new LinkedHashMap(null, 'id', 'name');
 *        h4.addLast({ id: 23, name: 'ss' });
 *        h4.addFirst('bb', 24); //同样效果
 */
(function () {

    var namespace = xutil;
    
    /**
     * 构造函数
     * 可构造空LinkedHashMap，也可以list进行初始化
     * 
     * @public
     * @constructor
     * @param {Array.<Object>} list 初始化列表
     *          为null则得到空LinkedHashMap
     * @param {(string|Function)=} defautlKeyAttr 
     *          表示list每个节点的哪个字段要做为HashMap的key，可缺省，
     *          如果为Function：
     *              param {*} list的每个节点
     *              return {*} HashMap的key
     * @param {(string|Function)=} defaultValueAttr 
     *          表示list每个节点的哪个字段要做为HashMap的value，可缺省，
     *          缺省则取list每个节点本身做为HashMap的value
     *          如果为Function：
     *              param {*} list的每个节点
     *              return {*} HashMap的value
     * @return {LinkedHashMap} 返回新实例
     */
    var LINKED_HASH_MAP = namespace.LinkedHashMap = 
            function (list, defautlKeyAttr, defaultValueAttr) {
                this._oMap = {};
                this._oHead = null;
                this._oTail = null;
                this._nLength = 0;
                this.setDefaultAttr(defautlKeyAttr, defaultValueAttr);
                list && this.appendAll(list);
            };
    var LINKED_HASH_MAP_CLASS = LINKED_HASH_MAP.prototype;

    /**
     * 设置defautlKeyAttr和defaultValueAttr
     *
     * @public
     * @param {(string|Function)=} defautlKeyAttr 参见构造函数中描述
     * @param {(string|Function)=} defaultValueAttr 参见构造函数中描述
     */
    LINKED_HASH_MAP_CLASS.setDefaultAttr = function (
        defautlKeyAttr, defaultValueAttr
    ) {
        this._sDefaultKeyAttr = defautlKeyAttr;
        this._sDefaultValueAttr = defaultValueAttr;
    };

    /**
     * 批量在最后追加数据
     * 
     * @public
     * @param {Array} list 要增加的列表
     * @param {(string|Function)=} keyAttr 
     *      表示list每个节点的哪个字段要做为HashMap的key，
     *      缺省则按defautlKeyAttr从list每个节点中取key
     * @param {(string|Function)=} valueAttr 
     *      表示list每个节点的哪个字段要做为HashMap的value，
     *      缺省则按defautlValueAttr从list每个节点中取value，
     *      无defautlValueAttr则取list每个节点本身做为HashMap的value
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.appendAll = function (list, keyAttr, valueAttr) {
        keyAttr == null && (keyAttr = this._sDefaultKeyAttr);
        if (keyAttr == null) { return this; }
        valueAttr == null && (valueAttr = this._sDefaultValueAttr);

        list = list || [];
        for (var i = 0, len = list.length, item; i < len; i ++) {
            if (!(item = list[i])) { continue; }
            this.addLast(
                this.$retieval(item, valueAttr), 
                this.$retieval(item, keyAttr)
            );
        }
        return this;
    };

    /**
     * 在最后增加
     * 用法一：
     *      my.addLast('asdf', 11)
     *      11为key，'asdf'为value
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.addLast({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.addLast({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传两个参数则表示用法一，
     * 传一个参数则表示用法二、三（即不传key参数）
     *
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key HashMap的关键字
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.addLast = function (item, key) {
        if (key == null) {
            // 用法一
            key = this.$retieval(item, this._sDefaultKeyAttr);
            item = this.$retieval(item, this._sDefaultValueAttr);
        }

        var node = { key: key, item: item, pre: null, next: null }; 
        this._oMap[key] = node;
        this.$insert(node, this._oTail, null);
        return this;
    };

    /**
     * 在最前增加
     * 用法一：
     *      my.addFirst('asdf', 11)
     *      11为key，'asdf'为value
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.addFirst({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.addFirst({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传两个参数则表示用法一，
     * 传一个参数则表示用法二、三（即不传key参数）
     *
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key HashMap的关键字
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.addFirst = function (item, key) {
        if (key == null) {
            // 用法一
            key = this.$retieval(item, this._sDefaultKeyAttr);
            item = this.$retieval(item, this._sDefaultValueAttr);
        }

        var node = { key: key, item: item, pre: null, next: null };
        this._oMap[key] = node;
        this.$insert(node, null, this._oHead);
        return this;
    };

    /**
     * 在某项前插入
     * 用法一：
     *      my.insertBefore('asdf', 11, 333)
     *      11为key，'asdf'为value，333为插入位置refKey  
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.insertBefore({ aa: 11, vv: 'asdf' }, 333)
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.insertBefore({ aa: 11, vv: 'asdf' }, 333)
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传三个参数则表示用法一，
     * 传两个参数则表示用法二、三（即不传key参数）
     *
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key item对应的HashMap的关键字
     * @param {string} refKey 在refKey项前插入
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.insertBefore = function () {
        var item;
        var key;
        var refKey;
        var arg = arguments;
        if (arg.length == 2) {
            // 用法二、三
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            refKey = arg[1];
        }
        else {
            // 用法一
            item = arg[0];
            key = arg[1];
            refKey = arg[2];
        }        

        var refNode = this._oMap[refKey];
        var node = { key: key, item: item, pre: null, next: null };
        if (refNode) {
            this._oMap[key] = node;
            this.$insert(node, refNode.pre, refNode);
        }
        return this;
    };

    /**
     * 在某项后插入
     * 用法一：
     *      my.insertAfter('asdf', 11, 333)
     *      11为key，'asdf'为value，333为插入位置refKey  
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.insertAfter({ aa: 11, vv: 'asdf' }, 333)
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.insertAfter({ aa: 11, vv: 'asdf' }, 333)
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传三个参数则表示用法一，
     * 传两个参数则表示用法二、三（即不传key参数）
     * 
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key item对应的HashMap的关键字，
     * @param {string} refKey 在refKey项后插入
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.insertAfter = function () {
        var item;
        var key;
        var refKey;
        var arg = arguments;
        if (arg.length == 2) {
            // 用法二、三
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            refKey = arg[1];
        }
        else {
            // 用法一
            item = arg[0];
            key = arg[1];
            refKey = arg[2];
        }

        var refNode = this._oMap[refKey];
        var node = { key: key, item: item, pre: null, next: null };
        if (refNode) {
            this._oMap[key] = node;
            this.$insert(node, refNode, refNode.next);
        }
        return this;
    };

    /**
     * 在某位置插入
     * 用法一：
     *      my.insertAt('asdf', 11, 0)
     *      11为key，'asdf'为value，0为插入位置index     
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.insertAt({ aa: 11, vv: 'asdf' }, 0)
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.insertAt({ aa: 11, vv: 'asdf' }, 0)
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传三个参数则表示用法一，
     * 传两个参数则表示用法二、三（即不传key参数）
     *
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key item对应的HashMap的关键字
     * @param {Object} index 插入位置，从0开始
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.insertAt = function () {
        var item;
        var key;
        var index;
        var arg = arguments;
        if (arg.length == 2) {
            // 用法二、三
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            index = arg[1];
        }
        else {
            // 用法一
            item = arg[0];
            key = arg[1];
            index = arg[2];
        }

        if (index != null && index == this.size()) {
            this.addLast(item, key);
        }
        else {
            var ref = this.getAt(index);
            if (ref && ref.key != null) {
                this.insertBefore(item, key, ref.key);
            }
        }
        return this;
    };

    /**
     * 全部清除LinkedHashMap内容
     *
     * @public
     */
    LINKED_HASH_MAP_CLASS.clean = function () {
        this._oMap = {};
        this._oHead = null;
        this._oTail = null;
        this._nLength = 0;
        this._sDefaultKeyAttr = null;
        this._sDefaultValueAttr = null;
    };

    /**
     * 清除LinkedHashMap内容，但是不清除defaultKeyAttr和defaultValueAttr
     *
     * @public
     */
    LINKED_HASH_MAP_CLASS.cleanWithoutDefaultAttr = function () {
        this._oMap = {};
        this._oHead = null;
        this._oTail = null;
        this._nLength = 0;
    };

    /**
     * 设置数据
     * 用法一：
     *      my.set(11, 'asdf')
     *      11为key，'asdf'为value
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.set({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.set({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传两个参数则表示用法一，
     * 传一个参数则表示用法二、三（即不传key参数）
     * 
     * @public
     * @param {Object=} key item对应的HashMap的关键字
     * @param {(*|Object)} item 增加的数据
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.set = function () {
        var key;
        var item;
        var arg = arguments;
        if (arg.length == 1) {
            // 用法二、三
            item = arg[0];
        } 
        else {
            // 用法一
            key = arg[0];
            item = arg[1];
        }

        this.addLast(item, key);
        return this;
    };
    
    /**
     * 取得数据
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @return {*} 取得的数据，未取到则返回null
     */
    LINKED_HASH_MAP_CLASS.get = function (key) {
        var node = this._oMap[key];
        return node ? node.item : null;
    };
    
    /**
     * 按index取得数据
     * 
     * @public
     * @param {Object} index 序号，从0开始
     * @return {Object} ret 取得的数据，
     *              例如：
     *              { key:'321', value: { id: '321', name: 'ss' } }，
     *              未取到则返回null
     * @return {number} ret.key HashMap的key
     * @return {*} ret.item 数据本身
     */
    LINKED_HASH_MAP_CLASS.getAt = function (index) {
        var ret = {};
        this.foreach(function (key, item, i) {
            if (index == i) {
                ret.key = key;
                ret.item = item;
                return false;
            }
        });
        return ret.key != null ? ret : null;
    };

    /**
     * 按key得到index
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {number} index 序号，从0开始，如果未找到，返回-1
     */
    LINKED_HASH_MAP_CLASS.getIndex = function (key) {
        var index = -1;
        this.foreach(function (k, item, i) {
            if (k == key) {
                index = i;
                return false;
            }
        });
        return index;
    };
    
    /**
     * 根据内容遍历，获取key
     * 
     * @public
     * @param {Object} item 内容
     * @param {Object} key item对应的HashMap的关键字
     */
    LINKED_HASH_MAP_CLASS.getKey = function (item) {
        var key;
        this.foreach(function (k, o, i) {
            if (o.item == item) {
                key = k;
                return false;   
            }
        });
        return key;
    };

    /**
     * 是否包含
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @return {boolean} 是否包含
     */
    LINKED_HASH_MAP_CLASS.containsKey = function (key) {
        return !!this.get(key);
    };

    /**
     * 将所有数据以Array形式返回
     * 
     * @public
     * @return {Array} 所有数据
     */
    LINKED_HASH_MAP_CLASS.list = function () {
        var ret = [];
        this.foreach(function (key, item) { ret.push(item); });
        return ret;
    };

    /**
     * 从链表首顺序遍历
     * 
     * @public
     * @param {Function} visitFunc 每个节点的访问函数
     *          param {string} key 每项的key
     *          param {*} item 每项
     *          param {number} index 遍历的计数
     *          return {boolan} 如果返回为false，则不再继续遍历
     */
    LINKED_HASH_MAP_CLASS.foreach = function (visitFunc) {
        var node = this._oHead;
        var i = 0;
        var goOn = true;
        while (node) {
            if (visitFunc(node.key, node.item, i++) === false) { 
                break; 
            }
            node = node.next;
        }
    };

    /**
     * 删除key对应的项
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @return {*} 被删除的项
     */
    LINKED_HASH_MAP_CLASS.remove = function (key) {
        var node = this._oMap[key];
        if (node) {
            delete this._oMap[key];
            var preNode = node.pre;
            var nextNode = node.next;
            preNode && (preNode.next = nextNode);
            nextNode && (nextNode.pre = preNode);
            this._nLength --; 
            (this._oHead == node) && (this._oHead = nextNode); 
            (this._oTail == node) && (this._oTail = preNode);
        }
        return node ? node.item : null;
    };

    /**
     * 得到LinkedHashMap大小
     * 
     * @public
     * @return {number} LinkedHashMap大小
     */
    LINKED_HASH_MAP_CLASS.size = function () {
        return this._nLength;
    };

    /**
     * 得到第一个数据
     * 
     * @public
     * @return {*} 第一个数据
     */
    LINKED_HASH_MAP_CLASS.first = function () {
        return this._oHead ? this._oHead.item : null;
    };
    
    /**
     * 得到第一个key
     * 
     * @public
     * @return {string} 第一个key
     */
    LINKED_HASH_MAP_CLASS.firstKey = function () {
        return this._oHead ? this._oHead.key : null;
    };

    /**
     * 得到最后一个数据
     * 
     * @public
     * @return {*} 最后一个数据
     */
    LINKED_HASH_MAP_CLASS.last = function () {
        return this._oTail ? this._oTail.item : null;
    };
    
    /**
     * 得到最后一个key
     * 
     * @public
     * @return {string} 最后一个key
     */
    LINKED_HASH_MAP_CLASS.lastKey = function () {
        return this._oTail ? this._oTail.key : null;
    };

    
    /**
     * 得到key对应的下一个项，未取到则返回null
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {boolean=} circular 如果到链尾，是否循环到链首，默认为false
     * @return {*} 取得的数据
     */
    LINKED_HASH_MAP_CLASS.next = function (key, circular) {
        var node = this.$next(key, circular);
        return node ? node.item : null;
    };
    
    /**
     * 得到key对应的下一个key，未取到则返回null
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {boolean=} circular 如果到链尾，是否循环到链首，默认为false
     * @return {string} 取得的key
     */
    LINKED_HASH_MAP_CLASS.nextKey = function (key, circular) {
        var node = this.$next(key, circular);
        return node ? node.key : null;
    };
    

    /**
     * 得到key对应的上一个项，未取到则返回null
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {boolean=} circular 如果到链尾，是否循环到链首，默认为false
     * @return {*} 取得的数据
     */
    LINKED_HASH_MAP_CLASS.previous = function (key, circular) {
        var node = this.$previous(key, circular);
        return node ? node.item : null;
    };
    
    /**
     * 得到key对应的上一个key，未取到则返回null
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {boolean=} circular 如果到链尾，是否循环到链首，默认为false
     * @return {string} 取得的key
     */
    LINKED_HASH_MAP_CLASS.previousKey = function (key, circular) {
        var node = this.$previous(key, circular);
        return node ? node.key : null;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$next = function (key, circular) {
        var node = this._oMap[key];
        if (!node) { return null; }
        var next = (circular && node == this._oTail) 
                ? this._oHead : node.next;
        return next;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$previous = function (key, circular) {
        var node = this._oMap[key];
        if (!node) { return null; }
        var pre = (circular && node == this._oHead) 
                ? this._oTail : node.pre;
        return pre;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$retieval = function (item, attr) {
        var k;
        if (Object.prototype.toString.call(attr) == '[object Function]') {
            k = attr(item);
        } 
        else if (attr == null) {
            k = item;
        } 
        else {
            k = item[attr];
        }
        return (k === void 0) ? null : k;
    };   

    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$insert = function (node, preNode, nextNode) {
        node.pre = preNode;
        node.next = nextNode;
        preNode ? (preNode.next = node) : (this._oHead = node);
        nextNode ? (nextNode.pre = node) : (this._oTail = node);
        this._nLength ++;
    };
    
})();

/**
 * xutil.ajax
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    工程中Ajax的统一入口。基于基本的ajax封装实现，提供便于工程开发的附加功能。
 *          功能：
 *          (1) 全局的的请求失败处理定义接口
 *          (2) 全局的等待提示定义接口
 *             （使用方式：请求时传参数showWaiting）
 *          (3) 请求超时设定及全局的超时处理定义接口
 *          (4) 提供complete和finalize事件，便于不论请求成功与否的时的处理（如某些清理）
 *          (5) 返回的一致性保证
 *              用于在不屏蔽二次点击/重复请求情况下保证只是最新的请求返回被处理。
 *              用abort方式实现，可abort重复发出的请求。
 *              没有使用为每个请求挂唯一性tokenId方式的原因是，
 *              tokenId方式不易处理这种问题：
 *              如果pending的连接已超过浏览器连接上限，用户看无响应继续点击，
 *              会造成自激性连接堆积，难以恢复。
 *              但是abort方式的缺点是，如果重复请求过于频繁（例如由用户点击过快造成），
 *              容易对后台造成压力。暂时未支持对请求过频繁的限制（TODO）。
 *              （使用方式：请求时传参数businessKey）
 *          (6) abort支持的完善
 *              在多局部刷新的web应用中，在适当时点可以abort掉未完成的请求，
 *              防止返回处理时因相应的dom已不存在而出错。
 *          (7) 多个请求同步（最后一个请求返回时才执行回调）的支持。
 *              参见createSyncWrap方法
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  tangram.ajax, e-json, xutil.ajax
 */

(function () {
    
    var AJAX = xutil.ajax;
    var exRequest = baidu.ejson.request;
        
    /**
     * 外部接口，可以在工程中定义这些方法的实现或变量的赋值（也均可缺省）
     */
    /**
     * 默认的ajax调用选项，常用于工程的统一配置。
     * 可以被真正调用ajax时传的options覆盖
     *
     * @type {Object}
     * @public
     * @see ajax.request
     */
    AJAX.DEFAULT_OPTIONS = null;
    /**
     * 全局统一的请求失败处理函数
     * 先调用自定义的失败处理函数，再调用此统一的失败处理函数。
     * 如果前者返回false，则不会调用后者。
     *
     * @type {Function}
     * @public
     * @param {number} status ajax返回状态
     * @param {(Object|string)} obj e-json整体返回的数据
     * @param {Function} defaultCase 可用此函数替换默认情况的处理函数
     */
    AJAX.DEFAULT_FAILURE_HANDLER = null;
    /**
     * 全局统一的请求超时处理函数
     * （无参数返回值）
     *
     * @type {Function}
     * @public
     */
    AJAX.DEFAULT_TIMEOUT_HANDLER = null;
    /**
     * 全局统一的请求函数
     *
     * @type {Function}
     * @public
     * @return {string} 参数字符串，如a=5&a=2&b=xxx
     */
    AJAX.DEFAULT_PARAM = null;
    /**
     * 用于显示全局的等待提示，当第一个需要显示等待的请求发生时会调用
     *
     * @type {Function}
     * @public
     */
    AJAX.SHOW_WAITING_HANDLER = null;
    /**
     * 用于隐藏全局的等待提示，当最后一个需要显示等待的请求结束时会调用
     *
     * @type {Function}
     * @public
     */
    AJAX.HIDE_WAITING_HANDLER = null;
    /**
     * 默认是否显示等待提示，默认为false，可在工程中修改此默认定义
     *
     * @type {Function}
     * @public
     */
    AJAX.DEFAULT_SHOW_WAITING = false;
        
    /**
     * 记录所有请求未结束的xhr，
     * 格式：{requestId: {xhr: <xhr>, clear: <clear>}}
     * 
     * @type {Object}
     * @private
     */
    var xhrSet = {};
    /**
     * 记录指定了businessKey的请求，
     * 格式：{businessKey: requestId}
     *
     * @type {Object}
     * @private
     */
    var businessSet = {};
    /**
     * 记录所有需要显示等待的requestId，
     * 是xhrSet的子集，
     * 格式：{requestId: 1}
     *
     * @type {Object}
     * @private
     */
    var waitingSet = {};
    /**
     * waitingSet的大小
     *
     * @type {number}
     * @private
     */
    var waitingCount = 0;
    /**
     * 唯一性ID
     *
     * @type {number}
     * @private
     */
    var uniqueIndex = 1;
    
    /**
     * append默认的参数
     *
     * @private
     * @param {string} data 参数
     */
    function appendDefaultParams(data) {
        var paramArr = [];

        if (hasValue(data) && data !== '') {
            paramArr.push(data);
        }

        var defaultParamStr = AJAX.DEFAULT_PARAM ? AJAX.DEFAULT_PARAM() : '';
        if (hasValue(defaultParamStr) && defaultParamStr !== '') {
            paramArr.push(defaultParamStr);
        }

        return paramArr.join('&');
    }
    
    /**
     * 打印日志
     *
     * @private
     * @param {string} msg 日志信息
     */
    function log(msg) {
        isObject(window.console) 
            && isFunction(window.console.log) 
            && window.console.log(msg);
    }
    
    /**
     * 显示等待处理
     *
     * @private
     * @param {string} requestId 请求ID
     * @param {boolean} showWaiting 是否显示等待
     */
    function handleShowWaiting(requestId, showWaiting) {
        if (showWaiting) {
            waitingSet[requestId] = 1;
            (waitingCount ++) == 0
                && AJAX.SHOW_WAITING_HANDLER 
                && AJAX.SHOW_WAITING_HANDLER();
        }
    }
    
    /**
     * 隐藏等待处理
     *
     * @private
     * @param {string} requestId 请求ID
     */
    function handleHideWaiting(requestId) {
        if (waitingSet[requestId]) {
            delete waitingSet[requestId];
            (-- waitingCount) <= 0 
                && AJAX.HIDE_WAITING_HANDLER 
                && AJAX.HIDE_WAITING_HANDLER();
        }
    }
    
    /**
     * abort处理
     *
     * @private
     * @param {string} businessKey 业务键
     * @param {string} requestId 请求ID
     */
    function handleBusinessAbort(businessKey, requestId) {
        var oldRequestId;
        if (hasValue(businessKey)) {
            (oldRequestId = businessSet[businessKey]) 
                && AJAX.abort(oldRequestId, true);
            businessSet[businessKey] = requestId;
        }
    }
    
    /**
     * 业务键清除处理
     *
     * @private
     * @param {string} businessKey 业务键
     */
    function handleBusinessClear(businessKey) {
        if (hasValue(businessKey)) {
            delete businessSet[businessKey];   
        }
    }
    
    /**
     * 发送请求
     * 
     * @public
     * @param {string} url
     * @param {Objet} options
     * @param {string} options.data 发送参数字符串，GET时会拼装到URL
     * @param {string} options.method 表示http method, 'POST'或'GET', 默认'POST'
     * @param {string} options.businessKey 业务键，提供自动abort功能。
     *              缺省则不用此功能。
     *              如果某业务键的请求尚未返回，又发起了同一业务键的请求，
     *              则前者自动被abort。
     *              这样保证了请求返回处理的一致性，
     *              在请求可以重复发起的环境下较有意义
     *              （例如用户连续点击“下一页”按钮刷新列表，
     *              同时为用户体验而不会在返回前屏蔽点击时）。
     * @param {boolean} options.showWaiting 是否需要显示等待，true则计入等待集合，
     *              在相应时机调用SHOW_WAITING_HANDLER和HIDE_WAITING_HANDLER；
     *              false则忽略。默认值由DEFAULT_SHOW_WAITING指定。
     * @param {Function} options.onsuccess 请求成功的回调函数
     *              param {Object} data e-json解析出的业务数据
     *              param {Object} obj e-json返回数据整体
     * @param {Function} options.onfailure 请求失败的回调函数
     *              param {number} status e-json返回状态
     *              param {(Object|string)} obj e-json返回数据整体
     * @param {Function} options.oncomplete 返回时触发的回调函数，
     *              先于onsuccess或onfailure执行
     *              param {(Object|string)} obj e-json返回的数据整体 
     *              return {boolean} 如果返回false，则onsucces和onfailure都不执行
     * @param {Function} options.onfinalize 返回时触发的回调函数，
     *              后于onsuccess或onfailure执行
     *              param {(Object|string)} obj e-json返回的数据整体
     * @param {Function} options.defaultFailureHandler 
     *              请求自定的默认的失败处理函数，可缺省
     *              param {number} status e-json返回状态
     *              param {(Object|string)} obj e-json返回数据整体
     * @param {number} options.timeout 请求超时时间，默认是无限大
     * @param {Function} options.ontimeout 超时时的回调
     * @param {string} options.syncName 用于请求的同步，参见createSyncWrap方法
     * @param {Object} options.syncWrap 用于请求的同步，参见createSyncWrap方法
     * @return {string} options.requestId request的标志，用于abort
     */
    AJAX.request = function (url, options) {
        options = extend(
            extend(
                {}, AJAX.DEFAULT_OPTIONS || {}
            ), 
            options || {}
        );
        var requestId = 'AJAX_' + (++uniqueIndex);
        var businessKey = options.businessKey;
        var defaultFailureHandler = 
                options.defaultFailureHandler || null;
        var timeout = options.timeout || 0;
        var ontimeout = options.ontimeout;
        var onfailure = options.onfailure;
        var onsuccess = options.onsuccess;
        var oncomplete = options.oncomplete;
        var onfinalize = options.onfinalize;
        var showWaiting = options.showWaiting || AJAX.DEFAULT_SHOW_WAITING;
        var syncWrap = options.syncWrap;
        var syncName = options.syncName;
        var xhr;
        
        function clear() {
            defaultFailureHandler = ontimeout = 
            onfailure = onsuccess = 
            onfinalize = oncomplete = xhr = options = null;

            delete xhrSet[requestId];
            handleBusinessClear(businessKey);
            handleHideWaiting(requestId);
        }

        // tangram的ajax提供的屏蔽浏览器缓存
        options.noCache = true;

        options.method = options.method || 'POST';

        options.data = appendDefaultParams(options.data || '');

        // 构造sucess handler
        options.onsuccess = function (data, obj) {
            if (requestId in xhrSet) { // 判断abort
                try {
                    if (!oncomplete || oncomplete(obj) !== false) {
                        onsuccess(data, obj);
                    }
                    onfinalize && onfinalize(obj);
                } 
                finally {
                    syncWrap && syncWrap.done(syncName);
                    clear();
                }
            }
        };

        // 构造failure handler
        options.onfailure = function (status, obj) {
            var needDef;
            if (requestId in xhrSet) { // 判断abort
                try {
                    if (!oncomplete || oncomplete(obj) !== false) {
                        needDef = onfailure(status, obj);
                    }
                    onfinalize && onfinalize(obj);
                } 
                finally {
                    if (needDef !== false) {
                        if (AJAX.DEFAULT_FAILURE_HANDLER) {
                            AJAX.DEFAULT_FAILURE_HANDLER(
                                status, obj, defaultFailureHandler
                            );
                        }
                        else if (defaultFailureHandler) {
                            defaultFailureHandler(status, obj);
                        }
                    }
                    syncWrap && syncWrap.done(syncName);
                    clear();
                }
            }
        };

        // 构造timeout handler
        options.ontimeout = function () {
            try {
                if (!oncomplete || oncomplete(obj) !== false) {
                    ontimeout && ontimeout();
                }
                onfinalize && onfinalize(obj);
            } 
            finally {
                AJAX.DEFAULT_TIMEOUT_HANDLER 
                    && AJAX.DEFAULT_TIMEOUT_HANDLER();
                syncWrap && syncWrap.done(syncName);
                clear();
            }
        };

        if (timeout > 0) {
            options.timeout = timeout;
            options.ontimeout = timeoutHandler;
        } 
        else {
            delete options.timeout;
        }
        
        handleShowWaiting(requestId, showWaiting);
        
        handleBusinessAbort(requestId, businessKey);
        
        // 发送请求
        xhrSet[requestId] = {
            xhr: exRequest(url, options),
            clear: clear
        };
        
        return requestId;
    }

    /**
     * 发送POST请求
     * 
     * @public
     * @param {string} url
     * @param {string} data 发送参数字符串，GET时会拼装到URL
     * @param {Function} onsuccess @see AJAX.request
     * @param {Function} onfailure @see AJAX.request
     * @param {Objet} options @see AJAX.request
     * @return {string} requestId request的标志，用于abort
     */
    AJAX.post = function (url, data, onsuccess, onfailure, options) {
        options = options || {};
        options.method = 'POST';
        options.data = data;
        options.onsuccess = onsuccess;
        options.onfailure = onfailure;
        return AJAX.request(url, options);
    };

    /**
     * 发送GET请求
     * 
     * @public
     * @param {string} url
     * @param {string} data 发送参数字符串，GET时会拼装到URL
     * @param {Function} onsuccess @see AJAX.request
     * @param {Function} onfailure @see AJAX.request
     * @param {Objet} options @see AJAX.request
     * @return {string} requestId request的标志，用于abort
     */
    AJAX.get = function (url, data, onsuccess, onfailure, options) {
        options = options || {};
        options.method = 'GET';
        options.data = data;
        options.onsuccess = onsuccess;
        options.onfailure = onfailure;
        return AJAX.request(url, options);        
    };

    /**
     * 按requestId终止请求，或终止所有请求
     * 如果已经中断或结束后还调用此方法，不执行任何操作。
     * 
     * @public
     * @param {string} requestId request的标志，
     *          如果缺省则abort所有未完成的请求
     * @param {boolean} silence abort后是否触发回调函数（即onfailure）
     *          true则不触发，false则触发，缺省为true
     */
    AJAX.abort = function (requestId, silence) {
        var willAbort = [];
        var i;
        var wrap;
        silence = silence || true;
        
        if (hasValue(requestId)) {
            (requestId in xhrSet) && willAbort.push(requestId);
        } 
        else {
            for (i in xhrSet) { willAbort.push(i); }
        }
        
        for (i = 0; requestId = willAbort[i]; i++) {
            try {
                wrap = xhrSet[requestId];
                silence && delete xhrSet[requestId];
                wrap.xhr.abort();
                wrap.clear.call(null);
            } catch (e) {
                log(
                    '[ERROR] abort ajax error. requestId=' + 
                        requestId + ', e=' + e
                );
            }
        }
    };
    
    /**
     * 按业务键（businessKey）终止请求
     * 如果已经中断或结束后还调用此方法，不执行任何操作。
     * 
     * @public
     * @param {string} businessKey 业务键
     * @param {boolean} silence abort后是否触发回调函数（即onfailure）
     *          true则不触发，false则触发，缺省为true
     */
    AJAX.abortBusiness = function (businessKey, silence) {
        var requestId = businessSet[businessKey];
        if (hasValue(requestId)) {
            delete businessSet[businessKey];
            AJAX.abort(requestId);
        }
    };

    /**
     * 创建一个同步对象，用于多个请求同步返回
     * 
     * @public
     * @usage 假如回调函数callbackX需要在请求a和请求b都返回后才被调用，则这样做：
     *        (1) 创建个“同步对象”
     *          var reqWrap = ajax.syncRequest(
     *              ['a', 'b'], 
     *              function() { ... this is the callback } 
     *          );
     *        (2) 请求时作为参数传入
     *          // 请求a
     *          ajax.request(url, { syncName: 'a', syncWrap: reqWrap }); 
     *          // 请求b
     *          ajax.request(url, { syncName: 'b', syncWrap: reqWrap });
     *          这样，reqWrap中定义的回调函数就会在a和b都返回后被执行了。
     * 
     * @param {Array} syncNameList 命名集合
     * @param {Function} callback 回调函数
     * @return {Object} 同步对象，用作request参数
     */
    AJAX.createSyncWrap = function (syncNameList, callback) {
        return new SyncWrap(syncNameList, callback);
    };

    /**
     * 用于多个请求同步的包装
     *
     * @constructor
     * @private
     * @param {Array} syncNameList 同步名列表
     * @param {Array} callback 结束回调
     */
    function SyncWrap(syncNameList, callback) {
        var i;
        this.syncNameMap = {};
        for (i = 0, syncNameList = syncNameList || []; i < syncNameList.length; i ++) {
            this.syncNameMap[syncNameList[i]] = 0;
        }
        this.callback = callback || new Function();
    }

    /**
     * 同步结束
     *
     * @public
     * @param {string} syncName 同步名
     */
    SyncWrap.prototype.done = function (syncName) {
        var name;
        this.syncNameMap[syncName] = 1;
        for (name in this.syncNameMap) {
            if (!this.syncNameMap[name]) { return; }
        }
        this.callback.call(null);
    };

    /**
     * 扩展
     *
     * @private
     * @param {Object} target 目标对象
     * @param {Object} source 源对象
     * @return {Object} 扩展结果
     */
    function extend(target, source) {
        for (var key in source) { target[key] = source[key]; }
        return target;
    }

    /**
     * 是否函数
     *
     * @private
     * @param {*} variable 输入
     * @return {boolean} 是否函数
     */
    function isFunction(variable) {
        return Object.prototype.toString.call(variable) == '[object Function]';        
    }

    /**
     * 是否有值
     *
     * @private
     * @param {*} variable 输入
     * @return {boolean} 是否有值
     */
    function hasValue(variable) {
        return variable != null;
    }

    /**
     * 是否对象
     *
     * @private
     * @param {*} variable 输入
     * @return {boolean} 是否对象
     */
    function isObject(variable) {
        return variable === Object(variable);
    }

})();

/**
 * xutil.collection
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    列表、数组、集合相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.object
 */

(function () {
    
    var COLLECTION = xutil.collection;
    var OBJECT = xutil.object;
    
    /**
     * target是否在list的field域中存在
     * 
     * @public
     * @param {*} target 被检测的目标
     * @param {Array} list 被检测的数组
     * @param {string} field 数组元素的域的名字，
     *      如果为空则用list节点本身做比较的valueInList
     * @param {Function} equalsFunc 比较函数，缺省则使用“==”做比较函数
     *          参数为：
     *          param {*} target 被检测的目标
     *          param {*} valueInList list中的项
     *          return {boolean} 是否相等
     * @return {boolean} 判断结果
     */
    COLLECTION.inList = function (target, list, field, equalsFunc) {
        if (target == null || !list) {
            return false;
        }

        for(var i = 0, l = list.length, v; i < l; i ++) {
            v = list[i];
            if (v == null && field) { continue; }

            v = field ? v[field] : v;
            if (equalsFunc ? equalsFunc(target, v) : (target == v)) {
                return true;
            }
        }

        return false;
    };

    /**
     * 用类似SQL的方式检索列表
     * 
     * @public
     * @param {*} target 被检测的目标
     * @param {Array} list 被检测的数组
     * @param {string} selectField 数组元素的域的名字，用于select
     * @param {string} whereField 数组元素的域的名字，用于where
     * @param {*} whereValue 数组元素的相应域的值，用于where
     * @param {Function} equalsFunc 比较函数，缺省则使用“==”做比较函数
     *          参数为：
     *          param {*} target 被检测的目标
     *          param {8} valueInList list中的项
     *          return {boolean} 是否相等
     * @return {Array} 检索结果
     */
    COLLECTION.selectFromWhere = function (
        fromList, selectField, whereField, whereValue, equalsFunc
    ) {
        var ret = [];

        if (whereValue == null || !fromList || !whereField || !selectField) {
            return ret;
        }

        for(var i = 0, l = fromList.length, v, s; i < l; i ++) {
            if (!(v = fromList[i])) { continue };

            s = v[whereField];
            if (equalsFunc ? equalsFunc(whereValue, s) : whereValue == s) {
                ret.push(v[selectField]);
            }
        }

        return ret;
    };
    
    /**
     * 用类似SQL的方式检索列表，返回单值
     * 
     * @public
     * @param {*} target 被检测的目标
     * @param {Array} list 被检测的数组
     * @param {string} selectField 数组元素的域的名字，用于select
     * @param {string} whereField 数组元素的域的名字，用于where
     * @param {*} whereValue 数组元素的相应域的值，用于where
     * @param {Function} equalsFunc 比较函数，缺省则使用“==”做比较函数
     *          param {*} target 被检测的目标
     *          param {*} valueInList list中的项
     *          return {boolean} 是否相等
     * @return {*} 检索结果，单值
     */
    COLLECTION.selectSingleFromWhere = function (
        fromList, selectField, whereField, whereValue, compareFunc
    ) {
        var result = COLLECTION.selectFromWhere(
                fromList, selectField, whereField, whereValue, compareFunc
            );
        return (result && result.length>0) ? result[0] : null;
    };
    
    /**
     * 排序 (用冒泡实现，是稳定排序)
     * 
     * @public
     * @param {string} field 数组元素的域的名字，如果为空则用list节点本身做比较的valueInList
     * @param {(string|Function)} compareFunc 比较函数，
     *          可以传string或Function，compareFunc缺省则相当于传"<" 
     *          如果为String: 可以传：">"（即使用算术比较得出的降序）, 
     *                                "<"（即使用算术比较得出的升序）
     *          如果为Function: 意为：v1是否应排在v2前面，参数为
     *              param {*} v1 参与比较的第一个值
     *              param {*} v2 参与比较的第二个值
     *              return {boolean} 比较结果，true:v1应在v2前面；false:v1不应在v2前面
     * @param {boolean} willNew 如果为true:原list不动，新创建一个list; 
     *          如果为false:在原list上排序; 缺省:false
     * @return {Array} 排序结果
     */
    COLLECTION.sortList = function (list, field, compareFunc, willNew) {
        
        willNew && (list = OBJECT.clone(list));
        field = field != null ? field : null;    
        
        if (compareFunc == '>') {
            compareFunc = function (v1, v2) { 
                var b1 = v1 != null;
                var b2 = v2 != null;
                return (b1 && b2) 
                            ? (v1 >= v2) /*大于等于，保证稳定*/ 
                            : (b1 || !b2); /*空值算最小，同为空值返回true保证稳定*/
            }
        } 
        else if (compareFunc == '<') {
            compareFunc = function (v1, v2) { 
                var b1 = v1 != null;
                var b2 = v2 != null;
                return (b1 && b2) 
                            ? (v1 <= v2) /*小于等于，保证稳定*/ 
                            : (!b1 || b2); /*空值算最大，同为空值返回true保证稳定*/
            }
        }
        
        var item1;
        var item2; 
        var v1;
        var v2;
        var switched = true;

        for (var i = 0, li = list.length - 1; i < li && switched; i ++) {
            switched = false;
            
            for (var j = 0, lj = list.length - i - 1; j < lj; j ++) {
                item1 = list[j];
                v1 = item1 != null ? (field ? item1[field] : item1) : null;
                item2 = list[j + 1];
                v2 = item2 != null ? (field ? item2[field] : item2) : null;
                if (!compareFunc(v1, v2)) {
                    list[j] = item2;
                    list[j + 1] = item1;
                    switched = true;
                }
            }
        }

        return list;    
    };
    
    /**
     * 遍历树
     * 支持先序遍历、后序遍历、中途停止
     * 
     * @public
     * @usage
     *      travelTree(root, funciton (node, options) { 
     *          do something ... 
     *      }, '_aChildren');
     * 
     * @param {Object} travelRoot 遍历的初始
     * @param {Function} callback 每个节点的回调
     *          参数为：
     *          param {Object} node 当前访问的节点
     *          param {Object} options 一些遍历中的状态
     *          param {number} options.level 当前层级，0层为根
     *          param {number} options.index 遍历的总计数，从0开始计
     *          param {Object} options.parent 当前节点的父亲
     *          param {Object} options.globalParam 全局用的参数，在遍历的任何环节可以填入
     *          param {Object} options.parentParam
     *              先序遍历时，此对象用于在callback中取出父节点传递来的数据
     *              后序遍历时，此对象用于在callback中填入的要传递给父节点的数据
     *          param {Object} options.childrenParam 
     *              先序遍历时，此对象用于在callback中填入的要传递给子节点的数据
     *              后序遍历时，此对象用于在callback中取出子节点传递来的数据
     *          return {number} 如果为STOP_ALL_TRAVEL则停止所有遍历，
     *              如果为STOP_SUB_TREE_TRAVEL则停止遍历当前子树
     * @param {string} childrenField 子节点列表属性名，缺省为'children'
     * @param {boolean} postorder true则先序遍历（缺省值），false则后序遍历
     * @param {Object} globalParam 全局参数
     */
    COLLECTION.travelTree = function (
        travelRoot, callback, childrenField, postorder, globalParam
    ) {
        $travelTree(
            travelRoot, 
            callback, 
            childrenField, 
            postorder, 
            0, 
            null, 
            { index:0 }, 
            {}, 
            {}, 
            globalParam || {}
        );
    }

    // 用于停止所有遍历
    COLLECTION.STOP_ALL_TRAVEL = 1; 
    // 用于停止遍历当前子树
    COLLECTION.STOP_SUB_TREE_TRAVEL = 2; 
    
    function $travelTree(
        travelRoot, 
        callback, 
        childrenField, 
        postorder, 
        level, 
        parent, 
        indexRef, 
        inToChildrenParam, 
        inToParentParam, 
        globalParam
    ) {
        if (travelRoot == null) {
            return;
        }
            
        postorder = !!postorder;
        
        var conti;
        var toChildrenParam;
        var toParentParam;

        if (!postorder) {
            conti = callback.call(
                null, 
                travelRoot, 
                {
                    level: level, 
                    index: indexRef.index, 
                    parent: parent, 
                    childrenParam: (toChildrenParam = {}), 
                    parentParam: inToChildrenParam,
                    globalParam: globalParam
                }
            );
            indexRef.index ++;
        }
        
        if (conti === COLLECTION.STOP_ALL_TRAVEL) {
            return conti; 
        }
        if (conti === COLLECTION.STOP_SUB_TREE_TRAVEL) { 
            return; 
        }
        
        var children = travelRoot[childrenField || 'children'] || [];
        for (var i = 0, len = children.length, node; i < len; i ++) {
            node = children[i];
            
            conti = $travelTree(
                node, 
                callback, 
                childrenField, 
                postorder, 
                level + 1, 
                travelRoot, 
                indexRef, 
                toChildrenParam, 
                (toParentParam = {}), 
                globalParam
            );
                
            if (conti === COLLECTION.STOP_ALL_TRAVEL) { 
                return conti; 
            }
        }
        
        if (postorder && conti !== COLLECTION.STOP_ALL_TRAVEL) { 
            conti = callback.call(
                null, 
                travelRoot, 
                {
                    level: level, 
                    index: indexRef.index, 
                    parent: parent, 
                    childrenParam: toParentParam, 
                    parentParam: inToParentParam,
                    globalParam: globalParam
                }
            );
            indexRef.index ++;
        }
        
        if (conti === COLLECTION.STOP_ALL_TRAVEL) { 
            return conti; 
        }
    };    

})();

/**
 * xutil.date
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:   时间相关工具函数集合。
 *          便于工程中统一时间格式，并提供时间相关的数学操作。
 * @author: sushuang(sushuang@baidu.com)
 * @depend: xutil.lang, xutil.number
 */

(function () {
    
    var DATE = xutil.date;
    var LANG = xutil.lang;
    var NUMBER = xutil.number;
        
    var DAY_MILLISECOND = 24*60*60*1000;
    
    /**
     * 默认通用的日期字符串格式为：
     * 'yyyy-MM-dd hh:mm'或'yyyy-MM-dd'或'yyyy-MM'或'yyyy'，
     * 如果要修改默认日期格式，修改如下诸属性。
     *
     * @type {string}
     * @public
     */
    DATE.DATE_FORMAT = 'yyyy-MM-dd';
    DATE.MINUTE_FORMAT = 'yyyy-MM-dd hh:mm';
    
    /**
     * 日期对象转换成字符串的简写
     * 
     * @public
     * @param {Date} currDate 日期对象
     * @param {string} format 格式，缺省为yyyy-MM-dd
     * @return {string} 日期字符串
     */
    DATE.dateToString = function (date, format) {
        if (!date) { return ''; }
        format = format || DATE.DATE_FORMAT;
        return DATE.format(date, format);
    };
    
    /**
     * 日期对象转换成字符串的简写，到分钟精度
     * 
     * @public
     * @param {Date} date 日期对象
     * @param {string} format 格式，缺省为yyyy-MM-dd
     * @return {string} 日期字符串
     */
    DATE.dateToStringM = function (date) {
        return DATE.dateToString(date, DATE.MINUTE_FORMAT);
    };
    
    
    /**
     * 字符串转换成日期对象的简写
     * 
     * @public
     * @param {string} dateStr 字符串格式的日期，yyyy-MM-dd 或  yyyy-MM 或 yyyy
     * @return {Date} 日期对象，如果输入为空则返回null
     */
    DATE.stringToDate = function (dateStr) {
        if (dateStr) {
            return DATE.parse(dateStr);
        }
        return null;
    };
    
    /**
     * 得到昨天的日期对象
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @return {Date} 结果
     */
    DATE.getYesterday = function (date) {
        if (!date) { return null; }
        return DATE.addDay(date, -1, true);
    };
    
    /**
     * 得到昨天的日期字符串
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @return {string} 结果
     */
    DATE.getYesterdayString = function (date) {
        if (!date) { return null; }
        return DATE.dateToString(DATE.getYesterday(date));
    };
    
    /**
     * 得到周末
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @param {boolean=} mode 
     *      true:得到星期六作为周末   false:得到星期日作为周末（默认）
     * @param {boolean=} remain 为false则新建日期对象（默认）；
     *                         为true则在输入的日期对象中改；
     *                         缺省为false
     */
    DATE.getWeekend = function (date, mode, remain) {
        var weekend = remain ? date : new Date(date);
        var offset = mode 
                ? (6 - weekend.getDay()) 
                : (7 - weekend.getDay()) % 7;
        weekend.setDate(weekend.getDate() + offset);
        return weekend;
    }
    
    /**
     * 得到周开始日期
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @param {boolean=} mode 
     *      true:得到星期日作为周开始   false:得到星期一作为周开始（默认）
     * @param {boolean=} remain 为false则新建日期对象（默认）；
     *                         为true则在输入的日期对象中改；
     *                         缺省为false
     */
    DATE.getWorkday = function (date, mode, remain) {
        var workday = remain ? date : new Date(date);
        var d = workday.getDate();
        d = mode 
                ? (d - workday.getDay()) 
                : (d - (6 + workday.getDay()) % 7);
        workday.setDate(d);
        return workday;
    }
    
    /**
     * 获得某天是当前年的第几天
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {number} 结果天数
     */
    DATE.dateCountFromYearBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var startDate = new Date(date.getTime());
        startDate.setDate(1);
        startDate.setMonth(0);
        return DATE.dateMinus(date, startDate) + 1;
    };
    
    /**
     * 获得某天是当前季度的第几天
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {number} 结果天数
     */
    DATE.dateCountFromQuarterBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        return DATE.dateMinus(date, DATE.getQuarterBegin(date)) + 1;
    };
    
    /**
     * 获得某天是当前月的第几天
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {number} 结果天数
     */
    DATE.dateCountFromMonthBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var startDate = new Date(date.getTime());
        startDate.setDate(1);
        return DATE.dateMinus(date, startDate) + 1;
    };
    
    /**
     * 获得某日期属于哪个季度，1~4
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {number} 季度号，1~4
     */
    DATE.getQuarter = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        return Math.floor(date.getMonth() / 3) + 1 ;
    };
    
    /**
     * 获得该季度的第一天
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {Date} 该季度的第一天
     */
    DATE.getQuarterBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var quarter = DATE.getQuarter(date);
        var mon = [0, 0, 3, 6, 9];
        return new Date(date.getFullYear(), mon[quarter], 1);
    };

    
    /**
     * 比较日期相同与否（两者有一者为空就认为是不同）
     * 
     * @public
     * @param {(string|Date)} date1 目标日期对象或日期字符串1
     * @param {(string|Date)} date2 目标日期对象或日期字符串2
     * @return {string} 比较结果
     */
    DATE.sameDate = function (date1, date2) {
        if (!date1 || !date2) { return false; }
        LANG.isString(date1) && (date1 = DATE.stringToDate(date1));
        LANG.isString(date2) && (date2 = DATE.stringToDate(date2));
        return date1.getFullYear() == date2.getFullYear() 
               && date1.getMonth() == date2.getMonth()
               && date1.getDate() == date2.getDate();
    };
    
    /**
     * 比较日期大小
     * 
     * @public
     * @param {(string|Date)} date1 目标日期对象或日期字符串1
     * @param {(string|Date)} date2 目标日期对象或日期字符串2
     * @return {string} 比较结果，
     *      -1: date1 < date2;  0: date1 == date2;  1: date1 > date2
     */
    DATE.compareDate = function (date1, date2) {
        var year1;
        var year2;
        var month1;
        var month2;
        var date1;
        var date2;

        LANG.isString(date1) && (date1 = DATE.stringToDate(date1));
        LANG.isString(date2) && (date2 = DATE.stringToDate(date2));
        if ((year1 = date1.getFullYear()) == (year2 = date2.getFullYear())) {
            if ((month1 = date1.getMonth()) == (month2 = date2.getMonth())) {
                if ((date1 = date1.getDate()) == (date2 = date2.getDate())) {
                    return 0;
                } 
                else { return date1 < date2 ? -1 : 1; }
            } 
            else { return month1 < month2 ? -1 : 1; }
        } 
        else { return year1 < year2 ? -1 : 1; }
    };
    
    /**
     * 用日做减法：date1 - date2
     * 如：date1为2012-03-13，date2为2012-03-15，则结果为-2。1.3天算2天。
     * 
     * @public
     * @param {(string|Date)} date1 目标日期对象或日期字符串1
     * @param {(string|Date)} date2 目标日期对象或日期字符串2
     * @return {string} 比较结果，
     *      -1: date1 < date2;  0: date1 == date2;  1: date1 > date2
     * @return {number} 减法结果天数
     */
    DATE.dateMinus = function (date1, date2) {
        // 格式化成一天最开始
        date1 = DATE.stringToDate(DATE.dateToString(date1)); 
        // 格式化成一天最开始
        date2 = DATE.stringToDate(DATE.dateToString(date2)); 
        var t = date1.getTime() - date2.getTime();
        var d = Math.round(t / DAY_MILLISECOND);
        return d;
    };
    
    /**
     * 增加天
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @param {number} num 增加的天数，可为负数
     * @param {boolean} willNew 为true则新建日期对象；
     *                          为false则在输入的日期对象中改；
     *                          缺省为false
     * @return {Date} 结果
     */
    DATE.addDay = function (date, num, willNew) {
        if (!date) { return null; }
        num = num || 0;
        if (willNew) {
            return new Date(date.getTime() + num * DAY_MILLISECOND);
        } 
        else {
            date.setDate(date.getDate() + num);
            return date;
        }
    };
    
    /**
     * 增加月
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @param {number} num 增加的月数，可为负数
     * @param {boolean} willNew 为true则新建日期对象；
     *                          为false则在输入的日期对象中改；
     *                          缺省为false
     * @return {Date} 结果
     */    
    DATE.addMonth = function (date, num, willNew) {
        if (!date) { return null; }
        num = num || 0;
        willNew && (date = new Date(date.getTime()));
        date.setMonth(date.getMonth() + num);
        return date;
    };  
    
    /**
     * 得到某日加num个月是几月
     * 
     * @public
     * @param {(string|Date)} date
     * @param {number} num 任意整数值，可以为负值
     * @return {Object} 
     *              {number} year 年
     *              {number} month 月号：1~12
     */
    DATE.nextMonth = function (date, num) {
        var year = date.getFullYear();
        var month = date.getMonth();
        return {
            year: year + Math.floor((month + num) / 12),
            month: (month + num + Math.abs(num * 12)) % 12 + 1
        }
    };
    
    /**
     * 得到某日加num个季度是几季度
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @param {number} num 任意整数值，可为负值
     * @return {Object} 
     *              {number} year 年
     *              {number} quarter 季度号：1~4
     */
    DATE.nextQuarter = function (date, num) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date));

        var quarter = DATE.getQuarter(date);
        var year = date.getFullYear();
        return {
            year: year + Math.floor((quarter - 1 + num) / 4),
            quarter: (quarter - 1 + num + Math.abs(num * 4)) % 4 + 1
        };
    };
    
    /**
     * 返回某日的星期几字符串
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @param {string} weekPrefix 星期几字符串前缀，缺省为'周'
     * @return {string} 星期几字符串
     */
    DATE.getDay = function (date, weekPrefix) {
        if (!date) { return ''; }
        LANG.isString(date) && (date = DATE.stringToDate(date));
        weekPrefix = weekPrefix || '周';
        var ret;
        switch (date.getDay()) {
            case 1: ret = weekPrefix + '一'; break;
            case 2: ret = weekPrefix + '二'; break;
            case 3: ret = weekPrefix + '三'; break;
            case 4: ret = weekPrefix + '四'; break;
            case 5: ret = weekPrefix + '五'; break;
            case 6: ret = weekPrefix + '六'; break;
            case 0: ret = weekPrefix + '日'; break;
            default: ret = ''; break;
        }
        return ret;
    };
    
    /**
     * 对目标日期对象进行格式化 (@see tangram)
     * 格式表达式，变量含义：
     * hh: 带 0 补齐的两位 12 进制时表示
     * h: 不带 0 补齐的 12 进制时表示
     * HH: 带 0 补齐的两位 24 进制时表示
     * H: 不带 0 补齐的 24 进制时表示
     * mm: 带 0 补齐两位分表示
     * m: 不带 0 补齐分表示
     * ss: 带 0 补齐两位秒表示
     * s: 不带 0 补齐秒表示
     * yyyy: 带 0 补齐的四位年表示
     * yy: 带 0 补齐的两位年表示
     * MM: 带 0 补齐的两位月表示
     * M: 不带 0 补齐的月表示
     * dd: 带 0 补齐的两位日表示
     * d: 不带 0 补齐的日表示
     * 
     * @public
     * @param {Date} source 目标日期对象
     * @param {string} pattern 日期格式化规则
     * @return {string} 格式化后的字符串
     */
    DATE.format = function (source, pattern) {
        var pad = NUMBER.pad;
        if (!LANG.isString(pattern)) {
            return source.toString();
        }
    
        function replacer(patternPart, result) {
            pattern = pattern.replace(patternPart, result);
        }
        
        var year    = source.getFullYear();
        var month   = source.getMonth() + 1;
        var date2   = source.getDate();
        var hours   = source.getHours();
        var minutes = source.getMinutes();
        var seconds = source.getSeconds();
    
        replacer(/yyyy/g, pad(year, 4));
        replacer(/yy/g, pad(parseInt(year.toString().slice(2), 10), 2));
        replacer(/MM/g, pad(month, 2));
        replacer(/M/g, month);
        replacer(/dd/g, pad(date2, 2));
        replacer(/d/g, date2);
    
        replacer(/HH/g, pad(hours, 2));
        replacer(/H/g, hours);
        replacer(/hh/g, pad(hours % 12, 2));
        replacer(/h/g, hours % 12);
        replacer(/mm/g, pad(minutes, 2));
        replacer(/m/g, minutes);
        replacer(/ss/g, pad(seconds, 2));
        replacer(/s/g, seconds);
    
        return pattern;
    };
    
    
    /**
     * 将目标字符串转换成日期对象 (@see tangram)
     * 对于目标字符串，下面这些规则决定了 parse 方法能够成功地解析：
     * 短日期可以使用“/”或“-”作为日期分隔符，但是必须用月/日/年的格式来表示，例如"7/20/96"。
     * 以 "July 10 1995" 形式表示的长日期中的年、月、日可以按任何顺序排列，年份值可以用 2 位数字表示也可以用 4 位数字表示。如果使用 2 位数字来表示年份，那么该年份必须大于或等于 70。
     * 括号中的任何文本都被视为注释。这些括号可以嵌套使用。
     * 逗号和空格被视为分隔符。允许使用多个分隔符。
     * 月和日的名称必须具有两个或两个以上的字符。如果两个字符所组成的名称不是独一无二的，那么该名称就被解析成最后一个符合条件的月或日。例如，"Ju" 被解释为七月而不是六月。
     * 在所提供的日期中，如果所指定的星期几的值与按照该日期中剩余部分所确定的星期几的值不符合，那么该指定值就会被忽略。例如，尽管 1996 年 11 月 9 日实际上是星期五，"Tuesday November 9 1996" 也还是可以被接受并进行解析的。但是结果 date 对象中包含的是 "Friday November 9 1996"。
     * JScript 处理所有的标准时区，以及全球标准时间 (UTC) 和格林威治标准时间 (GMT)。 
     * 小时、分钟、和秒钟之间用冒号分隔，尽管不是这三项都需要指明。"10:"、"10:11"、和 "10:11:12" 都是有效的。
     * 如果使用 24 小时计时的时钟，那么为中午 12 点之后的时间指定 "PM" 是错误的。例如 "23:15 PM" 就是错误的。 
     * 包含无效日期的字符串是错误的。例如，一个包含有两个年份或两个月份的字符串就是错误的。
     *             
     * @public
     * @param {string} source 目标字符串
     * @return {Date} 转换后的日期对象
     */
    DATE.parse = function (source) {
        var reg = new RegExp("^\\d+(\\-|\\/)\\d+(\\-|\\/)\\d+\x24");
        if ('string' == typeof source) {
            if (reg.test(source) || isNaN(Date.parse(source))) {
                var d = source.split(/ |T/);
                var d1 = d.length > 1 
                        ? d[1].split(/[^\d]/)
                        : [0, 0, 0];
                var d0 = d[0].split(/[^\d]/);
                
                return new Date(
                    d0[0],
                    (d0[1] != null ? (d0[1] - 1) : 0 ), 
                    (d0[2] != null ? d0[2] : 1), 
                    (d1[0] != null ? d1[0] : 0), 
                    (d1[1] != null ? d1[1] : 0), 
                    (d1[2] != null ? d1[2] : 0)
                );
            } 
            else {
                return new Date(source);
            }
        }
        
        return new Date();
    };

})();

/**
 * xutil.dom
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DOM相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 */

(function () {
    
    var DOM = xutil.dom;
    var objProtoToString = Object.prototype.toString;
    var TRIMER_REG = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );
    var SPACE_REG = /\s/;
    var USER_AGENT = navigator.userAgent;
    var DOCUMENT = document;
    var REGEXP = RegExp;

    DOM.isStrict = DOCUMENT.compatMode == 'CSS1Compat';
    DOM.ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) 
        ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined;
    DOM.firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) 
        ? REGEXP.$1 - 0 : undefined;
    DOM.operaVersion = /opera\/(\d+\.\d)/i.test(USER_AGENT) 
        ? REGEXP.$1 - 0 : undefined;
    DOM.safariVersion = /(\d+\.\d)(\.\d)?\s+safari/i.test(USER_AGENT) 
        && !/chrome/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined;
    
    /**
     * 从文档中获取指定的DOM元素 (@see tangram)
     * 
     * @public
     * @param {(string|HTMLElement)} id 元素的id或DOM元素
     * @return {(HTMLElement|null)} 获取的元素，查找不到时返回null
     */
    DOM.g = function (id) {
        if (objProtoToString.call(id) == '[object String]') {
            return document.getElementById(id);
        } 
        else if (id && id.nodeName && (id.nodeType == 1 || id.nodeType == 9)) {
            return id;
        }
        return null;
    };
    
    /**
     * 通过className获取元素 
     * （不保证返回数组中DOM节点的顺序和文档中DOM节点的顺序一致）
     * @public
     * 
     * @param {string} className 元素的class，只能指定单一的class，
     *          如果为空字符串或者纯空白的字符串，返回空数组。
     * @param {(string|HTMLElement)} element 开始搜索的元素，默认是document。
     * @return {Array} 获取的元素集合，查找不到或className参数错误时返回空数组.
     */
    DOM.q = function (className, element) {
        var result = [];

        if (!className 
            || !(className = String(className).replace(TRIMER_REG, ''))
        ) {
            return result;
        }
        
        if (element == null) {
            element = document;
        } 
        else if (!(element = DOM.g(element))) {
            return result;
        }
        
        if (element.getElementsByClassName) {
            return element.getElementsByClassName(className);
        } 
        else {
            var elements = element.all || element.getElementsByTagName("*");
            for (var i = 0, node, clzz; node = elements[i]; i++) {
                if ((clzz = node.className) != null) {
                    var startIndex = clzz.indexOf(className);
                    var endIndex = startIndex + className.length;
                    if (startIndex >= 0
                        && (
                            clzz.charAt(startIndex - 1) == '' 
                            || SPACE_REG.test(clzz.charAt(startIndex - 1))
                        )
                        && (
                            clzz.charAt(endIndex) == '' 
                            || SPACE_REG.test(clzz.charAt(endIndex))
                        )
                    ) {
                        result[result.length] = node;
                    }
                }
            }
        }
    
        return result;
    };

    /**
     * 为 Element 对象添加新的样式。
     * 
     * @public
     * @param {HTMLElement} el Element 对象
     * @param {string} className 样式名，可以是多个，中间使用空白符分隔
     */
    DOM.addClass = function (el, className) {
        // 这里直接添加是为了提高效率，因此对于可能重复添加的属性，请使用标志位判断是否已经存在，
        // 或者先使用 removeClass 方法删除之前的样式
        el.className += ' ' + className;
    };

    /**
     * 删除 Element 对象中的样式。
     * 
     * @public
     * @param {HTMLElement} el Element 对象
     * @param {string} className 样式名，可以是多个，中间用空白符分隔
     */
    DOM.removeClass = function (el, className) {
        var oldClasses = el.className.split(/\s+/).sort();
        var newClasses = className.split(/\s+/).sort();
        var i = oldClasses.length;
        var j = newClasses.length;

        for (; i && j; ) {
            if (oldClasses[i - 1] == newClasses[j - 1]) {
                oldClasses.splice(--i, 1);
            }
            else if (oldClasses[i - 1] < newClasses[j - 1]) {
                j--;
            }
            else {
                i--;
            }
        }
        el.className = oldClasses.join(' ');
    };    

    /**
     * 获取 Element 对象的父 Element 对象。
     * 在 IE 下，Element 对象被 removeChild 方法移除时，parentNode 仍然指向原来的父 Element 对象，
     * 并且input的parentNode可能为空。
     * 与 W3C 标准兼容的属性应该是 parentElement。
     *
     * @public
     * @param {HTMLElement} el Element 对象
     * @return {HTMLElement} 父 Element 对象，如果没有，返回 null
     */
    DOM.getParent = DOM.ieVersion 
        ? function (el) {
            return el.parentElement;
        } 
        : function (el) {
            return el.parentNode;
        };

    /**
     * 获取子节点
     *
     * @public
     * @param {HTMLElement} el Element 对象
     * @return {Array.<HTMLElement>} 子节点列表
     */
    DOM.children = function (el) {
        if (!el) { return []; }

        for (var result = [], o = el.firstChild; o; o = o.nextSibling) {
            if (o.nodeType == 1) {
                result.push(o);
            }
        }
        return result;    
    };

    /**
     * 删除
     *
     * @public
     * @param {HTMLElement} el Element 对象
     */
    DOM.remove = function (el) {
        if (el) {
            var tmpEl = el.parentNode;
            tmpEl && tmpEl.removeChild(el);
        }
    }

})();


/**
 * xutil.file
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    文件相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var FILE = xutil.file;
            
    /**
     * 过滤文件名的非法字符
     * 只考虑了windows和linux
     * windows文件名非法字符：\/:*?"<>|
     * linux文件名非法字符：/
     */
    FILE.FILE_NAME_FORBIDEN_CHARACTER = {
        '\\' : '＼',
        '/' : '／',
        ':' : '：',
        '*' : '＊',
        '?' : '？', 
        '"' : '＂',
        '<' : '＜',
        '>' : '＞',
        '|' : '｜'
    };
    
    /**
     * 修正文件名
     * 只考虑了windows和linux，
     * 有些字符被禁止做文件名，用类似的字符（如对应的全角字符）替代。
     * 
     * @public
     * @param {string} name 日期对象
     * @return {string} 修正后的文件名
     */    
    FILE.fixFileName = function (name) {
        if (name == null) {
            return name;
        }
        return name.replace(
            /./g, 
            function (w) {
                return FILE.FILE_NAME_FORBIDEN_CHARACTER[w] || w;
            }
        );
    };
    
})();

/**
 * xutil.fn
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    函数相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang
 */

(function () {
    
    var FN = xutil.fn;
    var LANG = xutil.lang;
    var slice = Array.prototype.slice;
    var nativeBind = Function.prototype.bind;
    
    /**
     * 为一个函数绑定一个作用域
     * 如果可用，使用**ECMAScript 5**的 native `Function.bind`
     * 
     * @public
     * @param {Function|string} func 要绑定的函数，缺省则为函数本身
     * @param {Object} context 作用域
     * @param {Any...} 绑定附加的执行参数，可缺省
     * @rerturn {Funtion} 绑定完得到的函数
     */
    FN.bind = function (func, context) {
        var args;
        if (nativeBind && func.bind === nativeBind) {
            return nativeBind.apply(func, slice.call(arguments, 1));
        }
        func = LANG.isString(func) ? context[func] : func;
        args = slice.call(arguments, 2);
        return function () {
            return func.apply(
                context || func, args.concat(slice.call(arguments))
            );
        };
    };

})();

/**
 * xutil.graphic
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    图形图像相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var GRAPHIC = xutil.graphic; 

    /**
     * 合并外界矩形
     *
     * @public
     * @param {Object...} bound...，可传入多个。
     *      bound格式：{left:..,top:..,width:..height:..}
     * @return {Object} 最大外界构成的新bound。如果为null则表示输入全为空。
     */
    GRAPHIC.unionBoundBox = function () {
        var left;
        var top;
        var right;
        var bottom;
        var width;
        var height;
        var bound = null, subBound;

        for(var i = 0, l = arguments.length; i < l; i ++) {
            if( !( subBound = arguments[i])) {
                continue;
            }

            if( !bound) {
                bound = subBound;
            } 
            else {
                left = subBound.left < bound.left 
                    ? subBound.left : bound.left;
                top = subBound.top < bound.top 
                    ? subBound.top : bound.top;
                right = subBound.left + subBound.width;
                width = right > bound.left + bound.width 
                    ? right - bound.left : bound.width;
                bottom = subBound.top + subBound.height;
                height = bottom > bound.top + bound.height 
                    ? bottom - bound.top : bound.height;
                bound.left = left;
                bound.top = top;
                bound.width = width;
                bound.height = height;
            }
        }
        return bound;
    };

})();
        
/**
 * xutil.lang
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    基本工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang, xutil.string
 */

(function () {
    
    var LANG = xutil.lang;
    var STRING = xutil.string;
    var objProto = Object.prototype;
    var objProtoToString = objProto.toString;
    var hasOwnProperty = objProto.hasOwnProperty;
 
    /**
     * 判断变量是否有值
     * null或undefined时返回false。
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */
    LANG.hasValue = function (variable) {
        // undefined和null返回true，其他都返回false
        return variable != null;
    };
    
    /**
     * 判断变量是否有值，且不是空白字符串
     * null或undefined时返回false。
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */
    LANG.hasValueNotBlank = function (variable) {
        return LANG.hasValue(variable)
           && (!LANG.isString(variable) || STRING.trim(variable) != '');
    };

    /**
     * 判断变量是否是空白
     * 如果variable是string，则判断其是否是空字符串或者只有空白字符的字符串
     * 如果variable是Array，则判断其是否为空
     * 如果variable是Object，则判断其是否全没有直接属性（原型上的属性不计）
     * 
     * @public
     * @param {(string|Array|Object)} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isBlank = function (variable) {
        if (LANG.isString(variable)) { 
            return trim(variable) == '';
        } 
        else if (LANG.isArray(variable)) {
            return variable.length == 0;
        } 
        else if (LANG.isObject(variable)) {
            for (var k in variable) {
                if (hasOwnProperty.call(variable, k)) {
                    return false;   
                }
            }
            return true;
        } 
        else {
            return !!variable;
        }
    };

    /**
     * 判断变量是否为undefined
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isUndefined = function (variable) {
        return typeof variable == 'undefined';
    };
    
    /**
     * 判断变量是否为null
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isNull = function (variable) {
        return variable === null;
    };
    
    /**
     * 判断变量是否为number
     * NaN和Finite时也会返回true。
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isNumber = function (variable) {
        return objProtoToString.call(variable) == '[object Number]';
    };
    
    /**
     * 判断变量是否为number
     * NaN和Finite时也会返回false。
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isNormalNumber = function (variable) {
        return LANG.isNumber(variable) 
            && !isNaN(variable) && isFinite(variable);
    };

    /**
     * 判断变量是否为Finite
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isFinite = function (variable) {
        return LANG.isNumber(variable) && isFinite(variable);
    };
    
    /**
     * 判断变量是否为NaN
     * 不同于js本身的isNaN，undefined情况不会返回true
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isNaN = function (variable) {
        // NaN是唯一一个对于'==='操作符不自反的
        return variable !== variable;
    };

    /**
     * 判断变量是否为string
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isString = function (variable) {
        return objProtoToString.call(variable) == '[object String]';
    };
    
    /**
     * 判断变量是否为boolean
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isBoolean = function (variable) {
        return variable === true 
            || variable === false 
            || objProtoToString.call(variable) == '[object Boolean]';        
    };
    
    /**
     * 判断是否为Function
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isFunction = function (variable) {
        return objProtoToString.call(variable) == '[object Function]';
    };
    
    /**
     * 判断是否为Object
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isObject = function (variable) {
         return variable === Object(variable);
    };
    
    /**
     * 判断是否为Array
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isArray = Array.isArray || function (variable) {
        return objProtoToString.call(variable) == '[object Array]';
    };
       
    /**
     * 判断是否为Date
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isDate = function (variable) {
        return objProtoToString.call(variable) == '[object Date]';
    };  
    
    /**
     * 判断是否为RegExp
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isRegExp = function (variable) {
        return objProtoToString.call(variable) == '[object RegExp]';
    };  
    
    /**
     * 判断是否为DOM Element
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */
    LANG.isElement = function (variable) {
        return !!(variable && variable.nodeType == 1);
    };
      
    /**
     * 转换为number
     * 此函数一般用于string类型的数值向number类型数值的转换, 如：'123'转换为123, '44px'转换为44
     * 遵循parseFloat的法则
     * 转换失败返回默认值（从而避免转换失败后返回NaN等）。
     * 
     * @public
     * @param {*} input 要转换的东西
     * @param {*} defaultValue 转换失败时，返回此默认值。如果defaultValue为undefined则返回input本身。
     * @return {(number|*)} 转换结果。转换成功则为number；转换失败则为defaultValue
     */
    LANG.toNumber = function (input, defaultValue) {
        defaultValue = 
            typeof defaultValue != 'undefined' ? defaultValue : input;
        return isFinite(input = parseFloat(input)) ? input : defaultValue;
    };
    
    /**
     * 用于将string类型的"true"和"false"转成boolean型
     * 如果输入参数是string类型，输入参数不为"true"时均转成false。
     * 如果输入参数不是string类型，则按照js本身的强制类型转换转成boolean（从而可以应对不知道input类型的情况）。
     * 
     * @public
     * @param {(string|*)} input 要转换的东西
     * @return {boolean} 转换结果
     */
    LANG.stringToBoolean = function (input) {
        if (LANG.isString(input)) {
            return trim(input) == 'true';
        } 
        else {
            return !!input; 
        }
    };

})();

/**
 * xutil.number
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    数值相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var NUMBER = xutil.number;
            
    /**
     * 得到序数词(1st, 2nd, 3rd, 4th, ...)的英文后缀
     * 
     * @public
     * @param {number} number 序数的数值
     * @return {string} 序数词英文后缀
     */    
    NUMBER.ordinalSuffix = function (number) {
        if (number == 1) {
            return 'st';
        } 
        else if (number == 2) {
            return 'nd';
        } 
        else if (number == 3) {
            return 'rd';
        } 
        else {
            return 'th';
        }
    };
    
    /**
     * 数值前部补0
     * 
     * @public
     * @param {(number|string)} source 输入数值, 可以整数或小数
     * @param {number} length 输出数值长度
     * @return {string} 输出数值
     */
    NUMBER.pad = function (source, length) {
        var pre = "";
        var negative = (source < 0);
        var string = String(Math.abs(source));
    
        if (string.length < length) {
            pre = (new Array(length - string.length + 1)).join('0');
        }
    
        return (negative ?  "-" : "") + pre + string;
    };
    
    /**
     * 将数值按照指定格式进行格式化
     * 支持：
     *      三位一撇，如：'23,444,12.98'
     *      前后缀，如：'23,444$', '23,444%', '#23,444'
     *      四舍五入
     *      四舍六入中凑偶（IEEE 754标准，欧洲金融常用）
     *      正数加上正号，如：'+23.45%'
     *      
     * @public
     * @example formatNumber(10000/3, "I,III.DD%"); 返回"3,333.33%"
     * @param {number} num 要格式化的数字
     * @param {string} formatStr 指定的格式
     *              I代表整数部分,可以通过逗号的位置来设定逗号分隔的位数 
     *              D代表小数部分，可以通过D的重复次数指定小数部分的显示位数
     * @param {string} usePositiveSign 是否正数加上正号
     * @param {number} cutMode 舍入方式：
     *                      0或默认:四舍五入；
     *                      2:IEEE 754标准的五舍六入中凑偶；
     *                      other：只是纯截取
     * @param {boolean} percentMultiply 百分数（formatStr满足/[ID]%/）是否要乘以100
     *                      默认为false
     * @return {string} 格式化过的字符串
     */
    NUMBER.formatNumber = function (
        num, formatStr, usePositiveSign, cutMode, percentMultiply
    ) {
        if (!formatStr) {
            return num;
        }

        if (percentMultiply && /[ID]%/.test(formatStr)) {
            num = num * 100;
        }

        num = NUMBER.fixNumber(num, formatStr, cutMode); 
        var str;
        var numStr = num.toString();
        var tempAry = numStr.split('.');
        var intStr = tempAry[0];
        var decStr = (tempAry.length > 1) ? tempAry[1] : "";
            
        str = formatStr.replace(/I+,*I*/g, function () {
            var matchStr = arguments[0];
            var commaIndex = matchStr.lastIndexOf(",");
            var replaceStr;
            var splitPos;
            var parts = [];
                
            if (commaIndex >= 0 && commaIndex != intStr.length - 1) {
                splitPos = matchStr.length - 1 - commaIndex; 
                while (intStr.length > splitPos) {
                    parts.push(intStr.substr(intStr.length-splitPos,splitPos));
                    intStr = intStr.substring(0, intStr.length - splitPos);
                }
                parts.push(intStr);
                parts.reverse();
                if (parts[0] == "-") {
                    parts.shift();
                    replaceStr = "-" + parts.join(",");
                } 
                else {
                    replaceStr = parts.join(",");
                }
            } 
            else {
                replaceStr = intStr;
            }
            
            if (usePositiveSign && replaceStr && replaceStr.indexOf('-') < 0) {
                replaceStr = '+' + replaceStr;
            }
            
            return replaceStr;
        });
        
        str = str.replace(/D+/g, function () {
            var matchStr = arguments[0]; 
            var replaceStr = decStr;
            
            if (replaceStr.length > matchStr.length) {
                replaceStr = replaceStr.substr(0, matchStr.length);
            } 
            else {
                while (replaceStr.length < matchStr.length) {
                    replaceStr += "0";
                }
            }
            return replaceStr;
        });
        // if ( !/[1-9]+/.test(str) ) { // 全零去除加减号，都不是效率高的写法
            // str.replace(/^(\+|\-)./, '');
        // } 
        return str;
    };
    
    /**
     * 不同方式的舍入
     * 支持：
     *      四舍五入
     *      四舍六入中凑偶（IEEE 754标准，欧洲金融常用）
     * 
     * @public
     * @param {number} cutMode 舍入方式
     *                      0或默认:四舍五入；
     *                      2:IEEE 754标准的五舍六入中凑偶
     */
    NUMBER.fixNumber = function (num, formatStr, cutMode) {
        var formatDec = /D+/.exec(formatStr);
        var formatDecLen = (formatDec && formatDec.length>0) 
                ? formatDec[0].length : 0;
        var p;
            
        if (!cutMode) { // 四舍五入
            p = Math.pow(10, formatDecLen);
            return ( Math.round (num * p ) ) / p ;
        } 
        else if (cutMode == 2) { // 五舍六入中凑偶
            return Number(num).toFixed(formatDecLen);
        } 
        else { // 原样
            return Number(num);
        }
    };

})();

/**
 * xutil.object
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    对象相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var OBJECT = xutil.object;
    var objProtoToString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var arraySlice = Array.prototype.slice;
    
    /**
     * getByPath和setByPath的默认context。
     * 可以在工程中修改。
     */
    OBJECT.PATH_DEFAULT_CONTEXT = window;

    /**
     * 根据对象路径得到数据。
     * 默认根是window。
     * 路径中支持特殊字符（只要不和分隔符冲突即可）。
     * 路径分隔符可以定制，默认是点号和中括号。
     * 如果未取到目标，返回null。
     * 注意：此方法不会去trim路径中的空格。
     * 例如：
     *      在window中
     *      已有var obj = { asdf: { zxcv: { qwer: 12 } } };
     *      可用getByPath('obj.asdf.zxcv.qwer'); 得到数值12。
     *      已有var obj = { aaa: [123, { fff: 678 }] };（路径中有数组）
     *      可用getByPath('aaa.2.fff', obj);
     *      或getByPath('aaa[2].fff', obj);得到数值678。
     * 
     * @public
     * @param {string} path 如xxx.sss.aaa[2][3].SomeObj，
     *      如果为null或undefined，返回context。
     * @param {Object=} context 根，缺省是window，
     *     另外可使用OBJECT.PATH_DEFAULT_CONTEXT配置缺省值
     * @param {Object=} options 选项
     * @param {string=} objDelimiter 对象定界符，默认是点号
     * @param {string=} arrBegin 数组起始标志符，默认是左方括号
     * @param {string=} arrEnd 数组结束标志符，默认是右方括号
     * @return {*} 取得的数据，如上例得到SomeObj
     */
    OBJECT.getByPath = function (path, context, options) {
        options = options || {};
        context = context || OBJECT.PATH_DEFAULT_CONTEXT;

        if (path == null) { return context; }

        var arrBegin = options.arrBegin || '[';
        var arrEnd = options.arrEnd || ']';
        var pathArr = path.split(
                options.objDelimiter != null ? options.objDelimiter : '.'
            );

        for (var i = 0, j, pai, pajs, paj; i < pathArr.length; i ++) {
            pai = pathArr[i];
            pajs = pai.split(arrBegin);

            for (j = 0; j < pajs.length; j ++) {
                paj = pajs[j];
                j > 0 && (paj = paj.split(arrEnd)[0]);

                // 如果未取到目标时context就非对象了
                if (context !== Object(context)) {
                    return;
                }

                context = context[paj];
            }
        }
        return context;
    };

    /**
     * 根据对象路径设置数据。
     * 默认根是window。
     * 如果路径中没有对象/数组，则创建之。
     * 路径中支持特殊字符（只要不和分隔符冲突即可）。
     * 路径分隔符可以定制，默认是点号和中括号。
     * 注意：此方法不会去trim路径中的空格。
     * 例如：
     *      可用setByPath('obj.asdf.zxcv', 12); 
     *      在window中生成对象obj，其内容为{ asdf: { zxcv: 12 } };
     *      又可用setByPath('asdf.aaa[2].fff', 678, obj);
     *      或者setByPath('obj.asdf.aaa[2].fff', 678);
     *      对obj赋值，使obj值最终为：
     *          { 
     *              asdf: { 
     *                  zxcv: 12,
     *                  aaa: [undefined, { fff: 678 }] 
     *              } 
     *          };（路径中有数组）
     * 
     * @public
     * @param {string} path 如xxx.sss.aaa[2][3].SomeObj
     * @param {*} value 要设置的值
     * @param {Object=} context 根，缺省是window
     *     另外可使用OBJECT.PATH_DEFAULT_CONTEXT配置缺省值
     * @param {Object=} options 选项
     * @param {string=} objDelimiter 对象定界符，默认是点号
     * @param {string=} arrBegin 数组起始标志符，默认是左方括号
     * @param {string=} arrEnd 数组结束标志符，默认是右方括号
     * @param {string=} conflict 当路径冲突时的处理.
     *      路径冲突指路径上已有值（即非undefined或null）但不是对象，
     *      例如假设当前已经有var obj = { a: 5 };
     *      又想setByPath('a.c.d', obj, 444)。
     *      conflict值可为：
     *          'THROW': 路径冲突时抛出异常（默认）；
     *          'IGNORE': 路径冲突时不做任何操作直接返回；
     *          'OVERLAP': 路径冲突时直接覆盖。
     */
    OBJECT.setByPath = function (path, value, context, options) {
        options = options || {};
        context = context || OBJECT.PATH_DEFAULT_CONTEXT;
        
        if (path == null) { return; }

        var arrBegin = options.arrBegin || '[';
        var arrEnd = options.arrEnd || ']';
        var conflict = options.conflict || 'THROW';
        var pathArr = path.split(
                options.objDelimiter != null ? options.objDelimiter : '.'
            );

        for (var i = 0, j, pai, pajs, paj, pv; i < pathArr.length; i ++) {
            pai = pathArr[i];
            pajs = pai.split(arrBegin);

            for (j = 0; j < pajs.length; j ++) {
                paj = pajs[j];
                j > 0 && (paj = paj.split(arrEnd)[0]);
                pv = context[paj];

                // 最终赋值
                if (i == pathArr.length - 1 && j == pajs.length - 1) {
                    context[paj] = value;
                    return;
                }
                else {
                    // 如果路径上已有值但不是对象
                    if (pv != null && pv !== Object(pv)) {
                        if (conflict == 'THROW') {
                            throw new Error('Path conflict: ' + path);
                        }
                        else if (conflict == 'IGNORE') {
                            return;
                        }
                    }

                    context = pv !== Object(pv)
                        // 如果路径上没有对象则创建
                        ? (
                            context[paj] = pajs.length > 1 && j < pajs.length - 1 
                            ? [] : {}
                        )
                        : context[paj];
                }
            }
        }
    };
    
    /**
     * 兼容性的setter，向一个对象中set数据
     * 
     * @public
     * @param {Object} container 目标对象
     * @param {string} key 关键字
     * @param {*} value 数据
     */
    OBJECT.set = function (container, key, value) {
        if (isFunction(container['set'])) {
            container['set'](key, value);
        } 
        else {
            container[key];
        }
    };

    /**
     * 在某对象中记录key/检查是否有key的方便方法
     * 
     * @public
     * @param {string=} key 如果为空，则fanhuitrue
     * @param {Object} context 需要enable/disable的对象
     * @return {boolean} 是否可以enable
     */
    OBJECT.objKey = (function () {

        /**
         * 在目标对象中会占用此成员记录key
         */
        var KEY_ATTR_NAME = '\x07__OBJ__KEY__';

        /**
         * 检查对象中是否有记录的key
         * 
         * @public
         * @param {Object} context 目标对象
         * @param {string=} key 如果为null或undefined，则返回false
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         * @return {boolean} 是否有key
         */
        function has(context, key, keyName) {
            if (key == null) { return false; }

            var hasKey = false;
            var keyList = getKeyList(context, keyName);

            for (var i = 0; i < keyList.length; i ++) {
                if (key == keyList[i]) {
                    hasKey = true;
                }
            }

            return hasKey;        
        }

        /**
         * 对象中key的数量
         * 
         * @public
         * @param {Object} context 目标对象
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         * @return {number} key的数量
         */
        function size(context, keyName) {
            return getKeyList(context, keyName).length;
        }

        /**
         * 在对象中记录key
         * 
         * @public
         * @param {Object} context 需要enable/disable的对象
         * @param {string=} key 如果为null或undefined，则不记录key
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         */
        function add(context, key, keyName) {
            if (key == null) { return; }

            if (!has(context, key, keyName)) {
                getKeyList(context, keyName).push(key);
            }
        }

        /**
         * 在对象中删除key
         * 
         * @public
         * @param {Object} context 需要enable/disable的对象
         * @param {string=} key 如果为null或undefined，则不删除key
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         */
        function remove(context, key, keyName) {
            if (key == null) { return; }

            var keyList = getKeyList(context, keyName);

            for (var i = 0; i < keyList.length; ) {
                if (key == keyList[i]) {
                    keyList.splice(i, 1);
                }
                else {
                    i ++;
                }
            }
        }

        /**
         * 得到keylist
         * 
         * @private
         * @param {Object} context 目标对象
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         * @return {Array} 
         */
        function getKeyList(context, keyName) {
            if (keyName == null) {
                keyName = '';
            }

            if (!context[KEY_ATTR_NAME + keyName]) {
                context[KEY_ATTR_NAME + keyName] = [];
            }

            return context[KEY_ATTR_NAME + keyName];
        }

        return {
            add: add,
            remove: remove,
            has: has,
            size: size,
            KEY_ATTR_NAME: KEY_ATTR_NAME
        };

    })();

    /**
     * 兼容性的getter，从一个对象中get数据
     * 
     * @public
     * @param {Object} container 目标对象
     * @param {string} key 关键字
     * @return {*} 数据
     */
    OBJECT.get = function (container, key) {
        if (isFunction(container['get'])) {
            return container['get'](key);
        } 
        else {
            return container[key];
        }
    };

    /**
     * 是否是空对象
     * 
     * @public
     * @param {Object} o 输入对象
     * @return {boolean} 是否是空对象
     */
    OBJECT.isEmptyObj = function (o) {    
        if (o !== Object(o)) {
            return false;
        }
        for (var i in o) {
            return false;
        }
        return true;
    };
                
    /**
     * 属性拷贝（对象浅拷贝）
     * target中与source中相同的属性会被覆盖。
     * prototype属性不会被拷贝。
     * 
     * @public
     * @usage extend(target, source1, source2, source3);
     * @param {(Object|Array)} target
     * @param {(Object|Array)...} source 可传多个对象，
     *          从第一个source开始往后逐次extend到target中
     * @return {(Object|Array)} 目标对象
     */
    OBJECT.extend = function (target) {
        var sourceList = arraySlice.call(arguments, 1);
        for (var i = 0, source, key; i < sourceList.length; i ++) {
            if (source = sourceList[i]) {
                for (key in source) {
                    if (source.hasOwnProperty(key)) {
                        target[key] = source[key];
                    }
                }
            }
        }
        return target;
    };
    
    /**
     * 属性赋值（对象浅拷贝）
     * 与extend的不同点在于，可以指定拷贝的属性，
     * 但是不能同时进行多个对象的拷贝。
     * target中与source中相同的属性会被覆盖。
     * prototype属性不会被拷贝。
     * 
     * @public
     * @param {(Object|Array)} target 目标对象
     * @param {(Object|Array)} source 源对象
     * @param {(Array.<string>|Object)} inclusion 包含的属性列表
     *          如果为{Array.<string>}，则意为要拷贝的属性名列表，
     *              如['aa', 'bb']表示将source的aa、bb属性
     *              分别拷贝到target的aa、aa上
     *          如果为{Object}，则意为属性名映射，
     *              如{'sAa': 'aa', 'sBb': 'bb'}表示将source的aa、bb属性
     *              分别拷贝到target的sAa、sBb上
     *          如果为null或undefined，
     *              则认为所有source属性都要拷贝到target中
     * @param {Array.<string>} exclusion 不包含的属性列表，
     *              如果与inclusion冲突，以exclusion为准.
     *          如果为{Array.<string>}，则意为要拷贝的属性名列表，
     *              如['aa', 'bb']表示将source的aa、bb属性分别拷贝到target的aa、aa上
     *          如果为null或undefined，则忽略此参数
     * @return {(Object|Array)} 目标对象
     */
    OBJECT.assign = function (target, source, inclusion, exclusion) {
        var i;
        var len;
        var inclusionMap = makeClusionMap(inclusion);
        var exclusionMap = makeClusionMap(exclusion);

        for (var i in source) {
            if (source.hasOwnProperty(i)) {
                if (!inclusion) {
                    if (exclusionMap[i] == null) {
                        target[i] = source[i];
                    }
                }
                else {
                    if (inclusionMap[i] != null && exclusionMap[i] == null) {
                        target[inclusionMap[i]] = source[i];
                    }
                }
            }
        }

        return target;
    };       
    
    /**
     * 对象深拷贝
     * 原型上的属性不会被拷贝。
     * 非原型上的属性中，
     * 会进行克隆的属性：
     *      值属性
     *      数组
     *      Date
     *      字面量对象(literal object @see isPlainObject)
     * 不会进行克隆只引用拷贝的属性：
     *      其他类型对象（如DOM对象，RegExp，new somefunc()创建的对象等）
     * 
     * @public
     * @param {(Object|Array)} source 源对象
     * @param {Object=} options 选项
     * @param {Array.<string>} options.exclusion 不包含的属性列表
     * @return {(Object|Array)} 新对象
     */
    OBJECT.clone = function (source, options) {
        options = options || {};
        var result;
        var i;
        var isArr;
        var exclusionMap = makeClusionMap(options.exclusion);

        if (isPlainObject(source)
            // 对于数组也使用下面方式，把非数字key的属性也拷贝
            || (isArr = isArray(source))
        ) {
            result = isArr ? [] : {};
            for (i in source) {
                if (source.hasOwnProperty(i) && !(i in exclusionMap)) {
                    result[i] = OBJECT.clone(source[i]);
                }
            }
        } 
        else if (isDate(source)) {
            result = new Date(source.getTime());
        } 
        else {
            result = source;
        }
        return result;
    };

    /**
     * 两个对象融合
     * 
     * @public
     * @param {(Object|Array)} target 目标对象
     * @param {(Object|Array)} source 源对象
     * @param {Object} options 参数
     * @param {boolean} options.overwrite 是否用源对象的属性覆盖目标对象的属性（默认true）
     * @param {(boolean|string)} options.clone 对于对象属性，
     *      如果值为true则使用clone（默认），
     *      如果值为false则直接引用，
     *      如果值为'WITHOUT_ARRAY'，则克隆数组以外的东西
     * @param {Array.<string>} options.exclusion 不包含的属性列表
     * @return {(Object|Array)} 目标对象
     */
    OBJECT.merge = function (target, source, options) {
        options = options || {};
        var overwrite = options.overwrite;
        overwrite == null && (overwrite = true);
        var clone = options.clone;
        clone == null && (clone = true);

        var exclusionMap = makeClusionMap(options.exclusion);

        if (isPlainObject(target) && isPlainObject(source)) {
            doMerge(target, source, overwrite, clone, exclusionMap);
        }
        return target;
    };

    function doMerge(target, source, overwrite, clone, exclusionMap) {
        var s;
        var t;
        
        for (var i in source) {
            s = source[i];
            t = target[i];

            if (!(i in exclusionMap) && source.hasOwnProperty(i)) {
                if (isPlainObject(t) && isPlainObject(s)) {
                    doMerge(t, s, overwrite, clone, exclusionMap);
                } 
                else if (overwrite || !(i in target)) {
                    target[i] = clone && (
                            clone != 'WITHOUT_ARRAY' || !isArray(s)
                        )
                        ? OBJECT.clone(s) 
                        : s;
                }
            }
        }
    }

    /**
     * 类继承
     *
     * @public
     * @param {Function} subClass 子类构造函数
     * @param {Function} superClass 父类
     * @return {Object} 生成的新构造函数的原型
     */
    OBJECT.inherits = function (subClass, superClass) {
        var oldPrototype = subClass.prototype;
        var clazz = new Function();

        clazz.prototype = superClass.prototype;
        OBJECT.extend(subClass.prototype = new clazz(), oldPrototype);
        subClass.prototype.constructor = subClass;
        subClass.superClass = superClass.prototype;

        return subClass.prototype;
    };

    /**
     * 模型继承
     * 生成的构造函数含有父类的构造函数的自动调用
     *
     * @public
     * @param {Function} superClass 父类，如果无父类则为null
     * @param {Function} subClassConstructor 子类的标准构造函数，
     *          如果忽略将直接调用父控件类的构造函数
     * @return {Function} 新类的构造函数
     */
    OBJECT.inheritsObject = function (superClass, subClassConstructor) {
        var agent = function (options) {
                return new agent.client(options);
            }; 
        var client = agent.client = function (options) {
                options = options || {};
                superClass && superClass.client.call(this, options);
                subClassConstructor && subClassConstructor.call(this, options);
            };
            
        superClass && OBJECT.inherits(agent, superClass);
        OBJECT.inherits(client, agent);
        client.agent = agent;

        return agent;
    };

    /**
     * 创建单例
     * 生成的构造函数含有父类的构造函数的自动调用
     *
     * @public
     * @param {Function} superClass 父类，如果无父类则为null
     * @param {Function} subClassConstructor 子类的标准构造函数，
     *          如果忽略将直接调用父控件类的构造函数
     * @return {Function} 新类的构造函数
     */
    OBJECT.createSingleton = function (superClass, subClassConstructor) {
        var instance;
        var agent = function (options) {
                return instance || (instance = new agent.client(options));
            };
        var client = agent.client = function (options) {
                options = options || {};
                superClass && superClass.client.call(this, options);
                subClassConstructor && subClassConstructor.call(this, options);
            };
            
        superClass && OBJECT.inherits(agent, superClass);
        OBJECT.inherits(client, agent);
        client.agent = agent;

        return agent;
    };

    /**
     * 试图判断是否是字面量对象 (@see jquery, tangram)
     * 字面量(literal)对象，简单来讲，
     * 即由{}、new Object()类似方式创建的对象，
     * 而DOM对象，函数对象，Date对象，RegExp对象，
     * 继承/new somefunc()自定义得到的对象都不是字面量对象。
     * 此方法尽力按通常情况排除通非字面量对象，
     * 但是不可能完全排除所有的非字面量对象。
     * 
     * @public
     * @param {Object} obj 输入对象
     * @return {boolean} 是否是字面量对象
     */
    var isPlainObject = OBJECT.isPlainObject = function (obj) {
        
        // 首先必须是Object（特别地，排除DOM元素）
        if (!obj || Object.prototype.toString.call(obj) != '[object Object]'
            // 但是在IE中，DOM元素对上一句话返回true，
            // 所以使用字面量对象的原型上的isPrototypeOf来判断
            || !('isPrototypeOf' in obj)) {
            return false;
        }

        try {
            // 试图排除new somefunc()创建出的对象
            if (// 如果没有constructor肯定是字面量对象
                obj.constructor
                // 有constructor但不在原型上时通过
                && !hasOwnProperty.call(obj, 'constructor') 
                // 用isPrototypeOf判断constructor是否为Object对象本身
                && !hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')
            ) {
                return false;
            }
        } catch ( e ) {
            // IE8,9时，某些情况下访问某些host objects(如window.location)的constructor时，
            // 可能抛异常，@see jquery #9897
            return false;
        }

        // 有一个继承的属性就不算字面量对象，
        // 因原型上的属性会在后面遍历，所以直接检查最后一个
        for (var key in obj) {}
        return key === undefined || hasOwnProperty.call(obj, key);
    };

    /**
     * 是否为数组
     */
    function isArray(o) {
        return objProtoToString.call(o) == '[object Array]';
    }

    /**
     * 是否为function
     */
    function isFunction(o) {
        return objProtoToString.call(o) == '[object Function]';
    }

    /**
     * 是否为Date
     */
    function isDate(o) {
        return objProtoToString.call(o) == '[object Date]';
    }

    /**
     * 做inclusion map, exclusion map
     */
    function makeClusionMap (clusion) {
        var i;
        var clusionMap = {};

        if (isArray(clusion)) {
            for (i = 0; i < clusion.length; i ++) {
                clusionMap[clusion[i]] = clusion[i];
            }
        } 
        else if (clusion === Object(clusion)) { 
            for (i in clusion) {
                clusionMap[clusion[i]] = i;
            }
        }

        return clusionMap;
    }

})();

/**
 * xutil.string
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    字符串相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang
 */

(function () {
    
    var STRING = xutil.string;
    var LANG = xutil.lang;
    var TRIMER = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );
    
    /**
     * 删除目标字符串两端的空白字符 (@see tangram)
     * 
     * @pubilc
     * @param {string} source 目标字符串
     * @returns {string} 删除两端空白字符后的字符串
     */
    STRING.trim = function (source) {
        return source == null 
            ? ""
            : String(source).replace(TRIMER, "");
    };
    
    /**
     * HTML编码，包括空格也会被编码
     * 
     * @public
     * @param {string} text 要编码的文本
     * @param {number} blankLength 每个空格的长度，
     *      为了显示效果，可调整长度，缺省为1
     */
    STRING.encodeHTMLWithBlank = function (text, blankLength) {
        var blankArr=[];
        blankLength = blankLength || 1;
        for(var i = 0; i < blankLength; i++) {
            blankArr.push('&nbsp;');
        }
        return STRING.encodeHTML(text).replace(/ /g, blankArr.join(''));
    };
    
    /**
     * 对目标字符串进行html编码 (@see tangram)
     * 编码字符有5个：&<>"'
     * 
     * @public
     * @param {string} source 目标字符串
     * @returns {string} html编码后的字符串
     */
    STRING.encodeHTML = function (source) {
        return String(source)
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");
    };
        
    /**
     * 对目标字符串进行html解码(@see tangram)
     * 
     * @public
     * @param {string} source 目标字符串
     * @returns {string} html解码后的字符串
     */
    STRING.decodeHTML = function (source) {
        var str = String(source)
                    .replace(/&quot;/g,'"')
                    .replace(/&lt;/g,'<')
                    .replace(/&gt;/g,'>')
                    .replace(/&amp;/g, "&");
        //处理转义的中文和实体字符
        return str.replace(/&#([\d]+);/g, function (_0, _1){
            return String.fromCharCode(parseInt(_1, 10));
        });
    };
        
    /**
     * 得到可显示的文本的方便函数，便于业务代码中批量使用
     * 
     * @public
     * @param {string} source 原文本
     * @param {string} defaultText 如果source为空，则使用defaultText，缺省为''。
     *      例如页面上表格内容为空时，显示'-'
     * @param {boolean} needEncodeHTML 是否要进行HTML编码，缺省为false
     * @param {Object} htmlEncoder HTML编码器，缺省为STRING.encodeHTML
     */
    STRING.toShowText = function (source, defaultText, needEncodeHTML, htmlEncoder) {
        defaultText =  LANG.hasValue(defaultText) ? defaultText : '';
        htmlEncoder = htmlEncoder || STRING.encodeHTML;
        var text = LANG.hasValueNotBlank(source) ? source : defaultText;
        needEncodeHTML && (text = htmlEncoder(text));
        return text;
    };
    
    /**
     * 去除html/xml文本中的任何标签
     * （前提是文本没有被encode过）
     * 
     * @public
     * @param {string} source 输入文本
     * @return {string} 输出文本
     */
    STRING.escapeTag = function (source) {
        if (!LANG.hasValueNotBlank(source)) {
            return '';
        }
        return String(source).replace(/<.*?>/g,'');
    };
    
    /**
     * 将目标字符串中可能会影响正则表达式构造的字符串进行转义。(@see tangram)
     * 给以下字符前加上“\”进行转义：.*+?^=!:${}()|[]/\
     * 
     * @public
     * @param {string} source 目标字符串
     * @return {string} 转义后的字符串
     */
    STRING.escapeReg = function (source) {
        return String(source)
                .replace(
                    new RegExp("([.*+?^=!:\x24{}()|[\\]\/\\\\])", "g"), 
                    '\\\x241'
                );
    };    
    
    /**
     * 求字符串的字节长度，非ASCII字符算两个ASCII字符长
     * 
     * @public
     * @param {string} str 输入文本
     * @return {number} 字符串字节长度
     */
    STRING.textLength = function (str){
        if (!LANG.hasValue(str)) { return 0; };
        return str.replace(/[^\x00-\xFF]/g,'**').length;
    };
    /**
     * 截取字符串，如果非ASCII字符，
     * 算两个字节长度（一个ASCII字符长度是一个单位长度）
     * 
     * @public
     * @param {string} str 输入文本
     * @param {number} start 从第几个字符开始截取
     * @param {number} length 截取多少个字节长度
     * @return {string} 截取的字符串
     */
    STRING.textSubstr = function (str, start, length) {
        if (!LANG.hasValue(str)) {
            return '';
        }
        var count=0;
        for(var i = start, l = str.length; i < l && count < length; i++) {
            str.charCodeAt(i) > 255 ? (count += 2) : (count++);
        }
        count > length && i--;
        return str.substring(start, i); 
    };
    
    /**
     * 折行，如果非ASCII字符，算两个单位长度（一个ASCII字符长度是一个单位长度）
     * 
     * @public
     * @param {string} str 输入文本
     * @param {number} length 每行多少个单位长度
     * @param {string} lineSeparater 换行符，缺省为\r
     * @return {string} 折行过的文本
     */
    STRING.textWrap = function (str, length, lineSeparater) {
        lineSeparater = lineSeparater || '\r';
        if (length < 2)  {
            throw Error ('illegle length');
        }
        if (!LANG.hasValueNotBlank(str)) {
            return '';
        }
        
        var i = 0;
        var lineStart=0;
        var l=str.length;
        var count=0;
        var textArr=[];
        var lineStart;

        while(true) {
            if (i>=l) {
                textArr.push(str.substring(lineStart, l+1));
                break;  
            }
            str.charCodeAt(i)>255 ? (count+=2) : (count++);
            if(count>=length) {
                (count>length) && (i=i-1);
                textArr.push(str.substring(lineStart, i+1));
                lineStart = i+1;
                count = 0;
            }
            i++;
        }
        return textArr.join(lineSeparater);     
    };
 
    /**
     * 按照模板对目标字符串进行格式化 (@see tangram)
     *
     * @public
     * @usage 
     *      template('asdf#{0}fdsa#{1}8888', 'PA1', 'PA2') 
     *      返回asdfPA1fdsaPA28888。
     *      template('asdf#{name}fdsa#{area}8888, { name: 'PA1', area: 'PA2' }) 
     *      返回asdfPA1fdsaPA28888。   
     * @param {string} source 目标字符串
     * @param {(Object|...string)} options 提供相应数据的对象
     * @return {string} 格式化后的字符串
     */
    STRING.template = function (source, options) {
        source = String(source);
        var data = Array.prototype.slice.call(arguments, 1);
        var toString = Object.prototype.toString;

        if(data.length) {
            data = data.length == 1 ? 
                (options !== null && 
                    (/\[object Array\]|\[object Object\]/.test(
                        toString.call(options)
                    )) 
                        ? options : data
                ) : data;

            return source.replace(
                /#\{(.+?)\}/g, 
                function (match, key) {
                    var replacer = data[key];
                    if('[object Function]' == toString.call(replacer)) {
                        replacer = replacer(key);
                    }
                    return ('undefined' == typeof replacer ? '' : replacer);
                }
            );

        }
        return source;
    };

})();

/**
 * xutil.uid
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    唯一性ID相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var UID = xutil.uid;
    var INCREASED_UID_BASE_PUBLIC = 1;
    var INCREASED_UID_BASE_PRIVATE = {};
    
    /**
     * 获取不重复的随机串（自增，在单浏览器实例，无worker情况下保证唯一）
     * @public
     * 
     * @param {Object} options
     * @param {string} options.key UID的所属。
     *          缺省则为公共UID；传key则为私有UID。
     *          同一key对应的UID不会重复，不同的key对应的UID可以重复。
     * @return {string} 生成的UID
     */
    UID.getIncreasedUID = function (key) {
        if (key != null) {
            !INCREASED_UID_BASE_PRIVATE[key] 
                && (INCREASED_UID_BASE_PRIVATE[key] = 1);
            return INCREASED_UID_BASE_PRIVATE[key] ++;
        } 
        else {
            return INCREASED_UID_BASE_PUBLIC ++ ;
        }
    };
    
    /**
     * 也可以在应用中重载此定义
     */
    UID.getUID = UID.getIncreasedUID;
    
})();


/**
 * xutil.url
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    时间相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang
 */

(function () {
    
    var URL = xutil.url;
    var LANG = xutil.lang;
    var objProtoToString = Object.prototype.toString;
    var arrayProtoSlice = Array.prototype.slice;

    /**
     * 包装js原生的decodeURIComponent，
     * 对于undefined和null均返回空字符串
     * 
     * @public
     * @param {string} input 输入文本
     * @return {string} 输出文本
     */
    URL.decodeURIComponent = function (input) { 
        return LANG.hasValueNotBlank(input) 
            ? decodeURIComponent(input) : input;
    };
    
    /**
     * 向URL增加参数
     * 
     * @public
     * @param {string} url 输入url
     * @param {string} paramStr 参数字符串
     * @param {number} urlType url类型，1:普通URL（默认）; 2:erURL 
     * @return {string} 结果url
     */
    URL.appendParam = function (url, paramStr, urlType) {
        urlType = urlType || 1;

        if (url.indexOf('?') < 0) {
            url += (urlType == 2 ? '~' : '?') + paramStr;
        } 
        else {
            url += '&' + paramStr;
        }

        return url;
    };

    /**
     * 替换url中的参数。如果没有此参数，则添加此参数。
     * 
     * @public
     * @param {string} 输入url
     * @param {string} paramName 参数名
     * @param {string} newValue 新参数值，如果为空则给此paramName赋空字串
     * @param {number} urlType url类型，1:普通URL（默认）; 2:erURL 
     * @return {string} 结果url
     */
    URL.replaceIntoParam = function (url, paramName, newValue, urlType) {
        var retUrl = url;
        
        if (!retUrl || !LANG.hasValueNotBlank(paramName)) { 
            return retUrl; 
        }
        newValue = newValue != null ? newValue : '';

        var regexp = new RegExp('([&~?])' + paramName + '=[^&]*');
        var paramStr = paramName + '=' + newValue;
        if (regexp.test(retUrl)) { // 替换
            // js不支持反向预查
            retUrl = retUrl.replace(regexp, '$1' + paramStr); 
        } 
        else { // 添加
            retUrl = URL.appendParamStr(retUrl, paramStr, urlType);
        }
        return retUrl;
    };
    
    /**
     * 一个将请求参数转换为对象工具函数
     * 
     * @public
     * @usage url.parseParam('asdf=123&qwer=654365&t=43&t=45&t=67'); 
     *          一个将请求参数转换为对象工具函数
     *          其中如上例，返回对象{asdf:123, qwer:654365, t: [43, 45, 67]}
     * @param {string} paramStr 请求参数字符串
     * @return {Object} 请求参数封装对象，如上例
     */
    URL.parseParam = function (paramStr) {
        var paramMap = {};

        if (paramStr == null) {
            return paramMap;
        }

        var paramArr = paramStr.split('&');
        for (var i = 0, len = paramArr.length, o; i < len; i++) {
            o = paramArr[i] != null ? paramArr[i] : '';
            o = o.split('=');
            
            if (o[0] == null) { continue; }

            if (paramMap.hasOwnProperty(o[0])) {
                if (objProtoToString(paramMap[o[0]]) == '[object Array]') {
                    paramMap[o[0]].push(o[1]);
                } 
                else {
                    paramMap[o[0]] = [paramMap[o[0]], o[1]];   
                }
            } 
            else {
                paramMap[o[0]] = o[1];   
            }
        }
        return paramMap;
    };

    /**
     * 请求参数变为string
     * null和undefined会被转为空字符串
     * 可支持urlencoding
     * 
     * @public
     * @usage url.stringifyParam({asdf:123, qwer:654365, t: [43, 45, 67]})
     *          一个将请求参数对象转换为数组的工具函数
     *          其中如上例，返回['asdf=123', 'qwer=654365', 't=43', 't=45', 't=67'] 
     *          可自己用join('&')变为请求参数字符串'asdf=123&qwer=654365&t=43&t=45&t=67'
     *
     * @param {Object} paramObj 请求参数封装
     *      key为参数名，
     *      value为参数值，{string}或者{Array.<string>}类型   
     * @param {boolean} useEncoding 是否使用urlencoding，默认false
     * @return {Array.<string>} 请求参数数组
     */
    URL.stringifyParam = function (paramObj, useEncoding) {
        var paramArr = [];
        var textParam = URL.textParam;

        function pushParam(name, value) {
            paramArr.push(
                textParam(name, !useEncoding) 
                + '=' 
                + textParam(value, !useEncoding)
            );
        }    

        var name;
        var value;
        var i;
        for (name in (paramObj || {})) {
            value = paramObj[name];
            if (Object.prototype.toString.call(value) == '[object Array]') {
                for (i = 0; i < value.length; i ++) {
                    pushParam(name, value[i]);
                }
            }
            else {
                pushParam(name, value);
            }
        }
        return paramArr;
    };

    /**
     * 格式化文本请求参数的方便函数，统一做提交前最常需要做的事：
     * (1) 判空防止请求参数中出现null/undefined字样，
     * (2) encodeURIComponent（默认进行，可配置）
     *
     * @public
     * @param {string} str 参数值
     * @param {boolean} dontEncoding 默认false
     * @param {string} defaultValue 数据为空时默认值，缺省为''
     * @return {string} 用于传输的参数值
     */
    URL.textParam = function (str, dontEncoding, defaultValue) {
        typeof defaultValue == 'undefined' && (defaultValue = '');
        str = str == null ? defaultValue : str;
        return dontEncoding ? str : encodeURIComponent(str);
    };

    /**
     * 格式化数值请求参数的方便函数，统一做提交前最常需要做的事：
     * 防止请求参数中出现null/undefined字样，如果为空可指定默认值
     *
     * @public
     * @param {(string|number)} value 参数值
     * @param {string} defaultValue 数据为空时的默认值，缺省为''
     * @return {string} 用于传输的参数值
     */
    URL.numberParam = function (value, defaultValue) {
        typeof defaultValue == 'undefined' && (defaultValue = '');
        return (value == null || value === '') ? defaultValue : value;
    };

    /**
     * 格式化数值请求参数的方便函数，统一做提交前最常需要做的事：
     * 直接构造array请求参数，如 aaa=1&aaa=233&aaa=443 ...
     * 防止请求参数中出现null/undefined字样，如果为空可指定默认值
     * 
     * @public
     * @param {array} arr 要构成arr的参数，结构可以为两种
     *              (1) ['asdf', 'zxcv', 'qwer']
     *                  不需要传入attrName。
     *              (2) [{ t: 'asdf' }, { t: 'zxcv' }]
     *                  需要传入attrName为t。
     * @param {string} paramName 参数名
     *                  如上例，假如传入值'aaa'，
     *                  则返回值为aaa=asdf&aaa=zxcv&aaa=qwer
     * @param {string=} attrName 为arr指定每项的属性名，解释如上
     * @param {Function=} paramFunc 即每个参数的处理函数,
     *                  缺省则为xutil.url.textParam
     * @param {...*} paramFunc_args 即paramFunc的补充参数
     * @return {Array} 参数字符串数组，如['aa=1', 'aa=33', 'aa=543']
     *              可直接使用join('&')形成用于传输的参数aa=1&aa=33&aa=543
     */
    URL.wrapArrayParam = function (arr, paramName, attrName, paramFunc) {
        if (!arr || !arr.length) {
            return [];
        }
        
        paramFunc = paramFunc || URL.textParam;
        var args = arrayProtoSlice.call(arguments, 4);

        var paramArr = [];
        for (var i = 0, item; i < arr.length; i ++) {
            item = arr[i];
            if (item === Object(item)) { // 如果item为Object
                item = item[attrName];
            }
            item = paramFunc.apply(null, [item].concat(args));
            paramArr.push(paramName + '=' + item);
        }

        return paramArr;
    };

})();

/**
 * xutil.validator
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    输入验证相关工具函数
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang
 */

(function () {
    
    var VALIDATOR = xutil.validator = {};

    var REGEXP_CASH = /^\d+(\.\d{1,2})?$/;
    var REGEXP_CASH_CAN_NAGE = /^(\+|-)?\d+(\.\d{1,2})?$/;
    var REGEXP_EMAIL = /^[_\w-]+(\.[_\w-]+)*@([\w-])+(\.[\w-]+)*((\.[\w]{2,})|(\.[\w]{2,}\.[\w]{2,}))$/;
    var REGEXP_URL = /^[^.。，]+(\.[^.，。]+)+$/;
    var REGEXP_MOBILE = /^1\d{10}$/;
    var REGEXP_ZIP_CODE = /^\d{6}$/;
    
    /**
     * 是否金额
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @param {boolean} canNagetive 是否允许负值，缺省为false
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isCash = function (value, canNagetive) {
        return canNagetive 
            ? REGEXP_CASH_CAN_NAGE.test(value) : REGEXP_CASH.test(value);
    };   

    /**
     * 是否金额
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isURL = function (value) {
        return REGEXP_URL.test(value); 
    };

    /**
     * 是否移动电话
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isMobile = function (value) {
        return REGEXP_MOBILE.test(value);
    };    

    /**
     * 是否电子邮箱
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isEMAIL = function (value) {
        return REGEXP_EMAIL.test(value);
    };
    
    /**
     * 是否邮政编码
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isZipCode = function (value) {
        return REGEXP_ZIP_CODE.test(value);
    };
    
})();

/**
 * ecui.XObject
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    视图和模型的基类
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.object
 * @version: 1.0.1
 */

(function () {

    //----------------------------------
    // 引用
    //----------------------------------
    
    var xobject = xutil.object;
    var inheritsObject = xobject.inheritsObject;
    var objProtoToString = Object.prototype.toString;
    var arrayProtoSlice = Array.prototype.slice;
    
    //----------------------------------
    // 类型定义
    //----------------------------------
    
    /**
     * 视图和模型的基类
     *
     * @class
     */
    var XOBJECT = xui.XObject = 
            inheritsObject(null, xobjectConstructor);
    var XOBJECT_CLASS = XOBJECT.prototype;
    
    /**
     * 构造函数
     *
     * @public
     * @constructor
     * @param {Object} options 参数     
     */
    function xobjectConstructor(options) {
        /**
         * 事件监听器集合
         * key: eventName
         * value: {Array.<Object>} 监听器列表
         *
         * @type {Object} 
         * @private
         */
        this._oEventHandlerMap = {};

        /**
         * 是否禁用（不可交互）
         *
         * @type {boolean} 
         * @private
         */
        this._bDisabled = false;
    }

    //----------------------------------
    // 基本方法
    //----------------------------------

    /**
     * 默认的初始化函数
     *
     * @public
     */
    XOBJECT_CLASS.init = function () {};
    
    /**
     * 默认的析构函数
     * 如果有设businessKey，则终止未完成的请求
     *
     * @public
     */
    XOBJECT_CLASS.dispose = function () {
        this._oEventHandlerMap = {};
    };

    /**
     * 是否禁用（不可交互）
     *
     * @public
     * @return {boolean} 是否禁用
     */
    XOBJECT_CLASS.isDisabled = function () {
        return !!this._bDisabled;
    };
    
    /**
     * 设置禁用（不可交互）
     *
     * @public
     * @return {boolean} 是否执行了禁用
     */
    XOBJECT_CLASS.disable = function () {
        if (!this._bDisabled) {
            this._bDisabled = true;
            return true;
        }
        return false;
    };
    
    /**
     * 设置启用（可交互）
     *
     * @public
     * @return {boolean} 是否执行了启用
     */
    XOBJECT_CLASS.enable = function () {
        if (this._bDisabled) {
            this._bDisabled = false;
            return true;
        }
        return false;
    };
    
    //------------------------------------------
    // 事件/通知/Observer相关方法
    //------------------------------------------
    
    /**
     * 注册事件监听器
     * 重复注册无效
     *
     * @public
     * @param {(string|Object|Array)} eventName 
     *                  类型是string时表示事件名，
     *                  类型是Object或Array时，含义见下方用法举例
     * @param {Function} handler 监听器
     * @param {Object=} context 即handler调用时赋给的this，
     *                  缺省则this为XDatasource对象本身
     * @param {...*} args handler调用时绑定的前几个参数
     * @usage
     *      [用法举例一] 
     *          myModel.attach('sync.result', this.eventHandler, this);
     *      [用法举例二] （同时绑定很多事件）
     *          var bind = xutil.fn.bind;
     *          myModel.attach(
     *              {    
     *                  'sync.parse': bind(this.handler1, this, arg1, arg2),
     *                  'sync.preprocess': bind(this.handler2, this),
     *                  'sync.result.INIT': bind(this.handler3, this),
     *                  'sync.result.DATA': [
     *                      bind(this.handler4, this),
     *                      bind(this.handler5, this, arg3),
     *                      bind(this.handler6, this)
     *                  ]
     *              }
     *      [用法举例三] （同时绑定很多事件）
     *          myModel.attach(
     *              ['sync.parse', this.handler1, this, arg1, arg2],
     *              ['sync.preprocess', this.handler2, this],
     *              ['sync.result.INIT', this.handler3, this],
     *              ['sync.result.DATA', this.handler4, this],
     *              ['sync.result.DATA', this.handler5, this, arg3],
     *              ['sync.result.DATA', this.handler6, this]
     *          );
     */
    XOBJECT_CLASS.attach = function (eventName, handler, context, args) {
        parseArgs.call(this, attach, arrayProtoSlice.call(arguments));
    };

    /**
     * 事件注册
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function attach(handlerWrap) {
        handlerWrap.once = false;
        doAttach.call(this, handlerWrap);
    }

    /**
     * 注册事件监听器，执行一次即被注销
     * 重复注册无效
     *
     * @public
     * @param {(string|Object|Array)} eventName 
     *                  类型是string时表示事件名，
     *                  类型是Object或Array时，含义见attach方法的用法举例
     * @param {Function} handler 监听器
     * @param {Object=} context 即handler中的this，
     *                  缺省则this为XDatasource对象本身
     * @param {...*} args handler执行时的前几个参数
     * @usage 用法举例同attach方法
     */
    XOBJECT_CLASS.attachOnce = function (eventName, handler, context, args) {
        parseArgs.call(this, attachOnce, arrayProtoSlice.call(arguments));
    };

    /**
     * 事件注册，执行一次即被注销
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function attachOnce(handlerWrap) {
        handlerWrap.once = true;
        doAttach.call(this, handlerWrap);
    }
    
    /**
     * 注册事件监听器
     * 重复注册无效
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function doAttach(handlerWrap) {
        var handlerList = this._oEventHandlerMap[handlerWrap.eventName];
        if (!handlerList) {
            handlerList = this._oEventHandlerMap[handlerWrap.eventName] = [];
        }
        if (getHandlerWrapIndex.call(this, handlerWrap) < 0) {
            handlerList.push(handlerWrap);
        }
    }

    /**
     * 注销事件监听器
     * 如果传了context参数，则根据handler和context来寻找已经注册的监听器，
     * 两者同时批评才会命中并注销。
     * （这样做目的是：
     *      当handler是挂在prototype上的类成员方法时，可用传context来区别，
     *      防止监听器注销影响到同类的其他实例
     *  ）
     * 如果context缺省，则只根据handler寻找已经注册了的监听器。
     *
     * @public
     * @param {(string|Object|Array)} eventName
     *                  类型是string时表示事件名，
     *                  类型是Object或Array时，含义见下方用法举例
     * @param {Function} handler 监听器
     * @param {Object=} context 即注册时handler中的this，
     *                  缺省则this为XDatasource对象本身
     * @usage
     *      [用法举例一] 
     *          myModel.detach('sync.result', this.eventHandler);
     *      [用法举例二] （同时注销绑定很多事件）
     *          myModel.detach(
     *              {    
     *                  'sync.parse': handler1,
     *                  'sync.preprocess': handler2,
     *                  'sync.result.DATA': [
     *                      handler5,
     *                      handler6
     *                  ]
     *              }
     *      [用法举例三] （同时注销绑定很多事件）
     *          myModel.detach(
     *              ['sync.parse', this.handler1],
     *              ['sync.result.INIT', this.handler3],
     *              ['sync.result.DATA', this.handler4],
     *              ['sync.result.DATA', this.handler5],
     *              ['sync.result.DATA', this.handler6]
     *          );
     */
    XOBJECT_CLASS.detach = function (eventName, handler, context) {
        parseArgs.call(this, doDetach, arrayProtoSlice.call(arguments));        
    };

    /**
     * 注销注册事件监听器
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function doDetach(handlerWrap) {
        var index = getHandlerWrapIndex.call(this, handlerWrap);
        if (index >= 0) {
            this._oEventHandlerMap[handlerWrap.eventName].splice(index, 1);
        }
    }    
    
    /**
     * 注销某事件的所有监听器
     *
     * @public
     * @param {string} eventName 事件名
     */
    XOBJECT_CLASS.detachAll = function (eventName) {
        delete this._oEventHandlerMap[eventName];
    };
    
    /**
     * 触发事件
     *
     * @public
     * @param {string} eventName 事件名
     * @param {Array} paramList 参数，可缺省
     * @return {boolean} 结果，
     *      有一个事件处理器返回false则为false，否则为true
     */
    XOBJECT_CLASS.notify = function (eventName, paramList) {
        var result = true;
        var onceList = [];
        var handlerList = this._oEventHandlerMap[eventName] || [];

        var i;
        var o;
        var handlerWrap;
        for (i = 0; handlerWrap = handlerList[i]; i++) {
            o = handlerWrap.handler.apply(
                handlerWrap.context, 
                (handlerWrap.args || []).concat(paramList || [])
            );
            (o === false) && (result = false);

            if (handlerWrap.once) {
                onceList.push(handlerWrap);
            }
        }
        for (i = 0; handlerWrap = onceList[i]; i++ ) {
            this.detach(eventName, handlerWrap.handler);
        }
        return result;
    };

    /**
     * 构造handlerWrap
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {string} eventName 事件名
     * @param {Function} handler 监听器
     * @param {Object} context 即handler中的this，
     *                  缺省则this为XDatasource对象本身
     * @param {...*} args handler执行时的前几个参数
     * @return {Object} wrap
     */
    function makeWrap(eventName, handler, context, args) {
        args = arrayProtoSlice.call(arguments, 3);
        args.length == 0 && (args = null);

        return {
            eventName: eventName,
            handler: handler,
            context: context || this,
            args: args
        };
    }
    
    /**
     * 处理函数参数
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Function} func 要执行的方法
     * @param {Array} args 输入的函数参数
     */
    function parseArgs(func, args) {
        var firstArg = args[0];

        if (objProtoToString.call(firstArg) == '[object String]') {
            func.call(this, makeWrap.apply(this, args));
        }

        else if (objProtoToString.call(firstArg) == '[object Array]') {
            for (var i = 0; i < args.length; i ++) {
                func.call(this, makeWrap.apply(this, args[i]));
            }
        }

        else if (firstArg === Object(firstArg)) {
            var hand;
            for (var eventName in firstArg) {
                hand = firstArg[eventName];

                if (objProtoToString.call(hand) == '[object Array]') {
                    for (var i = 0; i < hand.length; i ++) {
                        func.call(
                            this,
                            makeWrap.call(this, eventName, hand[i])
                        );
                    }
                }
                else {
                    func.call(this, makeWrap.call(this, eventName, hand));
                }
            }
        }
    }
    
    /**
     * 获得index
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function getHandlerWrapIndex(handlerWrap) {
        var handlerList = this._oEventHandlerMap[handlerWrap.eventName];
        if (handlerList) {
            for (var i = 0, wrap; wrap = handlerList[i]; i++ ) {
                if (wrap.handler === handlerWrap.handler
                    && wrap.context === handlerWrap.context
                ) {
                    return i;   
                }
            }
        }
        return -1;
    };
    
})();

/**
 * xui.XDatasource
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:   数据模型基类
 *
 *          使用模型（Model）和视图（View）分离的程序结构时，
 *          此类可作为模型的基类被继承及扩展，定义相应属性
 *          （@see OPTIONS_NAME），
 *          其各派生类提供前/后台的业务数据获取和管理。
 *          XDatasource推荐一定的代码结构规范，见如下@usage。
 *
 *          基础功能：
 *              (1) 向后台发送数据（用Ajax）
 *              (2) 获得数据：
 *                      主动注入数据
 *                          （出现在数据从其他代码中取得的情况，
 *                          如数据模型的依赖）
 *                      从前台取数据
 *                          （例如为了节省链接和加快速度，
 *                          JSON数据放在页面HTML中一块返回前端，
 *                          或者从本地存储中得到等）
 *                      从后台取数据
 *                          （用Ajax）
 *                  取数据顺序是：
 *                      首先看是否已有主动注入的"businessData"；
 *                      否则如果"local"定义了则从"local"中取；
 *                      否则如果"url"定义了则发Ajax请求从后台取。
 *              (3) Oberver模式的更新通知，及自定义事件
 *              (4) 多数据源的管理（参见datasourceId）
 *              (5) 推荐的请求生命期结构
 *                  （参数准备、返回值解析、结果响应、最终清理等）
 *              (6) 析构时，abort所有未完成的请求，
 *                  防止请求回来后视图、模型已经不存在导致js错误、
 *                  全局视图未清理等问题
 *
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 * @version: 1.0.1
 */

/**
 *                             -----------------
 *                             |   使用说明    |
 *                             -----------------
 * ____________________________________________________________________________
 * @usage 使用XDatasource
 *        [举例] 
 *          ___________________________________________________________________
 *          (1) 定义一个新的XDatasource（如下MyDatasource），用继承的方式:
 * 
 *              如果有数据获取的参数或代码逻辑要写在MyDatasource里面
 *              （如URL，返回解过解析等逻辑），
 *              则在MyDatasource中，定义OPTIONS_NAME中指定的各参数
 *              （不需要定义则缺省即可）。
 *              其中各参数可以定义成string或者Function
 * 
 *              // 定义MyDatasource类
 *              var MyDatasource = function() {}; 
 *              inherits(MyDatasource, XDatasource);
 *              
 *              // 定义url
 *              MyDatasource.prototype.url = '/order/go.action'; 
 *
 *              // 定义param的构造
 *              MyDatasource.prototype.param = function(options) {
 *                  var paramArr = [];
 *                  paramArr.push('name=' + options.args.name);
 *                  paramArr.push('year=' + options.args.year);
 *                  paramArr.push('id=' + this._nId);
 *                  return paramArr.join('&');
 *              }
 *
 *              // 定义返回数据的解析
 *              MyDatasource.prototype.parse = function(data, obj, options) {
 *                  // do something ...
 *                  return data;
 *              }
 * 
 *          ___________________________________________________________________
 *          (2) 使用定义好的MyDatasource
 *              
 *              如果有数据获取的参数或代码逻辑是写在MyDatasource外面
 *              （如sync后改变视图的回调），
 *              则用事件的方式注册到MyDatasource里,
 *
 *              例如：
 *              MyDatasource myDatasource = new MyDatasource();
 *              绑定事件：
 *              myDatasource.attach(
 *                  'sync.result', 
 *                  function(data, obj, options) {
 *                      // do something ..., 比如视图改变 
 *                  }
 *              );
 *              myDatasource.attach(
 *                  'sync.error', 
 *                  function(status, obj, options) {
 *                      // do something ..., 比如页面提示 
 *                  }
 *              );
 *              myDatasource.attach(
 *                  'sync.timeout', 
 *                  function(options) { 
 *                      // do something ..., 比如页面提示 
 *                  }
 *              );
 *
 *              往往我们需要给事件处理函数一个scope，
 *              比如可以使用第三方库提供的bind方法。
 *              也可以直接在attach方法中输入scope。
 *
 *              当需要绑定许多事件，可以使用代码更短小的方式绑定事件。
 *              （参见xui.XObject的attach方法）
 *
 *              例如：
 *              （下例中，this是要赋给事件处理函数的scope）
 *              var bind = xutil.fn.bind;
 *              myDatasource.attach(
 *                  {
 *                      'sync.preprocess.TABLE_DATA': bind(this.disable, this),
 *                      'sync.result.TABLE_DATA': bind(this.$handleListLoaded, this),
 *                      'sync.finalize.TABLE_DATA': [  
 *                          // 一个事件多个处理函数的情况
 *                          bind(this.enable, this),
 *                          bind(this.$resetDeleteBtnView, this)
 *                      ],
 *                      'sync.result.DELETE': bind(this.$handleDeleteSuccess, this)
 *                  }
 *              ); 
 *
 *              又例如，还可以这样写：
 *              （数组第一个元素是事件名，第二个是事件处理函数，第三个是函数的scope）
 *              myDatasource.attach(
 *                  ['sync.preprocess.TABLE_DATA', this.disable, this],
 *                  ['sync.result.TABLE_DATA', this.$handleListLoaded, this],
 *                  ['sync.finalize.TABLE_DATA', this.enable, this],
 *                  ['sync.finalize.TABLE_DATA', this.$resetDeleteBtnView, this],
 *                  ['sync.result.DELETE': this.$handleDeleteSuccess, this]
 *              );
 *              
 *              需要发送数据或者获取数据时调用myDatasource.sync()，
 *              即可触发相应事件。
 * 
 *              如果要传入外部参数，则在options.args中传入，
 *              例如上例的param和parse定义，sync时直接传入参数：
 *
 *              myDatasource.sync( 
 *                  { 
 *                      args: { name: 'ss', year: 2012 } 
 *                  } 
 *              ); 
 *
 *              这样param和parse函数中即可得到参数'ss', 2012。
 * 
 *              注意，如果sync时指定了datasourceId，比如
 *              myDatasource.sync( { datasourceId:'ds1' } );
 *              则先触发sync.result.ds1事件，再触发sync.result事件。
 *              error、timeout等事件也是此规则。
 * 
 *          ___________________________________________________________________
 *          (3) 如果调用sync时数据是从本地取得，
 *              比如页面初始化时把JSON数据写在了页面的某个dom节点中，
 *              则设置"local"参数，
 * 
 *              例如：
 *              MyDatasource.prototype.local = function() {
 *                   var data;
 *                   try {
 *                      JSON.parse(
 *                          decodeHTML(
 *                              document.getElementById('DATA').innerHTML
 *                          )
 *                      );
 *                      return this.wrapEJson(data);
 *                   } catch (e) {
 *                      return this.wrapEJson(null, 99999, 'business error');
 *                   }
 *              };
 *
 *              从而sync时会调用此local函数取得数据，
 *              如果success则会走parse和result过程。 (@see OPTIONS_NAME.local)
 *          
 *          ___________________________________________________________________
 *          (4) 如果调用sync时数据已经OK不需要解析处理等，
 *              则直接对businessData进行设置。
 * 
 *              例如：
 *              myDatasource.businessData = someData;
 *              从而sync时直接取someData了，走result过程了。
 *              (@see OPTIONS_NAME.businessData)
 * 
 *          ___________________________________________________________________
 *          (5) 如果一个XDatasource中要包含多个数据源，
 *              可以把url、result等属性(@see OPTIONS_NAME)定义成XDatasource.Set，
 *              在sync时使用datasourceId指定当前sync时使用哪个数据源。
 *
 *              例如：
 *              MyDatasource.prototype.url = new xui.XDatasource.Set();
 *              MyDatasource.prototype.url['ORDER'] = 'order.action';
 *              MyDatasource.prototype.url['ADD'] = 'add.action';
 *
 *              // 这样初始化也可以
 *              MyDatasource.prototype.result = new xui.XDatasource.Set(
 *                  {
 *                      'ORDER': function() { ... }
 *                      'ADD': function() { ... }
 *                  }
 *              );
 *
 *              MyDatasource.prototype.param = function() { // func_all... };
 *              MyDatasource.prototype.param['ORDER'] = 
 *                  function() { // func_order... };
 *
 *              则：myDatasource.sync( { datasourceId: 'ORDER' } ); 
 *              或者简写为：
 *                  myDatasource.sync('ORDER'); 
 *              表示取order.action，并走相应的result（func_order）。
 *
 *              另外，上例没有找到相应的param['ORDER']，
 *              但param本身定义成了函数，则走本身（func_all）。
 * 
 * ____________________________________________________________________________
 * @usage 绑定多个XDatasource
 *              如果多个XDatasource共用一个请求，可绑定在一起处理，
 *
 *              例如：
 *              CombinedXDatasource c = new CombinedXDatasource();
 *              c.addSyncCombine(datasource1);
 *              c.addSyncCombine(datasource2, 'DATASOURCE_LIST');
 *
 *              从而：
 *              使用c.sync()时，datasource1也会被触发parse事件
 *              以及sync.result/sync.error/sycn.timeout事件
 *              使用c.sync( { datasourceId: 'DATASOURCE_LIST' } )时，
 *              datasource1、datasource2都会被触发parse事件
 *              以及sync.result/sync.error/sycn.timeout事件
 * 
 * ____________________________________________________________________________
 * @usage 工程中重写/扩展XDatasource的实现类
 *              （一般在工程中用于指定静态的url，也可在需要时用于重写方法）
 *              直接调用
 *              XDatasource.extend(
 *                  MyXDatasource, 
 *                  { url: ..., method: ... }
 *              );
 *              进行扩展。
 */

(function () {
    
    //--------------------------
    // 引用
    //--------------------------

    var XOBJECT = xui.XObject;
    var xajax = xutil.ajax;
    var xlang = xutil.lang;
    var xobject = xutil.object;
    var inheritsObject = xobject.inheritsObject;
    var extend = xobject.extend;
    var clone = xobject.clone;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var isObject = xlang.isObject;
    var hasValue = xlang.hasValue;
    var sliceArray = Array.prototype.slice;
    
    //--------------------------
    // 类型定义
    //--------------------------

    /**
     * Model基类
     * 
     * @class
     * @extends xui.XObject
     */
    var XDATASOURCE = xui.XDatasource = 
            inheritsObject(XOBJECT, xdatasourceConstructor);
    var XDATASOURCE_CLASS = XDATASOURCE.prototype;

    /**
     * 构造函数
     *
     * @public
     * @constructor
     * @param {Object} options
     */
    function xdatasourceConstructor(options) {
        /**
         * 事件处理器集合
         *
         * @type {Object}
         * @private
         */
        this._oEventHandlerMap = {};
        /**
         * 绑定集合，key是datasourceId
         *
         * @type {Object}
         * @private
         */
        this._oSyncCombineSet = {};
        /**
         * 无datasourceId时默认的绑定集合
         *
         * @type {Array.<xui.XDatasource>}
         * @private
         */
        this._aSyncCombineSetDefault = [];
        /**
         * 当前未完成的request集合，key为requestId
         *
         * @type {Object}
         * @private
         */
        this._oRequestSet = {};
        /**
         * sync过程中的当前datasourceId
         *
         * @type {string}
         * @private
         */
        this._sCurrentDatasourceId;
    }

    /**
     * 一个hash map。表示每个datasourceId对应的配置。
     * 所以使用时须满足的格式：
     * key为datasourceId，
     * value为datasourceId对应的参数/属性。
     * 
     * @class
     * @constructor
     * @param {Object=} set 如果为null，则初始化空Set
     */
    var SET = XDATASOURCE.Set = function (set) {
        set && extend(this, set);
    };
    
    //---------------------------
    // 属性
    //---------------------------

    /**
     * 默认的错误状态值，
     * 用于从success转为error时
     *
     * @type {number} 
     * @protected
     */
    XDATASOURCE_CLASS.DEFAULT_ERROR_STATUS = 999999999999;

    /**
     * XDatasource中可在子类中定义或继承的属性
     * 这些属性不可误指定为其他用
     *
     * @protected
     */
    XDATASOURCE_CLASS.OPTIONS_NAME = [
        /**
         * 调用sync时最初始的预处理，较少使用。
         * 可能使用在：调用sync的地方和注册preprocess的地方不在同一类中的情况
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function：
         *              @param {Object} options 调用sync时传入的配置
         * @protected
         */
        'preprocess',

        /**
         * 主动注入的业务数据（主要意义是标志业务数据是否已经OK）,
         * 如果此属性有值表示数据已经OK，sync时不会再试图获取数据。
         *
         * @type {(Function|Any|xui.XDatasource.Set)} 
         *          如果为Function：
         *              @param {Object} options 调用sync时传入的配置
         *              @return {Any} businessData  
         * @protected
         */
        'businessData', 
        
        /**
         * 从本地取得数据
         * 例如可以数据挂在HTML中返回：
         * <div style="display:none" id="xxx"> ...some data... </div>
         * 
         * @type {(Function|Object|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {Object} e-json规范的返回值，
         *                  可用wrapEJson方法包装得到
         *          如果为Object，则是e-json对象
         * @protected
         */
        'local',
        
        /**
         * 请求后台的url
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} url  
         * @protected
         */
        'url', 
        
        /**
         * 请求的HTTP方法（'POST'或'GET'），默认是POST
         *
         * @type {(Function|string|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} 方法
         * @protected
         */
        'method', 
        
        /**
         * 用于阻止请求并发，同一businessKey的请求不能并发 (@see xajax)
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} 方法
         * @protected
         */
        'businessKey', 
        
        /**
         * 得到请求的参数字符串
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} 请求参数字符串   
         * @protected
         */
        'param',
        
        /**
         * 处理请求成功的结果数据
         * 
         * @type {(Function|Any|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {(Object|string)} data 获取到的业务数据
         *             param {(Object|string)} ejsonObj 后台返回全结果，一般不使用
         *             param {Object} options 调用sync时传入的配置
         *             return {Any} data 结果数据
         * @protected
         */
        'parse',
        
        /**
         * 获得数据结果
         *
         * @type {(Function|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {(Object|string)} data parse过的业务数据
         *             param {(Object|string)} ejsonObj 后台返回全结果，一般不使用
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'result',
        
        /**
         * 处理请求失败的结果
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {(Object|string)} status 后台返回错误状态
         *             param {(Object|string)} ejsonObj 后台返回全结果，一般不使用
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'error',
        
        /**
         * 处理请求超时的结果
         * 
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'timeout',

        /**
         * 请求返回时总归会触发的回调，先于result或error触发
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'complete',
        
        /**
         * 请求返回时总归会触发的回调，常用于最后的清理
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'finalize',
        
        /**
         * 定义请求超时的时间(ms)，缺省则不会请求超时
         *
         * @type {(Function|number|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {number} timout的毫秒数
         * @protected
         */
        'timeoutTime',
        
        /**
         * 如果一个XDatasource中包含多个数据源，
         * sync时用此指定当前请求使用那套url、parse、result等
         * 
         * @type {(Function|string|number)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} datasourceId
         * @protected
         */
        'datasourceId',

        /**
         * 调用ajax时额外的输入参数
         *
         * @type {(Function|Object|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {Object} ajax参数
         * @protected
         */
        'ajaxOptions'
    ];
    
    //-------------------------------------------------------------
    // 方法                                        
    //-------------------------------------------------------------

    /**
     * 功能：
     * (1) 发送数据到后台。
     * (2) 获取数据，可能从前台直接获取，也可能通过Ajax请求后台获取。
     *
     * @public
     * @param {(Object|string)} options 参数
     *                  参数 @see OPTIONS_NAME sync时指定的参数，
     *                  用于重载xdatasource本身的配置
     *                  如果是string，则表示datasourceId
     *                  如果是Object，则属性如下：
     * @param {Object} options.datasourceId 指定数据源id
     * @param {Object} options.args 用户定义的参数
     * @return {string} requestId 如果发生后台请求，返回请求Id，一般不使用
     */
    XDATASOURCE_CLASS.sync = function (options) {
        if (isString(options)) {
            options = { datasourceId: options, args: {} };
        } 
        else {
            options = options || {};
            options.args = options.args || {};
        }

        var datasourceId = getDatasourceId.call(this, options);
        this._sCurrentDatasourceId = datasourceId;

        // 预处理
        handleSyncPreprocess.call(this, datasourceId, options);

        var data;
        var ejsonObj;
        var url;
        var requestId;

        // 已经被注入数据
        if (hasValue(
                data = handleAttr.call(
                    this, datasourceId, 'businessData', options
                )
            )
        ) { 
            handleSyncHasData.call(this, datasourceId, options, data);
        }

        // 从本地获取数据
        else if (
            hasValue(
                ejsonObj = handleAttr.call(
                    this, datasourceId, 'local', options
                )
            )
        ) { 
            handleSyncLocal.call(this, datasourceId, options, ejsonObj);
        }    

        // 从后台获取数据 
        else if (
            hasValue(
                url = handleAttr.call(this, datasourceId, 'url', options)
            )
        ){ 
            requestId = handleSyncRemote.call(
                this, datasourceId, options, url
            );
        }

        delete this._sCurrentDatasourceId;

        return requestId;
    };
    
    /**
     * 默认的析构函数
     * 如果有设businessKey，则终止未完成的请求
     *
     * @public
     */
    XDATASOURCE_CLASS.dispose = function () {
        this.abortAll();
        this._oSyncCombineSet = null;
        this._aSyncCombineSetDefault = null;
        XDATASOURCE.superClass.dispose.call(this);
    };
    
    /**
     * 默认的parse函数
     *
     * @protected
     * @param {*} data ejsonObject的data域
     * @param {Object} ejsonObj e-json对象本身
     */
    XDATASOURCE_CLASS.parse = function (data, ejsonObj) { 
        return data; 
    };
    
    /**
     * 默认的datasourceId函数
     *
     * @protected
     * @param {Object} options 调用sync时传入的配置
     * @return {string} datasourceId 数据源Id
     */
    XDATASOURCE_CLASS.datasourceId = function (options) { 
        return void 0; 
    };
    
    /**
     * 主动设值，用于前端已有数据的情况
     * 不传参数则清空
     *
     * @public
     * @param {*} businessData 业务数据
     * @param {string} datsourceId 可指定datasourceId
     */
    XDATASOURCE_CLASS.setBusinessData = function (businessData, datasourceId) {
        this.businessData = businessData || null;
        notifyEvent.call(
            this, datasourceId, 'set.businessdata', {}, [businessData]
        );
    };
    
    /**
     * 得到当前的datasourceId，只在sync过程中可获得值，
     * 等同于在sync的回调中使用options.datasourceId
     *
     * @public
     * @return {string} 当前的datasourceId
     */
    XDATASOURCE_CLASS.getCurrentDatasourceId = function () {
        return this._sCurrentDatasourceId;
    };
    
    /**
     * 终止此Model管理的所有请求
     *
     * @public
     */
    XDATASOURCE_CLASS.abortAll = function () {
        var requestIdSet = clone(this._oRequestSet);
        for (var requestId in requestIdSet) {
            this.abort(requestId);
        }
        this.notify('abortAll', [requestIdSet]);
    };
    
    /**
     * 终止此Model管理的某请求
     *
     * @public
     * @param {string} requestId 请求Id，即sync方法调用的返回值
     */
    XDATASOURCE_CLASS.abort = function (requestId) {
        xajax.abort(requestId, true);
        delete this._oRequestSet[requestId];
    };
    
    /**
     * 包装成ejson对象
     *
     * @public
     * @param {*} data 业务数据
     * @param {number} status 返回状态，
     *              0为正常返回，非0为各种错误返回。缺省则为0。
     * @param {string} statusInfo 附加信息，可缺省
     * @return {Object} e-json对象
     */
    XDATASOURCE_CLASS.wrapEJson = function (data, status, statusInfo) {
        return { data: data, status: status || 0, statusInfo: statusInfo };
    };
    
    /**
     * 停止success流程，走向error流程。
     * 在parse或result中调用有效。
     * 一般用于parse或result中解析后台返回数据，
     * 发现数据错误，需要转而走向error流程的情况。
     *
     * @protected
     * @param {number=} status 错误状态码，如果不传则取DEFAULT_ERROR_STATUS
     * @param {string=} statusInfo 错误信息，可缺省
     */
    XDATASOURCE_CLASS.$goError = function (status, statusInfo) {
        this._bGoError = true;
        this._nErrorStatus = status == null ? DEFAULT_ERROR_STATUS : status;
        if (statusInfo != null) {
            this._sErrorStatusInfo = statusInfo; 
        }
    };

    /**
     * 预处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     */
    function handleSyncPreprocess(datasourceId, options) {
        handleAttr.call(this, datasourceId, 'preprocess', options);
        notifyEvent.call(this, datasourceId, 'sync.preprocess', options);
    }

    /**
     * 已有数据处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {*} data 业务数据
     */
    function handleSyncHasData(datasourceId, options, data) {
        handleAttr.call(
            this, datasourceId, 'result', options, 
            [data, this.wrapEJson(data)]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.result', options, 
            [data, this.wrapEJson(data)]
        );
    }

    /**
     * 本地数据处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {(Object|string)} ejsonObj e-json对象
     */
    function handleSyncLocal(datasourceId, options, ejsonObj) {
        handleCallback.call(
            this, datasourceId, handleComplete, options, ejsonObj
        );

        if (!ejsonObj.status) { 
            // status为0则表示正常返回 (@see e-json)
            handleCallback.call(
                this, datasourceId, handleSuccess, options, ejsonObj.data, ejsonObj
            );
        }
        else {
            handleCallback.call(
                this, datasourceId, handleFailure, options, ejsonObj.status, ejsonObj
            );
        }

        handleCallback.call(
            this, datasourceId, handleFinalize, options, ejsonObj
        );
    }

    /**
     * 远程请求处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {string} url 请求url
     * @return {string} requestId 请求ID
     */
    function handleSyncRemote(datasourceId, options, url) {
        var opt = {};
        var me = this;
        var paramStr;

        // 准备ajax参数
        opt.method = 
            handleAttr.call(me, datasourceId, 'method', options) 
            || 'POST';

        opt.businessKey = 
            handleAttr.call(me, datasourceId, 'businessKey', options);

        opt.data = 
            hasValue(
                paramStr = handleAttr.call(me, datasourceId, 'param', options)
            )
            ? paramStr : '';

        opt.timeout = 
            handleAttr.call(me, datasourceId, 'timeoutTime', options) 
            || undefined;

        opt.onsuccess = function (data, ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleSuccess, options, data, ejsonObj
            );
        };

        opt.onfailure = function (status, ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleFailure, options, status, ejsonObj
            );
        };

        opt.oncomplete = function (ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleComplete, options, ejsonObj
            );
            // 清除requestId
            delete me._oRequestSet[requestId];
        };

        opt.onfinalize = function (ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleFinalize, options, ejsonObj
            );
        };

        opt.ontimeout = function () {
            handleCallback.call(
                me, datasourceId, handleTimeout, options
            );
        };

        opt = extend(
            opt, 
            handleAttr.call(me, datasourceId, 'ajaxOptions', options) || {}
        );
        
        this._sBusinessKey = opt.businessKey;

        // 发送ajax请求
        var requestId = xajax.request(url, opt);
        this._oRequestSet[requestId] = 1;

        return requestId;
    }

    /**
     * 回调处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Function} callback 回调
     * @param {Object} options 参数
     */    
    function handleCallback(datasourceId, callback, options) {
        var args= sliceArray.call(arguments, 3, arguments.length);

        callback.apply(this, [datasourceId, options].concat(args));

        var i;
        var o;
        var list;

        // sync combines
        if (hasValue(datasourceId)) {
            list = this._oSyncCombineSet[datasourceId] || [];
            for (i = 0; o = list[i]; i++) {
                callback.apply(o, [datasourceId, {}].concat(args));
            }
        }

        list = this._aSyncCombineSetDefault || [];
        for (i = 0; o = list[i]; i++) {
            callback.apply(o, [datasourceId, {}].concat(args));
        }
    }
    
    /**
     * 回调处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {*} data 业务数据
     * @param {(Object|string)} ejsonObj e-json对象
     */    
    function handleSuccess(datasourceId, options, data, ejsonObj) {
        this._bGoError = false;

        function goFailure() {
            if (this._sErrorStatusInfo != null) {
                ejsonObj.statusInfo = this._sErrorStatusInfo;
            }
            handleCallback.call(
                this, 
                datasourceId, 
                handleFailure, 
                options, 
                this._nErrorStatus, 
                ejsonObj
            );
            this._bGoError = false;
            this._nErrorStatus = null;
            this._sErrorStatusInfo = null;
        }
        
        var data = handleAttr.call(
            this, datasourceId, 'parse', options, [data, ejsonObj]
        );
        if (this._bGoError) {
            goFailure.call(this);
            return;
        }

        handleAttr.call(
            this, datasourceId, 'result', options, [data, ejsonObj]
        );
        if (this._bGoError) {
            goFailure.call(this);
            return;
        }

        notifyEvent.call(
            this, datasourceId, 'sync.result', options, [data, ejsonObj]
        );
    }
    
    /**
     * 失败处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {number} status 返回状态
     * @param {(Object|string)} ejsonObj e-json对象
     */    
    function handleFailure(datasourceId, options, status, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'error', options, [status, ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.error', options, [status, ejsonObj]
        );        
    }

    /**
     * 请求完结处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {(Object|string)} ejsonObj e-json对象
     */    
    function handleComplete(datasourceId, options, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'complete', options, [ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.complete', options, [ejsonObj]
        );        
    }
    
    /**
     * 请求最终处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {(Object|string)} ejsonObj e-json对象
     */    
    function handleFinalize(datasourceId, options, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'finalize', options, [ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.finalize', options, [ejsonObj]
        );        
    }
    
    /**
     * 请求超时处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     */    
    function handleTimeout(datasourceId, options) {
        handleAttr.call(this, datasourceId, 'timeout', options);
        notifyEvent.call(this, datasourceId, 'sync.timeout', options);
    }
    
    /**
     * 属性处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {string} name 属性名
     * @param {Object} options 参数
     * @param {Array} args 调用参数
     */    
    function handleAttr(datasourceId, name, options, args) {
        options = options || {};
        args = args || [];
        args.push(options);
        
        var o;
        var datasourceId;

        // 优先使用options中的定义
        if (typeof options[name] != 'undefined') {
            o = options[name];
        } 
        else {
            // 次优先使用不分datasourceId的通用定义
            o = this[name];
            // 再次使用每个datasourceId的各自定义
            if (hasValue(datasourceId) 
                && isObject(o) 
                && hasValue(o[datasourceId])
            ) {
                o = o[datasourceId];
            }
        }

        if (o instanceof SET) { o = null; }

        return isFunction(o) ? o.apply(this, args) : o;
    }
    
    /**
     * 触发事件
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {string} eventName 事件名
     * @param {Object} options 参数
     * @param {Array} args 调用参数
     */    
    function notifyEvent(datasourceId, eventName, options, args) {
        options = options || {};
        args = args || [];
        args.push(options);
        if (hasValue(datasourceId)) {
            this.notify(eventName + '.' + datasourceId, args);
        }
        this.notify(eventName, args);        
    }

    /**
     * 获得数据源id
     *
     * @private
     * @param {Object} options 参数
     * @return {string} 数据源id
     */    
    function getDatasourceId (options) {
        options = options || {};
        var datasourceId = hasValue(options.datasourceId) 
            ? options.datasourceId : this.datasourceId;
        return isFunction(datasourceId) 
            ? datasourceId.call(this, options) : datasourceId;
    }
    
    //-------------------------------------------------------------
    // [多XDatasource组合/绑定]                                               
    //-------------------------------------------------------------
    
    /**
     * 为了公用sync，绑定多个XDatasource
     * 这个功能用于多个XDatasource共享一个请求的情况。
     * sync及各种事件，会分发给被绑定的XDatasource，
     * 由他们分别处理（如做请求返回值解析，取的自己需要的部分）
     *
     * @public
     * @param {xui.XDatasource} xdatasource 要绑定的XDatasource
     * @param {string} datasourceId 绑定到此datasourceId上，
     *          缺省则绑定到所有datasourceId上
     */
    XDATASOURCE_CLASS.addSyncCombine = function (xdatasource, datasourceId) {
        if (!(xdatasource instanceof XDATASOURCE)) { 
            return;
        }

        var o;
        if (hasValue(datasourceId)) {
            if (!(o = this._oSyncCombineSet[datasourceId])) {
                o = this._oSyncCombineSet[datasourceId] = [];
            }
            o.push(xdatasource);
        } 
        else {
            this._aSyncCombineSetDefault.push(xdatasource);
        }
    };
    
    /**
     * 取消绑定XDatasource
     * 这个功能用于多个XDatasource共享一个请求的情况。
     * sync及各种事件，会分发给被绑定的XDatasource，
     * 由他们分别处理（如做请求返回值解析，取的自己需要的部分）
     *
     * @public
     * @param {xui.XDatasource} xdatasource 要取消绑定的XDatasource
     * @param {string} datasourceId 与addSyncCombine的定义须一致
     */
    XDATASOURCE_CLASS.removeSyncCombine = function (xdatasource, datasourceId) {
        if (!(xdatasource instanceof XDATASOURCE)) { return; }

        var o = hasValue(datasourceId) 
                    ? (this._oSyncCombineSet[datasourceId] || []) 
                    : (this._aSyncCombineSetDefault || []);

        for (var j = 0; j < o.length;) {
            (xdatasource === o[j]) ? o.splice(j, 1) : j++;
        }
    };
    
    //-------------------------------------------------------------
    // XDatasource扩展
    //-------------------------------------------------------------
    
    /**
     * 扩展
     * （禁止对XDatasource类本身使用extend）
     *
     * @public
     * @static
     * @param {Object} clz XDatasource子类本身
     * @param {Object} options 扩展的内容 (@see OPTIONS_NAME)
     */
    XDATASOURCE.extend = function (clz, options) {
        if (clz instanceof XDATASOURCE && clz !== XDATASOURCE) {
            extend(clz.prototype, options);
        }
    };
    
})();

/**
 * xui.XView
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    视图基类
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 * @usage:   
 *          (1) 须实现xui.XView.domReady函数
 *          (2) 页面中使用：
 *              <script type="text/javascript">
 *                  xui.XView.start("aaa.bbb.ccc.SomePageView");
 *              </script>
 *              则启动了SomePageView类
 */

(function () {
    
    var XOBJECT = xui.XObject;
    var getByPath = xutil.object.getByPath;
    var inheritsObject = xutil.object.inheritsObject;
    
    /**
     * 视图基类
     *
     * @class
     */
    var XVIEW = xui.XView = inheritsObject(XOBJECT);
    var XVIEW_CLASS = XVIEW.prototype;
    
    /**
     * 页面开始
     * 
     * @public
     * @static
     * @param {string} viewPath 页面对象的路径
     * @param {Object} options 参数 
     * @return {ecui.ui.Control} 创建的页面对象
     */    
    XVIEW.start = function (viewPath, options) {
        var viewClass;
        
        XVIEW.$domReady(
            function () {
                XVIEW.$preStart && XVIEW.$preStart(viewPath, options);

                viewPath && (viewClass = getByPath(viewPath));
                viewClass && (new viewClass(options)).init();

                XVIEW.$postStart && XVIEW.$postStart(viewPath, options);
            }
        );
    };

    /**
     * 初始前的预处理
     * 
     * @private
     * @abstract
     * @static
     * @param {string} viewPath 页面对象的路径
     * @param {Object} options 参数 
     */
    XVIEW.$preStart = function (viewPath, options) {};

    /**
     * 初始后的处理
     * 
     * @private
     * @abstract
     * @static
     * @param {string} viewPath 页面对象的路径
     * @param {Object} options 参数 
     */
    XVIEW.$postStart = function (viewPath, options) {};

    /**
     * DOM READY函数，由工程自己定义
     * 
     * @private
     * @abstract
     * @static
     * @param {Function} callback
     */
    XVIEW.$domReady = null;

})();

/**
 * project declaration
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    项目起始文件，全局声明
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui.XProject
 */

// 如果打包时使用(function() { ... })()包裹住所有代码，
// 则以下声明的变量在闭包中；
// 否则以下声明的变量暴露到全局。
 
// DI名空间基础
xui.XProject.setNamespaceBase(
    window.__$DI__NS$__ = window.__$DI__NS$__ || {}
);

// 声明名空间用方法
var $namespace = xui.XProject.namespace;

// 注册依赖连接用方法
var $link = xui.XProject.link;

// 注册延迟初始化用方法
var $end = xui.XProject.end;

// 得到名空间根基
var $getNamespaceBase = xui.XProject.getNamespaceBase;

// DI根名空间
var di = $namespace('di');

// FIXME
// 暂时用这种方法注册进去
$getNamespaceBase().xui = xui;
$getNamespaceBase().xutil = xutil;

xutil.object.PATH_DEFAULT_CONTEXT = $getNamespaceBase();
/**
 * configuration of xutil.ajax
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight 全局(包括console和product)的ajax的配置
 *          （常量和默认失败处理等）
 *          （如不服此配置，可重载）
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.ajax, di.config.lang
 */

$namespace('di.config');

(function() {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var XAJAX = xutil.ajax;
    var isFunction = xutil.lang.isFunction;
    var LANG;
    var DIALOG;
    
    $link(function () {
        LANG = di.config.Lang;
        DIALOG = di.helper.Dialog;
    });

    //--------------------------------
    // 类型声明
    //--------------------------------

    var AJAX = $namespace().AJAX = function() {};

    /**
     * 默认选项
     */
    var DEFAULT_OPTIONS = {
        showWaiting: true // 默认在ajax请求时显示waiting
    };

    /**
     * 默认的ajax失败处理
     * 
     * @public
     * @param {number} status ajax返回状态
     * @param {Object|string} ejsonObj e-json整体返回的数据
     * @param {Function} defaultCase 可用此函数替换默认情况的处理函数
     */
    AJAX.handleDefaultFailure = function(status, ejsonObj, defaultCase) {
        switch (status) {
            case 100: // 未登陆
            case 201: 
            case 301: // 重定向的情况
            case 302: // 重定向的情况
            case 99999: // 其实302时返回的是这个 ...
                DIALOG.alert(LANG.SAD_FACE + LANG.RE_LOGIN, null, true);
                break;
            case 333: //没有权限
                DIALOG.alert(LANG.SAD_FACE + LANG.NO_AUTH_SYSTEM);
                break;
            case 1: // 返回html错误页面的情况
            case 403: // 403错误
            case 404: // 404错误
            case 405: // 405错误
            case 500: // 500错误
                DIALOG.alert(LANG.SAD_FACE + LANG.ERROR);
                break;
            default:
                if (isFunction(defaultCase)) {
                    defaultCase(status, ejsonObj);
                } 
                else {
                    DIALOG.alert(LANG.SAD_FACE + LANG.ERROR);
                }
        }
    }

    /**
     * 刷新整站
     *
     * @protected
     */
    // AJAX.reload = function() {
    //     try {
    //         window.top.location.reload();
    //     } 
    //     catch (e) {
    //         window.location.reload();
    //     }
    // }

    /**
     * 默认的timeout处理
     *
     * @public
     */
    AJAX.handleDefaultTimeout = function() {
        DIALOG.hidePrompt();
    }
    
    /**
     * 默认的请求参数
     *
     * @public
     * @return {string} 参数字符串，如a=5&a=2&b=xxx
     */
    AJAX.getDefaultParam = function() {
        var date = new Date(), paramArr = [];
        paramArr.push('_cltime=' + date.getTime()); // 供后台log当前时间
        paramArr.push('_cltimezone=' + date.getTimezoneOffset()); // 供后台log当前时区
        return paramArr.join('&');
    }
    
    /**
     * 用于显示全局的等待提示，当第一个需要显示等待的请求发生时会调用
     *
     * @public
     */
    AJAX.showWaiting = function() {
        DIALOG.waitingPrompt(LANG.AJAX_WAITING);
    }
    
    /**
     * 用于隐藏全局的等待提示，当最后一个需要显示等待的请求结束时会调用
     *
     * @public
     */
    AJAX.hideWaiting = function() {
        DIALOG.hidePrompt();
    }
        
    /**
     * 挂载配置
     */
    XAJAX.DEFAULT_FAILURE_HANDLER = AJAX.handleDefaultFailure;
    XAJAX.DEFAULT_ONTIMEOUT = AJAX.handleDefaultTimeout;
    XAJAX.DEFAULT_PARAM =AJAX.getDefaultParam;
    XAJAX.SHOW_WAITING_HANDLER = AJAX.showWaiting;
    XAJAX.HIDE_WAITING_HANDLER = AJAX.hideWaiting;
    XAJAX.DEFAULT_OPTIONS = DEFAULT_OPTIONS;    

})();
/**
 * di.config.Dict
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight 全局(包括console和product)的ajax的配置
 * @author:  xxx(xxx@baidu.com)
 */

$namespace('di.config');

(function() {

    /**
     * DICT初始化，此方法会在生成的repo-dict.js中自动被调用
     */
    var DICT = $namespace().Dict = function () {
        if (!initialized) {
            // 初始化类引用
            DICT.CLZ = {};
            for (var i = 0, clzDef; clzDef = DICT.CLZ_DEFS[i]; i ++) {
                if (clzDef.clzKey in DICT.CLZ) {
                    throw new Error("dupicate clzKey: " + clzDef.clzKey);
                }
                DICT.CLZ[clzDef.clzKey] = clzDef;
            }
            initialized = true;
        }
        return DICT;
    };

    var initialized = false;

    /**
     * 视图模版部署相对路径
     */
    DICT.VTPL_ROOT = 'asset-d';

    /**
     * 默认的遮罩透明度
     */
    DICT.DEFAULT_MASK_OPACITY = 0.5;

    /**
     * 自动化测试用的id属性
     */
    DICT.TEST_ATTR = 'data-o_o-di-test';

    /**
     * 指标维度元数据视图状态
     */
    DICT.META_STATUS = {
        DISABLED: 0,
        NORMAL: 1,
        SELECTED: 2
    };

})();
/**
 * di.config.Lang
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight 全局(包括console和product)的话术定义
 * @author:  xxx(xxx@baidu.com)
 */

$namespace('di.config');

(function() {
    
    //--------------------------------
    // 类型声明
    //--------------------------------

    var LANG = $namespace().Lang = {};

    /**
     * ajax请求失败
     */
    LANG.AJAX_FAILURE = function (status) {
        return status + ' SERVER ERROR';
    };

    LANG.AJAX_TIMEOUT = '请求超时，请稍后重试';
    LANG.AJAX_WAITING = '加载中...';
    
    LANG.SMILE_FACE = '&nbsp;<div class="global-smile-face"></div>&nbsp;&nbsp;&nbsp;';
    LANG.SAD_FACE = '&nbsp;<div class="global-sad-face"></div>&nbsp;&nbsp;&nbsp;';
    
    LANG.NO_DATA = '缺失数据';
    LANG.NO_AUTH = '抱歉，您没有查看当前页面的权限';
    LANG.NO_AUTH_OPERATION = '抱歉，您没有权限进行此操作';
    LANG.NO_AUTH_SYSTEM = '抱歉，您没有系统权限';
    LANG.ERROR = '系统异常';
    LANG.DATA_ERROR = '数据异常';
    LANG.RE_LOGIN = '请重新登陆';
    LANG.EMPTY_TEXT = '未查询到相关信息';
    LANG.SAVE_FAIL = '抱歉，保存失败，请重试';
    LANG.PARAM_ERROR = '抱歉，参数校验失败';
    LANG.FATAL_DATA_ERROR = '抱歉，服务器异常，操作无法继续';
    
    LANG.INPUT_MANDATORY = '必填';
    LANG.INVALID_FORMAT = '格式错误';
    LANG.NUMBER_OVERFLOW = '数据过大';
    LANG.NUMBER_UNDERFLOW = '数据过小';
    LANG.TEXT_OVERFLOW = '输入文字过多';
    LANG.DOWNLOAD_FAIL = '下载失败';
    LANG.OFFLINE_DOWNLOAD_FAIL = '离线下载请求失败';
    LANG.DELETE_SUCCESS = '删除成功';

    LANG.GET_DIM_TREE_ERROR = '抱歉，维度数据获取失败，请重试';

    LANG.CONFIRM_ADD_SHARE = '您真的要添加分享吗？';
    LANG.CONFIRM_REMOVE_SHARE = '您真的要取消分享吗？';
    LANG.CONFIRM_DELETE = '您真的要删除吗？';

    LANG.DIM_MANDATORY = '请确认每种维度都有勾选，再点击查询';

    LANG.DESC_OVERFLOW = '解释说明文字过多';
    LANG.DESC_MANDATORY = '解释说明必填';
    LANG.PLAN_OVERFLOW = '跟进计划文字过多';
    LANG.PLAN_MANDATORY = '跟进计划必填';
    LANG.REASON_ADD_ERROR = '原因添加失败，请重试';

    LANG.DRILL_DIM_DATA_ERROR = '[维度数据校验失败]';

    LANG.WAITING_HTML = '<span class="waiting-icon"></span>&nbsp;<span class="waiting-text">加载中...</span>';
        
})();
/**
 * repo dict
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    描述构件的引用。构建程序（buidlfront会根据此文件生成repo.js）
 * @author:  sushuang(sushuang@baidu.com)
 */

(function() {

    var DICT = $namespace('di.config').Dict;
    var extend = xutil.object.extend;
    var repoDict =

        //==[DI=BEGIN]==[NIGEB=ID]=========
        // 此注释不可改动，标记了解析段落的开始
        //=================================

        {
            /**
             * 默认的clzKey
             */
            "DEFAULT_CLZ_KEY": {
                "SNIPPET": "GENERAL_SNIPPET",
                "VCONTAINER": "GENERAL_VCONTAINER",
                "VPART": "GENERAL_VPART",
                "COMPONENT": "GENERAL_COMPONENT"
            },

            /**
             * 构件件类
             * 说明：
             * (1") 如果定义了adapterMethod"，则从di.shared.adapter."GeneralAdapterMethod"中获取方法拷贝到目标实例中
             * (2) ""如果定义了adapterPath"，则将该adapter中方法全拷贝至目标实例中。能够覆盖adapterMethod"定义。
             */
            "CLZ_DEFS": [

                //-------------------------------
                // SNIPPET
                //-------------------------------

                {
                    "clzKey": "GENERAL_SNIPPET",
                    "clzPath": "di.shared.ui.GeneralSnippet",
                    "clzType": "SNIPPET"
                },

                //-------------------------------
                // VPART
                //-------------------------------

                {
                    "clzKey": "GENERAL_VPART",
                    "clzPath": "di.shared.ui.GeneralVPart",
                    "clzType": "VPART"
                },

                //-------------------------------
                // COMPONENT
                //-------------------------------

                {
                    "clzKey": "GENERAL_COMPONENT",
                    "clzPath": "di.shared.ui.InteractEntity",
                    "clzType": "COMPONENT"
                },
                {
                    "clzKey": "DI_TABLE",
                    "clzPath": "di.shared.ui.DITable",
                    "clzType": "COMPONENT"
                },
                {
                    "clzKey": "DI_CHART",
                    "clzPath": "di.shared.ui.DIChart",
                    "clzType": "COMPONENT"
                },
                {
                    "clzKey": "DI_FORM",
                    "clzPath": "di.shared.ui.DIForm",
                    "clzType": "COMPONENT"
                },
                {
                    "clzKey": "OLAP_META_CONFIG",
                    "clzPath": "di.shared.ui.OlapMetaConfig",
                    "clzType": "COMPONENT"
                },

                //-------------------------------
                // VCONTAINER
                //-------------------------------

                {
                    "clzKey": "GENERAL_VCONTAINER",
                    "clzPath": "di.shared.ui.GeneralVContainer",
                    "clzType": "VCONTAINER"
                },
                {
                    "clzKey": "DI_TAB",
                    "clzPath": "di.shared.ui.DITab",
                    "clzType": "VCONTAINER"
                },
                {
                    "clzKey": "FOLD_PANEL",
                    "clzPath": "di.shared.ui.FoldPanel",
                    "clzType": "VCONTAINER"
                },

                //-------------------------------
                // VUI
                //-------------------------------

                {
                    "clzKey": "HIDDEN_INPUT",
                    "clzPath": "di.shared.vui.HiddenInput",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "clzType": "VUI"
                },
                {
                    "clzKey": "H_CHART",
                    "clzPath": "xui.ui.HChart",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "adapterPath": "di.shared.adapter.HChartVUIAdapter",
                    "clzType": "VUI"
                },
                {
                    "clzKey": "OLAP_META_DRAGGER",
                    "clzPath": "di.shared.vui.OlapMetaDragger",
                    "clzType": "VUI",
                    "adapterPath": "di.shared.adapter.MetaConfigVUIAdapter"
                },
                {
                    "clzKey": "TEXT_LABEL",
                    "clzPath": "di.shared.vui.TextLabel",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" }
                },
                {
                    "clzKey": "OLAP_META_IND_SELECT",
                    "clzPath": "ecui.ui.Select",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.MetaConfigVUIAdapter",
                    "dataOpt": {
                        "optionSize": 15
                    }
                },
                {
                    "clzKey": "DAY_POP_CALENDAR",
                    "clzPath": "ecui.ui.IstCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.IstCalendarVUIAdapter",
                    "dataOpt": {
                        "mode": "DAY",
                        "viewMode": "POP"
                    }
                },
                {
                    "clzKey": "RANGE_POP_CALENDAR",
                    "clzPath": "ecui.ui.IstCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.IstCalendarVUIAdapter",
                    "dataOpt": {
                        "mode": "RANGE",
                        "viewMode": "POP"
                    }
                },
                {
                    "clzKey": "CALENDAR_PLUS",
                    "clzPath": "ecui.ui.CalendarPlus",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.CalendarPlusVUIAdapter"
                },
                {
                    "clzKey": "X_CALENDAR",
                    "clzPath": "ecui.ui.XCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.XCalendarVUIAdapter"
                },
                {
                    "clzKey": "OLAP_TABLE",
                    "clzPath": "ecui.ui.OlapTable",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "dataOpt": { "defaultCCellAlign": "right" }
                },
                {
                    "clzKey": "BEAKER_CHART",
                    "clzPath": "ecui.ui.BeakerChart",
                    "clzType": "VUI",
                    "adapterPath": "di.shared.adapter.BeakerChartVUIAdapter"
                },
                {
                    "clzKey": "BREADCRUMB",
                    "clzPath": "ecui.ui.Breadcrumb",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" }
                },
                {
                    "clzKey": "BUTTON",
                    "clzPath": "ecui.ui.Button",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" }
                },
                {
                    "clzKey": "H_BUTTON",
                    "clzPath": "ecui.ui.HButton",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" }
                },
                {
                    "clzKey": "OFFLINE_DOWNLOAD",
                    "clzPath": "di.shared.vui.OfflineDownload",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "dataOpt": {
                        "headText": "请输入邮箱（多个邮箱使用逗号分隔）：",
                        "confirmText": "确定",
                        "cancelText": "取消",
                        "text": "离线下载1"
                    }
                },
                {
                    "clzKey": "SWITCH_BUTTON",
                    "clzPath": "ecui.ui.SwitchButton",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" }
                },
                {
                    "clzKey": "ECUI_SELECT",
                    "clzPath": "ecui.ui.Select",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiSelectVUIAdapter",
                    "dataOpt": {
                        "optionSize": 15
                    }
                },
                {
                    "clzKey": "ECUI_INPUT_TREE",
                    "clzPath": "ecui.ui.InputTree",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiInputTreeVUIAdapter"
                },
                {
                    "clzKey": "ECUI_SUGGEST",
                    "clzPath": "ecui.ui.Suggest",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiSuggestVUIAdapter"
                },
                {
                    "clzKey": "ECUI_INPUT",
                    "clzPath": "ecui.ui.Input",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" }
                }
            ]

        }

        //==[DI=END]==[DNE=ID]=============
        // 此注释不可改动，标记了解析段落的结束
        //=================================

    ;
    extend(DICT, repoDict);

    /**
     * 类引用处理
     */
    DICT.CLZ = {};
    for (var i = 0, clzDef; clzDef = DICT.CLZ_DEFS[i]; i ++) {
        if (clzDef.clzKey in DICT.CLZ) {
            throw new Error('dupicate clzKey: ' + clzDef.clzKey);
        }
        DICT.CLZ[clzDef.clzKey] = clzDef;
    }

})();
/**
 * di.config.URL
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight 全局(包括console和product)的URL定义
 * @author:  sushuang(sushuang@baidu.com)
 */
$namespace('di.config');

(function() {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var xextend = xui.XDatasource.extend;

    //--------------------------------
    // 类型声明
    //--------------------------------

    /**
     * 因为URL要作为权限验证，所以在使用时再加WEB_ROOT
     * web根目录, 页面初始时从后台传来，暂存在_TMP_WEB_ROOT_中
     *
     * @usage 
     *      假设有定义：kt.config.URL.SOME_TABLE_QUERY = '/some/table.action';
     *      用这样语句获得请求url： kt.config.URL('SOME_TABLE_QUERY'); 
     * @param {string} urlAttr url常量名
     * @return {string} 请求使用的url
     */
    var URL = $namespace().URL = function(urlConst) {
        var url = URL_SET[urlConst];
        if (!url) {
            throw new Error('empty url!');
        }
        return URL.getWebRoot() + url;
    };

    URL.fn = function (urlConst) {
        return xutil.fn.bind(URL, null, urlConst);
    };

    var URL_SET = {};
    var webRoot;

    /**
     * 得到运行时的web base
     * 
     * @public
     * @return {string} 运行时的web base
     */
    URL.getWebRoot = function() {
        return webRoot || $getNamespaceBase().WEB_ROOT || '';
    };

    URL.setWebRoot = function(root) {
        webRoot = root;
    }

    /**
     * 增加URL
     * 
     * @public
     * @param {string} 新增的URL
     */
    URL.addURL = function(name, url) {
        // 检查重复
        if (URL_SET[name]) {
            throw new Error('Duplicate URL! name=' + name + ' url=' + url);
        }

        // 新增
        URL_SET[name] = url;
    }

    //--------------------------------
    // 公用URL
    //--------------------------------  

    // 打开报表编辑
    URL_SET.OLAP_REPORT_INIT = '/reportTemplate/create.action';

    // PlaneTable
    URL_SET.PLANE_TABLE_SQL_SAVE = '/reportTemplate/planeTable/create.action';
    URL_SET.PLANE_TABLE_COL_DATA = '/reportTemplate/planeTable/doMapColumns.action';
    URL_SET.PLANE_TABLE_COL_SAVE = '/reportTemplate/planeTable/saveColumns.action';
    URL_SET.PLANE_TABLE_COND_DATA = '/reportTemplate/planeTable/doMapConds.action';
    URL_SET.PLANE_TABLE_COND_SAVE = '/reportTemplate/planeTable/saveConds.action';
    // 预览
    // @param reportTemplateId
    // @param AAAfromURL=12345&BBBfromURL=67899&showColumns=AAAfromURL&showColumns=BBBfromURL& ...
    // @return {  }
    URL_SET.PLANE_TABLE_DATA = '/reportTemplate/planeTable/preview.action';

    // 得到cube tree
    URL_SET.CUBE_META = '/meta/getCubeTree.action';

    // 获取维度树
    URL_SET.DIM_TREE_TABLE = '/reportTemplate/table/getDimTree.action';
    URL_SET.DIM_TREE_CHART = '/reportTemplate/chart/getDimTree.action';
    URL_SET.DIM_SELECT_SAVE_TABLE = '/reportTemplate/table/updateDimNodes.action';
    URL_SET.DIM_SELECT_SAVE_CHART = '/reportTemplate/chart/updateDimNodes.action';

    // 指标维度元数据
    URL_SET.META_CONDITION_IND_DIM_TABLE = '/reportTemplate/table/getMetaData.action';
    URL_SET.META_CONDITION_IND_DIM_CHART = '/reportTemplate/chart/getMetaData.action';
    URL_SET.META_CONDITION_SELECT_TABLE = '/reportTemplate/table/dragAndDrop.action';
    URL_SET.META_CONDITION_SELECT_CHART = '/reportTemplate/chart/dragAndDrop.action';
    URL_SET.META_CONDITION_LIST_SELECT_CHART = '/reportTemplate/chart/selectInd.action'; // 这是个为list形式的元数据提交而写的临时接口

    // 表单
    URL_SET.FORM_DATA = '/reportTemplate/initParams.action';
    URL_SET.FORM_ASYNC_DATA = '/reportTemplate/interactParam.action';

    // 表格
    URL_SET.OLAP_TABLE_DATA = '/reportTemplate/table/transform.action';
    URL_SET.OLAP_TABLE_DRILL = '/reportTemplate/table/drill.action';
    URL_SET.OLAP_TABLE_LINK_DRILL = '/reportTemplate/table/drillByLink.action';
    URL_SET.OLAP_TABLE_SORT = '/reportTemplate/table/sort.action';
    URL_SET.OLAP_TABLE_CHECK = '/reportTemplate/table/checkRow.action';
    URL_SET.OLAP_TABLE_SELECT = '/reportTemplate/table/selectRow.action';
    URL_SET.OLAP_TABLE_DOWNLOAD = '/reportTemplate/table/download.action';
    URL_SET.OLAP_TABLE_OFFLINE_DOWNLOAD = '/reportTemplate/table/downloadOffLine.action';
    URL_SET.OLAP_TABLE_LINK_BRIDGE = '/reportTemplate/table/linkBridge.action';

    // 图
    URL_SET.OLAP_CHART_DATA = '/reportTemplate/chart/transform.action';
    URL_SET.OLAP_CHART_X_DATA = '/reportTemplate/chart/reDraw.action';
    URL_SET.OLAP_CHART_S_DATA = '/reportTemplate/chart/reDrawSeries.action'; // 传入维度参数
    URL_SET.OLAP_CHART_S_ADD_DATA = '/reportTemplate/chart/addChartSeries.action'; // 传入维度参数，增加趋势线
    URL_SET.OLAP_CHART_S_REMOVE_DATA = '/reportTemplate/chart/removeChartSeries.action'; // 传入维度参数，删除趋势线
    URL_SET.OLAP_CHART_BASE_CONFIG_INIT = '/reportTemplate/chart/config.action';
    URL_SET.OLAP_CHART_BASE_CONFIG_SUBMIT = '/reportTemplate/chart/config.action';
    URL_SET.OLAP_CHART_DOWNLOAD = '/reportTemplate/chart/download.action';
    URL_SET.OLAP_CHART_OFFLINE_DOWNLOAD = '/reportTemplate/chart/downloadOffLine.action';
    // addSeriesUnit
    // removeSeriesUnit
    // setSeriesUnitType

    // 报表预览
    // URL_SET.REPORT_PREVIEW = '/layout-tpl/biz-pool.html';
    // URL_SET.REPORT_PREVIEW = '/layout-tpl/pgr.html';
    URL_SET.REPORT_PREVIEW = '/layout-tpl/ka-income.html';
    // URL_SET.REPORT_PREVIEW = '/layout-tpl/ka-income2.html';
    // URL_SET.REPORT_PREVIEW = '/reportTemplate/complex/generateReport.action';

})();
var ecui;
(function () {

//{assign var="phases" value="define,body" delimiter=","}//
//{foreach item="item" from=$phases}//
//{assign var="phase" value=$item}//
//{include file="adapter.js"}//
//{include file="core.js"}//
//{include file="control.js"}//
//{include file="input-control.js"}//
//{include file="button.js"}//
//{include file="scrollbar.js"}//
//{include file="panel.js"}//
//{include file="items.js"}//
//{include file="checkbox.js"}//
//{include file="radio.js"}//
//{include file="select.js"}//

//{include file="combox.js"}//
//{include file="form.js"}//
//{include file="tree-view.js"}//
//{include file="month-view.js"}//
//{include file="table.js"}//
//{include file="locked-table.js"}//
//{include file="popup-menu.js"}//
//{include file="listbox.js"}//
//{include file="tab.js"}//
//{include file="decorate.js"}//
//{include file="combine.js"}//

//*{include file="label.js"}//
//*{include file="progress.js"}//
//*{include file="collection.js"}//
//*{include file="calendar.js"}//
//*{include file="format-edit.js"}//
//*{include file="radio-tree.js"}//
//*{include file="check-tree.js"}//
//*{include file="color.js"}//
//*{include file="palette.js"}//
//*{include file="multi-select.js"}//
//*{include file="locked-table.js"}//
//*{include file="messagebox.js"}//
//*{include file="shield.js"}//
//*{include file="tween.js"}//
//{/foreach}//
})();

//{if 0}//
(function () {
//{/if}//
//{if $phase == "define"}//

//__gzip_unitize__i
//__gzip_unitize__list
//__gzip_unitize__o
//__gzip_unitize__el
//__gzip_unitize__params
    var core = ecui = {},
        array = core.array = {},
        dom = core.dom = {},
        ext = core.ext = {},
        json = core.json = {},
        string = core.string = {},
        ui = core.ui = {},
        util = core.util = {};

    //__gzip_original__WINDOW
    ///__gzip_original__DOCUMENT
    //__gzip_original__DATE
    //__gzip_original__FUNCTION
    //__gzip_original__MATH
    //__gzip_original__REGEXP
    //__gzip_original__ABS
    //__gzip_original__CEIL
    ///__gzip_original__FLOOR
    ///__gzip_original__MAX
    ///__gzip_original__MIN
    //__gzip_original__POW
    ///__gzip_original__ROUND
    ///__gzip_original__PARSEINT
    //__gzip_original__ISNAN
    var undefined,
        WINDOW = window,
        DOCUMENT = document,
        DATE = Date,
        FUNCTION = Function,
        MATH = Math,
        REGEXP = RegExp,
        ABS = MATH.abs,
        CEIL = MATH.ceil,
        FLOOR = MATH.floor,
        MAX = MATH.max,
        MIN = MATH.min,
        POW = MATH.pow,
        ROUND = MATH.round,
        PARSEINT = parseInt,
        ISNAN = isNaN;

    var USER_AGENT = navigator.userAgent,
        isStrict = DOCUMENT.compatMode == 'CSS1Compat',
        ieVersion = dom.ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        firefoxVersion = dom.firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,
        operaVersion = dom.operaVersion = /opera\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,
        safariVersion = dom.safariVersion = 
            /(\d+\.\d)(\.\d)?\s+safari/i.test(USER_AGENT) && !/chrome/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined;

    // 字符集基本操作定义
    var charset = {
            utf8: {
                byteLength: function (source) {
                    return source.replace(/[\x80-\u07ff]/g, '  ').replace(/[\u0800-\uffff]/g, '   ').length;
                },

                codeLength: function (code) {
                    return code > 2047 ? 3 : code > 127 ? 2 : 1;
                }
            },

            gbk: {
                byteLength: function (source) {
                    return source.replace(/[\x80-\uffff]/g, '  ').length;
                },

                codeLength: function (code) {
                    return code > 127 ? 2 : 1;
                }
            },

            '': {
                byteLength: function (source) {
                    return source.length;
                },

                codeLength: function (code) {
                    return 1;
                }
            }
        };

    // 读写特殊的 css 属性操作
    var styleFixer = {
            display:
                ieVersion < 8 ? {
                    get: function (el, style) {
                        return style.display == 'inline' && style.zoom == 1 ? 'inline-block' : style.display;
                    },

                    set: function (el, value) {
                        if (value == 'inline-block') {
                            value = 'inline';
                            el.style.zoom = 1;
                        }
                        el.style.display = value;
                    }
                } : firefoxVersion < 3 ? {
                    get: function (el, style) {
                        return style.display == '-moz-inline-box' ? 'inline-block' : style.display;
                    },

                    set: function (el, value) {
                        el.style.display = value == 'inline-block' ? '-moz-inline-box' : value;
                    }
                } : undefined,

            opacity:
                ieVersion ? {
                    get: function (el, style) {
                        return /alpha\(opacity=(\d+)/.test(style.filter) ? ((REGEXP.$1 - 0) / 100) + '' : '1';
                    },

                    set: function (el, value) {
                        el.style.filter =
                            el.style.filter.replace(/alpha\([^\)]*\)/gi, '') + 'alpha(opacity=' + value * 100 + ')';
                    }
                } : undefined,

            'float': ieVersion ? 'styleFloat' : 'cssFloat'
        };

        /**
         * 查询数组中指定对象的位置序号。
         * indexOf 方法返回完全匹配的对象在数组中的序号，如果在数组中找不到指定的对象，返回 -1。
         * @public
         * 
         * @param {Array} list 数组对象
         * @param {Object} obj 需要查询的对象
         * @return {number} 位置序号，不存在返回 -1
         */
    var indexOf = array.indexOf = function (list, obj) {
            for (var i = list.length; i--; ) {
                if (list[i] === obj) {
                    break;
                }
            }
            return i;
        },

        /**
         * 从数组中移除对象。
         * @public
         * 
         * @param {Array} list 数组对象
         * @param {Object} obj 需要移除的对象
         */
        remove = array.remove = function (list, obj) {
            for (var i = list.length; i--; ) {
                if (list[i] === obj) {
                    list.splice(i, 1);
                }
            }
        },

        /**
         * 为 Element 对象添加新的样式。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @param {string} className 样式名，可以是多个，中间使用空白符分隔
         */
        addClass = dom.addClass = function (el, className) {
            // 这里直接添加是为了提高效率，因此对于可能重复添加的属性，请使用标志位判断是否已经存在，
            // 或者先使用 removeClass 方法删除之前的样式
            el.className += ' ' + className;
        },

        /**
         * 获取所有 parentNode 为指定 Element 的子 Element 集合。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @return {Array} Element 对象数组
         */
        children = dom.children = function (el) {
            for (var result = [], o = el.firstChild; o; o = o.nextSibling) {
                if (o.nodeType == 1) {
                    result.push(o);
                }
            }
            return result;    
        },

        /**
         * 判断一个 Element 对象是否包含另一个 Element 对象。
         * contain 方法认为两个相同的 Element 对象相互包含。
         * @public
         * 
         * @param {HTMLElement} container 包含的 Element 对象
         * @param {HTMLElement} contained 被包含的 Element 对象
         * @return {boolean} contained 对象是否被包含于 container 对象的 DOM 节点上
         */
        contain = dom.contain = firefoxVersion ? function (container, contained) {
            return container == contained || !!(container.compareDocumentPosition(contained) & 16);
        } : function (container, contained) {
            return container.contains(contained);
        },

        /**
         * 创建 Element 对象。
         * @public
         * 
         * @param {string} className 样式名称
         * @param {string} cssText 样式文本
         * @param {string} tagName 标签名称，默认创建一个空的 div 对象
         * @return {HTMLElement} 创建的 Element 对象
         */
        createDom = dom.create = function (className, cssText, tagName) {
            tagName = DOCUMENT.createElement(tagName || 'DIV');
            if (className) {
                tagName.className = className;
            }
            if (cssText) {
                tagName.style.cssText = cssText;
            }
            return tagName;
        },

        /**
         * 获取 Element 对象的第一个子 Element 对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} 子 Element 对象
         */
        first = dom.first = function (el) {
            return matchNode(el.firstChild, 'nextSibling');
        },

        /**
         * 获取 Element 对象的属性值。
         * 在 IE 下，Element 对象的属性可以通过名称直接访问，效率是 getAttribute 方式的两倍。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} name 属性名称
         * @return {string} 属性值
         */
        getAttribute = dom.getAttribute = ieVersion < 8 ? function (el, name) {
            return el[name];
        } : function (el, name) {
            return el.getAttribute(name);
        },

        /**
         * 获取 Element 对象的父 Element 对象。
         * 在 IE 下，Element 对象被 removeChild 方法移除时，parentNode 仍然指向原来的父 Element 对象，与 W3C 标准兼容的属性应该是 parentElement。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} 父 Element 对象，如果没有，返回 null
         */
        getParent = dom.getParent = ieVersion ? function (el) {
            return el.parentElement;
        } : function (el) {
            return el.parentNode;
        },

        /**
         * 获取 Element 对象的页面位置。
         * getPosition 方法将返回指定 Element 对象的位置信息。属性如下：
         * left {number} X轴坐标
         * top  {number} Y轴坐标
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {Object} 位置信息
         */
        getPosition = dom.getPosition = function (el) {
            var top = 0,
                left = 0,
                body = DOCUMENT.body,
                html = getParent(body);

            if (ieVersion) {
                if(!isStrict) {
                    // 在怪异模式下，IE 将 body 的边框也算在了偏移值中，需要先纠正
                    o = getStyle(body);
                    if (ISNAN(top = PARSEINT(o.borderTopWidth))) {
                        top = -2;
                    }
                    if (ISNAN(left = PARSEINT(o.borderLeftWidth))) {
                        left = -2;
                    }
                }

                o = el.getBoundingClientRect();
                top += html.scrollTop + body.scrollTop - html.clientTop + FLOOR(o.top);
                left += html.scrollLeft + body.scrollLeft - html.clientLeft + FLOOR(o.left);
            }
            else if (el == body) {
                top = html.scrollTop + body.scrollTop;
                left = html.scrollLeft + body.scrollLeft;
            }
            else if (el != html) {
                for (o = el; o; o = o.offsetParent) {
                    top += o.offsetTop;
                    left += o.offsetLeft;
                }

                if (operaVersion || (/webkit/i.test(USER_AGENT) && getStyle(el, 'position') == 'absolute')) {
                    top -= body.offsetTop;
                }

                for (var o = getParent(el), style = getStyle(el); o != body; o = getParent(o), style = el) {
                    left -= o.scrollLeft;
                    if (!operaVersion) {
                        el = getStyle(o);
                        // 以下使用 html 作为临时变量
                        html = firefoxVersion && el.overflow != 'visible' && style.position == 'absolute' ? 2 : 1;
                        top += toNumber(el.borderTopWidth) * html - o.scrollTop;
                        left += toNumber(el.borderLeftWidth) * html;
                    }
                    else if (o.tagName != 'TR') {
                        top -= o.scrollTop;
                    }
                }
            }

            return {top: top, left: left};
        },

        /**
         * 获取 Element 对象的 CssStyle 对象或者是指定的样式值。
         * getStyle 方法如果不指定样式名称，将返回 Element 对象的当前 CssStyle 对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} name 样式名称
         * @return {CssStyle|Object} CssStyle 对象或样式值
         */
        getStyle = dom.getStyle = function (el, name) {
            var fixer = styleFixer[name],
                style = el.currentStyle || (ieVersion ? el.style : getComputedStyle(el, null));

            return name ? fixer && fixer.get ? fixer.get(el, style) : style[fixer || name] : style;
        },

        /**
         * 获取 Element 对象的文本。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {string} Element 对象的文本
         */
        getText = dom.getText = firefoxVersion ? function (el) {
            return el.textContent;
        } : function (el) {
            return el.innerText;
        },

        /**
         * 将 Element 对象插入指定的 Element 对象之后。
         * 如果指定的 Element 对象没有父 Element 对象，相当于 remove 操作。
         * @public
         *
         * @param {HTMLElement} el 被插入的 Element 对象
         * @param {HTMLElement} target 目标 Element 对象
         * @return {HTMLElement} 被插入的 Element 对象
         */
        insertAfter = dom.insertAfter = function (el, target) {
            var parent = getParent(target);
            return parent ? parent.insertBefore(el, target.nextSibling) : removeDom(el);
        },

        /**
         * 将 Element 对象插入指定的 Element 对象之前。
         * 如果指定的 Element 对象没有父 Element 对象，相当于 remove 操作。
         * @public
         *
         * @param {HTMLElement} el 被插入的 Element 对象
         * @param {HTMLElement} target 目标 Element 对象
         * @return {HTMLElement} 被插入的 Element 对象
         */
        insertBefore = dom.insertBefore = function (el, target) {
            var parent = getParent(target);
            return parent ? parent.insertBefore(el, target) : removeDom(el);
        },

        /**
         * 向指定的 Element 对象内插入一段 html 代码。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @param {string} position 插入 html 的位置信息，取值为 beforeBegin,afterBegin,beforeEnd,afterEnd
         * @param {string} html 要插入的 html 代码
         */
        insertHTML = dom.insertHTML = firefoxVersion ? function (el, position, html) {
            var name = {
                    AFTERBEGIN: 'selectNodeContents',
                    BEFOREEND: 'selectNodeContents',
                    BEFOREBEGIN: 'setStartBefore',
                    AFTEREND: 'setEndAfter'
                }[position.toUpperCase()],
                range = DOCUMENT.createRange();

            range[name](el);
            range.collapse(position.length > 9);
            range.insertNode(range.createContextualFragment(html));
        } : function (el, position, html) {
            el.insertAdjacentHTML(position, html);
        },

        /**
         * 获取 Element 对象的最后一个子 Element 对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} 子 Element 对象
         */
        last = dom.last = function (el) {
            return matchNode(el.lastChild, 'previousSibling');
        },

        /**
         * 将指定的 Element 对象的内容移动到目标 Element 对象中。
         * @public
         *
         * @param {HTMLElement} source 指定的 Element 对象
         * @param {HTMLElement} target 目标 Element 对象
         * @param {boolean} all 是否移动所有的 DOM 对象，默认仅移动 ElementNode 类型的对象
         */
        moveElements = dom.moveElements = function (source, target, all) {
            //__transform__el_o
            for (var el = source.firstChild; el; el = source) {
                source = el.nextSibling;
                if (all || el.nodeType == 1) {
                    target.appendChild(el);
                }
            }
        },

        /**
         * 获取 Element 对象的下一个 Element 对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} Element 对象
         */
        next = dom.next = function (el) {
            return matchNode(el.nextSibling, 'nextSibling');
        },

        /**
         * 从页面中移除 Element 对象。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} 被移除的 Element 对象
         */
        removeDom = dom.remove = function (el) {
            var parent = getParent(el);
            if (parent) {
                parent.removeChild(el);
            }
            return el;
        },

        /**
         * 删除 Element 对象中的样式。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @param {string} className 样式名，可以是多个，中间用空白符分隔
         */
        removeClass = dom.removeClass = function (el, className) {
            var oldClasses = el.className.split(/\s+/).sort(),
                newClasses = className.split(/\s+/).sort(),
                i = oldClasses.length,
                j = newClasses.length;

            for (; i && j; ) {
                if (oldClasses[i - 1] == newClasses[j - 1]) {
                    oldClasses.splice(--i, 1);
                }
                else if (oldClasses[i - 1] < newClasses[j - 1]) {
                    j--;
                }
                else {
                    i--;
                }
            }
            el.className = oldClasses.join(' ');
        },

        /**
         * 设置输入框的表单项属性。
         * 如果没有指定一个表单项，setInput 方法将创建一个表单项。
         * @public
         *
         * @param {HTMLElement} el InputElement 对象
         * @param {string} name 新的表单项名称，默认与 el 相同
         * @param {string} type 新的表单项类型，默认为 el 相同
         * @return {HTMLElement} 设置后的 InputElement 对象
         */
        setInput = dom.setInput = function (el, name, type) {
            if (!el) {
                if (type == 'textarea') {
                    el = createDom('', '', 'textarea');
                }
                else {
                    if (ieVersion < 9) {
                        return createDom('', '', '<input type="' + (type || '') + '" name="' + (name || '') + '">');
                    }
                    el = createDom('', '', 'input');
                }
            }

            name = name === undefined ? el.name : name;
            type = type === undefined ? el.type : type;

            if (el.name != name || el.type != type) {
                if ((ieVersion && type != 'textarea') ||
                        el.type != type && (el.type == 'textarea' || type == 'textarea')) {
                    insertHTML(
                        el,
                        'AFTEREND',
                        '<' + (type == 'textarea' ? 'textarea' : 'input type="' + type + '"') +
                            ' name="' + name + '" class="' + el.className +
                            '" style="' + el.style.cssText + '" ' + (el.disabled ? 'disabled' : '') +
                            (el.readOnly ? ' readOnly' : '') + '>'
                    );
                    name = el;
                    (el = el.nextSibling).value = name.value;
                    if (type == 'radio') {
                        el.checked = name.checked;
                    }
                    removeDom(name);
                }
                else {
                    el.type = type;
                    el.name = name;
                }
            }
            return el;
        },

        /**
         * 设置 Element 对象的样式值。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} name 样式名称
         * @param {string} value 样式值
         */
        setStyle = dom.setStyle = function (el, name, value) {
            var fixer = styleFixer[name];
            if (fixer && fixer.set) {
                fixer.set(el, value);
            }
            else {
                el.style[fixer || name] = value;
            }
        },

        /**
         * 设置 Element 对象的文本。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} text Element 对象的文本
         */
        setText = dom.setText = firefoxVersion ? function (el, text) {
            el.textContent = text;
        } : function (el, text) {
            el.innerText = text;
        },

        /**
         * JSON字串解析，将JSON字符串解析为JSON对象。
         * @public
         *
         * @param {string} text json字符串
         * @return {Object} json字符串描述的对象
         */
        parse = json.parse = function (text) {
            return new Function('return (' + text + ')')();
        },

        /**
         * JSON对象序列化。
         * @public
         *
         * @param {Object} source 需要序列化的对象
         * @return {string} json字符串
         */
        stringify = json.stringify = (function () {
//__gzip_unitize__result
//__gzip_unitize__source
            var escapeMap = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"' : '\\"',
                    '\\': '\\\\'
                };

            /**
             * 字符串序列化。
             * @private
             *
             * @param {string} source 需要序列化的字符串
             */
            function encodeString(source) {
                if (/["\\\x00-\x1f]/.test(source)) {
                    source = source.replace(
                        /["\\\x00-\x1f]/g,
                        function (match) {
                            var o = escapeMap[match];
                            if (o) {
                                return o;
                            }
                            o = match.charCodeAt();
                            return '\\u00' + FLOOR(o / 16) + (o % 16).toString(16);
                        }
                    );
                }
                return '"' + source + '"';
            }

            /**
             * 数组序列化。
             * @private
             *
             * @param {Array} source 需要序列化的数组
             */
            function encodeArray(source) {
                var i = 0,
                    result = [],
                    o,
                    l = source.length;

                for (var i = 0, result = [], o, l = source.length; i < l; i++) {
                    if ((o = stringify(source[i])) !== undefined) {
                        result.push(o);
                    }
                }
                return '[' + result.join(',') + ']';
            }

            /**
             * 处理日期序列化时的补零。
             * @private
             *
             * @param {number} source 数值，小于10需要补零
             */
            function pad(source) {
                return source < 10 ? '0' + source : source;
            }

            /**
             * 日期序列化。
             * @private
             *
             * @param {Date} source 需要序列化的日期
             */
            function encodeDate(source) {
                return '"' + source.getFullYear() + '-' + pad(source.getMonth() + 1) + '-' +
                        pad(source.getDate()) + 'T' + pad(source.getHours()) + ':' +
                        pad(source.getMinutes()) + ':' + pad(source.getSeconds()) + '"';
            }

            return function (source) {
                switch (typeof source) {
                case 'undefined':
                case 'function':
                case 'unknown':
                    return undefined;
                case 'number':
                    if (!isFinite(source)) {
                        return 'null';
                    }
                    // 对于有意义的数值与布尔类型直接输出
                case 'boolean':
                    return source.toString();
                case 'string':
                    return encodeString(source);
                default:
                    if (source === null) {
                        return 'null';
                    }
                    else if (source instanceof Array) {
                        return encodeArray(source);
                    }
                    else if (source instanceof Date) {
                        return encodeDate(source);
                    }
                    else {
                        var result = [],
                            o;

                        for (var i in source) {
                            if ((o = stringify(source[i])) !== undefined) {
                                result.push(encodeString(i) + ':' + o);
                            }
                        }

                        return '{' + result.join(',') + '}';
                    }
                }
            };
        })(),

        /**
         * 对目标字符串进行 html 解码。
         * @public
         *
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        decodeHTML = string.decodeHTML = (function () {
            var codeTable = {
                quot: '"',
                lt: '<',
                gt: '>',
                amp: '&'
            };

            return function (source) {
                //处理转义的中文和实体字符
                return source.replace(/&(quot|lt|gt|amp|#([\d]+));/g, function(match, $1, $2) {
                    return codeTable[$1] || String.fromCharCode(+$2);
                });
            };
        })(),

        /**
         * 对目标字符串进行 html 编码。
         * encodeHTML 方法对四个字符进行编码，分别是 &<>"
         * @public
         *
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        encodeHTML = string.encodeHTML = function (source) {
            return source.replace(/[&<>"']/g, function (c) {
                return '&#' + c.charCodeAt(0) + ';';
            });
        },

        /**
         * 计算字符串的字节长度。
         * 如果没有指定编码集，相当于获取字符串属性 length 的值。
         * 
         * @param {string} source 目标字符串
         * @param {string} charsetName 字符对应的编码集
         * @return {number} 字节长度
         */
        getByteLength = string.getByteLength = function (source, charsetName) {
            return charset[charsetName || ''].byteLength(source);
        },

        /**
         * 根据字节长度截取字符串。
         * 如果没有指定编码集，相当于字符串的 slice 方法。
         * 
         * @param {string} source 目标字符串
         * @param {number} length 需要截取的字节长度
         * @param {string} charsetName 字符对应的编码集
         * @return {string} 结果字符串
         */
        sliceByte = string.sliceByte = function (source, length, charsetName) {
            for (var i = 0, func = charset[charsetName || ''].codeLength; i < source.length; i++) {
                length -= func(source.charCodeAt(i));
                if (length < 0) {
                    return source.slice(0, i);
                }
            }

            return source;
        },

        /**
         * 驼峰命名法转换。
         * toCamelCase 方法将 xxx-xxx 字符串转换成 xxxXxx。
         * @public
         *
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        toCamelCase = string.toCamelCase = function (source) {
            if (source.indexOf('-') < 0) {
                return source;
            }
            return source.replace(/\-./g, function (match) {
                return match.charAt(1).toUpperCase();
            });
        },

        /**
         * 将目标字符串中常见全角字符转换成半角字符。
         * 
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        toHalfWidth = string.toHalfWidth = function (source) {
            return source.replace(/[\u3000\uFF01-\uFF5E]/g, function (c) {
                return String.fromCharCode(MAX(c.charCodeAt(0) - 65248, 32));
            });
        },

        /**
         * 过滤字符串两端的空白字符。
         * @public
         *
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        trim = string.trim = function (source) {
            return source && source.replace(/^\s+|\s+$/g, '');
        },

        /**
         * 日期格式化。
         * @public
         *
         * @param {Date} source 日期对象
         * @param {string} pattern 日期格式描述字符串
         * @return {string} 结果字符串
         */
        formatDate = string.formatDate = function (source, pattern) {
            var year = source.getFullYear(),
                month = source.getMonth() + 1,
                date = source.getDate(),
                hours = source.getHours(),
                minutes = source.getMinutes(),
                seconds = source.getSeconds();

            return pattern.replace(/(y+|M+|d+|H+|h+|m+|s+)/g, function (match) {
                var length = match.length;
                switch (match.charAt()) {
                case 'y':
                    return length > 2 ? year : year.toString().slice(2);
                case 'M':
                    match = month;
                    break;
                case 'd':
                    match = date;
                    break;
                case 'H':
                    match = hours;
                    break;
                case 'h':
                    match = hours % 12;
                    break;
                case 'm':
                    match = minutes;
                    break;
                case 's':
                    match = seconds;
                }
                return length > 1 && match < 10 ? '0' + match : match;
            });
        },

        /**
         * 挂载事件。
         * @public
         *
         * @param {Object} obj 响应事件的对象
         * @param {string} type 事件类型
         * @param {Function} func 事件处理函数
         */
        attachEvent = util.attachEvent = ieVersion ? function (obj, type, func) {
            obj.attachEvent('on' + type, func);
        } : function (obj, type, func) {
            obj.addEventListener(type, func, false);
        },

        /*
         * 空函数。
         * blank 方法不应该被执行，也不进行任何处理，它用于提供给不需要执行操作的事件方法进行赋值，与 blank 类似的用于给事件方法进行赋值，而不直接被执行的方法还有 cancel。
         * @public
         */
        blank = util.blank = function () {
        },

        /**
         * 调用指定对象超类的指定方法。
         * callSuper 用于不确定超类类型时的访问，例如接口内定义的方法。请注意，接口不允许被子类实现两次，否则将会引发死循环。
         * @public
         *
         * @param {Object} object 需要操作的对象
         * @param {string} name 方法名称
         * @return {Object} 超类方法的返回值
         */
        callSuper = util.callSuper = function (object, name) {
            /**
             * 查找指定的方法对应的超类方法。
             * @private
             *
             * @param {Object} clazz 查找的起始类对象
             * @param {Function} caller 基准方法，即查找 caller 对应的超类方法
             * @return {Function} 基准方法对应的超类方法，没有找到基准方法返回 undefined，基准方法没有超类方法返回 null
             */
            function findPrototype(clazz, caller) {
                for (; clazz; clazz = clazz.constructor.superClass) {
                    if (clazz[name] == caller) {
                        for (; clazz = clazz.constructor.superClass; ) {
                            if (clazz[name] != caller) {
                                return clazz[name];
                            }
                        }
                        return null;
                    }
                }
            }

            //__gzip_original__clazz
            var clazz = object.constructor.prototype,
                caller = callSuper.caller,
                func = findPrototype(clazz, caller);

            if (func === undefined) {
                // 如果Items的方法直接位于prototype链上，是caller，如果是间接被别的方法调用Items.xxx.call，是caller.caller
                func = findPrototype(clazz, caller.caller);
            }

            if (func) {
                return func.apply(object, caller.arguments);
            }
        },

        /*
         * 返回 false。
         * cancel 方法不应该被执行，它每次返回 false，用于提供给需要返回逻辑假操作的事件方法进行赋值，例如需要取消默认事件操作的情况，与 cancel 类似的用于给事件方法进行赋值，而不直接被执行的方法还有 blank。
         * @public
         *
         * @return {boolean} false
         */
        cancel = util.cancel = function () {
            return false;
        },

        /**
         * 卸载事件。
         * @public
         *
         * @param {Object} obj 响应事件的对象
         * @param {string} type 事件类型
         * @param {Function} func 事件处理函数
         */
        detachEvent = util.detachEvent = ieVersion ? function (obj, type, func) {
            obj.detachEvent('on' + type, func);
        } : function (obj, type, func) {
            obj.removeEventListener(type, func, false);
        },

        /**
         * 对象属性复制。
         * @public
         *
         * @param {Object} target 目标对象
         * @param {Object} source 源对象
         * @return {Object} 目标对象
         */
        extend = util.extend = function (target, source) {
            for (var key in source) {
                target[key] = source[key];
            }
            return target;
        },

        /**
         * 获取浏览器可视区域的相关信息。
         * getView 方法将返回浏览器可视区域的信息。属性如下：
         * top        {number} 可视区域最小X轴坐标
         * right      {number} 可视区域最大Y轴坐标
         * bottom     {number} 可视区域最大X轴坐标
         * left       {number} 可视区域最小Y轴坐标
         * width      {number} 可视区域的宽度
         * height     {number} 可视区域的高度
         * pageWidth  {number} 页面的宽度
         * pageHeight {number} 页面的高度
         * @public
         *
         * @return {Object} 浏览器可视区域信息
         */
        getView = util.getView = function () {
            //__gzip_original__clientWidth
            //__gzip_original__clientHeight
            var body = DOCUMENT.body,
                html = getParent(body),
                client = isStrict ? html : body,
                scrollTop = html.scrollTop + body.scrollTop,
                scrollLeft = html.scrollLeft + body.scrollLeft,
                clientWidth = client.clientWidth,
                clientHeight = client.clientHeight;

            return {
                top: scrollTop,
                right: scrollLeft + clientWidth,
                bottom: scrollTop + clientHeight,
                left: scrollLeft,
                width: clientWidth,
                height: clientHeight,
                pageWidth: MAX(html.scrollWidth, body.scrollWidth, clientWidth),
                pageHeight: MAX(html.scrollHeight, body.scrollHeight, clientHeight)
            };
        },

        /**
         * 类继承。
         * @public
         *
         * @param {Function} subClass 子类
         * @param {Function} superClass 父类
         * @return {Object} subClass 的 prototype 属性
         */
        inherits = util.inherits = function (subClass, superClass) {
            var oldPrototype = subClass.prototype,
                clazz = new FUNCTION();
                
            clazz.prototype = superClass.prototype;
            extend(subClass.prototype = new clazz(), oldPrototype);
            subClass.prototype.constructor = subClass;
            subClass.superClass = superClass.prototype;

            return subClass.prototype;
        },

        /**
         * 设置缺省的属性值。
         * 如果对象的属性已经被设置，setDefault 方法不进行任何处理，否则将默认值设置到指定的属性上。
         * @public
         *
         * @param {Object} obj 被设置的对象
         * @param {string} key 属性名
         * @param {Object} value 属性的默认值
         */
        setDefault = util.setDefault = function (obj, key, value) {
            if (!obj.hasOwnProperty(key)) {
                obj[key] = value;
            }
        },

        /**
         * 创建一个定时器对象。
         * @public
         *
         * @param {Function} func 定时器需要调用的函数
         * @param {number} delay 定时器延迟调用的毫秒数，如果为负数表示需要连续触发
         * @param {Object} caller 调用者，在 func 被执行时，this 指针指向的对象，可以为空
         * @param {Object} ... 向 func 传递的参数
         * @return {Function} 用于关闭定时器的方法
         */
        timer = util.timer = function (func, delay, caller) {
            function build() {
                return (delay < 0 ? setInterval : setTimeout)(function () {
                    func.apply(caller, args);
                    // 使用delay<0而不是delay>=0，是防止delay没有值的时候，不进入分支
                    if (!(delay < 0)) {
                        func = caller = args = null;
                    }
                }, ABS(delay));
            }

            var args = Array.prototype.slice.call(arguments, 3),
                handle = build(),
                pausing;

            /**
             * 中止定时调用。
             * @public
             *
             * @param {boolean} pause 是否暂时停止定时器，如果参数是 true，再次调用函数并传入参数 true 恢复运行。
             */
            return function (pause) {
                (delay < 0 ? clearInterval : clearTimeout)(handle);
                if (pause) {
                    if (pausing) {
                        handle = build();
                    }
                    pausing = !pausing;
                }
                else {
                    func = caller = args = null;
                }
            };
        },

        /**
         * 将对象转换成数值。
         * toNumber 方法会省略数值的符号，例如字符串 9px 将当成数值的 9，不能识别的数值将默认为 0。
         * @public
         *
         * @param {Object} obj 需要转换的对象
         * @return {number} 对象的数值
         */
        toNumber = util.toNumber = function (obj) {
            return PARSEINT(obj) || 0;
        },

        /**
         * 设置页面加载完毕后自动执行的方法。
         * @public
         *
         * @param {Function} func 需要自动执行的方法
         */
        ready = dom.ready = (function () {
            var hasReady = false,
                list = [],
                check,
                numStyles;

            function ready() {
                if (!hasReady) {
                    hasReady = true;
                    for (var i = 0, o; o = list[i++]; ) {
                        o();
                    }
                }
            }

            if (DOCUMENT.addEventListener && !operaVersion) {
                DOCUMENT.addEventListener('DOMContentLoaded', ready, false);
            }
            else if (ieVersion && WINDOW == top) {
                check = function () {
                    try {
                        DOCUMENT.documentElement.doScroll('left');
                        ready();
                    }
                    catch (e) {
                        timer(check, 0);
                    }
                };
            }
            else if (safariVersion) {
                check = function () {
                    var i = 0,
                        list,
                        o = DOCUMENT.readyState;

                    if (o != 'loaded' && o != 'complete') {
                        timer(check, 0);
                    }
                    else {
                        if (numStyles === undefined) {
                            numStyles = 0;
                            if (list = DOCUMENT.getElementsByTagName('style')) {
                                numStyles += list.length;
                            }
                            if (list = DOCUMENT.getElementsByTagName('link')) {
                                for (; o = list[i++]; ) {
                                    if (getAttribute(o, 'rel') == 'stylesheet') {
                                        numStyles++;
                                    }
                                }
                            }
                        }
                        if (DOCUMENT.styleSheets.length != numStyles) {
                            timer(check, 0);
                        }
                        else {
                            ready();
                        }
                    }
                };
            }

            if (check) {
                check();
            }

            attachEvent(WINDOW, 'load', ready);

            return function (func) {
                if (hasReady) {
                    func();
                }
                else {
                    list.push(func);
                }
            };
        })();
//{else}//
    /**
     * 获取 Element 对象指定位置的 Element 对象。
     * @private
     *
     * @param {HTMLElement} el Element 对象
     * @param {string} direction Element 对象遍历的属性
     * @return {HTMLElement} 指定位置的 Element 对象
     */
    function matchNode(el, direction) {
        for (; el; el = el[direction]) {
            if (el.nodeType == 1) {
                break;
            }
        }
        return el;
    }

    try {
        DOCUMENT.execCommand("BackgroundImageCache", false, true);
    }
    catch (e) {
    }
//{/if}//
//{if 0}//
})();
//{/if}//

//{if 0}//
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ext = core.ext,
        string = core.string,
        util = core.util,
        ui = core.ui,

        undefined,
        WINDOW = window,
        DOCUMENT = document,
        DATE = Date,
        MATH = Math,
        REGEXP = RegExp,
        ABS = MATH.abs,
        MAX = MATH.max,
        MIN = MATH.min,
        ISNAN = isNaN,

        USER_AGENT = navigator.userAgent,
        isStrict = DOCUMENT.compatMode == 'CSS1Compat',
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,

        indexOf = array.indexOf,
        remove = array.remove,
        addClass = dom.addClass,
        contain = dom.contain,
        createDom = dom.create,
        getAttribute = dom.getAttribute,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getStyle = dom.getStyle,
        insertHTML = dom.insertHTML,
        ready = dom.ready,
        removeDom = dom.remove,
        removeClass = dom.removeClass,
        setStyle = dom.setStyle,
        toCamelCase = string.toCamelCase,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        extend = util.extend,
        getView = util.getView,
        inherits = util.inherits,
        timer = util.timer,
        toNumber = util.toNumber;
//{/if}//
//{if $phase == "define"}//
    var NORMAL  = core.NORMAL  = 0,
        LOADING = core.LOADING = 1,
        REPAINT = core.REPAINT = 2;

//__gzip_unitize__event
    var $bind,
        $connect,
        $clearState,
        $create,
        $fastCreate,
        calcHeightRevise,
        calcLeftRevise,
        calcTopRevise,
        calcWidthRevise,
        createControl,
        disposeControl,
        drag,

        /**
         * 从指定的 Element 对象开始，依次向它的父节点查找绑定的 ECUI 控件。
         * findControl 方法，会返回从当前 Element 对象开始，依次向它的父 Element 查找到的第一个绑定(参见 $bind 方法)的 ECUI 控件。findControl 方法一般在控件创建时使用，用于查找父控件对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {ecui.ui.Control} ECUI 控件对象，如果不能找到，返回 null
         */
        findControl = core.findControl = function (el) {
            for (; el; el = getParent(el)) {
                if (el.getControl) {
                    return el.getControl();
                }
            }

            return null;
        },
        getActived,
        getAttributeName,
        getFocused,
        getHovered,
        getKey,
        getMouseX,
        getMouseY,
        getOptions,
        getScrollNarrow,
        getStatus,
        inheritsControl,
        intercept,
        isContentBox,
        loseFocus,
        mask,
        needInitClass,
        query,
        restore,
        setFocused,
        triggerEvent,
        wrapEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ];

    (function () {
        /**
         * 创建 ECUI 事件对象。
         * @public
         *
         * @param {string} type 事件类型
         * @param {Event} event 浏览器原生事件对象，忽略将自动填充
         */
        ///__gzip_original__UI_EVENT_CLASS
        var UI_EVENT = ui.Event = function (type, event) {
                this.type = type;

                if (event) {
                    this.pageX = event.pageX;
                    this.pageY = event.pageY;
                    this.which = event.which;
                    this.target = event.target;
                    this._oNative = event;
                }
                else {
                    this.pageX = mouseX;
                    this.pageY = mouseY;
                    this.which = keyCode;
                    this.target = DOCUMENT;
                }
            },
            UI_EVENT_CLASS = UI_EVENT.prototype,

            ecuiName = 'ecui',        // Element 中用于自动渲染的 ecui 属性名称
            isGlobalId,               // 是否自动将 ecui 的标识符全局化
            structural,               // DOM结构生成的方式，0表示填充所有内容，1表示不填充控件的class，2表示完全不填充

            flgContentBox,            // 在计算宽度与高度时，是否需要修正内填充与边框样式的影响
            flgFixedOffset,           // 在计算相对位置时，是否需要修正边框样式的影响
            scrollNarrow,             // 浏览器滚动条相对窄的一边的长度

            initRecursion = 0,        // init 操作的递归次数
            lastClientWidth,          // 浏览器之前的宽度

            plugins = {},             // 扩展组件列表
            maskElements = [],        // 遮罩层组

            mouseX,                   // 当前鼠标光标的X轴坐标
            mouseY,                   // 当前鼠标光标的Y轴坐标
            keyCode = 0,              // 当前键盘按下的键值，解决keypress与keyup中得不到特殊按键的keyCode的问题
            lastClick,                // 上一次产生点击事件的信息

            status,                   // 框架当前状态
            allControls = [],         // 全部生成的控件，供释放控件占用的内存使用
            independentControls = [], // 独立的控件，即使用create($create)方法创建的控件
            namedControls,            // 所有被命名的控件的集合
            uniqueIndex = 0,          // 控件的唯一序号
            connectedControls = {},   // 等待关联的控件集合

            activedControl,           // 当前环境下被激活的控件，即鼠标左键按下时对应的控件，直到左键松开后失去激活状态
            hoveredControl,           // 当前环境下鼠标悬停的控件
            focusedControl,           // 当前环境下拥有焦点的控件

            eventListeners = {},      // 控件事件监听描述对象

            envStack = [],            // 高优先级事件调用时，保存上一个事件环境的栈
            currEnv = {               // 当前操作的环境

                // 鼠标点击时控件如果被屏弊需要取消点击事件的默认处理，此时链接将不能提交
                click: function (event) {
                    event =wrapEvent(event);

                    //__transform__control_o
                    var control = findControl(event.target);

                    if (control && control.isDisabled()) {
                        event.preventDefault();
                    }
                },

                // 鼠标左键按下需要改变框架中拥有焦点的控件
                mousedown: function (event) {
                    if (activedControl) {
                        // 如果按下鼠标左键后，使用ALT+TAB使浏览器失去焦点然后松开鼠标左键，
                        // 需要恢复激活控件状态，第一次点击失效
                        bubble(activedControl, 'deactivate');
                        activedControl = null;
                        return;
                    }

                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl(),
                        // 修复ie下跨iframe导致的事件类型错误的问题
                        flag = ieVersion < 8 && isScrollClick(event),
                        target = control;

                    if (!(lastClick && isDblClick())) {
                        lastClick = {time: new DATE().getTime()};
                    }

                    if (control) {
                        if (flag) {
                            // IE8以下的版本，如果为控件添加激活样式，原生滚动条的操作会失效
                            // 常见的表现是需要点击两次才能进行滚动操作，而且中途不能离开控件区域
                            // 以免触发悬停状态的样式改变。
                            return;
                        }

                        for (; target; target = target.getParent()) {
                            if (target.isFocusable()) {
                                if (!(target != control && target.contain(focusedControl))) {
                                    // 允许获得焦点的控件必须是当前激活的控件，或者它没有焦点的时候才允许获得
                                    // 典型的用例是滚动条，滚动条不需要获得焦点，如果滚动条的父控件没有焦点
                                    // 父控件获得焦点，否则焦点不发生变化
                                    setFocused(target);
                                }
                                break;
                            }
                        }

                        if (!flag) {
                            // 如果不是在原生滚动条区域，进行左键按下的处理
                            mousedown(control, event);
                        }
                    }
                    else {
                        if (control = findControl(target = event.target)) {
                            // 如果点击的是失效状态的控件，检查是否需要取消文本选择
                            onselectstart(control, event);
                            // 检查是否INPUT/SELECT/TEXTAREA/BUTTON标签，需要失去焦点
                            if (target.tagName == 'INPUT' || target.tagName == 'SELECT' ||
                                    target.tagName == 'TEXTAREA' || target.tagName == 'BUTTON') {
                                timer(function () {
                                    target.blur();
                                });
                            }
                        }
                        // 点击到了空白区域，取消控件的焦点
                        setFocused();
                        // 正常情况下 activedControl 是 null，如果是down按下但未点击到控件，此值为undefined
                        activedControl = undefined;
                    }
                },

                // 鼠标移入的处理，需要计算是不是位于当前移入的控件之外，如果是需要触发移出事件
                mouseover: function (event) {
                    if (currEnv.type != 'drag' && currEnv.type != 'zoom') {
                        event = wrapEvent(event);

                        //__transform__control_o
                        var control = event.getControl(),
                            parent = getCommonParent(control, hoveredControl);

                        bubble(hoveredControl, 'mouseout', event, parent);
                        bubble(control, 'mouseover', event, parent);

                        hoveredControl = control;
                    }
                },

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl();

                    bubble(control, 'mousemove', event);
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl(),
                        commonParent;

                    if (activedControl !== null) {
                        // 如果为 null 表示之前没有触发 mousedown 事件就触发了 mouseup，
                        // 这种情况出现在鼠标在浏览器外按下了 down 然后回浏览器区域 up，
                        // 或者是 ie 系列浏览器在触发 dblclick 之前会触发一次单独的 mouseup，
                        // dblclick 在 ie 下的事件触发顺序是 mousedown/mouseup/click/mouseup/dblclick
                        bubble(control, 'mouseup', event);

                        if (activedControl) {
                            commonParent = getCommonParent(control, activedControl);
                            bubble(commonParent, 'click', event);
                            // 点击事件在同时响应鼠标按下与弹起周期的控件上触发(如果之间未产生鼠标移动事件)
                            // 模拟点击事件是为了解决控件的 Element 进行了 remove/append 操作后 click 事件不触发的问题
                            if (lastClick) {
                                if (isDblClick() && lastClick.target == control) {
                                    bubble(commonParent, 'dblclick', event);
                                    lastClick = null;
                                }
                                else {
                                    lastClick.target = control;
                                }
                            }
                            bubble(activedControl, 'deactivate', event);
                        }

                        // 将 activeControl 的设置复位，此时表示没有鼠标左键点击
                        activedControl = null;
                    }
                }
            },

            dragEnv = { // 拖曳操作的环境
                type: 'drag',

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target,
                        // 计算期待移到的位置
                        expectX = target.getX() + mouseX - currEnv.x,
                        expectY = target.getY() + mouseY - currEnv.y,
                        // 计算实际允许移到的位置
                        x = MIN(MAX(expectX, currEnv.left), currEnv.right),
                        y = MIN(MAX(expectY, currEnv.top), currEnv.bottom);

                    if (triggerEvent(target, 'dragmove', event, [x, y])) {
                        target.setPosition(x, y);
                    }

                    currEnv.x = mouseX + target.getX() - expectX;
                    currEnv.y = mouseY + target.getY() - expectY;
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target;
                    triggerEvent(target, 'dragend', event);
                    activedControl = currEnv.actived;
                    restore();

                    currEnv.mouseover(event);
                    currEnv.mouseup(event);
                }
            },

            interceptEnv = { // 强制点击拦截操作的环境
                type: 'intercept',

                mousedown: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target,
                        env = currEnv,
                        control = event.getControl();

                    lastClick = null;

                    if (!isScrollClick(event)) {
                        if (control && !control.isFocusable()) {
                            // 需要捕获但不激活的控件是最高优先级处理的控件，例如滚动条
                            mousedown(control, event);
                        }
                        else if (triggerEvent(target, 'intercept', event)) {
                            // 默认仅拦截一次，框架自动释放环境
                            restore();
                        }
                        else if (!event.cancelBubble) {
                            if (env == currEnv) {
                                // 不改变当前操作环境表示希望继续进行点击拦截操作
                                // 例如弹出菜单点击到选项上时，不自动关闭并对下一次点击继续拦截
                                if (control) {
                                    mousedown(control, event);
                                }
                            }
                            else {
                                // 手动释放环境会造成向外层环境的事件传递
                                currEnv.mousedown(event);
                            }
                        }
                    }
                }
            },

            zoomEnv = { // 缩放操作的环境
                type: 'zoom',

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__gzip_original__minWidth
                    //__gzip_original__maxWidth
                    //__gzip_original__minHeight
                    //__gzip_original__maxHeight
                    //__transform__target_o
                    var target = currEnv.target,
                        width = currEnv.width = mouseX - currEnv.x + currEnv.width,
                        height = currEnv.height = mouseY - currEnv.y + currEnv.height,
                        minWidth = currEnv.minWidth,
                        maxWidth = currEnv.maxWidth,
                        minHeight = currEnv.minHeight,
                        maxHeight = currEnv.maxHeight;

                    currEnv.x = mouseX;
                    currEnv.y = mouseY;

                    width = minWidth > width ? minWidth : maxWidth < width ? maxWidth : width;
                    height = minHeight > height ? minHeight : maxHeight < height ? maxHeight : height;

                    // 如果宽度或高度是负数，需要重新计算定位
                    target.setPosition(currEnv.left + MIN(width, 0), currEnv.top + MIN(height, 0));
                    if (triggerEvent(target, 'zoom', event)) {
                        target.setSize(ABS(width), ABS(height));
                    }
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target;
                    triggerEvent(target, 'zoomend', event);
                    activedControl = currEnv.actived;
                    restore();

                    repaint();
                    currEnv.mouseover(event);
                    currEnv.mouseup(event);
                }
            },

            /**
             * 初始化指定的 Element 对象对应的 DOM 节点树。
             * init 方法将初始化指定的 Element 对象及它的子节点，如果这些节点拥有初始化属性(参见 getAttributeName 方法)，将按照规则为它们绑定 ECUI 控件，每一个节点只会被绑定一次，重复的绑定无效。页面加载完成时，将会自动针对 document.body 执行这个方法，相当于自动执行以下的语句：ecui.init(document.body)
             * @public
             *
             * @param {Element} el Element 对象
             */
            init = core.init = function (el) {
                if (!initEnvironment() && el) {
                    var i = 0,
                        list = [],
                        options = el.all || el.getElementsByTagName('*'),
                        elements = [el],
                        o, namedMap = {};

                    if (!(initRecursion++)) {
                        // 第一层 init 循环的时候需要关闭resize事件监听，防止反复的重入
                        detachEvent(WINDOW, 'resize', repaint);
                    }

                    for (; o = options[i++]; ) {
                        if (getAttribute(o, ecuiName)) {
                            elements.push(o);
                        }
                    }

                    for (i = 0; el = elements[i]; i++) {
                        options = getOptions(el);
                        // 以下使用 el 替代 control
                        if (o = options.type) {
                            options.main = el;
                            list.push($create(ui[toCamelCase(o.charAt(0).toUpperCase() + o.slice(1))], options));
                            if (options.id) {
                                 namedMap[options.id] = list[list.length - 1];
                            }
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.cache();
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.init();
                    }

                    if (!(--initRecursion)) {
                        attachEvent(WINDOW, 'resize', repaint);
                    }

                    return namedMap;
                }
            },

            /**
             * 重绘浏览器区域的控件。
             * repaint 方法在页面改变大小时自动触发，一些特殊情况下，例如包含框架的页面，页面变化时不会触发 onresize 事件，需要手工调用 repaint 函数重绘所有的控件。
             * @public
             */
            repaint = core.repaint = function () {
                var i = 0,
                    list = [],
                    widthList = [],
                    o;

                if (ieVersion) {
                    // 防止 ie6/7 下的多次重入
                    o = (isStrict ? DOCUMENT.documentElement : DOCUMENT.body).clientWidth;
                    if (lastClientWidth != o) {
                        lastClientWidth = o;
                    }
                    else {
                        // 如果高度发生变化，相当于滚动条的信息发生变化，因此需要产生scroll事件进行刷新
                        onscroll(new UI_EVENT('scroll'));
                        return;
                    }
                }

                status = REPAINT;
                o = currEnv.type;
                // 隐藏所有遮罩层
                mask(false);
                if (o != 'zoom') {
                    // 改变窗体大小需要清空拖拽状态
                    if (o == 'drag') {
                        currEnv.mouseup();
                    }
                    // 按广度优先查找所有正在显示的控件，保证子控件一定在父控件之后
                    for (o = null; o !== undefined; o = list[i++]) {
                        for (var j = 0, controls = query({parent: o}); o = controls[j++]; ) {
                            if (o.isShow() && o.isResizable()) {
                                list.push(o);
                            }
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        // 避免在resize中调用repaint从而引起反复的reflow
                        o.repaint = blank;
                        triggerEvent(o, 'resize');
                        delete o.repaint;

                        if (ieVersion < 8) {
                            // 修复ie6/7下宽度自适应错误的问题
                            o = getStyle(j = o.getMain());
                            if (o.width == 'auto' && o.display == 'block') {
                                j.style.width = '100%';
                            }
                        }
                    }

                    if (ieVersion < 8) {
                        // 由于强制设置了100%，因此改变ie下控件的大小必须从内部向外进行
                        // 为避免多次reflow，增加一次循环
                        for (i = 0; o = list[i]; ) {
                            widthList[i++] = o.getMain().offsetWidth;
                        }
                        for (; o = list[i--]; ) {
                            o.getMain().style.width =
                                widthList[i] - (flgContentBox ? o.$getBasicWidth() * 2 : 0) + 'px';
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.cache(true, true);
                    }
                    for (i = 0; o = list[i++]; ) {
                        o.$setSize(o.getWidth(), o.getHeight());
                    }
                }

                if (ieVersion < 8) {
                    // 解决 ie6/7 下直接显示遮罩层，读到的浏览器大小实际未更新的问题
                    timer(mask, 0, null, true);
                }
                else {
                    mask(true);
                }
                status = NORMAL;
            };

        /**
         * 使一个 Element 对象与一个 ECUI 控件 在逻辑上绑定。
         * 一个 Element 对象只能绑定一个 ECUI 控件，重复绑定会自动取消之前的绑定。
         * @protected
         *
         * @param {HTMLElement} el Element 对象
         * @param {ecui.ui.Control} control ECUI 控件
         */
        $bind = core.$bind = function (el, control) {
            el._cControl = control;
            el.getControl = getControlByElement;
        };

        /**
         * 清除控件的状态。
         * 控件在销毁、隐藏与失效等情况下，需要使用 $clearState 方法清除已经获得的焦点与激活等状态。
         * @protected
         *
         * @param {ecui.ui.Control} control ECUI 控件
         */
        $clearState = core.$clearState = function (control) {
            var o = control.getParent();

            loseFocus(control);
            if (control.contain(activedControl)) {
                bubble(activedControl, 'deactivate', null, activedControl = o);
            }
            if (control.contain(hoveredControl)) {
                bubble(hoveredControl, 'mouseout', null, hoveredControl = o);
            }
        };

        /**
         * 为两个 ECUI 控件 建立连接。
         * 使用页面静态初始化或页面动态初始化(参见 ECUI 使用方式)方式，控件创建时，需要的关联控件也许还未创建。$connect 方法提供将指定的函数滞后到对应的控件创建后才调用的模式。如果 targetId 对应的控件还未创建，则调用会被搁置，直到需要的控件创建成功后，再自动执行(参见 create 方法)。
         * @protected
         *
         * @param {Object} caller 发起建立连接请求的对象
         * @param {Function} func 用于建立连接的方法，即通过调用 func.call(caller, ecui.get(targetId)) 建立连接
         * @param {string} targetId 被连接的 ECUI 控件 标识符，即在标签的 ecui 属性中定义的 id 值
         */
        $connect = core.$connect = function (caller, func, targetId) {
            if (targetId) {
                var target = namedControls[targetId];
                if (target) {
                    func.call(caller, target);
                }
                else {
                    (connectedControls[targetId] = connectedControls[targetId] || [])
                        .push({func: func, caller: caller});
                }
            }
        };

        /**
         * 创建 ECUI 控件。
         * $create 方法创建控件时不会自动渲染控件。在大批量创建控件时，为了加快渲染速度，应该首先使用 $create 方法创建所有控件完成后，再批量分别调用控件的 cache、init 与 repaint 方法渲染控件。options 对象支持的属性如下：
         * id         {string} 当前控件的 id，提供给 $connect 与 get 方法使用
         * main       {HTMLElement} 与控件绑捆的 Element 对象(参见 getMain 方法)，如果忽略此参数将创建 Element 对象与控件绑捆
         * parent     {ecui.ui.Control} 父控件对象或者父 Element 对象
         * primary    {string} 控件的基本样式(参见 getMainClass 方法)，如果忽略此参数将使用主元素的 className 属性
         * @protected
         *
         * @param {Function} type 控件的构造函数
         * @param {Object} options 初始化选项(参见 ECUI 控件)
         * @return {ecui.ui.Control} ECUI 控件
         */
        $create = core.$create = function (type, options) {
            type = type.client || type;
            options = options || {};

            //__gzip_original__parent
            var i = 0,
                parent = options.parent,
                el = options.main,
                o = options.primary || '',
                className;

            options.uid = 'ecui-' + (++uniqueIndex);

            if (el) {
                if (structural) {
                    className = el.className;
                }
                else {
                    el.className = className = el.className + ' ' + o + type.agent.TYPES;
                }

                // 如果没有指定基本样式，使用控件的样式作为基本样式
                if (!o) {
                    /\s*([^\s]+)/.test(className);
                    options.primary = REGEXP.$1;
                }

                // 如果指定的元素已经初始化，直接返回
                if (el.getControl) {
                    return el.getControl();
                }
            }
            else {
                // 没有传入主元素，需要自动生成，此种情况比较少见
                el = options.main = createDom(o + type.agent.TYPES);
                if (!o) {
                    options.primary = type.agent.types[0];
                }
            }

            // 生成控件
            type = new type(el, options);

            if (parent) {
//{if 0}//
                if (parent instanceof ui.Control) {
//{else}//                if (parent instanceof UI_CONTROL) {
//{/if}//
                    type.setParent(parent);
                }
                else {
                    type.appendTo(parent);
                }
            }
            else {
                type.$setParent(findControl(getParent(type.getOuter())));
            }

            oncreate(type, options);
            independentControls.push(type);

            // 处理所有的关联操作
            if (el = connectedControls[options.id]) {
                for (connectedControls[options.id] = null; o = el[i++]; ) {
                    o.func.call(o.caller, type);
                }
            }

            return type;
        };

        /**
         * 快速创建 ECUI 控件。
         * $fastCreate 方法仅供控件生成自己的部件使用，生成的控件不在控件列表中注册，不自动刷新也不能通过 query 方法查询(参见 $create 方法)。$fastCreate 方法通过分解 Element 对象的 className 属性得到样式信息，其中第一个样式为类型样式，第二个样式为基本样式。
         * @protected
         *
         * @param {Function} type 控件的构造函数
         * @param {HTMLElement} el 控件对应的 Element 对象
         * @param {ecui.ui.Control} parent 控件的父控件
         * @param {Object} options 初始化选项(参见 ECUI 控件)
         * @return {ecui.ui.Control} ECUI 控件
         */
        $fastCreate = core.$fastCreate = function (type, el, parent, options) {
            type = type.client || type;
            options = options || {};

            options.uid = 'ecui-' + (++uniqueIndex);
            if (!options.primary) {
                /\s*([^\s]+)/.test(el.className);
                options.primary = REGEXP.$1;
            }

            type = new type(el, options);
            type.$setParent(parent);

            oncreate(type, options);

            return type;
        };

        /**
         * 添加控件的事件监听函数。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         * @param {string} name 事件名称
         * @param {Function} caller 监听函数
         */
        core.addEventListener = function (control, name, caller) {
            name = control.getUID() + name;
            (eventListeners[name] = eventListeners[name] || []).push(caller);
        };

        /**
         * 获取高度修正值(即计算 padding, border 样式对 height 样式的影响)。
         * IE 的盒子模型不完全遵守 W3C 标准，因此，需要使用 calcHeightRevise 方法计算 offsetHeight 与实际的 height 样式之间的修正值。
         * @public
         *
         * @param {CssStyle} style CssStyle 对象
         * @return {number} 高度修正值
         */
        calcHeightRevise = core.calcHeightRevise = function (style) {
            return flgContentBox ? toNumber(style.borderTopWidth) + toNumber(style.borderBottomWidth) +
                    toNumber(style.paddingTop) + toNumber(style.paddingBottom)
                : 0;
        };

        /**
         * 获取左定位修正值(即计算 border 样式对 left 样式的影响)。
         * opera 等浏览器，offsetLeft 与 left 样式的取值受到了 border 样式的影响，因此，需要使用 calcLeftRevise 方法计算 offsetLeft 与实际的 left 样式之间的修正值。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {number} 左定位修正值
         */
        calcLeftRevise = core.calcLeftRevise = function (el) {
            //__transform__style_o
            var style = getStyle(el.offsetParent);
            return !firefoxVersion || style.overflow != 'visible' && getStyle(el, 'position') == 'absolute' ?
                toNumber(style.borderLeftWidth) * flgFixedOffset : 0;
        };

        /**
         * 获取上定位修正值(即计算 border 样式对 top 样式的影响)。
         * opera 等浏览器，offsetTop 与 top 样式的取值受到了 border 样式的影响，因此，需要使用 calcTopRevise 方法计算 offsetTop 与实际的 top 样式之间的修正值。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {number} 上定位修正值
         */
        calcTopRevise = core.calcTopRevise = function (el) {
            //__transform__style_o
            var style = getStyle(el.offsetParent);
            return !firefoxVersion || style.overflow != 'visible' && getStyle(el, 'position') == 'absolute' ?
                toNumber(style.borderTopWidth) * flgFixedOffset : 0;
        };

        /**
         * 获取宽度修正值(即计算 padding,border 样式对 width 样式的影响)。
         * IE 的盒子模型不完全遵守 W3C 标准，因此，需要使用 calcWidthRevise 方法计算 offsetWidth 与实际的 width 样式之间的修正值。
         * @public
         *
         * @param {CssStyle} style CssStyle 对象
         * @return {number} 宽度修正值
         */
        calcWidthRevise = core.calcWidthRevise = function (style) {
            return flgContentBox ? toNumber(style.borderLeftWidth) + toNumber(style.borderRightWidth) +
                    toNumber(style.paddingLeft) + toNumber(style.paddingRight)
                : 0;
        };

        /**
         * 创建 ECUI 控件。
         * 标准的创建 ECUI 控件 的工厂方法，适用于少量创建控件，生成的控件不需要任何额外的调用即可正常的显示，对于批量创建控件，请使用 $create 方法。options 对象支持的属性如下：
         * id        {string} 当前控件的 id，提供给 $connect 与 get 方法使用
         * main      {HTMLElement} 与控件绑捆的 Element 对象(参见 getMain 方法)，如果忽略此参数将创建 Element 对象与控件绑捆
         * parent    {ecui.ui.Control} 父控件对象或者父 Element 对象
         * primary   {string} 控件的基本样式(参见 getMainClass 方法)，如果忽略此参数将使用主元素的 className 属性
         * @public
         *
         * @param {string|Function} type 控件的类型名或控件的构造函数
         * @param {Object} options 初始化选项(参见 ECUI 控件)
         * @return {ecui.ui.Control} ECUI 控件
         */
        createControl = core.create = function (type, options) {
            type = $create('string' == typeof(type) ? ui[type] : type, options);
            type.cache();
            type.init();
            return type;
        };

        /**
         * 释放 ECUI 控件及其子控件占用的内存。
         * @public
         *
         * @param {ecui.ui.Control|HTMLElement} control 需要释放的控件对象或包含控件的 Element 对象
         */
        disposeControl = core.dispose = function (control) {
            var i = allControls.length,
//{if 0}//
                type = control instanceof ui.Control,
//{else}//                type = control instanceof UI_CONTROL,
//{/if}//
                namedMap = {},
                controls = [],
                o;

            if (type) {
                $clearState(control);
            }
            else {
                o = findControl(getParent(control));
                if (focusedControl && contain(control, focusedControl.getOuter())) {
                    setFocused(o);
                }
                if (activedControl && contain(control, activedControl.getOuter())) {
                    bubble(activedControl, 'deactivate', null, activedControl = o);
                }
                if (hoveredControl && contain(control, hoveredControl.getOuter())) {
                    bubble(hoveredControl, 'mouseout', null, hoveredControl = o);
                }
            }

            for (o in namedControls) {
                namedMap[namedControls[o].getUID()] = o;
            }

            for (; i--; ) {
                o = allControls[i];
                if (type ? control.contain(o) : !!o.getOuter() && contain(control, o.getOuter())) {
                    // 需要删除的控件先放入一个集合中等待遍历结束后再删除，否则控件链将产生变化
                    controls.push(o);
                    remove(independentControls, o);
                    if (o = namedMap[o.getUID()]) {
                        delete namedControls[o];
                    }
                    allControls.splice(i, 1);
                }
            }

            for (; o = controls[++i]; ) {
                o.$dispose();
            }
        };

        /**
         * 将指定的 ECUI 控件 设置为拖拽状态。
         * 只有在鼠标左键按下时，才允许调用 drag 方法设置待拖拽的 {'controls'|menu}，在拖拽操作过程中，将依次触发 ondragstart、ondragmove 与 ondragend 事件。range 参数支持的属性如下：
         * top    {number} 控件允许拖拽到的最小Y轴坐标
         * right  {number} 控件允许拖拽到的最大X轴坐标
         * bottom {number} 控件允许拖拽到的最大Y轴坐标
         * left   {number} 控件允许拖拽到的最小X轴坐标
         * @public
         *
         * @param {ecui.ui.Control} control 需要进行拖拽的 ECUI 控件对象
         * @param {ecui.ui.Event} event 事件对象
         * @param {Object} range 控件允许拖拽的范围，省略参数时，控件默认只允许在 offsetParent 定义的区域内拖拽，如果 
         *                       offsetParent 是 body，则只允许在当前浏览器可视范围内拖拽
         */
        drag = core.drag = function (control, event, range) {
            if (event.type == 'mousedown') {
                //__gzip_original__currStyle
                var parent = control.getOuter().offsetParent,
                    style = getStyle(parent);

                // 拖拽范围默认不超出上级元素区域
                extend(dragEnv, parent.tagName == 'BODY' || parent.tagName == 'HTML' ? getView() : {
                    top: 0,
                    right: parent.offsetWidth - toNumber(style.borderLeftWidth) - toNumber(style.borderRightWidth),
                    bottom: parent.offsetHeight - toNumber(style.borderTopWidth) - toNumber(style.borderBottomWidth),
                    left: 0
                });
                extend(dragEnv, range);
                dragEnv.right = MAX(dragEnv.right - control.getWidth(), dragEnv.left);
                dragEnv.bottom = MAX(dragEnv.bottom - control.getHeight(), dragEnv.top);

                initDragAndZoom(control, event, dragEnv, 'drag');
            }
        };

        /**
         * 获取指定名称的 ECUI 控件。
         * 使用页面静态初始化或页面动态初始化(参见 ECUI 使用方式)创建的控件，如果在 ecui 属性中指定了 id，就可以通过 get 方法得到控件，也可以在 Element 对象上使用 getControl 方法。
         * @public
         *
         * @param {string} id ECUI 控件的名称，通过 Element 对象的初始化选项 id 定义
         * @return {ecui.ui.Control} 指定名称的 ECUI 控件对象，如果不存在返回 null
         */
        core.get = function (id) {
            initEnvironment();
            return namedControls[id] || null;
        };

        /**
         * 获取当前处于激活状态的 ECUI 控件。
         * 激活状态，指鼠标在控件区域左键从按下到弹起的全过程，无论鼠标移动到哪个位置，被激活的控件对象不会发生改变。处于激活状态的控件及其父控件，都具有激活状态样式。
         * @public
         *
         * @return {ecui.ui.Control} 处于激活状态的 ECUI 控件，如果不存在返回 null
         */
        getActived = core.getActived = function () {
            return activedControl || null;
        };

        /**
         * 获取当前的初始化属性名。
         * getAttributeName 方法返回页面静态初始化(参见 ECUI 使用方式)使用的属性名，通过在 BODY 节点的 data-ecui 属性中指定，默认使用 ecui 作为初始化属性名。
         * @public
         *
         * @return {string} 当前的初始化属性名
         */
        getAttributeName = core.getAttributeName = function () {
            return ecuiName;
        };

        /**
         * 获取当前处于焦点状态的控件。
         * 焦点状态，默认优先处理键盘/滚轮等特殊事件。处于焦点状态的控件及其父控件，都具有焦点状态样式。通常鼠标左键的点击将使控件获得焦点状态，之前拥有焦点状态的控件将失去焦点状态。
         * @public
         *
         * @return {ecui.ui.Control} 处于焦点状态的 ECUI 控件，如果不存在返回 null
         */
        getFocused = core.getFocused = function () {
            return focusedControl || null;
        };

        /**
         * 获取当前处于悬停状态的控件。
         * 悬停状态，指鼠标当前位于控件区域。处于悬停状态的控件及其父控件，都具有悬停状态样式。
         * @public
         *
         * @return {ecui.ui.Control} 处于悬停状态的 ECUI 控件，如果不存在返回 null
         */
        getHovered = core.getHovered = function () {
            return hoveredControl;
        };

        /**
         * 获取当前有效的键值码。
         * getKey 方法返回最近一次 keydown 事件的 keyCode/which 值，用于解决浏览器的 keypress 事件中特殊按键(例如方向键等)没有编码值的问题。
         * @public
         *
         * @return {number} 键值码
         */
        getKey = core.getKey = function () {
            return keyCode;
        };

        /**
         * 获取当前鼠标光标的页面X轴坐标或相对于控件内部区域的X轴坐标。
         * getMouseX 方法计算相对于控件内部区域的X轴坐标时，按照浏览器盒子模型的标准，需要减去 Element 对象的 borderLeftWidth 样式的值。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件，如果省略参数，将获取鼠标在页面的X轴坐标，否则获取鼠标相对于控件内部区域的X轴坐标
         * @return {number} X轴坐标值
         */
        getMouseX = core.getMouseX = function (control) {
            if (control) {
                control = control.getBody();
                return mouseX - getPosition(control).left - toNumber(getStyle(control, 'borderLeftWidth'));
            }
            return mouseX;
        };

        /**
         * 获取当前鼠标光标的页面Y轴坐标或相对于控件内部区域的Y轴坐标。
         * getMouseY 方法计算相对于控件内部区域的Y轴坐标时，按照浏览器盒子模型的标准，需要减去 Element 对象的 borderTopWidth 样式的值。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件，如果省略参数，将获取鼠标在页面的Y轴坐标，否则获取鼠标相对于控件内部区域的Y轴坐标
         * @return {number} Y轴坐标值
         */
        getMouseY = core.getMouseY = function (control) {
            if (control) {
                control = control.getBody();
                return mouseY - getPosition(control).top - toNumber(getStyle(control, 'borderTopWidth'));
            }
            return mouseY;
        };

        /**
         * 获取所有被命名的控件。
         * @public
         *
         * @return {Object} 所有被命名的控件集合
         */
        core.getNamedControls = function () {
            return extend({}, namedControls);
        };

        /**
         * 从 Element 对象中获取初始化选项对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} attributeName 当前的初始化属性名(参见 getAttributeName 方法)
         * @return {Object} 初始化选项对象
         */
        getOptions = core.getOptions = function (el, attributeName) {
            attributeName = attributeName || ecuiName;

            var text = getAttribute(el, attributeName),
                options;

            if (text) {
                el.removeAttribute(attributeName);
                if (core.onparseoptions) {
                    if (options = core.onparseoptions(text)) {
                        return options;
                    }
                }

                for (
                    options = {};
                    /^(\s*;)?\s*(ext\-)?([\w\-]+)\s*(:\s*([^;\s]+(\s+[^;\s]+)*)\s*)?($|;)/.test(text);
                ) {
                    text = REGEXP["$'"];

                    el = REGEXP.$5;
                    attributeName = REGEXP.$2 ? (options.ext = options.ext || {}) : options;
                    attributeName[toCamelCase(REGEXP.$3)] =
                        !el || el == 'true' ? true : el == 'false' ? false : ISNAN(+el) ? el : +el;
                }

                return options;
            }
            else {
                return {};
            }
        };

        /**
         * 获取浏览器滚动条的厚度。
         * getScrollNarrow 方法对于垂直滚动条，返回的是滚动条的宽度，对于水平滚动条，返回的是滚动条的高度。
         * @public
         *
         * @return {number} 浏览器滚动条相对窄的一边的长度
         */
        getScrollNarrow = core.getScrollNarrow = function () {
            return scrollNarrow;
        };

        /**
         * 获取框架当前的状态。
         * getStatus 方法返回框架当前的工作状态，目前支持三类工作状态：NORMAL(正常状态)、LOADING(加载状态)与REPAINT(刷新状态)
         * @public
         *
         * @return {boolean} 框架当前的状态
         */
        getStatus = core.getStatus = function () {
            return status;
        };

        /**
         * 控件继承。
         * @public
         *
         * @param {Function} superClass 父控件类
         * @param {string} type 子控件的类型样式
         * @param {Function} preprocess 控件正式生成前对选项信息与主元素结构信息调整的预处理函数
         * @param {Function} subClass 子控件的标准构造函数，如果忽略将直接调用父控件类的构造函数
         * @return {Function} 新控件的构造函数
         */
        inheritsControl = core.inherits = function (superClass, type, preprocess, subClass) {
            var agent = function (options) {
                    return createControl(agent.client, options);
                },
                client = agent.client = function (el, options) {
                    if (agent.preprocess) {
                        el = agent.preprocess.call(this, el, options) || el;
                    }
                    if (superClass) {
                        superClass.client.call(this, el, options);
                    }
                    if (subClass) {
                        subClass.call(this, el, options);
                    }
                };

            agent.preprocess = preprocess;

            if (superClass) {
                inherits(agent, superClass);

                if (type && type.charAt(0) == '*') {
                    (agent.types = superClass.types.slice())[0] = type.slice(1);
                }
                else {
                    agent.types = (type ? [type] : []).concat(superClass.types);
                }
            }
            else {
                // ecui.ui.Control的特殊初始化设置
                agent.types = [];
            }
            agent.TYPES = ' ' + agent.types.join(' ');

            inherits(client, agent);
            client.agent = agent;

            return agent;
        };

        /**
         * 设置框架拦截之后的一次点击，并将点击事件发送给指定的 ECUI 控件。
         * intercept 方法将下一次的鼠标点击事件转给指定控件的 $intercept 方法处理，相当于拦截了一次框架的鼠标事件点击操作，框架其它的状态不会自动改变，例如拥有焦点的控件不会改变。如果 $intercept 方法不阻止冒泡，将自动调用 restore 方法。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         */
        intercept = core.intercept = function (control) {
            interceptEnv.target = control;
            setEnv(interceptEnv);
        };

        /**
         * 判断容器默认是否基于 content-box 属性进行布局。
         * isContentBox 返回的是容器默认的布局方式，针对具体的元素，需要访问 box-sizing 样式来确认它的布局方式。
         * @public
         *
         * @return {boolean} 容器是否使用 content-box 属性布局
         */
        isContentBox = core.isContentBox = function () {
            return flgContentBox;
        };

        /**
         * 使控件失去焦点。
         * loseFocus 方法不完全是 setFocused 方法的逆向行为。如果控件及它的子控件不处于焦点状态，执行 loseFocus 方法不会发生变化。如果控件或它的子控件处于焦点状态，执行 loseFocus 方法将使控件失去焦点状态，如果控件拥有父控件，此时父控件获得焦点状态。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         */
        loseFocus = core.loseFocus = function (control) {
            if (control.contain(focusedControl)) {
                setFocused(control.getParent());
            }
        };

        /**
         * 使用一个层遮罩整个浏览器可视化区域。
         * 遮罩层的 z-index 样式默认取值为 32767，请不要将 Element 对象的 z-index 样式设置大于 32767。当框架中至少一个遮罩层工作时，body 标签将增加一个样式 ecui-mask，IE6/7 的原生 select 标签可以使用此样式进行隐藏，解决强制置顶的问题。
         * @public
         *
         * @param {number} opacity 透明度，如 0.5，如果省略参数将关闭遮罩层
         * @param {number} zIndex 遮罩层的 zIndex 样式值，如果省略使用 32767
         */
        mask = core.mask = function (opacity, zIndex) {
            //__gzip_original__body
            var i = 0,
                body = DOCUMENT.body,
                o = getView(),
                // 宽度向前扩展2屏，向后扩展2屏，是为了解决翻屏滚动的剧烈闪烁问题
                // 不直接设置为整个页面的大小，是为了解决IE下过大的遮罩层不能半透明的问题
                top = MAX(o.top - o.height * 2, 0),
                left = MAX(o.left - o.width * 2, 0),
                text = ';top:' + top + 'px;left:' + left +
                    'px;width:' + MIN(o.width * 5, o.pageWidth - left) +
                    'px;height:' + MIN(o.height * 5, o.pageHeight - top) + 'px;display:';

            if ('boolean' == typeof opacity) {
                text += opacity ? 'block' : 'none'; 
                for (; o = maskElements[i++]; ) {
                    o.style.cssText += text;
                }
            }
            else if (opacity === undefined) {
                removeDom(maskElements.pop());
                if (!maskElements.length) {
                    removeClass(body, 'ecui-mask');
                }
            }
            else {
                if (!maskElements.length) {
                    addClass(body, 'ecui-mask');
                }
                maskElements.push(o = body.appendChild(createDom(
                    '',
                    'position:absolute;background-color:#000;z-index:' + (zIndex || 32767)
                )));
                setStyle(o, 'opacity', opacity);
                o.style.cssText += text + 'block';
            }
        };

        /**
         * 判断是否需要初始化 class 属性。
         * @public
         *
         * @return {boolean} 是否需要初始化 class 属性
         */
        needInitClass = core.needInitClass = function () {
            return !structural;
        };

        /**
         * 查询满足条件的控件列表。
         * query 方法允许按多种条件组合查询满足需要的控件，如果省略条件表示不进行限制。condition参数对象支持的属性如下：
         * type   {Function} 控件的类型构造函数
         * parent {ecui.ui.Control} 控件的父控件对象
         * custom {Function} 自定义查询函数，传入的参数是控件对象，query 方法会将自己的 this 指针传入查询函数中
         * @public
         *
         * @param {Object} condition 查询条件，如果省略将返回全部的控件
         * @return {Array} 控件列表
         */
        query = core.query = function (condition) {
            condition = condition || {};

            //__gzip_original__parent
            for (
                var i = 0,
                    result = [],
                    parent = condition.parent,
                    custom = condition.custom,
                    o;
                o = independentControls[i++];
            ) {
                if ((!condition.type || (o instanceof condition.type)) &&
                        (parent === undefined || (o.getParent() === parent)) &&
                        (!custom || custom.call(this, o))) {
                    result.push(o);
                }
            }

            return result;
        };

        /**
         * 移除控件的事件监听函数。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         * @param {string} name 事件名称
         * @param {Function} caller 监听函数
         */
        core.removeEventListener = function (control, name, caller) {
            if (name = eventListeners[control.getUID() + name]) {
                remove(name, caller);
            }
        };

        /**
         * 恢复当前框架的状态到上一个状态。
         * restore 用于恢复调用特殊操作如 drag、intercept 与 zoom 后改变的框架环境，包括各框架事件处理函数的恢复、控件的焦点设置等。
         * @public
         */
        restore = core.restore = function () {
            if (ieVersion) {
                if (currEnv.type == 'drag' || currEnv.type == 'zoom') {
                    // 取消IE的窗体外事件捕获，如果普通状态也设置，会导致部分区域无法点击
                    DOCUMENT.body.releaseCapture();
                }
            }
            setHandler(currEnv, true);
            setHandler(currEnv = envStack.pop());
        };

        /**
         * 使 ECUI 控件 得到焦点。
         * setFocused 方法将指定的控件设置为焦点状态，允许不指定需要获得焦点的控件，则当前处于焦点状态的控件将失去焦点，需要将处于焦点状态的控件失去焦点还可以调用 loseFocus 方法。如果控件处于失效状态，设置它获得焦点状态将使所有控件失去焦点状态。需要注意的是，如果控件处于焦点状态，当通过 setFocused 方法设置它的子控件获得焦点状态时，虽然处于焦点状态的控件对象发生了变化，但是控件不会触发 onblur 方法，此时控件逻辑上仍然处于焦点状态。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         */
        setFocused = core.setFocused = function (control) {
            if (control && control.isDisabled()) {
                // 处于失效状态的控件不允许获得焦点状态
                control = null;
            }

            var parent = getCommonParent(focusedControl, control);

            bubble(focusedControl, 'blur', null, parent);
            bubble(focusedControl = control, 'focus', null, parent);
        };

        /**
         * 触发事件。
         * triggerEvent 会根据事件返回值或 event 的新状态决定是否触发默认事件处理。
         * @public
         *
         * @param {ecui.ui.Control} control 控件对象
         * @param {string} name 事件名
         * @param {ecui.ui.Event} event 事件对象，可以为 false 表示直接阻止默认事件处理
         * @param {Array} args 事件的其它参数
         * @return {boolean} 是否阻止默认事件处理
         */
        triggerEvent = core.triggerEvent = function (control, name, event, args) {
            if (args && event) {
                args.splice(0, 0, event);
            }
            else if (event) {
                args = [event];
            }
            else {
                event = {returnValue: event, preventDefault: UI_EVENT_CLASS.preventDefault};
                args = args || [];
            }

            if (listeners = eventListeners[control.getUID() + name]) {
                for (var i = 0, listeners, o; o = listeners[i++]; ) {
                    o.apply(control, args);
                }
            }

            if ((control['on' + name] && control['on' + name].apply(control, args) === false) ||
                    event.returnValue === false ||
                    (control['$' + name] && control['$' + name].apply(control, args) === false)) {
                event.preventDefault();
            }

            return event.returnValue !== false;
        };

        /**
         * 包装事件对象。
         * event 方法将浏览器产生的鼠标与键盘事件标准化并添加 ECUI 框架需要的信息到事件对象中。标准化的属性如下：
         * pageX           {number} 鼠标的X轴坐标
         * pageY           {number} 鼠标的Y轴坐标
         * which           {number} 触发事件的按键码
         * target          {HTMLElement} 触发事件的 Element 对象
         * returnValue     {boolean}  是否进行默认处理
         * cancelBubble    {boolean}  是否取消冒泡
         * exit            {Function} 终止全部事件操作
         * getControl      {Function} 获取触发事件的 ECUI 控件 对象
         * getNative       {Function} 获取原生的事件对象
         * preventDefault  {Function} 阻止事件的默认处理
         * stopPropagation {Function} 事件停止冒泡
         * @public
         *
         * @param {Event} event 事件对象
         * @return {ecui.ui.Event} 标准化后的事件对象
         */
        wrapEvent = core.wrapEvent = function (event) {
            if (event instanceof UI_EVENT) {
                // 防止事件对象被多次包装
                return event;
            }

            var body = DOCUMENT.body,
                html = getParent(body);

            if (ieVersion) {
                event = WINDOW.event;
                event.pageX = html.scrollLeft + body.scrollLeft - html.clientLeft + event.clientX - body.clientLeft;
                event.pageY = html.scrollTop + body.scrollTop - html.clientTop + event.clientY - body.clientTop;
                event.target = event.srcElement;
                event.which = event.keyCode;
            }

            if (event.type == 'mousemove') {
                lastClick = null;
            }
            mouseX = event.pageX;
            mouseY = event.pageY;

            return new UI_EVENT(event.type, event);
        };

        /**
         * 将指定的 ECUI 控件 设置为缩放状态。
         * zoom 方法将控件设置为缩放，缩放的值允许负数，用于表示反向的缩放，调用它会触发控件对象的 onzoomstart 事件，在整个 zoom 的周期中，还将触发 onzoom 与 onzoomend 事件，在释放鼠标按键时缩放操作周期结束。range 参数支持的属性如下：
         * minWidth  {number} 控件允许缩放的最小宽度 
         * maxWidth  {number} 控件允许缩放的最大宽度 
         * minHeight {number} 控件允许缩放的最小高度 
         * maxHeight {number} 控件允许缩放的最大高度 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         * @param {ecui.ui.Event} event 事件对象
         * @param {Object} range 控件允许的缩放范围参数
         */
        core.zoom = function (control, event, range) {
            if (event.type == 'mousedown') {
                // 保存现场环境
                if (range) {
                    extend(zoomEnv, range);
                }
                zoomEnv.top = control.getY();
                zoomEnv.left = control.getX();
                zoomEnv.width = control.getWidth();
                zoomEnv.height = control.getHeight();

                initDragAndZoom(control, event, zoomEnv, 'zoom');
            }
        };

        /**
         * 键盘事件处理。
         * @private
         *
         * @param {Event} event 事件对象
         */
        currEnv.keydown = currEnv.keypress = currEnv.keyup = function (event) {
            event = wrapEvent(event);

            //__gzip_original__type
            //__gzip_original__which
            var type = event.type,
                which = event.which;

            if (type == 'keydown') {
                keyCode = which;
            }
            bubble(focusedControl, type, event);
            if (type == 'keyup' && keyCode == which) {
                // 一次多个键被按下，只有最后一个被按下的键松开时取消键值码
                keyCode = 0;
            }
        };

        /**
         * 双击事件与选中内容开始事件处理。
         * @private
         *
         * @param {Event} event 事件对象
         */
        if (ieVersion) {
            // IE下双击事件不依次产生 mousedown 与 mouseup 事件，需要模拟
            currEnv.dblclick = function (event) {
                currEnv.mousedown(event);
                currEnv.mouseup(event);
            };

            // IE下取消对文字的选择不能仅通过 mousedown 事件进行
            currEnv.selectstart = function (event) {
                event = wrapEvent(event);
                onselectstart(findControl(event.target), event);
            };
        }

        /**
         * 滚轮事件处理。
         * @private
         *
         * @param {Event} event 事件对象
         */
        currEnv[firefoxVersion ? 'DOMMouseScroll' : 'mousewheel'] = function (event) {
            event = wrapEvent(event);
            
            event.detail =
                event._oNative.wheelDelta !== undefined ? event._oNative.wheelDelta / -40 : event._oNative.detail;

            // 拖拽状态下，不允许滚动
            if (currEnv.type == 'drag') {
                event.preventDefault();
            }
            else {
                bubble(hoveredControl, 'mousewheel', event);
                if (!event.cancelBubble) {
                    bubble(focusedControl, 'mousewheel', event);
                }
            }
        };

        /**
         * 获取触发事件的 ECUI 控件 对象
         * @public
         *
         * @return {ecui.ui.Control} 控件对象
         */
        UI_EVENT_CLASS.getControl = function () {
            var o = findControl(this.target);
            if (o && !o.isDisabled()) {
                for (; o; o = o.getParent()) {
                    if (o.isCapturable()) {
                        return o;
                    }
                }
            }
            return null;
        };

        /**
         * 获取原生的事件对象。
         * @public
         *
         * @return {Object} 原生的事件对象
         */
        UI_EVENT_CLASS.getNative = function () {
            return this._oNative;
        };

        /**
         * 阻止事件的默认处理。
         * @public
         */
        UI_EVENT_CLASS.preventDefault = function () {
            this.returnValue = false;
            if (this._oNative) {
                if (ieVersion) {
                    this._oNative.returnValue = false;
                }
                else {
                    this._oNative.preventDefault();
                }
            }
        };

        /**
         * 事件停止冒泡。
         * @public
         */
        UI_EVENT_CLASS.stopPropagation = function () {
            this.cancelBubble = true;
            if (this._oNative) {
                if (ieVersion) {
                    this._oNative.cancelBubble = false;
                }
                else {
                    this._oNative.stopPropagation();
                }
            }
        };

        /**
         * 终止全部事件操作。
         * @public
         */
        UI_EVENT_CLASS.exit = function () {
            this.preventDefault();
            this.stopPropagation();
        };

        /**
         * 冒泡处理控件事件。
         * @private
         *
         * @param {ecui.ui.Control} start 开始冒泡的控件
         * @param {string} type 事件类型
         * @param {ecui.ui.Event} 事件对象
         * @param {ecui.ui.Control} end 终止冒泡的控件，如果不设置将一直冒泡至顶层
         */
        function bubble(start, type, event, end) {
            event = event || new UI_EVENT(type);
            event.cancelBubble = false;
            for (; start != end; start = start.getParent()) {
                event.returnValue = undefined;
                triggerEvent(start, type, event);
                if (event.cancelBubble) {
                    return;
                }
            }
        }

        /**
         * 获取两个控件的公共父控件。
         * @private
         *
         * @param {ecui.ui.Control} control1 控件1
         * @param {ecui.ui.Control} control2 控件2
         * @return {ecui.ui.Control} 公共的父控件，如果没有，返回 null
         */
        function getCommonParent(control1, control2) {
            if (control1 != control2) {
                var i = 0,
                    list1 = [],
                    list2 = [];

                for (; control1; control1 = control1.getParent()) {
                    list1.push(control1);
                }
                for (; control2; control2 = control2.getParent()) {
                    list2.push(control2);
                }

                list1.reverse();
                list2.reverse();

                // 过滤父控件序列中重复的部分
                for (; list1[i] == list2[i]; i++) {}
                control1 = list1[i - 1];
            }

            return control1 || null;
        }

        /**
         * 获取当前 Element 对象绑定的 ECUI 控件。
         * 与控件关联的 Element 对象(例如通过 init 方法初始化，或者使用 $bind 方法绑定，或者使用 create、$fastCreate 方法生成控件)，会被添加一个 getControl 方法用于获取它绑定的 ECUI 控件，更多获取控件的方法参见 get。
         * @private
         *
         * @return {ecui.ui.Control} 与 Element 对象绑定的 ECUI 控件
         */
        function getControlByElement() {
            return this._cControl;
        }

        /**
         * 初始化拖拽与缩放操作的环境。
         * @private
         *
         * @param {ecui.ui.Control} control 需要操作的控件
         * @param {ecui.ui.Event} event 事件对象
         * @param {Object} env 操作环境对象
         * @return {string} type 操作的类型，只能是drag或者zoom
         */
        function initDragAndZoom(control, event, env, type) {
            var currStyle = control.getOuter().style,
                // 缓存，防止多次reflow
                x = control.getX(),
                y = control.getY();

            currStyle.left = x + 'px';
            currStyle.top = y + 'px';
            currStyle.position = 'absolute';

            env.target = control;
            env.actived = activedControl;
            setEnv(env);

            // 清除激活的控件，在drag中不需要针对激活控件移入移出的处理
            activedControl = null;

            triggerEvent(control, type + 'start', event);

            if (ieVersion) {
                // 设置IE的窗体外事件捕获，如果普通状态也设置，会导致部分区域无法点击
                DOCUMENT.body.setCapture();
            }
        }

        /**
         * 初始化ECUI工作环境。
         * @private
         *
         * @return {boolean} 是否执行了初始化操作
         */
        function initEnvironment() {
            if (!namedControls) {
                status = LOADING;

                // 自动加载插件
                for (o in ext) {
                    plugins[o] = ext[o];
                }

                // 设置全局事件处理
                for (o in currEnv) {
                    attachEvent(DOCUMENT, o, currEnv[o]);
                }

                namedControls = {};

                var o = getOptions(DOCUMENT.body, 'data-ecui');

                ecuiName = o.name || ecuiName;
                isGlobalId = o.globalId;
                structural = indexOf(['class', 'all'], o.structural) + 1;

                insertHTML(
                    DOCUMENT.body,
                    'BEFOREEND',
                    '<div style="position:absolute;overflow:scroll;top:-90px;left:-90px;width:80px;height:80px;' +
                        'border:1px solid"><div style="position:absolute;top:0px;height:90px"></div></div>'
                );
                // 检测Element宽度与高度的计算方式
                o = DOCUMENT.body.lastChild;
                flgContentBox = o.offsetWidth > 80;
                flgFixedOffset = o.lastChild.offsetTop;
                scrollNarrow = o.offsetWidth - o.clientWidth - 2;
                removeDom(o);

                attachEvent(WINDOW, 'resize', repaint);
                attachEvent(WINDOW, 'unload', function () {
                    for (var i = 0; o = allControls[i++]; ) {
                        o.$dispose();
                    }

                    // 清除闭包中引用的 Element 对象
                    DOCUMENT = maskElements = null;
                });
                attachEvent(WINDOW, 'scroll', onscroll);

                init(DOCUMENT.body);
                addClass(DOCUMENT.body, 'ecui-loaded');

                status = NORMAL;
                return true;
            }
        }

        /**
         * 判断是否为允许的双击时间间隔。
         * @private
         *
         * @return {boolean} 是否为允许的双击时间间隔
         */
        function isDblClick() {
            return lastClick.time > new DATE().getTime() - 200;
        }

        /**
         * 判断点击是否发生在滚动条区域。
         * @private
         *
         * @param {ecui.ui.Event} event 事件对象
         * @return {boolean} 点击是否发生在滚动条区域
         */
        function isScrollClick(event) {
            var target = event.target,
                pos = getPosition(target),
                style = getStyle(target);
            return event.pageX - pos.left - toNumber(style.borderLeftWidth) >= target.clientWidth !=
                event.pageY - pos.top - toNumber(style.borderTopWidth) >= target.clientHeight;
        }

        /**
         * 处理鼠标点击。
         * @private
         *
         * @param {ecui.ui.Control} control 需要操作的控件
         * @param {ecui.ui.Event} event 事件对象
         */
        function mousedown(control, event) {
            bubble(activedControl = control, 'activate', event);
            bubble(control, 'mousedown', event);
            onselectstart(control, event);
        }

        /**
         * 控件对象创建后的处理。
         * @private
         *
         * @param {ecui.ui.Control} control 
         * @param {Object} options 控件初始化选项
         */
        function oncreate(control, options) {
            if (control.oncreate) {
                control.oncreate(options);
            }
            allControls.push(control);

            if (options.id) {
                namedControls[options.id] = control;
                if (isGlobalId) {
                    WINDOW[options.id] = control;
                }
            }

            if (options.ext) {
                for (var o in options.ext) {
                    if (plugins[o]) {
                        plugins[o](control, options.ext[o], options);
                        if (o = control['$init' + o.charAt(0).toUpperCase() + toCamelCase(o.slice(1))]) {
                            o.call(control, options);
                        }
                    }
                }
            }
        }

        /**
         * 窗体滚动时的事件处理。
         * @private
         */
        function onscroll(event) {
            event = wrapEvent(event);
            for (var i = 0, o; o = independentControls[i++]; ) {
                triggerEvent(o, 'pagescroll', event);
            }
            mask(true);
        }

        /**
         * 文本选择开始处理。
         * @private
         *
         * @param {ecui.ui.Control} control 需要操作的控件
         * @param {ecui.ui.Event} event 事件对象
         */
        function onselectstart(control, event) {
            for (; control; control = control.getParent()) {
                if (!control.isUserSelect()) {
                    event.preventDefault();
                    return;
                }
            }
        }

        /**
         * 设置 ecui 环境。
         * @private
         *
         * @param {Object} env 环境描述对象
         */
        function setEnv(env) {
            var o = {};
            setHandler(currEnv, true);

            extend(o, currEnv);
            extend(o, env);
            o.x = mouseX;
            o.y = mouseY;
            setHandler(o);

            envStack.push(currEnv);
            currEnv = o;
        }

        /**
         * 设置document节点上的鼠标事件。
         * @private
         *
         * @param {Object} env 环境描述对象，保存当前的鼠标光标位置与document上的鼠标事件等
         * @param {boolean} remove 如果为true表示需要移除data上的鼠标事件，否则是添加鼠标事件
         */
        function setHandler(env, remove) {
            for (var i = 0, func = remove ? detachEvent : attachEvent, o; i < 5; ) {
                if (env[o = eventNames[i++]]) {
                    func(DOCUMENT, o, env[o]);
                }
            }
        }

        ready(init);
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Control - ECUI 的核心组成部分，定义所有控件的基本操作。
基础控件是 ECUI 的核心组成部分，对 DOM 树上的节点区域进行封装。基础控件扩展了 Element 节点的标准事件(例如得到与失去焦点、激活等)，提供了方法对控件的基本属性(例如控件大小、位置与显示状态等)进行改变，是一切控件实现的基础。基本控件拥有四种状态：焦点(focus)、悬停(hover)、激活(active)与失效(disabled)。控件在创建过程中分为三个阶段：首先是填充控件所必须的 DOM 结构，然后缓存控件的属性信息，最后进行初始化真正的渲染并显示控件。

基础控件直接HTML初始化的例子，id指定名称，可以通过ecui.get(id)的方式访问控件:
<div ecui="type:control;id:demo">
  <!-- 这里放控件包含的内容 -->
  ...
</div>

属性
_bCapturable        - 控件是否响应浏览器事件状态
_bUserSelect        - 控件是否允许选中内容
_bFocusable         - 控件是否允许获取焦点
_bDisabled          - 控件的状态，为true时控件不处理任何事件
_bCached            - 控件是否已经读入缓存
_bCreated           - 控件是否已经完全生成
_sUID               - 控件的内部ID
_sPrimary           - 控件定义时的基本样式
_sClass             - 控件的当前样式
_sWidth             - 控件的基本宽度值，可能是百分比或者空字符串
_sHeight            - 控件的基本高度值，可能是百分比或者空字符串
_sDisplay           - 控件的布局方式，在hide时保存，在show时恢复
_eMain              - 控件的基本标签对象
_eBody              - 控件用于承载子控件的载体标签，通过$setBody函数设置这个值，绑定当前控件
_cParent            - 父控件对象
_aStatus            - 控件当前的状态集合
$$width             - 控件的宽度缓存
$$height            - 控件的高度缓存
$$bodyWidthRevise   - 内容区域的宽度修正缓存
$$bodyHeightRevise  - 内容区域的高度修正缓存
$$borderTopWidth    - 上部边框线宽度缓存
$$borderLeftWidth   - 左部边框线宽度缓存
$$borderRightWidth  - 右部边框线宽度缓存
$$borderBottomWidth - 下部边框线宽度缓存
$$paddingTop        - 上部内填充宽度缓存
$$paddingLeft       - 左部内填充宽度缓存
$$paddingRight      - 右部内填充宽度缓存
$$paddingBottom     - 下部内填充宽度缓存
$$position          - 控件布局方式缓存
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        REGEXP = RegExp,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        remove = array.remove,
        addClass = dom.addClass,
        getParent = dom.getParent,
        getStyle = dom.getStyle,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        blank = util.blank,
        timer = util.timer,
        toNumber = util.toNumber,

        REPAINT = core.REPAINT,

        $bind = core.$bind,
        $clearState = core.$clearState,
        calcLeftRevise = core.calcLeftRevise,
        calcTopRevise = core.calcTopRevise,
        disposeControl = core.dispose,
        findControl = core.findControl,
        getActived = core.getActived,
        getFocused = core.getFocused,
        getHovered = core.getHovered,
        getStatus = core.getStatus,
        inheritsControl = core.inherits,
        isContentBox = core.isContentBox,
        loseFocus = core.loseFocus,
        query = core.query,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ];
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_CONTROL
    ///__gzip_original__UI_CONTROL_CLASS
    /**
     * 初始化基础控件。
     * options 对象支持的属性如下：
     * type       控件的类型样式
     * primary    控件的基本样式
     * current    控件的当前样式
     * capturable 是否需要捕获鼠标事件，默认捕获
     * userSelect 是否允许选中内容，默认允许
     * focusable  是否允许获取焦点，默认允许
     * resizable  是否允许改变大小，默认允许
     * disabled   是否失效，默认有效
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_CONTROL = ui.Control =
        inheritsControl(
            null,
            null,
            null,
            function (el, options) {
                $bind(el, this);

                this._bDisabled = !!options.disabled;
                this._sUID = options.uid;
                this._sPrimary = options.primary || '';
                this._sClass = options.current || this._sPrimary;
                this._eMain = this._eBody = el;
                this._cParent = null;

                this._bCapturable = options.capturable !== false;
                this._bUserSelect = options.userSelect !== false;
                this._bFocusable = options.focusable !== false;
                if (options.resizable !== false) {
                    this._bResizable = true;
                    el = el.style;
                    this._sWidth = el.width;
                    this._sHeight = el.height;
                }
                else {
                    this._bResizable = false;
                }

                this._aStatus = ['', ' '];
            }
        ),
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_CONTROL_READY_LIST,
        UI_CONTROL_QUERY_SHOW = {custom: function (control) {
            return this != control && this.contain(control) && control.isShow();
        }};
//{else}//
    /**
     * 设置控件的父对象。
     * @private
     *
     * @param {ecui.ui.Control} control 需要设置的控件对象
     * @param {HTMLElement} parent 父控件对象
     * @param {HTMLElement} parentElement 父 Element 对象
     */
    function UI_CONTROL_ALTER_PARENT(control, parent, parentElement) {
        var oldParent = control._cParent,
            el = control.getOuter(),
            flag = control._bCreated && control.isShow();

        // 触发原来父控件的移除子控件事件
        if (parent != oldParent) {
            if (oldParent) {
                if (!triggerEvent(oldParent, 'remove', null, [control])) {
                    return;
                }
            }
            if (parent) {
                if (!triggerEvent(parent, 'append', null, [control])) {
                    parent = parentElement = null;
                }
            }
        }

        if (parentElement != getParent(el)) {
            if (parentElement) {
                parentElement.appendChild(el);
            }
            else {
                removeDom(el);
            }
            // 当 DOM 树位置发生改变时，$setParent必须被执行
            control.$setParent(parent);
        }

        if (flag != (control._bCreated && control.isShow())) {
            triggerEvent(control, flag ? 'hide' : 'show', false);
        }
    }

    /**
     * 控件获得激活事件的默认处理。
     * 控件获得激活时，添加状态样式 -active。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$activate = function () {
        this.alterClass('+active');
    };

    /**
     * 控件失去焦点事件的默认处理。
     * 控件失去焦点时，移除状态样式 -focus。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$blur = function () {
        this.alterClass('-focus');
    };

    /**
     * 缓存控件的属性。
     * $cache 方法缓存部分控件属性的值，在初始化时避免频繁的读写交替操作，加快渲染的速度，在子控件或者应用程序开发过程中，如果需要避开控件提供的方法直接操作 Element 对象，操作完成后必须调用 clearCache 方法清除控件的属性缓存，否则将引发错误。
     * @protected
     *
     * @param {CssStyle} style 主元素的 Css 样式对象
     * @param {boolean} cacheSize 是否需要缓存控件的大小，如果控件是另一个控件的部件时，不缓存大小能加快渲染速度，默认缓存
     */
    UI_CONTROL_CLASS.$cache = function (style, cacheSize) {
        if (ieVersion < 8) {
            o = style.borderWidth;
            if (o.indexOf(' ') > 0) {
                o = o.split(' ');
                this.$$borderTopWidth = toNumber(o[0]);
                this.$$borderRightWidth = toNumber(o[1]);
                this.$$borderBottomWidth = o[2] ? toNumber(o[2]) : this.$$borderTopWidth;
                this.$$borderLeftWidth = o[3] ? toNumber(o[3]) : this.$$borderRightWidth = toNumber(o[1]);
            }
            else {
                this.$$borderTopWidth = this.$$borderLeftWidth = this.$$borderRightWidth = this.$$borderBottomWidth =
                    toNumber(o);
            }
            o = style.padding;
            if (o.indexOf(' ') > 0) {
                o = o.split(' ');
                this.$$paddingTop = toNumber(o[0]);
                this.$$paddingRight = toNumber(o[1]);
                this.$$paddingBottom = o[2] ? toNumber(o[2]) : this.$$paddingTop;
                this.$$paddingLeft = o[3] ? toNumber(o[3]) : this.$$paddingRight;
            }
            else {
                this.$$paddingTop = this.$$paddingLeft = this.$$paddingRight = this.$$paddingBottom = toNumber(o);
            }
        }
        else {
            for (
                var i = 0,
                    list = [
                        'borderTopWidth', 'borderLeftWidth', 'borderRightWidth', 'borderBottomWidth',
                        'paddingTop', 'paddingLeft', 'paddingRight', 'paddingBottom'
                    ],
                    o;
                o = list[i++];
            ) {
                this['$$' + o] = toNumber(style[o]);
            }
        }

        this.$$position = style.position;

        if (cacheSize !== false) {
            o = isContentBox();
            this.$$width = this._eMain.offsetWidth || toNumber(style.width) + (o ? this.$getBasicWidth() : 0);
            this.$$height = this._eMain.offsetHeight || toNumber(style.height) + (o ? this.$getBasicHeight() : 0);
        }
    };

    /**
     * 控件失去激活事件的默认处理。
     * 控件失去激活时，移除状态样式 -active。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$deactivate = function () {
        this.alterClass('-active');
    };

    /**
     * 销毁控件的默认处理。
     * 页面卸载时将销毁所有的控件，释放循环引用，防止在 IE 下发生内存泄漏，$dispose 方法的调用不会受到 ondispose 事件返回值的影响。
     * @protected
     */
    UI_CONTROL_CLASS.$dispose = function () {
        try {
            triggerEvent(this, 'dispose', false);
        }
        catch (e) {
        }
        this._eMain.getControl = undefined;
        this._eMain = this._eBody = null;
        // 取消 $ready 的操作，防止控件在 onload 结束前被 dispose，从而引发 $ready 访问的信息错误的问题
        this.$ready = blank;
    };

    /**
     * 控件获得焦点事件的默认处理。
     * 控件获得焦点时，添加状态样式 -focus。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$focus = function () {
        this.alterClass('+focus');
    };

    /**
     * 获取控件的基本高度。
     * 控件的基本高度指控件基本区域与用户数据存放区域的高度差值，即主元素与内部元素(如果相同则忽略其中之一)的上下边框宽度(border-width)与上下内填充宽度(padding)之和。
     * @public
     *
     * @return {number} 控件的基本高度
     */
    UI_CONTROL_CLASS.$getBasicHeight = function () {
        return this.$$borderTopWidth + this.$$borderBottomWidth + this.$$paddingTop + this.$$paddingBottom;
    };

    /**
     * 获取控件的基本宽度。
     * 控件的基本宽度指控件基本区域与用户数据存放区域的宽度差值，即主元素与内部元素(如果相同则忽略其中之一)的左右边框宽度(border-width)与左右内填充宽度(padding)之和。
     * @public
     *
     * @return {number} 控件的基本宽度
     */
    UI_CONTROL_CLASS.$getBasicWidth = function () {
        return this.$$borderLeftWidth + this.$$borderRightWidth + this.$$paddingLeft + this.$$paddingRight;
    };

    /**
     * 获取指定的部件。
     * $getSection 方法返回控件的一个部件对象，部件对象也是 ECUI 控件，是当前控件的组成成份，不可缺少，请不要轻易的对部件对象进行操作。
     * @protected
     *
     * @param {string} name 部件名称
     * @return {ecui.ui.Control} 部件对象
     */
    UI_CONTROL_CLASS.$getSection = function (name) {
        return this['_u' + name];
    };

    /**
     * 隐藏控件。
     * $hide 方法直接隐藏控件，控件失去激活、悬停与焦点状态，不检查控件之前的状态，因此不会导致浏览器的刷新操作。
     * @protected
     */
    UI_CONTROL_CLASS.$hide = function () {
        if (this._sDisplay === undefined) {
            if (this._bCreated) {
                for (var i = 0, list = query.call(this, UI_CONTROL_QUERY_SHOW), o; o = list[i++]; ) {
                    triggerEvent(o, 'hide', false);
                }
            }

            o = this.getOuter().style;

            // 保存控件原来的 display 值，在显示时恢复
            this._sDisplay = o.display;
            o.display = 'none';
            // 控件隐藏时需要清除状态
            $clearState(this);
        }
    };

    /**
     * 设置控件容器支持坐标定位。
     * $locate 方法执行后，容器内部 Element 对象的 offsetParent 将指向主元素(参见 getMain 方法)。
     * @protected
     */
    UI_CONTROL_CLASS.$locate = function () {
        if (this.$$position == 'static') {
            this._eMain.style.position = this.$$position = 'relative';
        }
    };

    /**
     * 鼠标移出事件的默认处理。
     * 鼠标移出控件区域时，控件失去悬停状态，移除状态样式 -hover。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$mouseout = function () {
        this.alterClass('-hover');
    };

    /**
     * 鼠标移入事件的默认处理。
     * 鼠标移入控件区域时，控件获得悬停状态，添加状态样式 -hover。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$mouseover = function () {
        this.alterClass('+hover');
    };

    /**
     * 控件大小变化事件的默认处理。
     * @protected
     */
    UI_CONTROL_CLASS.$resize = function () {
        //__gzip_original__el
        //__gzip_original__currStyle
        var el = this._eMain,
            currStyle = el.style;

        currStyle.width = this._sWidth;
        if (ieVersion < 8 && getStatus() != REPAINT) {
            // 修复ie6/7下宽度自适应错误的问题
            var style = getStyle(el);
            if (style.width == 'auto' && style.display == 'block') {
                currStyle.width = '100%';
                currStyle.width = el.offsetWidth - (isContentBox() ? this.$getBasicWidth() * 2 : 0) + 'px';
            }
        }
        currStyle.height = this._sHeight;
    };

    /**
     * 设置控件的内层元素。
     * ECUI 控件 逻辑上分为外层元素、主元素与内层元素，外层元素用于控制控件自身布局，主元素是控件生成时捆绑的 Element 对象，而内层元素用于控制控件对象的子控件与文本布局，三者允许是同一个 Element 对象。
     * @protected
     *
     * @param {HTMLElement} el Element 对象
     */
    UI_CONTROL_CLASS.$setBody = function (el) {
        this._eBody = el;
    };

    /**
     * 直接设置父控件。
     * 相对于 setParent 方法，$setParent 方法仅设置控件对象逻辑上的父对象，不进行任何逻辑上的检查，用于某些特殊情况下的设定，如下拉框控件中的选项框子控件需要使用 $setParent 方法设置它的逻辑父控件为下拉框控件。
     * @protected
     *
     * @param {ecui.ui.Control} parent ECUI 控件对象
     */
    UI_CONTROL_CLASS.$setParent = function (parent) {
        this._cParent = parent;
    };

    /**
     * 设置控件的大小。
     * @protected
     *
     * @param {number} width 宽度，如果不需要设置则将参数设置为等价于逻辑非的值
     * @param {number} height 高度，如果不需要设置则省略此参数
     */
    UI_CONTROL_CLASS.$setSize = function (width, height) {
        //__gzip_original__style
        var style = this._eMain.style,
            o = this._eMain.tagName,
            fixedSize = isContentBox() && o != 'BUTTON' && o != 'INPUT';

        // 防止负宽度IE下出错
        if (width && (o = width - (fixedSize ? this.$getBasicWidth() : 0)) > 0) {
            style.width = o + 'px';
            this.$$width = width;
        }

        // 防止负高度IE下出错
        if (height && (o = height - (fixedSize ? this.$getBasicHeight() : 0)) > 0) {
            style.height = o + 'px';
            this.$$height = height;
        }
    };

    /**
     * 显示控件。
     * $show 方法直接显示控件，不检查控件之前的状态，因此不会导致浏览器的刷新操作。
     * @protected
     */
    UI_CONTROL_CLASS.$show = function () {
        this.getOuter().style.display = this._sDisplay || '';
        this._sDisplay = undefined;

        if (this._bCreated) {
            for (var i = 0, list = query.call(this, UI_CONTROL_QUERY_SHOW), o; o = list[i++]; ) {
                triggerEvent(o, 'show', false);
            }
        }
    };

    /**
     * 为控件添加/移除一个扩展样式。
     * 扩展样式分别附加在类型样式与当前样式之后(参见 getTypes 与 getClass 方法)，使用-号进行分隔。如果类型样式为 ui-control，当前样式为 demo，扩展样式 hover 后，控件主元素将存在四个样式，分别为 ui-control、demo、ui-control-hover 与 demo-hover。
     * @public
     *
     * @param {string} className 扩展样式名，以+号开头表示添加扩展样式，以-号开头表示移除扩展样式
     */
    UI_CONTROL_CLASS.alterClass = function (className) {
        var flag = className.charAt(0) == '+';

        if (flag) {
            className = '-' + className.slice(1) + ' ';
        }
        else {
            className += ' ';
        }

        (flag ? addClass : removeClass)(this._eMain, this.getTypes().concat([this._sClass, '']).join(className));

        if (flag) {
            this._aStatus.push(className);
        }
        else {
            remove(this._aStatus, className);
        }
    };

    /**
     * 将控件添加到页面元素中。
     * appendTo 方法设置父元素，并使用 findControl 查找父控件对象。如果父控件发生变化，原有的父控件若存在，将触发移除子控件事件(onremove)，并解除控件与原有父控件的关联，新的父控件若存在，将触发添加子控件事件(onappend)，如果此事件返回 false，添加失败，相当于忽略 parentElement 参数。
     * @public
     *
     * @param {HTMLElement} parentElement 父 Element 对象，忽略参数控件将移出 DOM 树
     */
    UI_CONTROL_CLASS.appendTo = function (parentElement) {
        UI_CONTROL_ALTER_PARENT(this, parentElement && findControl(parentElement), parentElement);
    };

    /**
     * 控件失去焦点状态。
     * blur 方法将使控件失去焦点状态，参见 loseFocus 方法。
     * @public
     */
    UI_CONTROL_CLASS.blur = function () {
        loseFocus(this);
    };

    /**
     * 缓存控件的属性。
     * cache 方法验证控件是否已经缓存，如果未缓存将调用 $cache 方法缓存控件属性的值。在子控件或者应用程序开发过程中，如果需要避开控件提供的方法直接操作 Element 对象，操作完成后必须调用 clearCache 方法清除控件的属性缓存，否则将引发错误。
     * @public
     *
     * @param {boolean} cacheSize 是否需要缓存控件的大小，如果控件是另一个控件的部件时，不缓存大小能加快渲染速度，默认缓存
     * @param {boolean} force 是否需要强制刷新缓存，相当于之前执行了 clearCache 方法，默认不强制刷新
     */
    UI_CONTROL_CLASS.cache = function (cacheSize, force) {
        if (force || !this._bCached) {
            this._bCached = true;
            this.$cache(getStyle(this._eMain), cacheSize);
        }
    };

    /**
     * 清除控件的缓存。
     * 在子控件或者应用程序开发过程中，如果需要避开控件提供的方法直接操作 Element 对象，操作完成后必须调用 clearCache 方法清除控件的属性缓存，否则将引发错误。
     * @public
     */
    UI_CONTROL_CLASS.clearCache = function () {
        this._bCached = false;
    };

    /**
     * 判断是否包含指定的控件。
     * contain 方法判断指定的控件是否逻辑上属于当前控件的内部区域，即当前控件是指定的控件的某一级父控件。
     * @public
     *
     * @param {ecui.ui.Control} control ECUI 控件
     * @return {boolean} 是否包含指定的控件
     */
    UI_CONTROL_CLASS.contain = function (control) {
        for (; control; control = control._cParent) {
            if (control == this) {
                return true;
            }
        }
        return false;
    };

    /**
     * 控件获得失效状态。
     * 控件获得失效状态时，添加状态样式 -disabled(参见 alterClass 方法)。disable 方法导致控件失去激活、悬停、焦点状态，所有子控件的 isDisabled 方法返回 true，但不会设置子控件的失效状态样式。
     * @public
     *
     * @return {boolean} 控件失效状态是否改变
     */
    UI_CONTROL_CLASS.disable = function () {
        if (!this._bDisabled) {
            this.alterClass('+disabled');
            this._bDisabled = true;
            $clearState(this);
            return true;
        }
        return false;
    };

    /**
     * 销毁控件。
     * dispose 方法销毁控件及其所有的子控件，相当于调用 ecui.dispose(this) 方法。
     * @public
     */
    UI_CONTROL_CLASS.dispose = function () {
        disposeControl(this);
    };

    /**
     * 控件解除失效状态。
     * 控件解除失效状态时，移除状态样式 -disabled(参见 alterClass 方法)。enable 方法仅解除控件自身的失效状态，如果其父控件失效，isDisabled 方法返回 true。
     * @public
     *
     * @return {boolean} 控件失效状态是否改变
     */
    UI_CONTROL_CLASS.enable = function () {
        if (this._bDisabled) {
            this.alterClass('-disabled');
            this._bDisabled = false;
            return true;
        }
        return false;
    };

    /**
     * 控件获得焦点状态。
     * 如果控件没有处于焦点状态，focus 方法将设置控件获取焦点状态，参见 isFocused 与 setFocused 方法。
     * @public
     */
    UI_CONTROL_CLASS.focus = function () {
        if (!this.isFocused()) {
            setFocused(this);
        }
    };

    /**
     * 获取控件的内层元素。
     * getBody 方法返回用于控制子控件与文本布局的内层元素。
     * @public
     *
     * @return {HTMLElement} Element 对象
     */
    UI_CONTROL_CLASS.getBody = function () {
        return this._eBody;
    };

    /**
     * 获取控件内层可使用区域的高度。
     * getBodyHeight 方法返回能被子控件与文本填充的控件区域高度，相当于盒子模型的 content 区域的高度。
     * @public
     *
     * @return {number} 控件内层可使用区域的宽度
     */
    UI_CONTROL_CLASS.getBodyHeight = function () {
        return this.getHeight() - this.getMinimumHeight();
    };

    /**
     * 获取控件内层可使用区域的宽度。
     * getBodyWidth 方法返回能被子控件与文本填充的控件区域宽度，相当于盒子模型的 content 区域的宽度。
     * @public
     *
     * @return {number} 控件内层可使用区域的宽度
     */
    UI_CONTROL_CLASS.getBodyWidth = function () {
        return this.getWidth() - this.getMinimumWidth();
    };

    /**
     * 获取控件的当前样式。
     * getClass 方法返回控件当前使用的样式，扩展样式分别附加在类型样式与当前样式之后，从而实现控件的状态样式改变，详细的描述请参见 alterClass 方法。当前样式与 getPrimary 方法返回的基本样式存在区别，在控件生成初期，当前样式等于基本样式，基本样式在初始化后无法改变，setClass 方法改变当前样式。
     * @public
     *
     * @return {string} 控件的当前样式
     */
    UI_CONTROL_CLASS.getClass = function () {
        return this._sClass;
    };

    /**
     * 获取控件的内容。
     * @public
     *
     * @return {string} HTML 片断
     */
    UI_CONTROL_CLASS.getContent = function () {
        return this._eBody.innerHTML;
    };

    /**
     * 获取控件区域的高度。
     * @public
     *
     * @return {number} 控件的高度
     */
    UI_CONTROL_CLASS.getHeight = function () {
        this.cache();
        return this.$$height;
    };

    /**
     * 获取控件的主元素。
     * getMain 方法返回控件生成时定义的 Element 对象(参见 create 方法)。
     * @public
     *
     * @return {HTMLElement} Element 对象
     */
    UI_CONTROL_CLASS.getMain = function () {
        return this._eMain;
    };

    /**
     * 获取控件的最小高度。
     * setSize 方法不允许设置小于 getMinimumHeight 方法返回的高度值。
     * @public
     *
     * @return {number} 控件的最小高度
     */
    UI_CONTROL_CLASS.getMinimumHeight = function () {
        this.cache();
        return this.$getBasicHeight() + (this.$$bodyHeightRevise || 0);
    };

    /**
     * 获取控件的最小宽度。
     * @public
     *
     * @return {number} 控件的最小宽度
     */
    UI_CONTROL_CLASS.getMinimumWidth = function () {
        this.cache();
        return this.$getBasicWidth() + (this.$$bodyWidthRevise || 0);
    };

    /**
     * 获取控件的外层元素。
     * getOuter 方法返回用于控制控件自身布局的外层元素。
     * @public
     *
     * @return {HTMLElement} Element 对象
     */
    UI_CONTROL_CLASS.getOuter = function () {
        return this._eMain;
    };

    /**
     * 获取父控件。
     * 控件接收的事件将向父控件冒泡处理，getParent 返回的结果是 ECUI 的逻辑父控件，父控件与子控件不一定存在 DOM 树层面的父子级关系。
     * @public
     *
     * @return {ecui.ui.Control} 父控件对象
     */
    UI_CONTROL_CLASS.getParent = function () {
        return this._cParent || null;
    };

    /**
     * 获取控件的基本样式。
     * getPrimary 方法返回控件生成时指定的 primary 参数(参见 create 方法)。基本样式与通过 getClass 方法返回的当前样式存在区别，在控件生成初期，当前样式等于基本样式，基本样式在初始化后无法改变，setClass 方法改变当前样式。
     * @public
     *
     * @return {string} 控件的基本样式
     */
    UI_CONTROL_CLASS.getPrimary = function () {
        return this._sPrimary;
    };

    /**
     * 获取控件的类型。
     * @public
     *
     * @return {string} 控件的类型
     */
    UI_CONTROL_CLASS.getType = function () {
        return this.constructor.agent.types[0];
    };

    /**
     * 获取控件的类型样式组。
     * getTypes 方法返回控件的类型样式组，类型样式在控件继承时指定。
     * @public
     *
     * @return {Array} 控件的类型样式组
     */
    UI_CONTROL_CLASS.getTypes = function () {
        return this.constructor.agent.types.slice();
    };

    /**
     * 获取控件的内部唯一标识符。
     * getUID 方法返回的 ID 不是初始化选项中指定的 id，而是框架为每个控件生成的内部唯一标识符。
     * @public
     *
     * @return {string} 控件 ID
     */
    UI_CONTROL_CLASS.getUID = function () {
        return this._sUID;
    };

    /**
     * 获取控件区域的宽度。
     * @public
     *
     * @return {number} 控件的宽度
     */
    UI_CONTROL_CLASS.getWidth = function () {
        this.cache();
        return this.$$width;
    };

    /**
     * 获取控件的相对X轴坐标。
     * getX 方法返回控件的外层元素的 offsetLeft 属性值。如果需要得到控件相对于整个文档的X轴坐标，请调用 getOuter 方法获得外层元素，然后调用 DOM 的相关函数计算(例如 ecui.dom.getPosition)。
     * @public
     *
     * @return {number} X轴坐标
     */
    UI_CONTROL_CLASS.getX = function () {
        var el = this.getOuter();

        return this.isShow() ? el.offsetLeft - calcLeftRevise(el) : 0;
    };

    /**
     * 获取控件的相对Y轴坐标。
     * getY 方法返回控件的外层元素的 offsetTop 属性值。如果需要得到控件相对于整个文档的Y轴坐标，请调用 getOuter 方法获得外层元素，然后调用 DOM 的相关函数计算(例如 ecui.dom.getPosition)。
     * @public
     *
     * @return {number} Y轴坐标
     */
    UI_CONTROL_CLASS.getY = function () {
        var el = this.getOuter();

        return this.isShow() ? el.offsetTop - calcTopRevise(el) : 0;
    };

    /**
     * 隐藏控件。
     * 如果控件处于显示状态，调用 hide 方法会触发 onhide 事件，控件转为隐藏状态，并且控件会自动失去激活、悬停与焦点状态。如果控件已经处于隐藏状态，则不执行任何操作。
     * @public
     *
     * @return {boolean} 显示状态是否改变
     */
    UI_CONTROL_CLASS.hide = function () {
        if (this.isShow()) {
            triggerEvent(this, 'hide');
        }
    };

    /**
     * 控件初始化。
     * init 方法在控件缓存读取后调用，有关控件生成的完整过程描述请参见 基础控件。
     * @public
     */
    UI_CONTROL_CLASS.init = function () {
        if (!this._bCreated) {
            if (this._bDisabled) {
                this.alterClass('+disabled');
            }
            this.$setSize(this.getWidth(), this.getHeight());

            if (UI_CONTROL_READY_LIST === null) {
                // 页面已经加载完毕，直接运行 $ready 方法
                this.$ready();
            }
            else {
                if (!UI_CONTROL_READY_LIST) {
                    // 页面未加载完成，首先将 $ready 方法的调用存放在调用序列中
                    // 需要这么做的原因是 ie 的 input 回填机制，一定要在 onload 之后才触发
                    // ECUI 应该避免直接使用 ecui.get(xxx) 导致初始化，所有的代码应该在 onload 之后运行
                    UI_CONTROL_READY_LIST = [];
                    timer(function () {
                        for (var i = 0, o; o = UI_CONTROL_READY_LIST[i++]; ) {
                            o.$ready();
                        }
                        UI_CONTROL_READY_LIST = null;
                    });
                }
                if (this.$ready != blank) {
                    UI_CONTROL_READY_LIST.push(this);
                }
            }
            this._bCreated = true;
        }
    };

    /**
     * 判断控件是否处于激活状态。
     * @public
     *
     * @return {boolean} 控件是否处于激活状态
     */
    UI_CONTROL_CLASS.isActived = function () {
        return this.contain(getActived());
    };

    /**
     * 判断是否响应浏览器事件。
     * 控件不响应浏览器事件时，相应的事件由父控件进行处理。
     * @public
     *
     * @return {boolean} 控件是否响应浏览器事件
     */
    UI_CONTROL_CLASS.isCapturable = function () {
        return this._bCapturable;
    };

    /**
     * 判断控件是否处于失效状态。
     * 控件是否处于失效状态，影响控件是否处理事件，它受到父控件的失效状态的影响。可以通过 enable 与 disable 方法改变控件的失效状态，如果控件失效，它所有的子控件也会失效
     * @public
     *
     * @return {boolean} 控件是否失效
     */
    UI_CONTROL_CLASS.isDisabled = function () {
        return this._bDisabled || (!!this._cParent && this._cParent.isDisabled());
    };

    /**
     * 判断是否允许获得焦点。
     * 控件不允许获得焦点时，被点击时不会改变当前处于焦点状态的控件，但此时控件拥有框架事件响应的最高优先级。
     * @public
     *
     * @return {boolean} 控件是否允许获取焦点
     */
    UI_CONTROL_CLASS.isFocusable = function () {
        return this._bFocusable;
    };

    /**
     * 判断控件是否处于焦点状态。
     * @public
     *
     * @return {boolean} 控件是否处于焦点状态
     */
    UI_CONTROL_CLASS.isFocused = function () {
        return this.contain(getFocused());
    };

    /**
     * 判断控件是否处于悬停状态。
     * @public
     *
     * @return {boolean} 控件是否处于悬停状态
     */
    UI_CONTROL_CLASS.isHovered = function () {
        return this.contain(getHovered());
    };

    /**
     * 判断控件是否允许改变大小。
     * @public
     *
     * @return {boolean} 控件是否允许改变大小
     */
    UI_CONTROL_CLASS.isResizable = function () {
        return this._bResizable;
    };

    /**
     * 判断是否处于显示状态。
     * @public
     *
     * @return {boolean} 控件是否显示
     */
    UI_CONTROL_CLASS.isShow = function () {
        return !!this.getOuter().offsetWidth;
    };

    /**
     * 判断是否允许选中内容。
     * @public
     *
     * @return {boolean} 控件是否允许选中内容
     */
    UI_CONTROL_CLASS.isUserSelect = function () {
        return this._bUserSelect;
    };

    /**
     * 控件完全刷新。
     * 对于存在数据源的控件，render 方法根据数据源重新填充控件内容，重新计算控件的大小进行完全的重绘。
     * @public
     */
    UI_CONTROL_CLASS.render = function () {
        this.resize();
    };

    /**
     * 控件刷新。
     * repaint 方法不改变控件的内容与大小进行重绘。控件如果生成后不位于文档 DOM 树中，样式无法被正常读取，控件显示后如果不是预期的效果，需要调用 repaint 方法刷新。
     * @public
     */
    UI_CONTROL_CLASS.repaint = function () {
        this.cache(true, true);
        this.$setSize(this.getWidth(), this.getHeight());
    };

    /**
     * 控件重置大小并刷新。
     * resize 方法重新计算并设置控件的大小，浏览器可视化区域发生变化时，可能需要改变控件大小，框架会自动调用控件的 resize 方法。
     */
    UI_CONTROL_CLASS.resize = function () {
        if (this._bResizable) {
            this.$resize();
            this.repaint();
        }
    };

    /**
     * 设置控件可使用区域的大小。
     * @public
     *
     * @param {number} width 宽度
     * @param {number} height 高度
     */
    UI_CONTROL_CLASS.setBodySize = function (width, height) {
        this.setSize(width && width + this.getMinimumWidth(), height && height + this.getMinimumHeight());
    };

    /**
     * 设置控件的当前样式。
     * setClass 方法改变控件的当前样式，扩展样式分别附加在类型样式与当前样式之后，从而实现控件的状态样式改变，详细的描述请参见 alterClass 方法。控件的当前样式通过 getClass 方法获取。
     * @public
     *
     * @param {string} currClass 控件的当前样式名称
     */
    UI_CONTROL_CLASS.setClass = function (currClass) {
        var i = 0,
            oldClass = this._sClass,
            classes = this.getTypes(),
            list = [];

        currClass = currClass || this._sPrimary;

        // 如果基本样式没有改变不需要执行
        if (currClass != oldClass) {
            classes.splice(0, 0, this._sClass = currClass);
            for (; classes[i]; ) {
                list[i] = this._aStatus.join(classes[i++]);
            }
            classes[0] = oldClass;
            this._eMain.className =
                list.join('') +
                    this._eMain.className.split(/\s+/).join('  ').replace(
                        new REGEXP('(^| )(' + classes.join('|') + ')(-[^ ]+)?( |$)', 'g'),
                        ''
                    );
        }
    };

    /**
     * 设置控件的内容。
     * @public
     *
     * @param {string} html HTML 片断
     */
    UI_CONTROL_CLASS.setContent = function (html) {
        this._eBody.innerHTML = html;
    };

    /**
     * 设置当前控件的父控件。
     * setParent 方法设置父控件，将当前控件挂接到父控件对象的内层元素中。如果父控件发生变化，原有的父控件若存在，将触发移除子控件事件(onremove)，并解除控件与原有父控件的关联，新的父控件若存在，将触发添加子控件事件(onappend)，如果此事件返回 false，添加失败，相当于忽略 parent 参数。
     * @public
     *
     * @param {ecui.ui.Control} parent 父控件对象，忽略参数控件将移出 DOM 树
     */
    UI_CONTROL_CLASS.setParent = function (parent) {
        UI_CONTROL_ALTER_PARENT(this, parent, parent && parent._eBody);
    };

    /**
     * 设置控件的坐标。
     * setPosition 方法设置的是控件的 left 与 top 样式，受到 position 样式的影响。
     * @public
     *
     * @param {number} x 控件的X轴坐标
     * @param {number} y 控件的Y轴坐标
     */
    UI_CONTROL_CLASS.setPosition = function (x, y) {
        var style = this.getOuter().style;
        style.left = x + 'px';
        style.top = y + 'px';
    };

    /**
     * 设置控件的大小。
     * 需要设置的控件大小如果低于控件允许的最小值，将忽略对应的宽度或高度的设置。
     * @public
     *
     * @param {number} width 控件的宽度
     * @param {number} height 控件的高度
     */
    UI_CONTROL_CLASS.setSize = function (width, height) {
        if (this._bResizable) {
            this.cache();

            //__gzip_original__style
            var style = this._eMain.style;

            // 控件新的大小不允许小于最小值
            if (width < this.getMinimumWidth()) {
                width = 0;
            }
            if (height < this.getMinimumHeight()) {
                height = 0;
            }

            this.$setSize(width, height);

            if (width) {
                this._sWidth = style.width;
            }
            if (height) {
                this._sHeight = style.height;
            }
        }
    };

    /**
     * 显示控件。
     * 如果控件处于隐藏状态，调用 show 方法会触发 onshow 事件，控件转为显示状态。如果控件已经处于显示状态，则不执行任何操作。
     * @public
     */
    UI_CONTROL_CLASS.show = function () {
        if (!this.isShow()) {
            triggerEvent(this, 'show');
            return true;
        }
        return false;
    };

    (function () {
        // 初始化事件处理函数，以事件名命名，这些函数行为均是判断控件是否可操作/是否需要调用事件/是否需要执行缺省的事件处理，对应的缺省事件处理函数名以$开头后接事件名，处理函数以及缺省事件处理函数参数均为事件对象，仅执行一次。
        for (var i = 0, o; o = eventNames[i++]; ) {
            UI_CONTROL_CLASS['$' + o] = UI_CONTROL_CLASS['$' + o] || blank;
        }

        // 初始化空操作的一些缺省处理
        UI_CONTROL_CLASS.$intercept = UI_CONTROL_CLASS.$append = UI_CONTROL_CLASS.$remove =
            UI_CONTROL_CLASS.$zoomstart = UI_CONTROL_CLASS.$zoom = UI_CONTROL_CLASS.$zoomend =
            UI_CONTROL_CLASS.$dragstart = UI_CONTROL_CLASS.$dragmove = UI_CONTROL_CLASS.$dragend =
            UI_CONTROL_CLASS.$ready = UI_CONTROL_CLASS.$pagescroll = blank;
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Decorate - 装饰器插件。
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ext = core.ext,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        REGEXP = RegExp,
        FLOOR = MATH.floor,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        
        addClass = dom.addClass,
        createDom = dom.create,
        getStyle = dom.getStyle,
        insertBefore = dom.insertBefore,
        insertHTML = dom.insertHTML,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        toCamelCase = string.toCamelCase,
        inherits = util.inherits,

        $bind = core.$bind,
        isContentBox = core.isContentBox,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 装饰器插件加载。
     * @public
     *
     * @param {ecui.ui.Control} control 需要应用插件的控件
     * @param {string} value 插件的参数
     */
    var EXT_DECORATE = ext.decorate = function (control, value) {
        value.replace(/([A-Za-z0-9\-]+)\s*\(\s*([^)]+)\)/g, function ($0, $1, $2) {
            // 获取装饰器函数
            $1 = EXT_DECORATE[toCamelCase($1.charAt(0).toUpperCase() + $1.slice(1))];

            // 获取需要调用的装饰器列表
            $2 = $2.split(/\s+/);
            // 以下使用 el 计数
            for (var i = 0; $0 = $2[i++]; ) {
                new $1(control, $0);
            }
        });
    };

    /**
     * 初始化装饰器，将其附着在控件外围。
     * @public
     *
     * @param {ecui.ui.Control|ecui.ext.decorate.Decorator} control 需要装饰的控件
     * @param {string} primary 装饰器的基本样式
     * @param {Array} list 需要生成的区块样式名称集合
     */
    var DECORATOR = EXT_DECORATE.Decorator = function (control, primary, list) {
            //__transform__id_i
            var id = control.getUID(),
                o = (this._oInner = DECORATOR[id] || control).getOuter();

            insertBefore(this._eMain = createDom(this._sPrimary = primary), o).appendChild(o);
            $bind(this._eMain, control);
            control.clearCache();

            DECORATOR[id] = this;

            if (!DECORATOR_OLD_METHODS[id]) {
                // 给控件的方法设置代理访问
                id = DECORATOR_OLD_METHODS[id] = {};
                for (o in DECORATOR_PROXY) {
                    id[o] = control[o];
                    control[o] = DECORATOR_PROXY[o];
                }
            }

            if (list) {
                for (id = 0; o = list[id]; ) {
                    list[id++] =
                        '<div class="' + primary + '-' + o +
                            '" style="position:absolute;top:0px;left:0px"></div>';
                }

                insertHTML(this._eMain, 'BEFOREEND', list.join(''));
            }
        },
        DECORATOR_CLASS = DECORATOR.prototype,

        DECORATOR_PROXY = {},
        DECORATOR_OLD_METHODS = {};
//{else}//
    /**
     * 清除所有的装饰器效果，同时清除所有的代理函数。
     * @public
     *
     * @param {ecui.ui.Control} control ECUI 控件
     */
    DECORATOR.clear = function (control) {
        var id = control.getUID(),
            o;

        // 清除所有的代理函数
        for (o in DECORATOR_PROXY) {
            delete control[o];

            // 方法不在原型链上需要额外恢复
            if (control[o] != DECORATOR_OLD_METHODS[id][o]) {
                control[o] = DECORATOR_OLD_METHODS[id][o];
            }
        }

        o = DECORATOR[id];

        insertBefore(control.getOuter(), o._eMain);
        removeDom(o._eMain);
        for (; o != control; o = o._oInner) {
            o.$dispose();
        }
        delete DECORATOR[id];
        delete DECORATOR_OLD_METHODS[id];
    };

    /**
     * 缓存装饰器的属性。
     * @protected
     *
     * @param {CssStyle} style 主元素的 Css 样式对象
     * @param {boolean} cacheSize 是否需要缓存控件的大小，如果控件是另一个控件的部件时，不缓存大小能加快渲染速度，默认缓存
     */
    DECORATOR_CLASS.$cache = function (style, cacheSize) {
        this._oInner.$cache(style, cacheSize, true);
        UI_CONTROL_CLASS.$cache.call(this, getStyle(this._eMain), false);
        this._oInner.$$position = 'relative';
        this.$$position = style.position == 'absolute' ? 'absolute' : 'relative';
        this.$$layout =
            ';top:' + style.top + ';left:' + style.left + ';display:' + style.display +
                (ieVersion ? ';zoom:' + style.zoom : '');
    };

    /**
     * 销毁装饰器的默认处理。
     * @protected
     */
    DECORATOR_CLASS.$dispose = function () {
        this._eMain = null;
    };

    /**
     * 装饰器大小变化事件的默认处理。
     * @protected
     */
    DECORATOR_CLASS.$resize = function () {
        //__gzip_original__style
        var style = this._eMain.style;

        style.width = '';
        if (!ieVersion) {
            style.height = '';
        }
        this._oInner.$resize(true);
    };

    /**
     * 设置装饰器的大小。
     * @protected
     *
     * @param {number} width 宽度，如果不需要设置则将参数设置为等价于逻辑非的值
     * @param {number} height 高度，如果不需要设置则省略此参数
     */
    DECORATOR_CLASS.$setSize = function (width, height) {
        //__gzip_original__style
        //__gzip_original__inner
        var style = this._eMain.style,
            inner = this._oInner,
            invalidWidth = UI_CONTROL_CLASS.$getBasicWidth.call(this),
            invalidHeight = UI_CONTROL_CLASS.$getBasicHeight.call(this),
            fixedSize = isContentBox();

        inner.$setSize(width && width - invalidWidth, height && height - invalidHeight, true);

        style.width = inner.getWidth(true) + (fixedSize ? 0 : invalidWidth) + 'px';
        style.height = inner.getHeight(true) + (fixedSize ? 0 : invalidHeight) + 'px';
    };

    /**
     * 为装饰器添加/移除一个扩展样式。
     * @public
     *
     * @param {string} className 扩展样式名，以+号开头表示添加扩展样式，以-号开头表示移除扩展样式
     */
    DECORATOR_CLASS.alterClass = function (className) {
        var flag = className.charAt(0) == '+';

        this._oInner.alterClass(className, true);

        if (flag) {
            className = '-' + className.slice(1);
        }

        (flag ? addClass : removeClass)(this._eMain, this._sPrimary + className);
    };

    /**
     * 获取装饰器的当前样式。
     * @public
     *
     * @return {string} 控件的当前样式
     */
    DECORATOR_CLASS.getClass = function () {
        return this._sPrimary;
    };

    /**
     * 获取装饰器区域的高度。
     * @public
     *
     * @return {number} 装饰器的高度
     */
    DECORATOR_CLASS.getHeight = function () {
        return this._oInner.getHeight(true) + UI_CONTROL_CLASS.$getBasicHeight.call(this);
    };

    /**
     * 获取装饰器的最小高度。
     * @public
     *
     * @return {number} 装饰器的最小高度
     */
    DECORATOR_CLASS.getMinimumHeight = function () {
        return this._oInner.getMinimumHeight(true) + UI_CONTROL_CLASS.$getBasicHeight.call(this);
    };

    /**
     * 获取装饰器的最小宽度。
     * @public
     *
     * @return {number} 装饰器的最小宽度
     */
    DECORATOR_CLASS.getMinimumWidth = function () {
        return this._oInner.getMinimumWidth(true) + UI_CONTROL_CLASS.$getBasicWidth.call(this);
    };

    /**
     * 获取装饰器的外层元素。
     * @public
     *
     * @return {HTMLElement} Element 对象
     */
    DECORATOR_CLASS.getOuter = function () {
        return this._eMain;
    };

    /**
     * 获取装饰器区域的宽度。
     * @public
     *
     * @return {number} 装饰器的宽度
     */
    DECORATOR_CLASS.getWidth = function () {
        return this._oInner.getWidth(true) + UI_CONTROL_CLASS.$getBasicWidth.call(this);
    };

    /**
     * 装饰器初始化。
     * @public
     */
    DECORATOR_CLASS.init = function () {
        this._eMain.style.cssText = 'position:' + this.$$position + this.$$layout;
        this._oInner.getOuter(true).style.cssText += ';position:relative;top:auto;left:auto;display:block';
        this._oInner.init(true);
    };

    /**
     * 销毁控件的默认处理。
     * 控件销毁时需要先销毁装饰器。
     * @protected
     */
    DECORATOR_PROXY.$dispose = function () {
        DECORATOR.clear(this);
        this.$dispose();
    };

    (function () {
        function build(name, index) {
            DECORATOR_PROXY[name] = function () {
                var id = this.getUID(),
                    o = DECORATOR[id],
                    args = arguments;

                return args[index] ? DECORATOR_OLD_METHODS[id][name].apply(this, args) : o[name].apply(o, args);
            };
        }

        // 这里批量生成函数代理
        for (
            var i = 0, names = [
                ['$cache', 2], ['$resize', 0], ['$setSize', 2],
                ['alterClass', 1], ['getOuter', 0],
                ['getMinimumWidth', 0], ['getMinimumHeight', 0],
                ['getWidth', 0], ['getHeight', 0], ['init', 0]
            ];
            i < 10;
        ) {
            // 如果是代理进入的，会多出来一个参数作为标志位
            build(names[i][0], names[i++][1]);
        }
    })();
//{/if}//
/*
LRDecorator - 左右扩展装饰器，将区域分为"左-控件-右"三部分，使用paddingLeft与paddingRight作为左右区域的宽度
*/
//{if $phase == "define"}//
    /**
     * 初始化左右扩展装饰器，将其附着在控件外围。
     * @public
     *
     * @param {Control} control 需要装饰的控件
     * @param {string} primary 装饰器的基本样式
     */
    var LR_DECORATOR = EXT_DECORATE.LRDecorator = function (control, primary) {
            DECORATOR.call(this, control, primary, ['left', 'right']);
        };
//{else}//
    /**
     * 设置装饰器区域的大小
     * @public
     *
     * @param {number} width 装饰器区域的宽度
     * @param {number} height 装饰器区域的高度
     */
    inherits(LR_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            text = ';top:' + this.$$paddingTop + 'px;height:' + this._oInner.getHeight(true) + 'px;width:';

        o.style.cssText +=
            text + this.$$paddingRight + 'px;left:' + (this.$$paddingLeft + this._oInner.getWidth(true)) + 'px';
        o.previousSibling.style.cssText += text + this.$$paddingLeft + 'px';
    };
//{/if}//
/*
TBDecorator - 上下扩展装饰器，将区域分为"上-控件-下"三部分，使用paddingTop与paddingBottom作为上下区域的高度
*/
//{if $phase == "define"}//
        /**
         * 初始化上下扩展装饰器，将其附着在控件外围。
         * @public
         *
         * @param {Control} control 需要装饰的控件
         * @param {string} primary 装饰器的基本样式
         */
    var TB_DECORATOR = EXT_DECORATE.TBDecorator = function (control, primary) {
            DECORATOR.call(this, control, primary, ['top', 'bottom']);
        };
//{else}//
    /**
     * 设置装饰器区域的大小
     * @public
     *
     * @param {number} width 装饰器区域的宽度
     * @param {number} height 装饰器区域的高度
     */
    inherits(TB_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            text = ';left:' + this.$$paddingLeft + 'px;width:' + this._oInner.getWidth(true) + 'px;height:';

        o.style.cssText +=
            text + this.$$paddingBottom + 'px;top:' + (this.$$paddingTop + this._oInner.getHeight(true)) + 'px';
        o.previousSibling.style.cssText += text + this.$$paddingTop + 'px';
    };
//{/if}//
/*
MagicDecorator - 九宫格扩展装饰器，将区域分为"左上-上-右上-左-控件-右-左下-下-右下"九部分，使用padding定义宽度与高度
*/
//{if $phase == "define"}//
    /**
     * 初始化九宫格扩展装饰器，将其附着在控件外围。
     * @public
     *
     * @param {Control} control 需要装饰的控件
     * @param {string} primary 装饰器的基本样式
     */
    var MAGIC_DECORATOR = EXT_DECORATE.MagicDecorator = function (control, primary) {
            DECORATOR.call(
                this,
                control,
                primary,
                ['widget0', 'widget1', 'widget2', 'widget3', 'widget5', 'widget6', 'widget7', 'widget8']
            );
        };
//{else}//
    /**
     * 设置装饰器区域的大小
     * @public
     *
     * @param {number} width 装饰器区域的宽度
     * @param {number} height 装饰器区域的高度
     */
    inherits(MAGIC_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            i = 9,
            paddingTop = this.$$paddingTop,
            paddingLeft = this.$$paddingLeft,
            widthList = this._oInner.getWidth(true),
            heightList = this._oInner.getHeight(true),
            topList = [0, paddingTop, paddingTop + heightList],
            leftList = [0, paddingLeft, paddingLeft + widthList];

        widthList = [paddingLeft, widthList, this.$$paddingRight];
        heightList = [paddingTop, heightList, this.$$paddingBottom];

        for (; i--; ) {
            if (i != 4) {
                o.style.cssText +=
                    ';top:' + topList[FLOOR(i / 3)] + 'px;left:' + leftList[i % 3] + 'px;width:' + widthList[i % 3] +
                        'px;height:' + heightList[FLOOR(i / 3)] + 'px';
                o = o.previousSibling;
            }
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Combine - 联合器插件。
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        ext = core.ext,
        util = core.util,

        REGEXP = RegExp,

        indexOf = array.indexOf,
        remove = array.remove,
        blank = util.blank,

        $connect = core.$connect,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'mousewheel', 'keydown', 'keypress', 'keyup',
            'focus', 'blur', 'activate', 'deactivate'
        ];
//{/if}//
//{if $phase == "define"}//
    /**
     * 控件组合。
     * 控件组合后形成一个共同体虚拟控件，虚拟控件体内所有控件的基本事件与操作将同时进行，一个控件只能被组合到一个共同体虚拟控件中。
     * @public
     *
     * @param {Array} controls 需要组合的控件列表
     * @param {Array} names 需要组合的操作名称列表，如果存在 * 表示需要加载全部的默认操作
     */
    var COMBINE = function (controls, names) {
            this._aControls = [];
            if (!names) {
                names = ['disable', 'enable'];
            }
            else if ((i = indexOf(names, '*')) >= 0) {
                names.splice(i, 1, 'disable', 'enable');
                names = eventNames.concat(names);
            }
            names.splice(0, 0, '$dispose');
            this._aNames = names;
            for (var i = 0, o; o = controls[i++]; ) {
                if ('string' == typeof o) {
                    $connect(this, EXT_COMBINE_BIND, o);
                }
                else {
                    EXT_COMBINE_BIND.call(this, o);
                }
            }
        },
        EXT_COMBINE_CLASS = COMBINE.prototype,
        EXT_COMBINE_PROXY = {};
//{else}//
    /**
     * 联合器调用方法创建。
     * 联合器的方法都创建在代理对象中，用于分组进行调用。
     * @public
     *
     * @param {string} name 需要创建的方法名
     * @return {Function} 进行分组联合调用的函数
     */
    function EXT_COMBINE_BUILD(name) {
        if (!EXT_COMBINE_PROXY[name]) {
            EXT_COMBINE_CLASS[name] = function () {
                var i = 0,
                    uid = this.getUID(),
                    combine = COMBINE[uid],
                    o;

                combine[name] = blank;
                for (; o = combine._aControls[i++]; ) {
                    if (indexOf(eventNames, name) < 0) {
                        COMBINE[uid + name].apply(o, arguments);
                    }
                    else if (o != this) {
                        triggerEvent(o, name, arguments[0]);
                    }
                }
                delete combine[name];
            };

            EXT_COMBINE_PROXY[name] = function () {
                COMBINE[this.getUID()][name].apply(this, arguments);
            };
        }

        return EXT_COMBINE_PROXY[name];
    }

    /**
     * 为控件绑定需要联合调用的方法。
     * @public
     *
     * @param {ecui.ui.Control} control 控件对象
     */
    function EXT_COMBINE_BIND(control) {
        for (var i = 0, uid = control.getUID(), o; o = this._aNames[i++]; ) {
            if (indexOf(eventNames, o) < 0) {
                COMBINE[uid + o] = control[o];
                control[o] = EXT_COMBINE_BUILD(o);
            }
            else {
                core.addEventListener(control, o, EXT_COMBINE_BUILD(o));
            }
        }
        this._aControls.push(control);
        COMBINE[uid] = this;
    }

    /**
     * 联合器释放。
     * @protected
     */
    EXT_COMBINE_PROXY.$dispose = function () {
        var i = 0,
            uid = this.getUID(),
            combine = COMBINE[uid],
            el = this.getMain(),
            o = [this.getClass()].concat(this.getTypes());

        COMBINE[uid + '$dispose'].call(this);
        el.className = o.join(' ');
        remove(combine._aControls, this);
        for (; o = combine._aNames[i++]; ) {
            delete COMBINE[uid + o];
        }
    };

    /**
     * 联合器插件加载。
     * @public
     *
     * @param {ecui.ui.Control} control 需要应用插件的控件
     * @param {string} value 插件的参数
     */
    ext.combine = function (control, value) {
        if (/(^[^(]+)(\(([^)]+)\))?$/.test(value)) {
            value = REGEXP.$3;
            new COMBINE(
                [control].concat(REGEXP.$1.split(/\s+/)),
                value.split(/\s+/)
            );
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//
// FIXME
// 暂时用这种方法注册进去
$getNamespaceBase().ecui = ecui;

/*
MessageBox - 消息框功能。
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,

        createDom = dom.create,

        createControl = core.create,
        disposeControl = core.dispose;
//{/if}//
//{if $phase == "define"}//
    var ECUI_MESSAGEBOX,
        ECUI_MESSAGEBOX_BUTTONS = [];
//{else}//
    /**
     * 消息框点击事件处理。
     * @private
     * 
     * @param {Event} event 事件对象
     */
    function ECUI_MESSAGEBOX_ONCLICK(event) {
        ECUI_MESSAGEBOX.hide();
        if (this._fAction) {
            this._fAction.call(null, event);
        }
    }

    /**
     * 消息框显示提示信息，仅包含确认按钮。
     * @protected
     * 
     * @param {string} text 提示信息文本
     * @param {Array} buttonTexts 按钮的文本数组
     * @param {Array} 按钮配置
     *          {String} text 文本
     *          {String} className 按钮样式
     *          {Function} action 点击事件处理函数
     * @param {Number} opacity 不透明度
     */
    core.$messagebox = function (text, title, buttons, opacity) {
        if (!ECUI_MESSAGEBOX) {
            ECUI_MESSAGEBOX = createControl(
                'Form',
                {
                    main: createDom('ui-form ui-messagebox'),
                    hide: true,
                    parent: document.body,
                    autoCenter: true,
                    closeButton: false
                }
            );

            body = ECUI_MESSAGEBOX.getBody();
            body.innerHTML =
                '<div class="ui-messagebox-text"></div>' +
                '<div class="ui-messagebox-bottom"></div>';
        }

        var i = 0,
            length = buttons.length,
            body = ECUI_MESSAGEBOX.getBody(),
            bottom = body.lastChild,
            o;

        if (!ECUI_MESSAGEBOX.isShow()) {
            while (length > ECUI_MESSAGEBOX_BUTTONS.length) {
                ECUI_MESSAGEBOX_BUTTONS.push(
                    createControl('Button', {element: createDom('ui-button', '', 'span'), parent: bottom})
                );
            }

            disposeControl(body = body.firstChild);
            body.innerHTML = text;

            for (; o = ECUI_MESSAGEBOX_BUTTONS[i]; i++) {
                if (i < length) {
                    o.setContent(buttons[i].text);
                    o.$show();
                    o._fAction = buttons[i].action;
                    o.onclick = ECUI_MESSAGEBOX_ONCLICK;
                    if (buttons[i].className) {
                        o.setClass(buttons[i].className);
                    }
                    else {
                        o.setClass(o.getPrimary());
                    }
                }
                else {
                    o.$hide();
                }
            }

            ECUI_MESSAGEBOX.setTitle(title || '提示');
            ECUI_MESSAGEBOX.showModal(opacity);
        }
    };

    /**
     * 消息框显示提示信息，仅包含确认按钮。
     * @public
     * 
     * @param {string} text 提示信息文本
     * @param {Function} onok 确认按钮点击事件处理函数
     */
    core.alert = function (text, onok) {
        core.$messagebox(text, '提示', [
            {text: '确定', className: 'ui-button-g', action: onok}
        ]);
    };

    /**
     * 消息框显示提示信息，包含确认/取消按钮。
     * @public
     * 
     * @param {string} text 提示信息文本
     * @param {Function} onok 确认按钮点击事件处理函数
     * @param {Function} oncancel 取消按钮点击事件处理函数
     */
    core.confirm = function (text, onok, oncancel) {
        core.$messagebox(text, '确认', [
            {text: '确定', className: 'ui-button-g', action: onok},
            {text: '取消', action: oncancel}
        ]);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * di.helper.Dialog
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    全局的提示信息 
 *           (代码拷贝自 rigel.layer。但是tip是“小窍门”的意思，而不是“提示”的意思，所以改成prompt)
 * @author:  sushuang(sushuang@baidu.com)
 * @depends: ecui
 */

$namespace('di.helper');

(function() {
    
    //--------------------------------
    // 引用
    //--------------------------------

    // FIXME 
    // 后续去除此ecui引用
    var ui = ecui;
    var encodeHTML = xutil.string.encodeHTML;
    var LANG;
    var UTIL;
    var DICT;
    var DI_FACTORY;

    $link(function() {
        LANG = di.config.Lang;
        DICT = di.config.Dict;
        UTIL = di.helper.Util;
        DI_FACTORY = di.shared.model.DIFactory;
    });

    //--------------------------------
    // 类型声明
    //--------------------------------

    var DIALOG = $namespace().Dialog = {};
    
    var ePrompt = null;
    var bPromptMask = false;
    var promptTimer = null;

    DIALOG.prompt = function () {
        prompt.apply(this, arguments);
    };
    DIALOG.waitingPrompt = function () {
        waitingPrompt.apply(this, arguments);
    };
    DIALOG.hidePrompt = function () {
        hidePrompt.apply(this, arguments);
    };

    /**
     * 设置prompt定义
     *
     * @public
     * @param {Object} def 定义
     * @param {string} def.anchor 值可为：
     *      'I'：internal，在报表引擎内部定位，如果是iframe加载报表引擎，这样则定位不理想），默认
     *      'E'：external，在报表引擎外定位（报表引擎所在的iframe的window上）
     * @param {string} diAgent 是否为stub
     */
    DIALOG.setPromptDef = function(def, diAgent) {
        if (diAgent == 'STUB' && def && def.anchor == 'E') {
            // 临时写法，后续规整
            // FIXME
            prompt = getRemoteDelegation('prompt');
            hidePrompt = getRemoteDelegation('hideprompt');
            waitingPrompt = getRemoteDelegation('waitingprompt');
        }
    };

    /**
     * 设置prompt定义
     *
     * @public
     */
    function getRemoteDelegation(eventName) {
        return function() {
            var eventChannel = DI_FACTORY().getEventChannel();
            if (eventChannel) {
                eventChannel.triggerEvent(eventName, arguments);
            }
        };
    };

    /**
     * 信息提示，支持自动消失
     *
     * @public
     * @param {string} text 信息
     * @param {boolean} mask 是否使用遮罩
     * @param {number} timeout 消失时间
     */
    function prompt(text, mask, timeout) {
        var win;
        try {
            // win = window.top;
            win = window;
            // TODO
            // 在iframe中，根据定位到top中间，或者dom加到top上。
        } 
        catch (e) {
        }
        
        var x = UTIL.getScrollLeft(win) + UTIL.getViewWidth(win) / 2;
        var y = 5;

        if(!ePrompt) {
            ePrompt = document.createElement('div');
            ePrompt.style.cssText = 'display:none;position:fixed;*position:absolute';
            ePrompt.className = 'global-prompt';
            document.body.appendChild(ePrompt);
        }

        clearPromptTimer();

        if(ePrompt.style.display == '') {
            return false;
        }

        ePrompt.innerHTML = text;
        ePrompt.style.display = '';
        ePrompt.style.left = x - ePrompt.offsetWidth / 2 + 'px';
        ePrompt.style.top = y + 'px';
        if(mask) {
            ui.mask(0);
            bPromptMask = true;
        }

        if (timeout) {
            promptTimer = setTimeout(
                function () {
                    DIALOG.hidePrompt();
                }, 
                timeout
            );
        }
        return true;        
    };

    /**
     * 等待提示
     *
     * @public
     * @param {string} text 信息
     * @param {boolean} mask 是否使用遮罩
     * @param {number} timeout 消失时间
     */
    function waitingPrompt(text) {
        if (text == null) {
            text = LANG.AJAX_WAITING;
        }
        text = [
            '<div class="global-prompt-waiting"></div>',
            '<div class="global-prompt-waiting-text">', text, '</div>'
        ].join('');
        DIALOG.prompt(text);
    }
    
    /**
     * 隐藏信息提示
     *
     * @public
     * @param {string} messag 信息
     * @param {boolean} 是否使用遮罩
     * @param {number} timeout 消失时间
     */
    function hidePrompt() {
        clearPromptTimer();
        ePrompt.style.display = 'none';
        if(bPromptMask) {
            bPromptMask = false;
            ui.mask();
        }
    };
        
    function clearPromptTimer() {
        if (promptTimer) {
            clearTimeout(promptTimer);
            promptTimer = null;
        }
    }

    /**
     * 显示提示窗口
     *
     * @public
     * @param {string} text 提示信息
     * @param {string} title 标题
     * @param {Array.<Object>} buttons 按钮，其中每一项结构为
     *      {string} text 按钮文字
     *      {string} className cssClassName
     *      {Function} action 按下按钮的回调
     * @param {number=} mask 使用mask的透明值，如果不传此参数则不使用
     */
    DIALOG.showDialog = function(text, title, buttons, mask) {
        ui.$messagebox(text, title, buttons, mask);
    };

    /**
     * 只含确定键的提示窗口
     *
     * @public
     * @param {String} text 提示信息
     * @param {Function} onconfirm 确定按钮的处理函数
     * @param {boolean} noBtn 是否不显示btn（不显示则禁止了一切页面的继续操作）
     */
    DIALOG.alert = function(text, onconfirm, noBtn) {
        DIALOG.showDialog(
            text, 
            '提示', 
            noBtn
                ? []
                : [
                    { 
                        text: '确定', 
                        className: 'ui-button-g', 
                        action: onconfirm 
                    }
                ], 
            DICT.DEFAULT_MASK_OPACITY
        );
    };

    /**
     * 含确定和取消键的窗口
     *
     * @public
     * @param {String} text 提示信息
     * @param {Function} ok 确定按钮的处理函数
     * @param {Function} cancel 取消按钮的处理函数
     */
    DIALOG.confirm = function(text, onconfirm, oncancel) {
        DIALOG.showDialog(
            text, 
            '确认', 
            [
                { 
                    text: '确定', 
                    className: 'ui-button-g', 
                    action: onconfirm 
                },
                { 
                    text: '取消', 
                    action: oncancel 
                }
            ], 
            DICT.DEFAULT_MASK_OPACITY
        );
    };
    
    /**
     * 自定义键的窗口
     *
     * @public
     * @param {string} title 标题
     * @param {string} message 提示信息
     * @param {Array.<Object>} buttons 按钮，每项为：
     *          {string} text 按钮文字
     *          {string} className 样式文字
     *          {Function} action 点击的回调函数
     */
    DIALOG.dialog = function(title, message, buttons) {
        var html;
        buttons = buttons || [];
        
        html.push(
            '<div class="ui-messagebox-icon"></div>', 
            '<div class="ui-messagebox-content">',
                '<div class="ui-messagebox-text">', 
                    encodeHTML(message), 
                '</div>',
            '</div>'
        );

        DIALOG.showDialog(
            html.join(''), 
            title, 
            buttons, 
            DICT.DEFAULT_MASK_OPACITY
        );     
    };

    /**
     * 错误alert
     *
     * @public
     */
    DIALOG.errorAlert = function() {
        DIALOG.alert(LANG.ERROR);
    };

})();
/**
 * di.helper.Formatter
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    格式化集合
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 */

$namespace('di.helper');
 
(function() {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var xlang = xutil.lang;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var hasValue = xlang.hasValue;
    var hasValueNotBlank = xlang.hasValueNotBlank;
    var encodeHTML = xutil.string.encodeHTML;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var formatNumber = xutil.number.formatNumber;
    var arraySlice = Array.prototype.slice;
    var DICT;

    $link(function() {
        DICT = di.config.Dict;
    });
    
    /**
     * 约定，所有formatter第一个参数是data
     * 取得formatter使用这种方式：
     * kt.helper.Formatter('SOME_FORMATTER')
     * kt.helper.Formatter('SOME_FORMATTER', true, 'asdf', ...)
     * （从第二参数起是绑定给formatter的参数）
     * formatter的this指针，即每项的对象。
     *
     * @param {string} formatterName 格式化名
     * @param {Any...} 调用formatter时的从第二个开始的参数
     * @return {Function} formatter
     */
    var FORMATTER = $namespace().Formatter = function(formatterName) {
        var args = arraySlice.call(arguments, 1);
        return function(data) {
            var argsInput = arraySlice.call(arguments, 1);
            return FORMATTER[formatterName].apply(
                this, 
                [data].concat(args, argsInput)
            );
        }
    };

    /**
     * 统一的比率格式
     */
    FORMATTER.DEFAULT_RATE_FORMAT = 'I,III.DD%';

    /**
     * 得到用于ecui表格的formatter
     * 取得formatter使用这种方式：
     * tableFormatter('SOME_FORMATTER')
     * tableFormatter('SOME_FORMATTER', true, 'asdf', ...)
     * （从第二参数起是绑定给formatter的参数）
     * 
     * @param {(string|Object)} field 数据源项的要格式化的属性名
     *              如果为Obejct，则各域为
     *              {string} data 数据属性名
     *              {string} link 链接属性名
     * @param {string} formatterName 格式化名
     * @param {Any...} 调用formatter时的从第二个开始的参数
     * @return {Function} formatter
     */
    FORMATTER.tableFormatter = function(field, formatterName) {
        var args = arraySlice.call(arguments, 2);
        var dataField; 
        var linkField;

        if (isString(field)) {
            dataField = field;
        } 
        else {
            dataField = field.data;
            linkField = field.link;
        }   

        return function(item) {
            var text = FORMATTER[formatterName].apply(
                item, 
                [item[dataField]].concat(args)
            );
            return prepareLink(item, text, linkField);
        };
    }

    /**
     * 表格中普通文本格式化，默认encodeHTML
     * 
     * @public
     * @param {Any} data 值
     * @param {string} needEncodeHTML 默认为true
     * @return {string} 显示值
     */
    FORMATTER.SIMPLE_TEXT = function(data, needEncodeHTML) {    
        needEncodeHTML = hasValue(needEncodeHTML) ? needEncodeHTML : true;
        data = hasValueNotBlank(data) ? data : '-';
        data = needEncodeHTML ? encodeHTML(data) : data;
        return data;
    }
    
    /**
     * 截断字符，用HTML的title属性显示全部字符
     * 
     * @public
     * @param {Any} data 值
     * @param {number} length 显示字节长度
     * @param {string} needEncodeHTML 默认为true
     * @param {string} color 当截断时，显示颜色，缺省则原色
     * @param {string} classNames 补充的classNames
     * @return {string} 显示值
     */
    FORMATTER.CUT_TEXT = function(
        data, length, needEncodeHTML, color, classNames
    ) {
        var shortText = '', isCut, colorStyle = '',
        needEncodeHTML = hasValue(needEncodeHTML) ? needEncodeHTML : true;
        data = hasValueNotBlank(data) ? data : '-';

        if (textLength(data) > length) {
            shortText = textSubstr(data, 0, length - 2) + '..';
            isCut = true;
        } 
        else {
            shortText = data;
            isCut = false;
        }

        shortText = needEncodeHTML ? encodeHTML(shortText) : shortText;
        if (isCut && hasValue(color)) {
            colorStyle = 'color:' + color + '';
        }
        data = needEncodeHTML ? encodeHTML(data) : data;
        return '<span class="' + classNames + '" style="' + colorStyle + '" title="' + data + '" >' + shortText + '&nbsp;</span>'; 
    }

    /**
     * 表格中比率的格式化
     * 
     * @public
     * @param {Any} data 值
     * @param {string} format 数据格式，缺省则为'I,III.DD%'
     * @return {string} 显示值
     */
    FORMATTER.SIMPLE_RATE = function(data, format) {
        var text, flagClass;
        if (!hasValueNotBlank(data)) {
            return '-';
        }
        format = format || FORMATTER.DEFAULT_RATE_FORMAT;
        text = formatNumber(data, format);
        return text;
    }

    /**
     * 表格中普通数据格式化
     * 
     * @public
     * @param {Any} data 值
     * @param {string} format 数据格式，缺省不格式化
     * @return {string} 显示值
     */
    FORMATTER.SIMPLE_NUMBER = function(data, format) {
        data = hasValueNotBlank(data) 
            ? (!format ? data : formatNumber(data, format)) 
            : '-';
        return data;
    }

    /**
     * 表格中带颜色的数据格式化（默认正数红，负数绿）
     * 
     * @public
     * @param {Any} data 值
     * @param {string} format 数据格式，缺省不格式化
     * @param {string} positiveColor 非负数的颜色，默认'red'
     * @param {string} nagetiveColor 负数的颜色，默认'green'
     * @return {string} 显示值
     */
    FORMATTER.COLORED_NUMBER = function(
        data, format, positiveColor, nagetiveColor
    ) {    
        var style, text = '-';
        positiveColor = positiveColor || 'red';
        nagetiveColor = nagetiveColor || 'green';
        if (hasValueNotBlank(data)) {
            style = 'style="color:' + (data < 0 ? nagetiveColor : positiveColor) + '" ';
            text = '<span ' + style + '>' + (!format ? data : formatNumber(data, format)) + '</span>';
        }
        return text;
    }


    /**
     * @private
     */
    function prepareLink (item, text, linkField, dontTargetBlank) {
        var href;
        if (hasValueNotBlank(linkField)) {
            href = item[linkField];
        }
        if (!hasValueNotBlank(href) || !hasValueNotBlank(text)) { 
            return text;
        }
        var targetBlank = dontTargetBlank ? '' : ' target="_blank" ';
        return '<a ' + targetBlank + ' href="' + href + '">' + text + '</a>';
    }

})();
/**
 * di.helper.SnippetParser
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    提供html片段的解析
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 */

$namespace('di.helper');
 
(function () {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var setByPath = xutil.object.setByPath;
    var getByPath = xutil.object.getByPath;
    var getParent = xutil.dom.getParent;
    var merge = xutil.object.merge;
    var DICT;
    var DIALOG;

    $link(function () {
        DICT = di.config.Dict;
        DIALOG = di.helper.Dialog;
    });

    /**
     * html片段解析器
     *
     * @usage
     *      单例，
     *      这样得到实例：var unitFactory = di.helper.SnippetParser();
     */
    $namespace().SnippetParser = function () {
        return instance = instance || {
            parseProdSnippet: parseProdSnippet,
            setupEventChannel: setupEventChannel
        };
    };

    var instance;

    var DEFAULT_DOM_ATTR_NAME = 'data-o_o-di';
    var STUB_EVENT_CHANNEL_ANCHOR = 'BODY';
    var STUB_EVENT_CHANNEL_OUTWARD = 'data-d-outward-d-atad';
    var STUB_EVENT_CHANNEL_INWARD = 'data-d-inward-d-atad';
    var ID_DELIMITER = '.';

    function setupEventChannel(el, prodDef, diFactory) {
        var els = getAllEls(el);
        var domAttrName = prodDef.domAttrName || DEFAULT_DOM_ATTR_NAME;

        // 便利dom节点
        for (var i = 0, eo, attr; eo = els[i]; i ++) {
            // 事件通道
            attr = eo.getAttribute(domAttrName);
            if (attr == STUB_EVENT_CHANNEL_ANCHOR) {
                return createStubEventChannel(eo, diFactory);
            }
        }                
    }

    /**
     * 解析生产环境的snippet
     * 
     * @public
     * @param {HTMLElement} el html片段的根节点
     * @param {Object} depict 定义描述
     * @param {Object} prodDef 生成环境定义
     * @param {Object} diFactory 工厂
     */
    function parseProdSnippet(el, depict, prodDef, diFactory) {    
        prodDef = prodDef || {};
        var domAttrName = prodDef.domAttrName || DEFAULT_DOM_ATTR_NAME;

        var els = getAllEls(el);
        var def;
        var attr;
        var ins;
        var clz;
        var clzType;
        var clzKey;
        var i;
        var j;
        var eo;

        // 做entityDef集合
        var entityDefs = depict.entityDefs || [];
        var entityDefMap = {};
        for (i = 0; i < entityDefs.length; i ++) {
            def = entityDefs[i];
            entityDefMap[def.id] = def;
        }

        // 遍历dom节点
        for (i = 0; eo = els[i]; i ++) {
            // 事件通道
            attr = eo.getAttribute(domAttrName);
            if (attr == STUB_EVENT_CHANNEL_ANCHOR) {
                // createStubEventChannel(eo, diFactory);
                continue;
            }

            // 处理实例声明的节点
            if (attr) {
                def = entityDefMap[attr];
                checkId(def.id);
                recordDef(def, eo, diFactory);
            }
        }

        // 根据id，为component寻找到逻辑隶属snippet，
        // 添加reportTemplateId的引用
        // 根据包含关系，为component寻找视图隶属snippet。
        diFactory.forEachEntity(
            ['COMPONENT'], 
            function (def, ins, id) {
                // 设置逻辑隶属snippet
                var idArr = def.id.split(ID_DELIMITER);
                var snptDef = diFactory.getEntity(idArr[0], 'DEF');
                if (!snptDef) {
                    throw new Error(def.id + ' 未定义隶属的snippet');
                }
                setByPath('belong.snippet', snptDef.id, def);

                // 向外循环，设置视图隶属snippet
                var el = def.el;
                var parentDef;
                var besnpt = getByPath('layout.parentSnippet', def);
                if (!besnpt) {
                    setByPath('layout.parentSnippet', besnpt = [], def);
                }
                while ((el = getParent(el)) && el != document) {
                    parentDef = diFactory.getEntity(
                        el.getAttribute(domAttrName), 
                        'DEF'
                    );

                    if (parentDef && parentDef.clzType == 'SNIPPET') {
                        besnpt.push(parentDef.id);
                    }
                }
            }
        );

        // 根据dom包含关系，为vpart添加其内部实体的引用
        // FIXME
        // 如果后面要vpart中能嵌套snippet，则不能如下简单处理，须考虑层级。
        diFactory.forEachEntity(
            ['VPART'],
            function(def, ins, id) {
                var subEls = getAllEls(def.el);
                var index = { COMPONENT: 0, VUI: 0 };
                var refName = { COMPONENT: 'componentRef', VUI: 'vuiRef' };

                for (var i = 0, eo, subDef, clzType; eo = subEls[i]; i ++) {
                    subDef = diFactory.getEntity(
                        eo.getAttribute(domAttrName), 
                        'DEF'
                    );

                    if (!subDef) { continue; }

                    refName[clzType = subDef.clzType] && setByPath(
                        refName[clzType] + '.inner[' + (index[clzType] ++) + ']',
                        subDef.id, 
                        def
                    );
                }
            }
        );

        // 记录根snippet
        diFactory.rootSnippet(depict.rootSnippet); 
    }

    /**
     * 生成对外事件通道
     * 
     * @private
     */
    function createStubEventChannel(el, diFactory) {  

        // outward (报表发事件，di-stub收事件)
        var triggerEvent = function(eventName, args) {
            var handler = el[STUB_EVENT_CHANNEL_OUTWARD];
            if (handler) {
                try {
                    handler(eventName, args);
                }
                catch (e) {
                    // TODO
                }
            }
        };
        
        // inward (di-stub发事件，报表收事件)
        el[STUB_EVENT_CHANNEL_INWARD] = function(eventName, args) {
            var hList = listenerMap[eventName];
            if (hList) {
                for (var i = 0; i < hList.length; i ++) {
                    try {
                        hList[i] && hList[i].apply(null, args || []);
                    }
                    catch (e) {
                        // TODO
                    }
                }
            }
        };

        var listenerMap = {};

        var addEventListener = function(eventName, listener) {
            var hList = listenerMap[eventName];
            if (!hList) {
                hList = listenerMap[eventName] = [];
            }
            hList.push(listener);          
        }

        var eventChannel;
        diFactory.setEventChannel(
            eventChannel = {
                anchorEl: el,
                triggerEvent: triggerEvent,
                addEventListener: addEventListener
            }
        );

        return eventChannel;
    }

    /**
     * 生成instance
     * 
     * @private
     * @param {Object} def json声明
     * @param {HTMLElement=} el dom节点
     * @param {Object} diFactory 工厂
     */
    function recordDef(def, el, diFactory) {  
        // 仅记录留待后续创建
        def.el = el;
        diFactory.addEntity(def, 'DEF');
    }

    /**
     * 检查id，非法则抛出异常
     * 目前只允许使用 1-9a-zA-Z、中划线、下划线
     *
     * @private
     * @param {string} id
     */
    function checkId(id) {
        if (!/[1-9a-zA-Z\-_\.]/.test(id)) {
            throw new Error('id is illegal: ' + id);
        }
    }

    /**
     * 得到所有子el
     * 
     * @private
     * @param {HTMLElement} el 根el
     * @return {Array} 所有子el
     */
    function getAllEls(el) {
        return el.all || el.getElementsByTagName('*');
    }

})();
/**
 * di.helper.Util
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    业务辅助函数集
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil, tangram.ajax, tangram.json
 */

$namespace('di.helper');
 
(function () {
    
    //----------------------------------------
    // 引用
    //----------------------------------------

    var xlang = xutil.lang;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var stringToDate = xutil.date.stringToDate;
    var hasValue = xlang.hasValue;
    var hasValueNotBlank = xlang.hasValueNotBlank;
    var encodeHTML = xutil.string.encodeHTML;
    var sortList = xutil.collection.sortList;
    var dateToString = xutil.date.dateToString;
    var getWorkday = xutil.date.getWorkday;
    var getWeekend = xutil.date.getWeekend;
    var getQuarter = xutil.date.getQuarter;
    var getQuarterBegin = xutil.date.getQuarterBegin;
    var g = xutil.dom.g;
    var isDate = xutil.lang.isDate;
    var $fastCreate = ecui.$fastCreate;
    var stringify = baidu.json.stringify;
    var getByPath = xutil.object.getByPath;
    var ECUI_CONTROL;
    var DIALOG;
    var LANG;
    var REGEXP = RegExp;

    $link(function () {
        ECUI_CONTROL = getByPath('ecui.ui.Control');
        DIALOG = di.helper.Dialog;
        LANG = di.config.Lang;
    });
        
    //----------------------------------------
    // 类型声明
    //----------------------------------------

    var UTIL = $namespace().Util = {};

    var DAY_MILLISEC = 1000 * 60 * 60 * 24; 
    
    //----------------------------------------
    // 方法
    //----------------------------------------

    /**
     * 就是通常用的assert
     * 
     * @public
     * @param {boolean} cond 条件真假
     * @param {string} msg 如果cond为false时的信息
     */
    UTIL.assert = function (cond, msg) {
        if (!cond) {
            throw new Error(msg || 'Assert fail!');
        }
    }

    /**
     * 在控件中初始化自己的主元素，如需使用则放在preprocess最前调用。
     * 用于这种情况：外部逻辑只构造了一个空元素（使控件定位），然后$fastCreate控件，控件自己管理自己的所有行为。
     * 
     * @public
     * @param {ecui.ui.Control} control 控件
     * @param {HTMLElement} el 控件的主元素
     * @param {Object} options 控件的初始化参数
     */
    UTIL.preInit = function (control, el, options) {
        options.primary = control.getType();
        el.className = control.getTypes().join(' ') + el.className;
    };
    
    /**
     * 初始化一个ecui控件
     * 用于这种情况：外部逻辑只构造了一个空元素（使控件定位）。
     * 
     * @public
     * @param {constructor} contorlClass ecui的类
     * @param {HTMLElement} el 控件的主元素
     * @param {ecui.ui.Control} parentControl 父控件
     * @param {Object} options 控件的初始化参数
     * @return {ecui.ui.Control} 创建好的控件
     */
    UTIL.ecuiCreate = function (controlClass, el, parentControl, options) {
        var type = controlClass.types[0];
        options = options || {};
        !options.primary && (options.primary = type);
        el.className = controlClass.TYPES + ' ' + el.className;
        return $fastCreate(controlClass, el, parentControl, options);
    };

    /**
     * 析构名为"_u***"的成员ecui控件
     * 
     * @public
     * @param {Object} container 
     */
    UTIL.disposeInnerControl = function (container) {
        for (var attr in container) {
            /_u\w+/.test(attr) 
                && container[attr]
                && UTIL.ecuiDispose(container[attr]);
        }
    };

    /**
     * 检查dimSel是否全勾选
     *
     * @public
     * @param {string} dimSelStr 
     * @return {boolean} 是否valid
     */
    UTIL.validDimSel = function (dimSelStr) {
        var i, o, oo, arr;
        if (!hasValueNotBlank(dimSelStr)) { return false; }

        arr = dimSelStr.split('|');
        for (i = 0; i < arr.length; i ++) {
            if (!hasValueNotBlank(o = arr[i])) {
                return false;
            }
            oo = o.split(':');
            if (!hasValueNotBlank(oo[0]) || !hasValueNotBlank(oo[1])) {
                return false;
            }
        }  
        return true;
    };

    /**
     * 将dimSel中未选择的项补为选择维度树根节点
     *
     * @public
     * @param {string} dimSelStr 维度选择字符串
     * @param {Object} dimDatasourceMap 维度散列O
     *                  key: dimId, 
     *                  value: { datasource: dimDatasource }
     * @return {string} 补全过的dimSelStr
     */
    UTIL.completeDimSel = function (dimSelStr, dimDatasourceMap) {
        if (!hasValueNotBlank(dimSelStr)) { return false; }

        var dimSelObj = UTIL.parseDimSel(dimSelStr);
        var rootNode;
        for (var dimId in dimSelObj) {
            rootNode = dimDatasourceMap[dimId].datasource.rootNode;
            if (rootNode 
                && (!dimSelObj[dimId] || dimSelObj[dimId].length == 0)
            ) {
                dimSelObj[dimId] = [rootNode.dimNodeId];
            }
        }
        return UTIL.stringifyDimSel(dimSelObj);
    };    

    /**
     * 把字符串格式的dimSel解析成对象
     *
     * @public
     * @param {string} dimSelStr 
     * @return {Object} dimSel对象
     *          格式：{<dimId>: [<dimNodeId>, <dimNodeId>, ...], ...}
     */
    UTIL.parseDimSel = function (dimSelStr) {
        var i, o, oo, ooo, arr, ret = {};
        if (!hasValueNotBlank(dimSelStr)) { return null; }
        arr = dimSelStr.split('|');
        for (i = 0; i < arr.length; i ++) {
            if (!hasValueNotBlank(o = arr[i])) { continue; }
            oo = o.split(':');
            if (!hasValueNotBlank(oo[0])) { continue; }
            ret[oo[0]] = hasValueNotBlank(oo[1]) ? oo[1].split(',') : [];
        }
        return ret;
    };

    /**
     * 把对象格式的dimSel解析成字符串格式
     *
     * @public
     * @param {Object} dimSelObj
     *          格式：{<dimId>: [<dimNodeId>, <dimNodeId>, ...], ...}
     * @return {string} dimSel字符串
     */
    UTIL.stringifyDimSel = function (dimSelObj) {
        var dimId, arr = [];
        if (!dimSelObj) {
            return '';
        }
        for (dimId in dimSelObj) {
            arr.push(dimId + ':' + (dimSelObj[dimId] || []).join(','));
        }
        return arr.join('|');
    };

    /**
     * 得到el的属性里的json
     * 出错时会抛出异常
     * 
     * @private
     * @param {HTMLElement} el dom节点
     * @param {string} attrName 属性名
     * @return {Object} 属性信息
     */
    UTIL.getDomAttrJSON = function (el, attrName) {
        var attr = el.getAttribute(attrName);
        if (attr) {
            return (new Function('return (' + attr + ');'))();
        }
    };

    /**
     * 判断dimSel是否相同
     *
     * @public
     * @param {string} dimSelStr1 要比较的dimSel1
     * @param {string} dimSelStr2 要比较的dimSel2
     * @param {Object} dimIdMap dimId集合，在其key指定的dimId上比较
     * @return {boolean} 比较结果 
     */
    UTIL.sameDimSel = function (dimSelStr1, dimSelStr2, dimIdMap) {
        var dimId, list1, list2, 
            dimSelObj1 = UTIL.parseDimSel(dimSelStr1), 
            dimSelObj2 = UTIL.parseDimSel(dimSelStr2);

        for (dimId in dimIdMap) {
            sortList((list1 = dimSelObj1[dimId]), null, '<', false);
            sortList((list2 = dimSelObj2[dimId]), null, '<', false);
            if (list1.join(',') !== list2.join(',')) {
                return false;
            }
        }
        return true;
    };

    /**
     * 判断某个dim的选择是否相同（都为空算相同）
     *
     * @public
     * @param {Array{string}} dimNodeIdArr1 要比较的dim1
     * @param {Array{string}} dimNodeIdArr2 要比较的dim2
     * @return {boolean} 比较结果 
     */
    UTIL.sameDimNodeIdArr = function (dimNodeIdArr1, dimNodeIdArr2) {
        dimNodeIdArr1 = dimNodeIdArr1 || [];
        dimNodeIdArr2 = dimNodeIdArr2 || [];

        if (dimNodeIdArr1.length != dimNodeIdArr2.length) {
            return false;
        }

        sortList(dimNodeIdArr1, null, '<', false);
        sortList(dimNodeIdArr2, null, '<', false);

        for (var i = 0; i < dimNodeIdArr1.length; i ++) {
            if (dimNodeIdArr1[i] != dimNodeIdArr2[i]) {
                return false;
            }
        }
        return true;
    };

    /**
     * 渲染空表格
     * 
     * @public
     * @param {ecui.ui.LiteTable} tableCon table控件
     * @param {string} text 解释文字，可缺省
     */
    UTIL.emptyTable = function (tableCon, text) {
        var oldText, html = '';

        if (hasValue(text)) {
            oldText = tableCon.getEmptyText();
            tableCon.setEmptyText(text);
        }

        tableCon.setData([]);

        if (hasValue(oldText)) {
            tableCon.setEmptyText(oldText);
        }
    };

    /**
     * 渲染表格的等待状态
     * 
     * @public
     * @param {ecui.ui.LiteTable} tableCon table控件
     */
    UTIL.waitingTable = function (tableCon) {
        UTIL.emptyTable(tableCon, LANG.WAITING_HTML);
    };    

    /**
     * 得到wrap格式的当前选择
     *
     * @public
     * @param {Object} wrap，格式为：
     *          {Array.<Object>} list
     *              {string} text
     *              {*} value
     *          {*} selected
     */
    UTIL.getWrapSelected = function (wrap) {
        for (var i = 0; o = wrap.list[i]; i ++) {
            if (o.value == wrap.selected) {
                return o;
            }
        }
    };

    /**
     * 打印异常
     *
     * @public
     * @param {Error} e 异常对象
     */
    UTIL.logError = function (e) {
        try {
            if (console && console.log) {
                console.log(e);
                (e.message != null) && console.log(e.message);
                (e.stack != null) && console.log(e.stack);
            }
        } 
        catch (e) {
        }
    };

    /**
     * 解析成DI约定的字符串时间格式
     *
     * @public
     * @param {Date|number} date 目标时间或者时间戳
     * @param {string} config.granularity 时间粒度，'D', 'W', 'M', 'Q', 'Y'
     * @param {Object} options 参数
     * @param {boolean} options.firstWeekDay 为true则周数据时格式化成周一，默认false
     */
    UTIL.formatTime = function (date, granularity, options) {
        if (!date) { return; }
        if (!isDate(date)) { date = new Date(date); }
        options = options || {};

        switch (granularity) {
            case 'D': 
                return dateToString(date, 'yyyy-MM-dd');
            case 'W':
                return options.firstWeekDay 
                    // 取周一
                    ? dateToString(getWorkday(date), 'yyyy-MM-dd')
                    // 保留原来日期
                    : dateToString(date, 'yyyy-MM-dd')
            case 'M':
                return dateToString(date, 'yyyy-MM');
            case 'Q':
                return date.getFullYear() + '-Q' + getQuarter(date);
            case 'Y':
                return String(date.getFullYear());
            default: 
                return '';
        }
    };

    /**
     * 由DI约定的字符串时间格式得到Date对象
     *
     * @public
     * @param {Date|string} date 目标时间
     */
    UTIL.parseTime = function (dateStr) {
        if (!dateStr) { return null; }
        if (isDate(dateStr)) { return dateStr; }

        if (dateStr.indexOf('-Q') >= 0) {
            var par = [0, 0, 3, 6, 9];
            dateStr = dateStr.split('-Q');
            return new Date(
                parseInt(dateStr[0], 10), 
                par[parseInt(dateStr[1], 10)], 
                1
            );
        }
        else {
            return stringToDate(dateStr);
        }
    };    

    /**
     * 解析标准化的时间定义。
     * 标准化的时间定义由timeUtil数组组成，或者是单纯的一个timeUnit。
     *（timeUtil定义由parseTimeUtitDef方法规定
     * 例如: 
     *      时间定义可以是一个timeUnit: [+1D, +5W]
     *      也可以是timeUnit组成的数组: [[+1D, +5W], [+5W, +10Q], ...]
     *
     * @param {(Array.<Array.<string>>|Array.<string>)} def 时间定义
     * @param {(Array.<string>|Array.<Date>)} ref 基准时间
     * @return {Array.<Object>} timeUnitList 结果时间单元数组，
     *      其中每个数组元素的格式见parseTimeUnitDef的返回。
     */
    UTIL.parseTimeDef = function (def, ref) {
        var dArr = [];
        var retArr = [];
        if (isArray(def) && def.length) {
            var def0 = def[0];
            if (isString(def0)) {
                dArr = [def];
            }
            else if (isArray(def0)) {
                dArr = def;
            }
            else {
                UTIL.assert('TimeDef illegal: ' + def);
            }
            for (var i = 0, unit; i < dArr.length; i ++) {
                if (isArray(unit = dArr[i])) {
                    retArr.push(UTIL.parseTimeUnitDef(unit, ref));
                }
                else {
                    UTIL.assert('TimeDef illegal: ' + def);
                }
            }
        }

        return retArr;
    };

    /**
     * 解析标准化的时间单元定义
     * 时间单元用于描述一个时间或者一段时间
     * 
     * @param {Array.<string>} def 时间单元定义，其中：
     *      数组第一个元素表示def.start，即开始时间，
     *                      绝对值（如2012-12-12）
     *                      或相对于基准时间的偏移（如-5d）
     *      数组第二个元素表示def.end 结束时间，格式同上。（可缺省）
     *      数组第三个元素表示def.range 区间，相对于start或end的偏移（如-4d）（可缺省）
     *                  如果已经定义了start和end，则range忽略。
     *                  如果start或end只有一个被定义，则range是相对于它的偏移。
     *                  如果只有start被定义，则只取start。
     *                  例如start是+1ME，range是+5WB，
     *                  表示一个时间范围：从下月的最后一天开始，到下月最后一天往后5周的周一为止。
     * @param {(Array.<string>|Array.<Date>)} ref 基准时间
     *      格式同上，但数组中每个项都是绝对时间
     * @return {Object} timeUnit 结果时间单元
     * @return {Date} timeUnit.start 开始时间
     * @return {Date} timeUnit.end 结束时间
     */
    UTIL.parseTimeUnitDef = function (def, ref) {
        if (!def || !def.length) {
            return null;
        }

        var ret = {};
        var start = def[0];
        var end = def[1];
        var interval = def[2];

        ret.start = UTIL.parseTimeOffset(ref[0], start);
        ret.end = UTIL.parseTimeOffset(ref[1], end);

        // range情况处理
        if ((!start || !end) && interval) {
            var from;
            var to;
            if (start) {
                from = 'start';
                to = 'end';
            }
            else {
                from = 'end';
                to = 'start';
            }
            ret[to] = UTIL.parseTimeOffset(ret[from], interval);
        }
        else if (!end && !interval) {
            ret.end = ret.start;
        }

        return ret;
    };

    /**
     * 解析时间的偏移表达式
     *
     * @public
     * @param {(Date|string)} baseDate 基准时间，
     *      如果为 {string} 则格式为yyyy-MM-dd
     * @param {string} offset 偏移量，
     *      第一种情况是：
     *          用YMDWQ（年月日周季）分别表示时间粒度，
     *          用B/E表示首尾，如果没有B/E标志则不考虑首尾
     *          例如：
     *              假如baseDate为2012-05-09
     *              '+4D'表示baseDate往后4天，即2012-05-13 
     *              '-2M'表示往前2个月（的当天），即2012-03-13
     *              '2Q'表示往后2个季度（的当天），即2012-11-13
     *              '1W'表示往后1周（的当天），即2012-05-20
     *              '1WB'表示往后1周的开头（周一），即2012-05-14
     *              '-1WE'表示往前一周的结束（周日），即2012-05-06
     *              '0WE'表示本周的结束（周日），即2012-05-13
     *              月、季、年同理
     *      第二种情况是：直接指定日期，如yyyy-MM-dd，
     *          则返回此指定日期
     *      第三种情况是：空，则返回空
     * @return {Date} 解析结果
     */
    UTIL.parseTimeOffset = function (baseDate, offset) {
        if (offset == null) { return null; }
        if (!baseDate) { return baseDate; }
        
        if (isString(baseDate)) {
            baseDate = UTIL.parseTime(baseDate);
        }
        offset = offset.toUpperCase();
        
        var t = [
            baseDate.getFullYear(), 
            baseDate.getMonth(), 
            baseDate.getDate()
        ];
        var p = { Y: 0, M: 1, D: 2 };

        if (/^([-+]?)(\d+)([YMDWQ])([BE]?)$/.test(offset)) {
            var notMinus = !REGEXP.$1 || REGEXP.$1 == '+';
            var off = parseInt(REGEXP.$2);
            var timeType = REGEXP.$3;
            var beginEnd = REGEXP.$4;

            if ('YMD'.indexOf(timeType) >= 0) {
                t[p[timeType]] += notMinus ? (+ off) : (- off);
            }
            else if (timeType == 'W') {
                off = off * 7;
                t[p['D']] += notMinus ? (+ off) : (- off);
            }
            else if (timeType == 'Q') {
                off = off * 3;
                t[p['M']] += notMinus ? (+ off) : (- off);
            }
            var ret = new Date(t[0], t[1], t[2]);

            if (beginEnd) {
                if (timeType == 'Y') {
                    beginEnd == 'B'
                        ? (
                            ret.setMonth(0),
                            ret.setDate(1)
                        )
                        : (
                            ret.setFullYear(ret.getFullYear() + 1),
                            ret.setMonth(0),
                            ret.setDate(1),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
                else if (timeType == 'M') {
                    beginEnd == 'B'
                        ? ret.setDate(1)
                        : (
                            ret.setMonth(ret.getMonth() + 1),
                            ret.setDate(1),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
                else if (timeType == 'W') {
                    ret = (beginEnd == 'B' ? getWorkday : getWeekend)(ret);
                }
                else if (timeType == 'Q') {
                    (beginEnd == 'B') 
                        ? (ret = getQuarterBegin(ret))
                        : (
                            ret.setMonth(ret.getMonth() + 3),
                            ret = getQuarterBegin(ret),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
            }

            return ret;
        }
        else {
            return UTIL.parseTime(offset);
        }
    };

    /**
     * 季度格式解析，格式形如：2012-Q1
     *
     * @param {string} dateStr 季度字符串
     * @return {Date} 季度第一天日期
     */
    UTIL.parseQuarter = function (dateStr) {
        var par = [0, 0, 3, 6, 9];
        dateStr = dateStr.split('-Q'); 
        return new Date(
            parseInt(dateStr[0], 10), 
            par[parseInt(dateStr[1], 10)], 
            1
        );
    };

    /**
     * json stringify
     *
     * @param {Object} obj 对象
     * @return {string} json 字符串
     */
    UTIL.jsonStringify = function (obj) {
        return obj ? stringify(obj) : '';
    };

    /**
     * ecui 发事件
     * 没有ecui时则直接返回
     *
     * @param {ecui.ui.Control} control ECUI 控件
     * @param {string} name 事件名称
     * @param {Object} event 事件对象
     * @param {Array} args 事件参数
     */
    UTIL.ecuiTriggerEvent = function (control, name, event, args) {
        if (!ecui) { return; }
        return ecui.triggerEvent(control, name, event, args);
    };  

    /**
     * ecui 添加监听器
     * 没有ecui时则直接返回
     *
     * @param {ecui.ui.Control} control ECUI 控件
     * @param {string} name 事件名称
     * @param {Function} caller 监听函数
     * @param {boolean=} once 是否只执行一次就注销
     */
    UTIL.ecuiAddEventListener = function (control, name, caller, once) {
        if (!ecui) { return; }

        var newCaller = once 
            ? function () {
                // 运行一次后就注销自己
                ecui.removeEventListener(control, name, arguments.callee);
                // 执行原来caller
                return caller.apply(this, arguments);
            }
            : caller;

        return ecui.addEventListener(control, name, newCaller);
    };    

    /**
     * ecui 析构控件
     * 没有ecui时则直接返回
     *
     * @param {ecui.ui.Control|HTMLElement} control 
     *      需要释放的控件对象或包含控件的 Element 对象
     */
    UTIL.ecuiDispose = function (control) {
        ecui && ecui.dispose(control);
    };

    /**
     * 是否是ecui控件
     *
     * @param {Object} obj 对象
     * @return {boolean} 是否是ecui控件
     */
    UTIL.isEcuiControl = function (obj) {
        return !!(ECUI_CONTROL && obj instanceof ECUI_CONTROL);
    };

    /**
     * 下载
     * 只支持下载失败的判断。
     * （在iframe的onload中使用readyState判断，如果下载成功则不会走onload）
     * 默认情况失败则弹窗提示。
     *
     * @public
     * @param {Object} url 链接和参数
     * @param {Function} onfailure 失败的回调
     * @param {boolean} showDialog 显示对话框提示。默认不显示。
     */
    UTIL.download = function (url, onfailure, showDialog) {
        onfailure = onfailure || new Function();

        var failureHandler = showDialog 
            ? function () {
                DIALOG.alert(LANG.SAD_FACE + LANG.DOWNLOAD_FAIL, onfailure);
            }
            : onfailure;

        var elDownload = g(downloadIframeId);
        if (!elDownload) {
            var elDownload = document.createElement('iframe');
            elDownload.id = downloadIframeId;
            elDownload.style.display = 'none';
            document.body.appendChild(elDownload);
        }

        elDownload.onload = function () {
            var doc = elDownload.contentWindow.document;
            
            if (doc.readyState == 'complete' || doc.readyState == 'loaded') {
                failureHandler();
            }

            elDownload.onload = null;
        };

        // 开始下载
        elDownload.src = url;
    };

    /**
     * 新开窗口
     *
     * @public
     * @param {string} url 目标url
     */
    UTIL.targetBlank = function (url) {
        var doc = document;
        var body = doc.body;
        var el = doc.createElement('a');
        el.style.display = 'none';
        el.href = url || '#';
        el.target = '_blank';
        body.appendChild(el);
        el.click();
        body.removeChild(el);
    };

    /**
     * 对每个对象，执行方法
     *
     * @public
     * @param {Array} list 要执行方法的对象列表
     * @param {string} methodName 要执行的方法名
     */
    UTIL.foreachDo = function (list, methodName) {
        for (var i = 0, o; i < list.length; i ++) {
            (o = list[i]) && (
                o.$di
                    ? o.$di(methodName)
                    : o[methodName]
            );
        }
    };

    var downloadIframeId = String(
        'download-iframe-' + Math.round(Math.random() * 10000000000000)
    );

    function naming (attrName, prefix) {
        return prefix + attrName.charAt(0).toUpperCase() + attrName.slice(1);
    }
    
    function attrNaming (attrName, o) {
        var prefix = '';
        if (UTIL.isEcuiControl(o)) {
            prefix = '_u';
        } else if (isArray(o)) {
            prefix = '_a';
        } else if (isFunction(o)) {
            prefix = '_f';
        } else {
            prefix = '_m';
        }
        return naming(attrName, prefix);
    }

    //-------------------------------------------------------
    // 逻辑表达式
    //-------------------------------------------------------

    /**
     * 计算json配置的逻辑表达式
     * 
     * @public
     * @param {Object} jsonLogicExp 表达式
     *      支持与（and）、或（or）非（not）逻辑。
     *      原子语句的判断由使用提供（atomCal）
     *      原子语句必须是对象形式定义
     *      格式例如：（array的第一个元素是操作符，后面是操作数）
     *      [
     *          'and',
     *           [ 
     *               'or',
     *               { someCustomerRule: 'asdf', someValue: 1234 },
     *               { someCustomerRule: 'asdf', someValue: 1234 },
     *               { someCustomerRule: 'asdf', someValue: 1234 }
     *           ],
     *           { someCustomerRule: 'zcvcxz', someValue: 32432 }
     *      ]
     *
     * @param {Function} atomCalFunc 原子语句的计算的回调函数
     *      参数为{Object}格式的原子语句
     *      返回值为{boolean}表示判断结果
     * @return {boolean} 计算结果
     */
    UTIL.evalJsonLogic = function (jsonLogicExp, atomCalFunc) {
        if (!jsonLogicExp || !atomCalFunc) {
            jsonLogicExpError(jsonLogicExp);
        }

        var operator;
        var i;
        var ret;

        // 是逻辑表达式
        if (isArray(jsonLogicExp)) {

            jsonLogicExp.length < 2 && jsonLogicExpError(jsonLogicExp);

            operator = jsonLogicExp[0];
            if (operator == 'and') {
                ret = true;
                for (i = 1; i < jsonLogicExp.length; i ++) {
                    ret = ret && UTIL.evalJsonLogic(
                        jsonLogicExp[i], atomCalFunc
                    );
                }
                return ret;
            }
            else if (operator == 'or') {
                ret = false;
                for (i = 1; i < jsonLogicExp.length; i ++) {
                    ret = ret || UTIL.evalJsonLogic(
                        jsonLogicExp[i], atomCalFunc
                    );
                }
                return ret;
            }
            else if (operator == 'not') {
                return !UTIL.evalJsonLogic(
                    jsonLogicExp[i], atomCalFunc
                );
            }
            else {
                jsonLogicExpError(jsonLogicExp);
            }
        }
        // 是原子语句
        else {
            return atomCalFunc(jsonLogicExp);
        }
    };

    function jsonLogicExpError(jsonLogicExp, msg) {
        throw new Error(
            'Illegle json logic express, ' + (msg || '') 
            + '. ' + stringify(jsonLogicExp)
        );
    }

    //-------------------------------------------------------
    // dom相关 (modified based on tangram and ecui)
    //-------------------------------------------------------

    /**
     * 获取横向滚动量
     * 
     * @public
     * @param {Window} win 指定window
     * @return {number} 横向滚动量
     */
    UTIL.getScrollLeft = function (win) {
        win = win || window;
        var d = win.document;
        return win.pageXOffset || d.documentElement.scrollLeft || d.body.scrollLeft;
    };

    /**
     * 获取纵向滚动量
     *
     * @public
     * @param {Window} win 指定window
     * @return {number} 纵向滚动量
     */
    UTIL.getScrollTop = function (win) {
        win = win || window;
        var d = win.document;
        return win.pageYOffset || d.documentElement.scrollTop || d.body.scrollTop;
    };

    /**
     * 获取页面视觉区域宽度
     *             
     * @public
     * @param {Window} win 指定window
     * @return {number} 页面视觉区域宽度
     */
    UTIL.getViewWidth = function (win) {
        win = win || window;
        var doc = win.document;
        var client = doc.compatMode == 'BackCompat' ? doc.body : doc.documentElement;

        return client.clientWidth;
    };

    /**
     * 获取页面视觉区域高度
     * 
     * @public
     * @param {Window} win 指定window
     * @return {number} 页面视觉区域高度
     */
    UTIL.getViewHeight = function (win) {
        win = win || window;
        var doc = win.document;
        var client = doc.compatMode == 'BackCompat' ? doc.body : doc.documentElement;

        return client.clientHeight;
    };

    /**
     * 获取页面宽度
     *
     * @public
     * @param {Window} win 指定window
     * @return {number} 页面宽度
     */
    UTIL.getWidth = function (win) {
        win = win || window;
        var doc = win.document;
        var body = doc.body;
        var html = doc.documentElement;
        var client = doc.compatMode == 'BackCompat' ? body : doc.documentElement;

        return Math.max(html.scrollWidth, body.scrollWidth, client.clientWidth);
    };

    /**
     * 获取页面高度
     *             
     * @public
     * @param {Window} win 指定window
     * @return {number} 页面高度
     */
    UTIL.getHeight = function (win) {
        win = win || window;
        var doc = win.document;
        var body = doc.body;
        var html = doc.documentElement;
        var client = doc.compatMode == 'BackCompat' ? body : doc.documentElement;

        return Math.max(html.scrollHeight, body.scrollHeight, client.clientHeight);
    };

    //-------------------------------------------------
    // Deprecated
    //-------------------------------------------------

    /**
     * 注入ui和model的方便方法
     * 
     * @public 
     * @deprecated
     * @usage 例如：util.ref(container, 'abc', o); 
     *        则首先会去container中寻找方法setAbc调用，
     *        如果没有则直接对属性进行赋值：
     *              前缀映射举例：
     *                  {ecui.ui.Control} => _uAbc
     *                  {Array} => _aAbc
     *                  {Function} => _fAbc
     *                  {others} => _mAbc
     * @param {Object} container 目标容器
     * @param {string} attrName 属性名
     * @param {ecui.ui.Contorl|SomeModel|Array|Function} o 被设置内容
     * @return {ecui.ui.Contorl|SomeModel|Array|Function} o 被设置内容
     */
    UTIL.ref = function (container, attrName, o) {
        var f;
        if (isFunction(f = container[naming(attrName, 'set')])) {
            f.call(container, o);
        } else if (hasValue(f = attrNaming(attrName, o))){
            container[f] = o;
        }
        return o;
    };
    
    /**
     * 从对象中得到model的方便方法
     * 
     * @deprecated
     * @public 
     * @usage 例如：util.getModel(container, 'abc'); 
     *        则首先会去container中寻找方法getAbc调用，
     *        如果没有则直接从属性container._mAbc中取
     * @param {Object} container 目标容器
     * @param {string} attrName 属性名
     * @return {SomeModel} o 模型对象
     */
    UTIL.getModel = function (container, attrName) {
        var f;
        if (isFunction(f = container[naming(attrName, 'get')])) {
            return f.call(container);
        } else {
            return container[naming(attrName, '_m')];
        }
    };

})();
/**
 * di.helper.ArgHandlerFactory
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    默认的参数解析方法集合
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 */

$namespace('di.shared.arg');
 
(function () {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var isObject = xutil.lang.isObject;
    var extend = xutil.object.extend;
    var getByPath = xutil.object.getByPath;
    var setByPath = xutil.object.setByPath;
    var isArray = xutil.lang.isArray;
    var formatTime = di.helper.Util.formatTime;
    var parseTimeUnitDef = di.helper.Util.parseTimeUnitDef;
    var assign = xutil.object.assign;
    var merge = xutil.object.merge;
    var DI_FACTORY;

    $link(function () {
        DI_FACTORY = di.shared.model.DIFactory;
    });

    /**
     * 默认的参数解析方法集合
     * 约定：所有parser的
     *      this：是参数所属的函数被调用时的scope。
     *      输入：
     *          {Array} tarArgs 要处理的参数数组。
     *          {*...} 其余参数。
     *
     * 注意GeneralArgHandler如果要更改原参数对象的内容，需要新建副本，
     * 以免影响其他事件处理器的响应。
     *
     * 得到argHandler的方法：
     *      var argHandler = di.helper.ArgHandlerFactory(
     *          [somObj1, 'handlerName1', 'asdf', 'zxcv', ...],
     *          [null, 'handlerName2', 'zxz', 1242, ...]
     *      );
     * 则得到了一个argHandler，其中会顺序调用handlerName1, handlerName2
     * handlerName1调用时，'asdf', 'zxcv', ... 会作为后面的参数自动传入，
     * handlerName2同理。
     *
     * @param {Array...} descs 
     *          每个Array：
     *              第一个元素是转换函数调用时的scope（可缺省），
     *              第二个元素是转换函数名，
     *              以后的元素是转换函数调用时，tarArgs后面的参数。
     * @return {Function} 参数转换函数
     */
    $namespace().ArgHandlerFactory = function (descs) {
        // 目前全由内部提供，后续支持可扩展
        if (arguments.length < 1) {
            return null;
        }

        var funcs = [];

        // 这其中会进行check，如果非法则返回空
        for (var i = 0, desc; i < arguments.length; i ++) {
            desc = arguments[i];
            funcs.push(
                [
                    desc[0], 
                    NS[desc[1]], 
                    desc.slice(2)
                ]
            );
            if (!funcs[funcs.length - 1][1]) {
                return null;
            }
        }

        return function (tarArgs) {
            // 链式调用各个argHandler
            for (var i = 0, func; func = funcs[i]; i ++) {
                func[1].apply(
                    func[0], 
                    [tarArgs].concat(func[2])
                );
            }
            return tarArgs;
        }
    }

    var NS = {};

    /**
     * 清除参数内容
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {number=} index 参数index，如果缺省则全部清除
     */
    NS.clear = function (tarArgs, index) {
        if (index != null) {
            tarArgs[index] = void 0;
        }
        else {
            for (var i = 0; i < tarArgs.length; i ++) {
                tarArgs[i] = void 0;
            }
        }
    };

    /**
     * 对第一个参数，根据源属性路径取得值，根据目标属性路径放到结果对象中。
     * 属性路径例如'aaa.bbb[3][4].ccc.ddd'
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} srcPath 源属性路径，如果为null，则取数组元素本身
     * @param {string} tarPath 目标属性路径，如果为null，则放到数组元素本身上
     * @param {number} index 对第哪个参数进行操作，默认为0
     * @param {Object=} options 参见xutil.object.setByPath的options
     */
    NS.attr = function (tarArgs, srcPath, tarPath, index, options) {
        index = String(index || 0);
        var value = tarArgs[index];
        setByPath(
            !tarPath ? index : (index + '.' + tarPath),
            isObject(value) ? getByPath(srcPath, value, options) : value,
            tarArgs,
            options
        );
    };

    /**
     * 对第一个参数，按arrPath得到数组，对每一个元素，按arcPath和tarPath进行转换
     * 属性路径例如'aaa.bbb[3][4].ccc.ddd'
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} arrPath 数组目标，如果为null，则取tarArgs[0]本身
     * @param {string} srcPath 源属性路径，如果为null，则取数组元素本身
     * @param {string} tarPath 目标属性路径，如果为null，则放到数组元素本身上
     * @param {Object=} options 参见xutil.object.setByPath的options
     */
    NS.attrArr = function (tarArgs, arrPath, srcPath, tarPath, options) {
        var value = tarArgs[0];
        var arr = isObject(value)
            ? (
                arrPath 
                    ? getByPath(arrPath, value, options) 
                    : value
            )
            : null;

        if (isArray(arr)) {
            for (var i = 0, itemA; i < arr.length; i ++) {
                NS.attr(arr, srcPath, tarPath, i, options);
            }
        }
    };

    /**
     * 设置数据（用于配置时）
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {*} data 数据
     * @param {number} index 向第哪个参数，默认为0
     */
    NS.setData = function (tarArgs, data, index) {
        tarArgs[index || 0] = data;
    };

    /**
     * merge数据（用于配置时）
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {*} data 数据
     * @param {number} index 向第哪个参数，默认为0
     */
    NS.mergeData = function (tarArgs, data, index) {
        merge(tarArgs[index || 0], data);
    };

    /**
     * 从diIdList给定的id对应的di实例中用getValue取值，
     * 覆盖到tarArgs第一个参数中。
     *
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} di实例的id
     * @param {string} srcPath 源属性路径
     * @param {string} tarPath 目标属性路径
     * @param {Object=} options 参见xutil.object.setByPath的options
     */
    NS.getValue = function (tarArgs, diId, srcPath, tarPath, options) {
        var ins = DI_FACTORY().getEntity(diId, 'INS');
        var o = [];
        if (ins && ins.$di) {
            var value = ins.$di('getValue');
            setByPath(
                !tarPath ? '0' : ('0.' + tarPath), 
                isObject(value) ? getByPath(srcPath, value, options) : value,
                o,
                options
            );
            
            if (isObject(o[0])) {
                extend(tarArgs[0] || (tarArgs[0] = {}), o[0]);
            }
            else {
                tarArgs[0] = o[0];
            }
        }
    };

    /**
     * 修正时间
     * 应用场景例如：可以在这里配置固定时间，隐含时间等界面输入无法不表达出的时间参数
     *
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} attrName 参数属性名
     * @param {Object.<Array.<string>>} timeUnitDefMap 按此参数修正时间。 
     *      格式例如：{ D: ['-1Y', '0D'], W: ['-1Y', '0D'], M: ['-24M', '0D'], Q: ['-2Y', '0D'] }
     */
    NS.patchTime = function (tarArgs, attrName, timeUnitDefMap) {
        var arg = tarArgs[0];
        if (isObject(arg) && isObject(arg = arg[attrName])) {
            var gran = arg.granularity;
            arg = parseTimeUnitDef(
                timeUnitDefMap[gran], 
                [arg.start, arg.end, arg.range]
            );
            arg.start = formatTime(arg.start, gran);
            arg.end = formatTime(arg.end, gran);
            extend(tarArgs[0][attrName], arg);
        }
    };

})();
/**
 * di.shared.model.AuthModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [通用模型] 权限数据模型
 * author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function () {
    
    /* 外部引用 */
    var inheritsObject = xutil.object.inheritsObject;
    var XDATASOURCE = xui.XDatasource;
        
    /* 类型声明 */
    var AUTH_MODEL = $namespace().AuthModel = inheritsObject(XDATASOURCE);
    var AUTH_MODEL_CLASS = AUTH_MODEL.prototype;
        
    /**
     * 获得用户Id
     * @public
     * 
     * @return {string} 用户id
     */
    AUTH_MODEL_CLASS.getUserId = function () {
        // TODO
    };    
    
})();


/**
 * di.shared.model.DateModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [通用模型] 时间数据模型
 * author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function() {
    
    /* 外部引用 */
    var inheritsObject = xutil.object.inheritsObject; 
    var XDATASOURCE = xui.XDatasource;
        
    /* 类型声明 */
    var DATE_MODEL = $namespace().DateModel = inheritsObject(XDATASOURCE);
    var DATE_MODEL_CLASS = DATE_MODEL.prototype;
        
    /**
     * 初始化当前值
     * @override
     */
    DATE_MODEL_CLASS.setData = function(data) {
        this.businessData = true;
        this._nInitServerTime = parseInt(data.serverTime) || new Date().getTime();
        this._nServerTimeOffset = this._nInitServerTime - (new Date).getTime();
    };
    
    /**
     * 获得服务器的当前时间
     * 不保证准确的地方：
     * 1. 网路延迟没有考虑
     * 2. 如果用户在打开了网页后修改了客户端的系统时间，则此值会错误
     * @public
     * 
     * @return {Date} 当前时间
     */
    DATE_MODEL_CLASS.now = function() {
        var date = new Date();
        date.setTime(date.getTime() + this._nServerTimeOffset);
        return date;
    };
    
})();


/**
 * di.shared.model.UserModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    [通用模型] 用户数据模型
 * @author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function () {
    
    /* 外部引用 */
    var inheritsObject = xutil.object.inheritsObject;
    var XDATASOURCE = xui.XDatasource;
        
    /* 类型声明 */
    var USER_MODEL = $namespace().UserModel = inheritsObject(XDATASOURCE);
    var USER_MODEL_CLASS = USER_MODEL.prototype;
        
    /**
     * 获得用户Id
     * @public
     * 
     * @return {string} 用户id
     */
    USER_MODEL_CLASS.getUserId = function () {
        // TODO
    };    
    
})();


/**
 * di.shared.model.GlobalModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [通用模型] 全局数据模型
 * author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

/**
 * @usage 单例，直接如此获取单例即可：var g = di.shared.GlobalModel();
 */
(function() {
    
    /* 外部引用 */
    var inherits = xutil.object.inherits;
    var USER_MODEL;
    var AUTH_MODEL;
    var DATE_MODEL;
    var GLOBAL_MENU_MANAGER;
    var XDATASOURCE = xui.XDatasource;
    
    $link(function() {
        var sharedNS = di.shared;
        USER_MODEL = sharedNS.model.UserModel;
        AUTH_MODEL = sharedNS.model.AuthModel;
        DATE_MODEL = sharedNS.model.DateModel;
        GLOBAL_MENU_MANAGER = sharedNS.model.GlobalMenuManager;
    });
    
    /* 类型声明 */
    var GLOBAL_MODEL = $namespace().GlobalModel = function(options) {
            if (instance && options) {
                throw new Error('global model has been created');
            }
            if (!instance && !options) {
                throw new Error('global model creation needs options');
            }

            if (!instance) {
                (instance = new SINGLETON(options))
            }
            return instance;
        };
    var GLOBAL_MODEL_CLASS = inherits(GLOBAL_MODEL, XDATASOURCE);
        
    function SINGLETON(options) {
        XDATASOURCE.client.call(this);

        // 初始化全局模型
        this._mUserModel = new USER_MODEL();
        this._mAuthModel = new AUTH_MODEL();
        this._mDateModel = new DATE_MODEL();
        this._mDateModel.setData(options);

        this._sGlobalType = options.globalType;
        if (this._sGlobalType == 'CONSOLE') {
            this._mGlobalMenuManager = new GLOBAL_MENU_MANAGER(options)
        }
    };
    
    var instance;

    /**
     * 获得DateModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getDateModel = function() {
        return this._mDateModel;
    };
    
    /**
     * 获得UserModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getUserModel = function() {
        return this._mUserModel;
    };
    
    /**
     * 获得AuthModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getAuthModel = function() {
        return this._mAuthModel;
    };
    
    /**
     * 获得GlobalMenuManager
     * @public
     */
    GLOBAL_MODEL_CLASS.getGlobalMenuManager = function() {
        return this._mGlobalMenuManager;
    };

    inherits(SINGLETON, GLOBAL_MODEL);
    
})();


/**
 * di.shared.model.DIFactory
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    工厂
 *           约定：
 *              各种组件的类型均从这里获取，不直接引用。
 *              全局实例从这里获取。
 *           
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {



    //-------------------------------------------------------
    // 引用 
    //-------------------------------------------------------

    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var DIALOG = di.helper.Dialog;
    var xlang = xutil.lang;
    var xobject = xutil.object;
    var xurl = xutil.url;
    var isString = xlang.isString;
    var isArray = xlang.isArray;
    var isObject = xlang.isObject;
    var isFunction = xlang.isFunction;
    var isEmptyObj = xobject.isEmptyObj;
    var getByPath = xobject.getByPath;
    var objKey = xobject.objKey;
    var assign = xobject.assign;
    var extend = xobject.extend;
    var merge = xobject.merge;
    var clone = xobject.clone;
    var getUID = xutil.uid.getUID;
    var bind = xutil.fn.bind;
    var assert = UTIL.assert;
    // FIXME
    // 独立此引用
    var ecuiAddEventListener = UTIL.ecuiAddEventListener;
    var ecuiTriggerEvent = UTIL.ecuiTriggerEvent;
    var targetBlank = UTIL.targetBlank;
    var objProtoToString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var arrayPush = Array.prototype.push;
    var isEcuiControl = UTIL.isEcuiControl;
    var evalJsonLogic = UTIL.evalJsonLogic;
    var stringifyParam = xurl.stringifyParam;
    var XOBJECT = xui.XObject;
    var COMMON_PARAM_FACTORY;
    var ARG_HANDLER_FACTORY;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

        



    //----------------------------------------------------------
    // 类型声明 
    //----------------------------------------------------------

    /**
     * Unit工厂
     * 
     * @usage
     *      单例，
     *      这样得到实例：var unitFactory = di.shared.model.DIFactory();
     */
    $namespace().DIFactory = function () {
        if (!instance) {

            instance = {
                installClz: installClz,
                getClz: getClz,
                addEntity: addEntity,
                removeEntity: removeEntity,
                createIns: createIns,
                mountInteractions: mountInteractions,
                mountInteraction: mountInteraction,
                getDIMethod: getDIMethod,
                getEntity: function (id, mode) {
                    return getEntity(id, mode == 'RAW' ? 'DEF' : mode);
                },
                findEntity: findEntity,
                forEachEntity: forEachEntity,
                createDIEvent: createDIEvent,
                getRef: getRef,
                mergeOpt: mergeOpt,
                setGlobalTemp: setGlobalTemp,
                getGlobalTemp: getGlobalTemp,
                setEventChannel: setEventChannel,
                getEventChannel: getEventChannel,
                setInteractMemo: setInteractMemo,
                getInteractMemo: getInteractMemo,
                rootSnippet: rootSnippet,
                isDIEvent: isDIEvent,
                setFuncAuth: setFuncAuth,
                INIT_EVENT_NAME: INIT_EVENT_NAME,
                INIT_EVENT_AGENT_ID: INIT_EVENT_AGENT_ID
            };
        }
        return instance;
    };





    //----------------------------------------------------------
    // 常量/内部变量
    //----------------------------------------------------------

    /**
     * 为实例挂载属性或方法时使用的前缀，
     * 以及一些隐含的引用名
     */
    var DI_ATTR_PREFIX = '\x06diA^_^';
    var DI_METHOD_PREFIX = '\x06diM^_^';
    var DI_DEF_TAG = '\x06diDef^_^';
    var DI_EVENT_AGENT_TAG = '\x06diEAgt^_^';
    var DI_EVENT_TAG = '\x06diEvt^_^';
    var DI_TMP_TAG = '\x06diTmp^_^';
    var DI_OPT_HOME_TAG = '\x06diOpt^_^';
    var DI_OPT_CACHE_TAG = '\x06diOpt_cache^_^';
    var DI_OPT_ID_TAG = '\x06diOpt_id^_^';
    var SEP = '\x06_';
    var INIT_EVENT_NAME = '\x06diEvt_init^_^';
    var INIT_EVENT_AGENT_ID = '\x06diEvtAgtId_init^_^';

    /**
     * clzType
     */
    var INS_CLZ_TYPE = [
        'SNIPPET',
        'COMPONENT',
        'VUI',   
        'VCONTAINER',
        'VPART'
    ];

    /**
     * 默认的vui adapter
     */
    var GENERAL_ADAPTER_METHOD_PATH = 'di.shared.adapter.GeneralAdapterMethod';
    var generalAdapterMethod;

    /**
     * DIFactory实例
     */
    var instance;

    /**
     * 库
     */
    var repository = {
        // 类库
        CLZ: {},

        // 各种实例库
        SNIPPET: {},
        SNIPPET_DEF: {},
        COMPONENT: {},
        COMPONENT_DEF: {},
        VUI: {},   
        VUI_DEF: {},   
        VCONTAINER: {},
        VCONTAINER_DEF: {},
        VPART: {},
        VPART_DEF: {}
    };

    /**
     * 根snippet
     */
    var rootSnippetId;

    /**
     * 对外事件通道
     */
    var eventChannel;

    /**
     * 设置或获取临时全局参数，参见setGlobalTemp
     */
    var globalTempData = {};

    /**
     * 功能权限key集合
     */
    var funcAuthKeys = {};



    //-----------------------------------------------------------------
    // 契约方法
    //-----------------------------------------------------------------

    /**
     * 调用挂载到各个实例上的di方法（如果找不到，则调用同名原有方法）
     * 挂载后，在实例中使用this.$di('someMethodName')调用挂载的方法
     * 如果调用时要传参，则为this.$di('someMethodName', arg1, arg2)
     * （PS：之所以没做成$di('someMethodName')(arg1, arg2)的样子，
     * 因为这样不好得到this）
     *
     * @param {string} methodName 方法名
     * @param {*...} args 调用参数
     */
    var $di = {
        INS: function (methodName, args) {
            return (
                // 寻找di挂载的方法
                this[DI_METHOD_PREFIX + methodName]
                // 如果找不到，则调用同名原有方法
                || this[methodName]
            ).apply(
                this,
                Array.prototype.slice.call(arguments, 1)
            );
        },
        DEF: function (methodName, args) {
            return DEF_CONTRACT_METHOD[methodName].apply(
                this,
                Array.prototype.slice.call(arguments, 1)
            );
        }
    };

    /**
     * 通用契约方法，用于注入
     */
    var COMMON_CONTRACT_METHOD = {
        start: function (options) {
            var opt = options[DI_TMP_TAG];
            this.$di('setId', opt.id);
            this.$di('setEl', opt.el);

            var def = getEntity(opt.id, 'DEF');
            if (opt.el && opt.el.style.display == 'none') {
                setDIAttr(this, 'styleDisplay', def.styleDisplay);
            }

            var func; 
            (func = getDIMethod(this, 'setTplMode')) 
                && func.call(this, opt.tplMode);
            (func = getDIMethod(this, 'setCommonParamGetter')) 
                && func.call(this, opt.commonParamGetter);
        },

        getDIFactory: function () {
            return instance;
        },

        getMethod: function (methodName) {
            return getDIMethod(this, methodName);
        },

        getDef: function () {
            return getEntity(
                COMMON_CONTRACT_METHOD.getId.call(this),
                'DEF'
            );
        },

        setId: function (id) {
            setDIAttr(this, 'id', id);
        },

        getId: function () {
            return getDIAttr(this, 'id');
            // return getAttrIncludeGlobal(this, 'id');
        },

        setEl: function (el) {
            setDIAttr(this, 'el', el);
        },

        getEl: function (id) {
            return getDIAttr(this, 'el');
        },

        setTplMode: function (tplMode) {
            setDIAttr(this, 'tplMode', tplMode);
        },

        getTplMode: function () {
            return getDIAttr(this, 'tplMode');
            // return getAttrIncludeGlobal(this, 'tplMode');
        },

        setCommonParamGetter: function (commonParamGetter) {
            setDIAttr(this, 'commonParamGetter', commonParamGetter);
        },

        getCommonParamGetter: function () {
            return getDIAttr(this, 'commonParamGetter');
        },

        getEventChannel: getEventChannel,

        diShow: function () {
            var def = this.$di('getDef');
            var el = this.$di('getEl');
            var styleDisplay = getDIAttr(this, 'styleDisplay');
            var hideByAuth = getDIAttr(this, 'hideByAuth');
            if (styleDisplay != null && !hideByAuth) {
                setDIAttr(this, 'styleDisplay', null);
                el.style.display = styleDisplay;
            }
        },

        diHide: function () {
            var el = this.$di('getEl');
            if (el && getDIAttr(this, 'styleDisplay') == null) {
                setDIAttr(this, 'styleDisplay', el.style.display);
                el.style.display = 'none';
            }
        },

        /**
         * 设置耳聋，聋则不收到任何事件
         * 
         * @param {boolean} isDeaf 是否耳聋
         * @param {string=} key 禁用者的标志，缺省则忽略
         */
        setDeaf: function (isDeaf, key) {
            var keyName = 'deaf';

            // 设置禁用，并记录objKey
            if (isDeaf) {
                objKey.add(this, key, keyName);
                setDIAttr(this, keyName, true);
            }
            // 所有key都清除了，或者未传key，才解除禁用
            else {
                objKey.remove(this, key, keyName);
                (key == null || objKey.size(this, keyName) == 0)
                    && setDIAttr(this, keyName, false);
            }
        },

        isDeaf: function () {
            return getDIAttr(this, 'deaf');
        },

        /**
         * 设置getValue禁用
         * 
         * @param {boolean} valueDisabled 是否getValue禁用
         * @param {string=} key 禁用者的标志，缺省则忽略
         */
        setValueDisabled: function (valueDisabled, key) {
            var keyName = 'valueDisabled';

            // 设置禁用，并记录objKey
            if (valueDisabled) {
                objKey.add(this, key, keyName);
                setDIAttr(this, keyName, true);
            }
            // 所有key都清除了，或者未传key，才解除禁用
            else {
                objKey.remove(this, key, keyName);
                (key == null || objKey.size(this, keyName) == 0) 
                    && setDIAttr(this, keyName, false);
            }
        },

        isValueDisabled: function () {
            return getDIAttr(this, 'valueDisabled');
        },

        getClzType: 'placeholder',

        /**
         * 解禁操作
         *
         * @protected
         * @param {string=} key 禁用者的标志
         */
        disable: function (key) {
            objKey.add(this, key);

            if (!getDIAttr(this, 'disabled')) {
                setDIAttr(this, 'disabled', true);
                this.disable && this.disable();
            }
        },

        /**
         * 禁用操作
         *
         * @protected
         * @param {string=} key 禁用者的标志，空则无条件解禁
         */
        enable: function (key) {
            objKey.remove(this, key);

            if (objKey.size(this) == 0 && getDIAttr(this, 'disabled')) {
                setDIAttr(this, 'disabled', false);
                this.enable && this.enable();
            }
        },

        /**
         * 得到opt或opt值的统一入口
         *
         * @public
         * @param {string} optName 如cfgOpt、baseOpt
         * @param {string=} attr 属性名，如果为空，则得到opt本身
         * @return {Object} 得到的opt
         */
        getOpt: function (optName, attr) {
            var def = getEntity(this.$di('getId'), 'RAW');
            return getOpt(def, optName, attr, { clone: true });
        },

        /**
         * 设置def的参数
         *
         * @public
         * @param {string} optName 如cfgOpt、baseOpt
         * @param {string} attr 属性名
         * @param {*} value 属性值
         */
        setOpt: function (optName, attr, value) {
            var def = getEntity(this.$di('getId'), 'RAW');
            setOpt(def, optName, attr, value);
        },

        /** 
         * @param {string} refName 如'vuiRef'，'vpartRef'
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @param {string=} modee 值为'DEF'（默认）或者'INS'
         * @return {(Array.<Object>|Object)} ref的数组
         *      例如：vuiDef的内容为：
         *      {string} vuiDef.id ID
         *      {Object} vuiDef.clz 类
         *      {string} vuiDef.clzKey 类key
         *      {Object} vuiDef.initObject 初始化参数，可能为空
         */
        getRef: function (refName, refPath, mode) {
            return getRef(this, refName, refPath, mode)
        },

        /**
         * 为给定的事件使用事件代理。注册事件代理后，
         * 对此事件的addeventlistener和dispatch都只针对于代理，屏蔽了原生事件。
         * 此方法常用于vui的adapter。
         *
         * @public
         * @param {string=} eventName 事件名，缺省则对于全部事件都使用event agent
         */
        registerEventAgent: function (eventName) {
            registerEventAgent(this, eventName);
        },

        /**
         * 添加事件监听
         * 目前只支持XObject和ecui
         * 
         * @param {string} eventName 事件名
         * @param {Function} handler 事件处理函数
         * @param {Object} scope 域，handler执行时的this
         * @param {Object=} options 选项
         * @param {string=} options.interactionId interact的id
         * @param {string=} options.dispatcherId 触发event的di ins的id
         * @param {Function=} options.argHandler 参数转化函数，用于适配事件的参数
         *      输入为 {Array} 参数构成的数组
         *      输出为 {Array} 转化完成后的参数构成的数组
         *      注意argHandler如果要更改原参数对象的内容，需要新建副本，
         *      以免影响其他事件处理器的响应。
         * @param {Array} options.bindArgs 绑定的参数，总在最前面传入handler，
         *      但是不会传入argHandler
         * @param {boolean=} options.once handler是否只调用一次后就注销
         * @param {boolean=} options.dontClone 是否禁用clone。默认不禁用。
         *      clone的用意是，每次创建一个参数副本给事件处理器，
         *      防止事件处理修改了参数而影响其他事件处理器的调用，
         *      只有普通Object和Array和基本类型能被clone，否则抛置异常。
         * @param {(Function|boolean)=} checkDeaf 检查是否deaf，deaf则不响应事件
         *      默认是true，如果传false则不检查，如果传function则用此function检查
         * @param {string} options.viewDisableDef 视图禁用定义
         * @param {(Array|Object)=} options.rule 事件路径定义
         */
        addEventListener: function (
            eventName, handler, scope, options
        ) {
            assert(
                eventName && handler && scope, 
                'Event listener can not be empty.'
            );

            options = options || {};
            var argHandler = options.argHandler;
            var dontClone = options.dontClone;
            var once = options.once;
            var checkDeaf = options.checkDeaf;
            var bindArgs = options.bindArgs || [];
            var id = options.id;
            var dispatcherId = options.dispatcherId;
            var interactionId = options.interactionId;
            var viewDisableDef = options.viewDisableDef;
            var rule = options.rule;
            var eventMatchMode = options.eventMatchMode;
            var eventAgent = getEventAgentByName(this, eventName) || this;

            var newHandler = function () {
                // 耳聋则不响应事件
                if (checkDeaf !== false
                    && (isFunction(checkDeaf)
                            ? checkDeaf(scope)
                            : (scope && scope.$di && scope.$di('isDeaf'))
                    )
                ) {
                    return;
                }

                // 处理diEvent
                var diEvent = arguments[0];
                var args = Array.prototype.slice.call(
                    arguments,
                    isDIEvent(diEvent)
                        ? (
                            // diEvent或者由事件dispatch者传来
                            //（从而支持interactPath）
                            diEvent = cloneEvent(diEvent),
                            1
                        )
                        : (
                            // diEvent未传来，则在此处创建。
                            diEvent = createDIEvent(eventName),
                            0
                        )
                );
                // 注入触发事件的ins的diId
                setEventAttr(diEvent, 'dispatcherId', dispatcherId, true),
                setEventAttr(diEvent, 'interactionId', interactionId, true),
                diEvent.viewDisableDef = viewDisableDef;

                // 对interactionRule求值
                if (rule && !evalJsonLogic(
                        rule, 
                        bind(evalRule, null, diEvent)
                    )
                ) {
                    return;
                }

                // 克隆参数
                !dontClone && (args = argsClone(args));

                // 执行arg handler
                args = argHandler ? argHandler.call(scope, args) : args;

                // 设定interact memo
                scope.$di && setInteractMemo(scope, 'diEvent', diEvent);

                // 执行action
                var ret = handler.apply(scope, bindArgs.concat(args));

                // 清除interact memo
                scope.$di && setInteractMemo(scope, 'diEvent', void 0);

                return ret;
            };
            
            if (eventAgent instanceof XOBJECT) {
                eventAgent[once ? 'attachOnce' : 'attach'](eventName, newHandler);
            }
            else if (isEcuiControl(eventAgent)) {
                ecuiAddEventListener(eventAgent, eventName, newHandler, once);
            }

            options = null;
        },

        /**
         * 分发事件
         * 目前只支持XObject和ecui
         * 
         * @param {(string|DIEvent)} eventName 事件名（或者diEvent对象）
         * @param {Array} args 事件参数
         */
        dispatchEvent: function (eventName, args, options) {
            options = options || {};

            var eventAgent = getEventAgentByName(this, eventName) || this;

            // diEvent用以支持interactPath功能
            var diEvent;
            if (isDIEvent(eventName)) {

                // 这个限制，是为了保证：收到diEvent的eventHandler都是用$di('addEventListener')注册的
                // 因为diEvent要暗自用第一个参数传递，$di('addEventListener')注册的才能识别
                assert(
                    eventAgent != this,
                    '如果使用diEvent，必须先registerEventAgent。'
                );

                diEvent = eventName;
                eventName = diEvent.getEventName();
                // 暗自用第一个参数传递diEvent对象
                (args = args || []).splice(0, 0, diEvent);
            }

            if (eventAgent instanceof XOBJECT) {
                eventAgent.notify(eventName, args);
            }
            else if (isEcuiControl(eventAgent)) {
                ecuiTriggerEvent(eventAgent, eventName, null, args);
            }
        },

        /**
         * 因为功能权限而禁用vui, 此为默认行为，可重载改变
         * 
         * @public
         */
        funcAuthVerify: function () {
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiIns;
            var vuiDef;

            for (var refPathKey in vuiSet) {
                vuiIns = vuiSet[refPathKey];
                vuiDef = vuiIns.$di('getDef');
                if (// 如果vui配了funcAuth，则要检查查权限
                    vuiDef.funcAuth 
                    && !(vuiDef.funcAuth in funcAuthKeys)
                ) {
                    // 没权限禁用
                    vuiIns.$di('getEl').style.display = 'none';
                    setDIAttr(vuiIns, 'hideByAuth', true);
                }
            }
        },

        /** 
         * 创建VUI实例
         * 如果工厂里有VUI定义，则用工厂里的定义创建，
         * 否则返回空
         *
         * 例：在component中创建一个vui，
         *  这个vui本身是一个ecui控件，
         *  如果在模板中有定义，则用模板中定义的创建，
         *  否则使用ecui的$fastCreate创建：
         *      var options = { myAttr1: 1, myAttr2: 'yyy' };
         *      this._uSomeControl = this.$di 
         *          && this.$di('create', ['theVUINameInTpl', 1], options)
         *          || ecui.$fastCreate(ecui.ui.MyControl, mainEl, null, options);
         *
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @param {Object=} options 被创建者需要的初始化参数
         * @return {Object} vui实例，如果创建失败则返回空
         */
        vuiCreate: function (refPath, options) {
            var def = this.$di('getRef', 'vuiRef', refPath, 'DEF');
            if (!def) { return null; }
            
            options = mergeOpt(
                def, 
                extend({}, options, { id: def.id, el: def.el }),
                'DATA_INIT'
            );

            // vuiSet用于component引用自身的vui
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiSetKey = makePathKey(refPath);

            assert(
                !vuiSet[vuiSetKey],
                'vui已经存在: refPath=' + refPath + ' vuiSetKey=' + vuiSetKey
            );

            // 设置默认值
            if (getOpt(def, 'cfgOpt', 'paramMode') == null) {
                setOpt(def, 'cfgOpt', 'paramMode', 'NORMAL');
            }

            // 得到适配器和适配方法
            var adptMethod = def.adapterMethod || {};
            var adpt = def.adapter && def.adapter(def, options) || {};

            // 创建实例
            var ins;
            if (adpt['create']) {
                ins = adpt['create'](def, options);
            }
            else if (adptMethod['create']) {
                ins = generalAdapterMethod[adptMethod['create']](def, options);
            }

            // 实例创建失败
            if (!ins) {
                return null;
            }

            // 绑定$di
            ins.$di = $di.INS;

            // 设置基本属性
            setDIAttr(ins, 'id', def.id);
            setDIAttr(ins, 'el', def.el);
            if (def.el && def.el.style.display == 'none') {
                setDIAttr(ins, 'styleDisplay', def.styleDisplay);
            }

            // 保存实例
            vuiSet[vuiSetKey] = ins;
            addEntity(ins, 'INS');

            // 拷贝adapter方法到实例上
            var setDataMethod;
            var methodName;
            for (methodName in adptMethod) {
                if (methodName != 'create') {
                    setDIMethod(
                        ins, 
                        methodName, 
                        generalAdapterMethod[methodName]
                    );
                }
            }
            for (methodName in adpt) {
                if (methodName != 'create') {
                    setDIMethod(
                        ins, 
                        methodName, 
                        adpt[methodName]
                    );
                }
            }

            // 绑定默认方法
            addVUISetDataMethod(ins);
            addVUIGetValueMethod(ins);
            addVUIInitMethod(ins);
            addDisposeMethod(ins, vuiSet, vuiSetKey);

            return ins;
        },

        /**
         * component获得自己的vui实例
         * 
         * @public
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @return {Object} vui实例
         */
        vuiGet: function (refPath) {
            return getMakeAttr(this, 'vuiSet')[makePathKey(refPath)];
        },

        /** 
         * 创建VPART实例
         * 如果工厂里有VPART定义，则用工厂里的定义创建，
         * 否则返回空
         *
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @param {Object=} options 被创建者需要的初始化参数
         * @return {Object} vpart实例，如果创建失败则返回空
         */
        vpartCreate: function (refPath, options) {
            var def = this.$di('getRef', 'vpartRef', refPath, 'DEF');
            if (!def) { return null; }

            options = mergeOpt(
                def, 
                extend({}, options, { id: def.id, el: def.el }),
                'DATA_INIT'
            );

            // vpartSet用于component引用自身的vpart
            var vpartSet = getMakeAttr(this, 'vpartSet');
            var vpartSetKey = makePathKey(refPath);

            assert(
                !vpartSet[vpartSetKey],
                'vpart已经存在: refPath=' + refPath + ' vpartSetKey=' + vpartSetKey
            );

            // 创建实例
            var ins = new def.clz(options);

            // 实例创建失败
            if (!ins) {
                return null;
            }

            // 绑定$di
            ins.$di = $di.INS;

            // 设置基本属性
            setDIAttr(ins, 'id', def.id);
            setDIAttr(ins, 'el', def.el);
            if (def.el && def.el.style.display == 'none') {
                setDIAttr(ins, 'styleDisplay', def.styleDisplay);
            }

            // 保存实例
            vpartSet[vpartSetKey] = ins;
            addEntity(ins, 'INS');

            // 绑定默认方法
            addDisposeMethod(ins, vpartSet, vpartSetKey);

            return ins;
        },

        /**
         * vcontainer获得自己的vpart实例
         * 
         * @public
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @return {Object} vui实例
         */
        vpartGet: function (refPath) {
            return getMakeAttr(this, 'vpartSet')[makePathKey(refPath)];
        },

        /**
         * Component的getValue的统一实现，
         * 遍历每个vui，调用其getValue方法，
         * 用每个vui的name作为key，组成返回值对象。
         * （如果没有name，则不会被getValue），
         * 如果要控制某个vui的getValue，可自己实现vuiGetValue方法
         * 
         * @public
         * @return {Object} value
         */
        getValue: function () {
            var def = this.$di('getDef');
            var valueDisabledMode = def.valueDisabledMode;

            var cmptValDisabled = this.$di('isValueDisabled');
            if (cmptValDisabled && valueDisabledMode == 'NORMAL') {
                return null;
            }

            var value = {};
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiIns;
            var vuiDef;
            var vuiValue;

            if (this.getValue) {
                value = this.getValue() || {};
            }

            var valDisabled;
            for (var refPathKey in vuiSet) {
                vuiIns = vuiSet[refPathKey];
                vuiDef = vuiIns.$di('getDef');
                valDisabled = cmptValDisabled || vuiIns.$di('isValueDisabled');

                if (vuiDef.name == null 
                    || (valDisabled && valueDisabledMode == 'NORMAL')
                ) { 
                    continue; 
                }

                value[vuiDef.name] = valDisabled && valueDisabledMode == 'DI'
                    ? null
                    : (
                        isObject(vuiValue = vuiIns.$di('getValue')) 
                            ? COMMON_PARAM_FACTORY.markParamMode(
                                vuiValue,
                                getOpt(vuiDef, 'cfgOpt', 'paramMode')
                            )
                            : vuiValue
                    );
            }

            return value;
        },

        /**
         * COMPONENT中，在interaction时得到event，
         * 其中含有disableFunc和enableFunc，
         * 调用则会执行disable和enable.
         * 用于在异步行为时做用户操作屏蔽。
         * 只能在interaction的action开始执行时调用
         * 
         * @public
         * @return {Object} event 
         *      {Function} event.disableFunc
         *      {Function} event.enableFunc
         */
        getEvent: function () {
            var event = getInteractMemo(this, 'diEvent');
            /*
            // 使用sync view disable配置代替
            var visDef = event.viewDisableDef;
            if (visDef) {
                var key = 'INTERACTION_VIEW_DISABLE_' + this.$di('getId');
                event.viewDisable = {
                    disable: makeViewDisableFunc(visDef, 'disable', key),
                    enable: makeViewDisableFunc(visDef, 'enable', key)
                }
            };
            */
            return event;
        },

        /**
         * 执行view disable
         * 
         * @protected
         * @param {string} actName 值为disable或者enable
         * @param {string} datasourceId 
         */
        syncViewDisable: function (actName, datasourceId) {
            assert(
                actName == 'enable' || actName == 'disable',
                'Wrong actName: ' + actName
            );
            var def = this.$di('getDef');
            var key = 'ASYNC_VIEW_DISABLE_' + this.$di('getId');
            var vdDef = (def.sync || {}).viewDisable;
            doViewDisable(
                vdDef == 'ALL'
                    ? vdDef
                    : (isObject(vdDef) && vdDef[datasourceId]),
                actName,
                key
            );
        },

        /**
         * 报表跳转
         * 
         * @protected
         * @param {string} linkBridgeType 跳转类型，值可为'I'(internal)或者'E'(external)
         * @param {string} url 目标url
         * @param {string} param 参数
         */
        linkBridge: function (linkBridgeType, url, param) {
            // 报表引擎内部处理，直接跳转
            if (linkBridgeType == 'I') {
                targetBlank(url + '?' + param);
            }
            // 给di-stub发事件，由引用报表引擎的系统来跳转
            else if (linkBridgeType == 'E') {
                eventChannel && eventChannel.triggerEvent(
                    'linkbridge', 
                    [url, param]
                );
            }
        }        
    };

    var DEF_CONTRACT_METHOD = {
        getDIFactory: COMMON_CONTRACT_METHOD.getDIFactory,
        getMethod: function (methodName) {
            return DEF_CONTRACT_METHOD[methodName];
        },
        setId: function (id) {
            this.id = id;
        },
        getId: function () {
            return this.id;
        },
        getOpt: COMMON_CONTRACT_METHOD.getOpt,
        setOpt: COMMON_CONTRACT_METHOD.setOpt,
        getRef: COMMON_CONTRACT_METHOD.getRef
    };





    //----------------------------------------------------------------------
    // rule相关
    //----------------------------------------------------------------------

    /**
     * 处理interaction规则
     * 
     * @private 
     * @param {Object} diEvent 
     * @param {Array.<Object>} atomRule
     *      结构例如：
     *      { operator: 'includes', interactionIds: ['aaaaa-rid1', 'aaaa-rid2' ]}
     * @return {boolean} 判断结果
     */
    function evalRule(diEvent, atomRule) {
        // 目前支持的operator：
        var ruleMap = { 
            includes: evalRuleIncludesExcludes, 
            excludes: evalRuleIncludesExcludes, 
            equals: evalRuleEquals
        };        

        assert(
            atomRule.operator in ruleMap,
            'Illegal rule: ' + atomRule.operator
        );

        return ruleMap[atomRule.operator](diEvent, atomRule);
    }

    /**
     * 处理interaction规则 incudes excludes
     * 
     * @private 
     * @param {Object} diEvent 
     * @param {Array.<Object>} atomRule
     *      结构例如：
     *      { operator: 'includes', interactionIds: ['aaaaa-rid1', 'aaaa-rid2' ]}
     * @return {boolean} 判断结果
     */
     function evalRuleIncludesExcludes(diEvent, atomRule) {
        if (!diEvent) { return false; }

        var rSet = { includes: {}, excludes: {} };

        for (var j = 0; j < (atomRule.interactionIds || []).length; j ++) {
            rSet[atomRule.operator][atomRule.interactionIds[j]] = 1;
        }

        var path = getEventAttr(diEvent, 'interactPath');
        for (var i = 0, e, iid; e = path[path.length - i - 1]; i ++) {
            iid = getEventAttr(e, 'interactionId');

            if (iid in rSet.excludes) {
                return false;
            }

            if (rSet.includes[iid]) {
                delete rSet.includes[iid];
            }
        }

        if (!isEmptyObj(rSet.includes)) {
            return false;
        }

        return true;

        // TODO
        // 按路径模式匹配的代码（如下类似），后续有需求再加
        // for (
        //     var i = 0, e, eDef; 
        //     eDef = interactPathDef[dlen - i - 1], e = realPath[rlen - i - 1];
        //     i ++
        // ) {
        //     if (!eDef) {
        //         if (eventMatchMode == 'EXACT') { return false; }
        //         else { break; }
        //     }

        //     if (getEventAttr(e, 'dispatcherId') != eDef.dispatcherId
        //         || getEventAttr(e, 'eventName') != eDef.name
        //     ) {
        //         return false;
        //     }
        // }
    }

    /**
     * 处理interaction规则 equals
     * 
     * @private 
     * @param {Object} diEvent 
     * @param {Array.<Object>} atomRule
     *      结构例如：
     *      { atomRule: 'equals', argHandlers: [ ... ], value: 1234 }
     * @return {boolean} 判断结果
     */
     function evalRuleEquals(diEvent, atomRule) {
        var val = parseArgHandlerDesc(atomRule).call(null, [])[0];
        return val == atomRule.value;
     }





    //-------------------------------------------------------------------
    // DI Event
    //-------------------------------------------------------------------

    /**
     * DI事件
     * 
     * @private
     * @param {string=} eventName 事件名
     * @param {Object=} options 参数
     * @param {string=} options.dispatcherId 触发event的di ins的id
     * @param {string=} options.interactionId interaction的id
     * @param {string=} options.isClone 是否是clone
     * @param {Array.<Object>=} options.interactPath 事件路径
     * @return {Function} event实例
     */
    function createDIEvent(eventName, options) {
        options = options || {};

        var evt = function (eName) {
            return createDIEvent(
                eName,
                // interactPath上所有event对象都引用本interactPath
                { interactPath: evt[DI_EVENT_TAG].interactPath }         
            );
        }

        // event对象中保存数据的地方
        var repo = evt[DI_EVENT_TAG] = {
            eventName: eventName,
            dispatcherId: options.dispatcherId,
            interactionId: options.interactionId,
            interactPath: (options.interactPath || []).slice()
        };

        // 最新一个event总在interactPath末尾
        var path = repo.interactPath;
        options.isClone
            ? path.splice(path.length - 1, 1, evt)
            : path.push(evt);

        // event对象的方法
        extend(evt, DI_EVENT_METHODS);

        return evt;
    };

    var DI_EVENT_METHODS = {
        /** 
         * 得到事件名
         * 
         * @public
         * @this {Object} diEvent对象
         * @return {string} 事件名
         */
        getEventName: function () {
            return this[DI_EVENT_TAG].eventName;
        },

        /** 
         * 得到interactionId
         * 
         * @public
         * @this {Object} diEvent对象
         * @return {string} interactionIdId
         */
        getInteractionId: function () {
            return this[DI_EVENT_TAG].interactionId;
        }

        /**
         * 是否为用户触发的事件中的第一个事件
         * 
         * @public
         */
        // isUserFirst: function () {
        //     var path = this[DI_EVENT_TAG].interactPath;
        //     return path && path[0] && path[0].getEventName() != INIT_EVENT_NAME
        // },

        /**
         * 是否为自然初始化的事件中的第一个有效事件
         * 
         * @public
         */
        // isInitFirst: function () {
        //     var path = this[DI_EVENT_TAG].interactPath;
        //     if (path 
        //         && path[0] 
        //         && path[0].getEventName() == INIT_EVENT_NAME
        //         && path[1] === this
        //     ) {
        //         return true;
        //     }
        //     else {
        //         return false;
        //     }
        // }
    };

    /**
     * 得到副本
     * 
     * @public
     * @this {Event} 对象
     * @param {Object} event 事件对象
     * @return {string} 事件
     */
    function cloneEvent(event) {
        var repo = event[DI_EVENT_TAG];
        return createDIEvent(
            repo.eventName,
            {
                dispatcherId: repo.dispatcherId,
                interactionId: repo.interactionId,
                interactPath: repo.interactPath,
                isClone: true
            }
        );
    }

    /**
     * 得到event对象的属性值
     *
     * @private
     */
    function getEventAttr(event, attrName) {
        return event[DI_EVENT_TAG][attrName];
    }

    /**
     * 设置event对象的属性值
     *
     * @private
     */
    function setEventAttr(event, attrName, value, checkExist) {
        if (checkExist && event[DI_EVENT_TAG][attrName] !== void 0) {
            throw new Error('请使用diEvent("newEventName")创建新的diEvent实例');
        }
        event[DI_EVENT_TAG][attrName] = value;
    }

    /**
     * 是否为event对象
     *
     * @private
     */
    function isDIEvent(obj) {
        return isObject(obj) && obj[DI_EVENT_TAG];
    }





    //--------------------------------------------------------------------
    // DI Opt 相关方法
    //--------------------------------------------------------------------

    /**
     * 初始化opt
     * 现在支持的opt定义方式：
     *      (1) def[optName] ==> Object
     *      (2) def[optName + 's'] ==> Array
     *
     * @private
     * @param {Object} src 源
     * @param {string} optName opt名
     * @return {Object} opt
     */
    function initializeOpt(def, optName) {

        // 创建optCache
        var optCacheHome = def[DI_OPT_CACHE_TAG];
        if (!optCacheHome) {
            optCacheHome = def[DI_OPT_CACHE_TAG] = {};
        }
        optCacheHome[optName] = {};

        // 创建opt存储位置
        var optHome = def[DI_OPT_HOME_TAG];
        if (!optHome) {
            optHome = def[DI_OPT_HOME_TAG] = {};
        }

        var opt = optHome[optName] = def[optName] || {};
        var opts = optHome[optName + 's'] = def[optName + 's'] || [];

        // 删除def[optName]防止直接得到（只允许通过getOpt方法得到）
        def[optName] = null;
        def[optName + 's'] = null;

        // 生成id，用于optCache
        opt[DI_OPT_ID_TAG] = 'DI_OPT_' + getUID('DI_OPT');
        for (var i = 0; i < opts.length; i ++) {
            opts[i][optName][DI_OPT_ID_TAG] = 'DI_OPT_' + getUID('DI_OPT');
        }
    }

    /**
     * 提取定义的opt
     *
     * @private
     * @param {Object} src 源
     * @param {string} optName opt名
     * @param {string=} attr 属性名，如果为空，则得到opt本身
     * @param {Obejct=} options 参数
     * @param {Object=} options.diEvent di事件
     * @param {boolean=} options.clone 是否返回副本，默认是false
     * @return {Object} opt
     */
    function getOpt(def, optName, attr, options) {
        options = options || {};

        var optHome = def[DI_OPT_HOME_TAG];
        var optCache = def[DI_OPT_CACHE_TAG][optName];
        var opt = optHome[optName];
        var opts = optHome[optName + 's'];
        var diEvent = options.diEvent;
        var i;
        var o;
        var ret;
        var matchedOpt = [];
        var matchedIds = [];
        var evalRuleFunc = bind(evalRule, null, diEvent);

        matchedOpt.push(opt);
        matchedIds.push(opt[DI_OPT_ID_TAG]);

        // 根据rule找到匹配的opt
        for (i = 0; i < opts.length; i ++) {
            if ((o = opts[i]) 
                && o.rule 
                && o[optName]
                && evalJsonLogic(o.rule, evalRuleFunc)
            ) {
                matchedOpt.push(o[optName]);
                matchedIds.push(o[optName][DI_OPT_ID_TAG]);
            }
        }

        var cacheKey = matchedIds.join(SEP);

        // 优先取缓存，否则merge
        if (!(ret = optCache[cacheKey])) {
            ret = optCache[cacheKey] = {};
            for (i = 0; i < matchedOpt.length; i ++) {
                merge(
                    ret, 
                    matchedOpt[i], 
                    { overwrite: true, clone: 'WITHOUT_ARRAY' }
                );
            }
        }

        if (attr != null) {
            ret = ret[attr];
        }

        return options.clone
            ? clone(ret, { exclusion: [DI_OPT_CACHE_TAG] })
            : ret;
    }

    /**
     * 设置opt
     *
     * @private
     * @param {Object} src 源
     * @param {string} optName 如cfgOpt、dataOpt
     * @param {string} attr 属性名
     * @param {*} value 属性值
     */
    function setOpt(def, optName, attr, value) {
        def[DI_OPT_HOME_TAG][optName][attr] = value;

        // 清除optcache
        def[DI_OPT_CACHE_TAG][optName] = {};
    }

    /** 
     * 融合参数
     *
     * @public
     * @param {Object} def 目标实例定义
     * @param {Object} invokerData 调用者提供的options
     * @param {string} optType 可为'INIT', 'DATA'
     * @param {Object=} options
     * @param {Object=} options.forceData 最高等级的参数
     * @param {Object=} options.diEvent di事件
     */
    function mergeOpt(def, invokerData, optType, options) {
        def = def || {};
        options = options || {};
        var ret = {};

        // 使用了clone模式的merge，但是为减少消耗，不clone array
        var mOpt = { overwrite: true, clone: 'WITHOUT_ARRAY' };
        var mOpt2 = extend({}, mOpt, { exclusion: [DI_OPT_ID_TAG] });
        var optopt = { diEvent: options.diEvent };

        var clzDef = getClz(def.clzKey) || {};
        var clzDataOpt = getOpt(clzDef, 'dataOpt', null, optopt);
        var dataOpt = getOpt(def, 'dataOpt', null, optopt);

        merge(ret, clzDataOpt, mOpt2);
        merge(ret, invokerData, mOpt);
        merge(ret, dataOpt, mOpt2);

        if (optType == 'DATA_SET') {
            merge(ret, getOpt(def, 'dataSetOpt', null, optopt), mOpt2);
        }
        else if (optType == 'DATA_INIT') {
            merge(ret, getOpt(def, 'dataInitOpt', null, optopt), mOpt2);
        }
        else {
            throw new Error('error optType:' + optType);
        }

        options.forceData && 
                merge(ret, options.forceData, mOpt);

        return ret;
    }






    //-----------------------------------------------------------------------
    // Arg Handler 相关
    //-----------------------------------------------------------------------

    /**
     * 解析argHandler定义
     * 
     * @param {Object} container 定义argHandler的容器
     * @param {Object=} scope 可缺省
     * @private
     */
    function parseArgHandlerDesc(container, scope) {
        var argH;
        var argHs = [];

        if (argH = container.argHandler) {
            argHs.push(argH);
        }
        if (argH = container.argHandlers) {
            argHs.push.apply(argHs, argH);
        }

        for (var i = 0; i < argHs.length; i ++) {
            argHs[i] = [scope].concat(argHs[i]);
        }

        return ARG_HANDLER_FACTORY.apply(null, argHs);
    }






    //-----------------------------------------------------------------------
    // DI Factory方法
    //-----------------------------------------------------------------------

    /**
     * 对注册的类实例化并enhance
     * 一般在类加载完后调用此方法，
     * 如果相应的类并未加载完，则忽略
     *
     * @private
     */
    function installClz() {
        var clzKey;
        var clzDef;
        var proto;

        generalAdapterMethod = getByPath(
            GENERAL_ADAPTER_METHOD_PATH,
            $getNamespaceBase()
        );

        for (clzKey in DICT.CLZ) {
            repository['CLZ'][clzKey] = clzDef = clone(DICT.CLZ[clzKey]);

            // 得到类实例
            if (clzDef.clzPath 
                && (clzDef.clz = getByPath(clzDef.clzPath, $getNamespaceBase()))
            ) {
                proto = clzDef.clz.prototype;

                // 绑定$di
                proto.$di = $di.INS;

                // 添加约定方法
                mountMethod(
                    proto,
                    [
                        'start',
                        'getDIFactory',
                        'setId',
                        'getId',
                        'getDef',
                        'isDeaf',
                        'setDeaf',
                        'setEl',
                        'getEl',
                        'disable',
                        'enable',
                        'diShow',
                        'diHide',
                        'setValueDisabled',
                        'isValueDisabled',
                        'addEventListener',
                        'dispatchEvent',
                        'registerEventAgent',
                        'getOpt',
                        'setOpt',
                        'getRef'
                    ],
                    COMMON_CONTRACT_METHOD
                );

                if (clzDef.clzType == 'COMPONENT') {
                    mountMethod(
                        proto,
                        [
                            'setTplMode',
                            'getTplMode',
                            'vuiCreate',
                            'vuiGet',
                            'getValue',
                            'getEvent',
                            'getEventChannel',
                            'getCommonParamGetter',
                            'setCommonParamGetter',
                            'linkBridge',
                            'syncViewDisable',
                            'funcAuthVerify'                     
                        ],
                        COMMON_CONTRACT_METHOD
                    );
                }                

                if (clzDef.clzType == 'VCONTAINER') {
                    mountMethod(
                        proto,
                        [
                            'vpartCreate',
                            'vpartGet'
                        ],
                        COMMON_CONTRACT_METHOD
                    );
                }

                // 赋予类型
                setDIMethod(
                    proto, 
                    'getClzType', 
                    (function (clzType) {
                        return function () { return clzType; }     
                    })(clzDef.clzType)
                );
            }

            // 得到adapter实例
            clzDef.adapterPath && (
                clzDef.adapter = 
                    getByPath(clzDef.adapterPath, $getNamespaceBase())
            );

            // 选项初始化
            initializeOpt(clzDef, 'dataOpt');
            initializeOpt(clzDef, 'dataInitOpt');
            initializeOpt(clzDef, 'dataSetOpt');
            initializeOpt(clzDef, 'valueGetOpt');
            initializeOpt(clzDef, 'cfgOpt');
        }
    }

    /**
     * 为类挂载di的方法。如果类中已经有此方法，则不挂载。
     *
     * @private
     * @param {Object} proto 类的prototype
     * @param {Array.<string>} methodNameList 方法名
     * @param {Array.<string>} methodSet 方法集合
     */
    function mountMethod(proto, methodNameList, methodSet) {
        for (
            var i = 0, methodName, prefixedMethodName; 
            methodName = methodNameList[i]; 
            i ++
        ) {
            setDIMethod(proto, methodName, methodSet[methodName]);
        }
    }

    /**
     * vui本身要求提供setData方法，
     * vui提供的setData意为重新设置完全数据并渲染
     * 这里的setData方法又为vui的setData方法的加了一层包装，
     * 用于将模板里自定义的dataOpt与传入的options融合
     * （融合顺序依照mergeOpt方法的定义）。
     * Component对vui进行操作时须调用此setData方法，
     * （如：this._uSomeVUi.$di('setData', data);）
     * 而非直接调用vui本身提供的setData方法。
     * 
     * @private
     * @param {Object} ins 目标对象
     */
    function addVUISetDataMethod(ins) {
        var oldMethod = getDIMethod(ins, 'setData');

        setDIMethod(
            ins,
            'setData',
            oldMethod
                /**
                 * @param {*} data
                 * @param {Object=} options 参数
                 * @param {*=} options.forceData 最高merge优先级的data
                 * @param {Object=} options.diEvent di事件
                 */
                ? function (data, options) {
                    options = options || {};
                    data = mergeOpt(
                        this.$di('getDef'), data, 'DATA_SET', options
                    );
                    // TODO 
                    // isSilent的统一支持
                    return oldMethod.call(this, data);
                }
                // 如果没有提供，表示不需要，则给予空方法
                : new Function()
        );
    }

    /**
     * vui的getValue方法的封装
     * 
     * @private
     * @param {Object} ins 目标对象
     */
    function addVUIGetValueMethod(ins) {
        var oldMethod = getDIMethod(ins, 'getValue');

        setDIMethod(
            ins,
            'getValue',
            oldMethod 
                ? function () {
                    return this.$di('isValueDisabled')
                        ? null
                        : oldMethod.call(this);
                }
                // 如果没有提供，表示不需要，则给予空方法
                : new Function()
        );
    }

    /**
     * vui的init方法的封装
     * 
     * @private
     * @param {Object} ins 目标对象
     */
    function addVUIInitMethod(ins) {
        var oldMethod = getDIMethod(ins, 'init');

        setDIMethod(
            ins,
            'init',
            function () {
                mountInteractions(ins);
                oldMethod && oldMethod.call(this);
            }
        );
    }

    /**
     * 包装的(vui和vpart的）析构方法
     * 
     * @private
     * @param {Object} ins 目标对象
     */
    function addDisposeMethod(ins, vSet, vSetKey) {
        var oldMethod = getDIMethod(ins, 'dispose');

        setDIMethod(
            ins,
            'dispose',
            function () {
                delete vSet[vSetKey];
                removeEntity(ins);
                oldMethod && oldMethod.call(this);
                this.$di('setEl', null);
            }
        );
    }

    /**
     * 创建di实例
     *
     * @private
     * @param {Object} def 实例定义
     * @param {Object} options 初始化参数
     * @param {string} options.tplMode （默认为'FROM_SNIPPET'）
     * @param {string} options.commonParamGetter
     * @return {Object} 创建好的实例
     */
    function createIns(def, options) {   
        options = options || {};
        // 为了下面new时能在构造方法中访问这些数据，
        // 所以放到globalTemp中
        var opt = {
            id: def.id,
            el: def.el,
            // 标志html片段从snippet中取，而不是组件自己创建
            tplMode: options.tplMode || 'FROM_SNIPPET',
            commonParamGetter: options.commonParamGetter
        };
        opt[DI_TMP_TAG] = extend({}, opt);

        // DI_FACTORY().setGlobalTemp('DI_DEF_FOR_NEW', opt);
        var ins = new def.clz(
            mergeOpt(def, extend(options, opt), 'DATA_INIT')
        );
        // DI_FACTORY().setGlobalTemp('DI_DEF_FOR_NEW', null);

        // ins.$di('setId', def.id);
        // ins.$di('setEl', def.el);
        // ins.$di('setTplMode', def.tplMode);

        addEntity(ins);

        return ins;
    }    

    /**
     * 根据配置，挂载多个interaction
     *
     * @public
     * @param {Object} ins 实例
     */
    function mountInteractions(ins) {   
        var def = ins.$di('getDef');

        // 模板中定义的事件绑定(interaction)
        if (!def.interactions) { return; }

        for (
            var i = 0, interact; 
            interact = def.interactions[i]; 
            i ++
        ) {
            mountInteraction(ins, interact);
        }        
    }

    /**
     * 根据配置，挂载interaction
     *
     * @public
     * @param {Object} ins 实例
     */
    function mountInteraction(ins, interact) {  
        var def = ins.$di('getDef');

        var events = [];
        interact.event && events.push(interact.event);
        interact.events && arrayPush.apply(events, interact.events);

        for (var j = 0, evt, triggerIns; j < events.length; j ++) {
            evt = events[j];
            triggerIns = evt.triggerIns || getEntity(evt.rid, 'INS');

            // 设置这个断言的部分原因是，vui事件不保证能提供diEvent
            assert(
                triggerIns.$di('getDef').clzType != 'VUI',
                '不允许监听vui事件'
            );

            if (!triggerIns) { return; }

            triggerIns.$di(
                'addEventListener', 
                evt.name,
                getDIMethod(ins, interact.action.name),
                ins,
                {
                    interactionId: interact.id,
                    dispatcherId: evt.rid,
                    argHandler: parseArgHandlerDesc(interact, ins),
                    once: interact.once,
                    viewDisableDef: interact.viewDisable,
                    rule: evt.rule 
                        ? ['and', interact.rule, evt.rule] 
                        : interact.rule
                }
            );
        }
    }

    /**
     * 根据引用路径（refPath）得到引用。
     * 路径可直接指向对象树叶节点，也可以指向途中的节点。
     *
     * @public
     * @param {Object} obj 目标INS或者DEF
     * @param {string} refName 如'vuiRef'，'vpartRef'
     * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
     * @param {string=} mode 值为'DEF'（默认）或者'INS'
     * @param {Object=} options 选项
     * @param {boolean=} options.flatReturn 
     *      true则返回一个数组，里面是所有目标实例，
     *      false则返回源结构，里面的id会替换为目标实例（默认）。
     * @return {(Array.<Object>|Object)} ref数组或者ref项
     */
    function getRef(obj, refName, refPath, mode, options) {
        options = options || {};

        var refBase = (
            getEntity(obj.$di('getId'), 'DEF') || {}
        )[refName];

        if (!refBase) { return null; }

        return findEntity(
            getByPath(refPath, refBase), 
            mode, 
            { isClone: true, flatReturn: options.flatReturn }
        );
    }

    /**
     * 设置方法，如果没有此方法的话
     *
     * @private
     * @param {Object} o 类的prototype或者实例
     * @param {string} methodName 方法名
     * @param {Function} method 方法
     * @param {boolean} force 是否强制覆盖，默认true
     */    
    function setDIMethod(o, methodName, method, force) {
        force == null && (force = true);
        var prefixedMethodName = DI_METHOD_PREFIX + methodName;
        if (force || !o[prefixedMethodName]) {
            o[prefixedMethodName] = method;
        }
    }      

    /**
     * 获取方法
     *
     * @private
     * @param {Object} o 类的prototype或者实例
     * @param {string} methodName 方法名
     * @return {Function} method 方法
     */    
    function getDIMethod(o, methodName) {
            // 寻找di挂载的方法
        return o[DI_METHOD_PREFIX + methodName]
            // 如果找不到，则调用同名原有方法
            || o[methodName];
    }

    /**
     * 得到类
     *
     * @public
     * @param {string} clzKey 类的key
     * @return {Object} clzDef 类定义
     *      clzDef.clz 类
     *      clzDef.clzKey 类key
     *      clzDef.clzPath 类路径
     *      clzDef.adapterPath 适配器路径
     *      clzDef.adapter 适配器
     *      clzDef.dataOpt 初始化参数
     */
    function getClz(clzKey) {
        return repository['CLZ'][clzKey];
    }

    /**
     * 添加实体（ins或def）
     *
     * @public
     * @param {Object} o 实例或实例定义
     * @param {string} mode 'INS'（默认）, 'DEF'
     * @return {DIFactory} 本身
     */
    function addEntity(o, mode) {
        if (mode == 'DEF') {
            if (o.clzType && o.id) {
                
                // 装上clz
                var clzDef = getClz(
                    o.clzKey || DICT.DEFAULT_CLZ_KEY[o.clzType]
                ); 
                o = merge(clone(clzDef), o);

                // def标志
                o[DI_DEF_TAG] = true;

                // 赋予$di
                o.$di = $di.DEF;

                // 选项初始化
                initializeOpt(o, 'dataOpt');
                initializeOpt(o, 'dataInitOpt');
                initializeOpt(o, 'dataSetOpt');
                initializeOpt(o, 'cfgOpt');

                // 保存
                repository[o.clzType + '_DEF'][o.id] = assign({}, o);
            }
        }
        else {        
            repository[o.$di('getClzType')][o.$di('getId')] = o;
        }
        return instance;
    }    

    /**
     * 删除实例
     *
     * @public
     * @param {Object} o 实例或实例定义
     */
    function removeEntity(o) {
        if (o[DI_DEF_TAG]) {
            delete repository[o.clzType + '_DEF'][o.id];
        }
        else {        
            delete repository[o.$di('getClzType')][o.$di('getId')];
        }
    }

    /**
     * 得到实例
     *
     * @private
     * @param {string} id 实例id
     * @param {string} mode 'INS', 'DEF'（默认）, 'RAW'（原定义对象，内部使用）
     * @return {Object} 实例
     */
    function getEntity(id, mode) {
        var suffix = mode == 'INS' ? '' : '_DEF';
        var o;
        var ret;
        var optCache;

        for (var i = 0, clzType; clzType = INS_CLZ_TYPE[i]; i ++) {
            if (clzType != 'CLZ' 
                && (o = repository[clzType + suffix][id])
            ) {
                if (mode == 'INS' || mode == 'RAW') {
                    return o;
                }
                // mode为'DEF'则返回副本
                else {
                    ret = clone(o, { exclusion: [DI_OPT_CACHE_TAG] });
                    // 不克隆optCache节省开销
                    ret[DI_OPT_CACHE_TAG] = o[DI_OPT_CACHE_TAG];
                    return ret;
                }
            }
        }
        return null;
    }

    /**
     * 为对象装填ins或def，或者返回装填好的副本
     *
     * @public
     * @param {(Object|Array)} target 目标对象中，
     *      只可以含有Object或Array或实例id
     * @param {string} mode 'INS', 'DEF'（默认）
     * @param {Object=} options 选项
     * @param {boolean=} options.flatReturn 
     *      true则返回一个数组，里面是所有目标实例，
     *      false则返回源结构，里面的id会替换为目标实例（默认）。
     * @param {boolean=} options.isClone 是否是clone模式，
     *      true则不修改target，返回值是新对象，
     *      false则修改target，返回target。（默认）
     * @return {Object} target 源对象
     */
    function findEntity(target, mode, options) {
        options = options || {}
        var result;
        var i;
        var flatRet = options.flatReturn ? [] : null;

        if (isArray(target)) {
            result = options.isClone ? [] : target;
            for (i = 0; i < target.length; i ++) {
                target.hasOwnProperty(i)
                    && (result[i] = findEntity(target[i], mode));
            }
        }
        else if (isObject(target)) {
            result = options.isClone ? {} : target;
            for (i in target) {
                target.hasOwnProperty(i)
                    && (result[i] = findEntity(target[i], mode));
            }
        } 
        else {
            result = getEntity(target, mode);
            flatRet && flatRet.push(result);
        }

        return flatRet ? flatRet : result;
    }

    /**
     * 遍历unit
     *
     * @protected
     * @param {(string|Array)} clzType 单值或数组，
     *      如果是数组，则顺序遍历
     * @param {Function} callback 回调，参数为
     *              {Object} def
     *              {Object} ins
     *              {string} id
     */
    function forEachEntity(clzType, callback) {
        clzType = isString(clzType) 
            ? [clzType] : (clzType || []);

        for (var i = 0, c, repoIns, repoDef; c = clzType[i]; i ++) {
            var repoDef = repository[c + '_DEF'];
            var repoIns = repository[c];
            for (var id in repoDef) {
                repoDef[id] && callback(repoDef[id], repoIns[id], id);
            }
        }
    }

    /**
     * 设置di私有的属性
     * 
     * @private
     * @param {Object} o 目标ins
     * @param {string} attrName 属性名
     * @param {*} attrValue 属性值
     */
    function setDIAttr(o, attrName, attrValue) {
        if (o && attrName != null) {
            o[DI_ATTR_PREFIX + attrName] = attrValue;
        }
    }

    /**
     * 得到di私有的属性
     * 
     * @private
     * @param {Object} o 来源ins
     * @param {string} attrName 属性名
     * @return {*} attrValue 属性值
     */
    function getDIAttr(o, attrName) {
        if (o && attrName != null) {
            return o[DI_ATTR_PREFIX + attrName];
        }
        return null;
    }

    /**
     * 获得对象，如果没有就创建
     *
     * @param {Object} di实例
     * @param {string} attrName
     * @param {*=} makeValue 如果没有，则创建的值，默认为{}
     * @private
     */
    function getMakeAttr(ins, attrName, makeValue) {
        if (makeValue === void 0) {
            makeValue = {};
        }
        var value = getDIAttr(ins, attrName);
        if (value === void 0) {
            setDIAttr(ins, attrName, value = makeValue);
        }
        return value;
    }

    /**
     * 得到di私有的属性，如果没有则从global中取
     * 专用于new创建时
     * 
     * @private
     * @param {Object} o 来源对象
     * @param {string} attrName 属性名
     * @return {*} attrValue 属性值
     */
    function getAttrIncludeGlobal(o, attrName) {
        var ret = getDIAttr(o, attrName);
        if (ret == null) {
            ret = (getGlobalTemp('DI_DEF_FOR_NEW') || {})[attrName];
        }
        return ret;
    }

    /**
     * 设置事件通道
     *
     * @public
     * @param {Object} ec 事件通道 
     */
    function setEventChannel(ec) {
        eventChannel = ec;
    }

    /**
     * 得到事件通道
     *
     * @public
     * @param {Object} 事件通道 
     */
    function getEventChannel() {
        return eventChannel;
    }

    /**
     * 设置或获取临时全局参数
     * 除非一些不好处理的问题，
     * 否则不建议使用！
     * 
     * @public
     * @param {string} key 使用者标志
     * @param {*} data
     */
    function setGlobalTemp(key, data) {
        globalTempData[key] = data;
    }

    /**
     * 设置或获取临时全局参数
     * 除非一些不好处理的问题，
     * 否则不建议使用！
     * 
     * @public
     * @param {string} key 使用者标志
     * @return {*} data
     */
    function getGlobalTemp(key) {
        return globalTempData[key];
    }

    /**
     * refPath变成唯一的key
     *
     * @private
     */
    function makePathKey(refPath) {
        return refPath.replace(/[\]\s]/g, '').replace(/\[/g, '.');
    }

    /**
     * 得到或创建事件代理
     *
     * @private
     */
    function registerEventAgent(obj, eventName) {
        var agent = obj[DI_EVENT_AGENT_TAG];
        if (!agent) {
            agent = obj[DI_EVENT_AGENT_TAG] = new XOBJECT();
            agent.eventNameMap = {};
        }
        if (eventName != null) {
            agent.eventNameMap[eventName] = 1;
        }
        else {
            agent.eventNameAll = 1;
        }
    }

    function getEventAgentByName(obj, eventName) {
        var agent = obj[DI_EVENT_AGENT_TAG];
        if (agent 
            && (
                agent.eventNameAll
                || agent.eventNameMap[eventName]
            )
        ) {
            return agent;
        }
    }

    function rootSnippet(id) {
        id && (rootSnippet = id) || (id = rootSnippet);
        var def = getEntity(id, 'DEF');
        assert(def, 'no def. id=' + id);
        return def;
    }

    /*
    function makeViewDisableFunc(disDef, actName, key) {
        if (!disDef) { return null; }

        var repCmpt = repository['COMPONENT'];
        var repCtnr = repository['VCONTAINER'];

        if (disDef == 'ALL') {
            disDef = [];
            for (id in repCmpt) { disDef.push(id); }
            for (id in repCtnr) { disDef.push(id); }
        }

        return function () {
            for (var i = 0, ins, id; i < disDef.length; i ++) {
                id = disDef[i];
                ins = repCmpt[id] || repCtnr[id];
                ins && ins.$di(actName, key);
            }
        }
    }*/

    function setFuncAuth(auth) {
        if (!auth) {
            return;
        }
        funcAuthKeys = {};
        for (var i = 0; i < (auth || []).length; i ++) {
            funcAuthKeys[auth[i]] = 1;
        }
    }

    function doViewDisable(disDef, actName, key) {
        if (!disDef) { return null; }

        var repCmpt = repository['COMPONENT'];
        var repCtnr = repository['VCONTAINER'];

        if (disDef == 'ALL') {
            disDef = [];
            for (id in repCmpt) { disDef.push(id); }
            for (id in repCtnr) { disDef.push(id); }
        }

        for (var i = 0, ins, id; i < disDef.length; i ++) {
            id = disDef[i];
            ins = repCmpt[id] || repCtnr[id];
            ins && ins.$di(actName, key);
        }
    }

    function setInteractMemo(ins, attr, value) {
        var memo = getDIAttr(ins, 'interactMemo');
        if (!memo) {
            setDIAttr(ins, 'interactMemo', memo = {});
        }
        if (value !== void 0) {
            memo[attr] = value;
        }
        else {
            delete memo[attr];
        }
    }

    function getInteractMemo(ins, attr) {
        var memo = getDIAttr(ins, 'interactMemo');
        return memo ? memo[attr] : void 0;
    }

    /**
     * 参数clone
     * 如果不为可clone的类型，则抛出异常
     *
     * @private
     * @param {*} args
     * @return {*} clone结果
     */
    function argsClone(args) {
        var result;
        var i;
        var len;
        var objStr = objProtoToString.call(args);
        var isArr;

        if (objStr == '[object Date]') {
            result = new Date(args.getTime());
        }
        else if (
            objStr == '[object Function]' 
            || objStr == '[object RegExp]'
        ) {
            result = args;
        }
        else if (
            // array也用下面方式复制，从而非数字key属性也能被复制
            (isArr = objStr == '[object Array]')
            // 对于其他所有Object，先检查是否是可以拷贝的object，
            // 如果不是，抛出异常，防止隐含错误
            || args === Object(args)
        ) {
            result = isArr ? [] : {};
            !isArr && checkObjectClonable(args);
            for (i in args) {
                if (args.hasOwnProperty(i)) {
                    result[i] = argsClone(args[i]);
                }
            }
        } 
        else {
            result = args;
        }
        return result;
    }

    /**
     * 检查对象是否可以拷贝。
     * 如果不可以，抛出异常；
     */
    function checkObjectClonable(obj) {
        var clonable = true;

        // 排除DOM元素
        if (Object.prototype.toString.call(obj) != '[object Object]'
            // 但是在IE中，DOM元素对上一句话返回true，
            // 所以使用字面量对象的原型上的isPrototypeOf来判断
            || !('isPrototypeOf' in obj)) {
            clonable = false;
        }

        // 试图排除new somefunc()创建出的对象
        if (// 如果没有constructor则通过
            obj.constructor
            // 有constructor但不在原型上时通过
            && !hasOwnProperty.call(obj, 'constructor') 
            // 用isPrototypeOf判断constructor是否为Object对象本身
            && !hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')
        ) {
            clonable = false;
        }

        if (!clonable) {
            throw new Error('Object can not be clone: ' + obj);
        }
    };    

})();
/**
 * di.shared.model.CommonParamFactory
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    通用请求参数处理器工厂
 * @author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function () {
    
    var clone = xutil.object.clone;
    var extend = xutil.object.extend;
    var textParam = xutil.url.textParam;
    var jsonStringify = di.helper.Util.jsonStringify;
    var isArray = xutil.lang.isArray;
    var isObject = xutil.lang.isObject;

    /** 
     * 通用请求参数获取器工厂
     * 
     * @class
     * @param {Object} options 参数
     * @param {Object} options.externalParam 报表外部参数
     */
    var COMMON_PARAM_FACTORY = $namespace().CommonParamFactory = 
        function (options) {
            // 外部传来的报表参数。
            // 这些参数会回传给前端，而后在前后端传递。
            this.externalParam = options 
                && clone(options.externalParam) 
                || {};
        };
    var COMMON_PARAM_FACTORY_CLASS = COMMON_PARAM_FACTORY.prototype;

    /**
     * 要将对象格式化为json传输的标志
     */
    var STRINGIFY_FLAG = 'diF\x06^_^jsonnosj^_^\x06';

    /**
     * 如果是对象，
     * 则标注用http传输数据使用的格式，
     * 可以是stringify成json的格式，
     * 或者普通格式
     *
     * @public
     * @static
     * @param {*} data 可转为json的对象
     * @param {string} paramMode 可为'NORMAL'（默认），'JSON'
     * @return 原输入
     */
    COMMON_PARAM_FACTORY.markParamMode = function(data, paramMode) {
        if (isObject(data)) {
            if (!paramMode || paramMode == 'NORMAL') {
                delete data[STRINGIFY_FLAG];
            }
            else {
                data[STRINGIFY_FLAG] = paramMode;
            }
        }
        return data;
    };

    /**
     * 得到生产环境的getter
     *
     * @public
     * @param {Object} options 参数
     * @param {Object} options.reportTemplateId 后台的reportTemplateId
     */
    COMMON_PARAM_FACTORY_CLASS.getGetter = function(options) {
        options = options || {};

        var externalParam = this.externalParam;

        /**
         * 即后台的reportTemplateId。
         * reportTemplateId在必须以snippet为单位。
         * 每次请求后台都须调用commonParamGetter.update(data)对其进行更新，
         * 因为针对于每个报表，一个snippet中的第一个请求总要是使用记录在模板中reportTemplateId
         * （形如PERSISTENT***）来请求，后台用这个id从DB中取出报表，生成一个副本，放入缓存，
         * 并返回这个副本的reportTemplateId（形如：SESSION_LOADED***），后续，此snippet中的所有请求，
         * 都须以这个副本的reportTemplateId作为参数。
         * 所以要用update函数对这个reportTemplateId进行更新。
         */
        var reportTemplateId = options.reportTemplateId;

        /**
         * 初始为'INIT'，允许调用commonParamGetter。
         * 第一次调用而未返回时变为'FORBIDDEN'，这时再次调用则抛出异常，
         * （这是为了防止报表设计时，设计出：一个报表初始用）
         * 第一次调用返回时，变为'OPEN'，以后可随意调用。
         */
        var loadValve = 'INIT';

        /**
         * 通用参数获取器，
         * 会进行encodeURIComponent，和去除空值
         *
         * @public
         * @param {Object=} paramObj 请求参数
         *      key为参数名，
         *      value为参数值，{string}或者{Array.<string>}类型
         * @param {string} paramMode 什么格式传输，值可为：
         *      'NORMAL'（默认）：普通格式（数组使用aa=2&aa=3&aa=5的方式，不支持对象传输）；
         *      'JSON'：使用json格式传输对象（含数组）
         * @return {string} 最终请求参数最终请求参数
         */
        function commonParamGetter(paramObj, paramMode) {
            if (loadValve == 'INIT') {
                loadValve = 'FORBIDDEN';
            }
            else if (loadValve == 'FORBIDDEN') {
                throw new Error('' 
                    + '一个snippet中的第一个请求不能并发，请调整报表设计。' 
                    + '在第一请求返回后再发出其他请求。'
                );
            }

            var o = {};
            extend(o, externalParam, paramObj);
            o.reportTemplateId = reportTemplateId;

            // o._REQ_KEY = reqKey || '';
            // if (diEvent) {
            // 
            // }

            return stringifyParam(o, paramMode);
        };

        /** 
         * 通用参数更新方法
         *
         * @public
         * @return {Object} options 参数
         * @return {Object} options.reportTemplateId 后台模板id
         */
        commonParamGetter.update = function (options) {
            // 后台的约定：无论何时，
            // 总是以reprotTemplateId这个名字进行 传参 和 回传。
            var rTplId = options && options.reportTemplateId || null;
            if (rTplId) {
                loadValve = 'OPEN';
                reportTemplateId = rTplId;
            }
            else if (loadValve != 'OPEN') {
                loadValve = 'INIT';
            }
        };

        /** 
         * 得到当前reportTemplateId
         *
         * @public
         * @return {string} 当前reportTemplateId
         */
        commonParamGetter.getReportTemplateId = function () {
            return reportTemplateId;
        };

        return commonParamGetter;
    };

    /**
     * 请求参数变为string
     * null和undefined会被转为空字符串
     * 可支持urlencoding
     * 
     * @public
     * @param {Object} paramObj 请求参数封装
     *      key为参数名，
     *      value为参数值，{string}或者{Array.<string>}类型   
     * @param {Object=} options 参数
     * @param {string=} options.paramMode 什么格式传输，值可为：
     *      'NORMAL'（默认）：普通格式（数组使用aa=2&aa=3&aa=5的方式，不支持对象传输）；
     *      'JSON'：使用json格式传输对象（含数组）
     * @param {string=} options.suffix 参数名后缀
     * @return {Array.<string>} 请求参数数组
     */
    function stringifyParam(paramObj, options) {
        var paramArr = [];
        options = options || {};

        function pushParam(name, value) {
            paramArr.push(textParam(name) + '=' + textParam(value));
        }

        var name;
        var value;
        var i;

        for (name in paramObj) {
            value = paramObj[name];

            // paramMode为'JSON'，
            // 无论数组还是对象，都格式化成json传输
            if (isObject(value) 
                && (options.paramMode == 'JSON' || value[STRINGIFY_FLAG] == 'JSON')
            ) {
                // 格式化成json前清理
                delete value[STRINGIFY_FLAG];

                // 格式化成json
                pushParam(name, jsonStringify(value));

                // 格式化成json后恢复
                value[STRINGIFY_FLAG] = 1;
            }
            // 没有json化标志，则用传统方式处理
            else {
                if (isArray(value)) {
                    for (i = 0; i < value.length; i ++) {
                        pushParam(name, value[i]);
                    }
                }
                else {
                    pushParam(name, value);
                }
            }
        }

        return paramArr.join('&');
    };    

})();


/**
 * di.shared.adapter.GeneralAdapterMethod
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    通用的默认适配器
 *           一般在di.config.Dict中使用adapterMethods来引用此中方法，
 *           拷贝到目标对象中
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var extend = xutil.object.extend;

    /**
     * 通用的适配器方法
     */
    $namespace().GeneralAdapterMethod = {
        ecuiCreate: ecuiCreate,
        ecuiDispose: ecuiDispose,
        xuiCreate: xuiCreate,
        xuiDispose: xuiDispose
    };

    /**
     * 创建ecui控件
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @return {Object} 创建的实例
     */
    function ecuiCreate(def, options) {
        return UTIL.ecuiCreate(def.clz, def.el, null, options);
    }

    /**
     * 释放ecui控件
     *
     * @public
     * @this {Object} 控件
     */
    function ecuiDispose() {
        UTIL.ecuiDispose(this);
    }

    /**
     * 创建xui-ui控件
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @return {Object} 创建的实例
     */
    function xuiCreate(def, options) {
        return new def.clz(options);
    }

    /**
     * 释放xui-ui控件
     *
     * @public
     * @this {Object} 控件
     */
    function xuiDispose() {
        this.dispose && this.dispose();
    }
    
    // ...

})();


/**
 * di.shared.ui.InteractEntity
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    Base Entity
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var assign = xutil.object.assign;
    var addClass = xutil.dom.addClass;
    var isObject = xutil.lang.isObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var XOBJECT = xui.XObject;
    var LANG = di.config.Lang;
    var alert;
    
    $link(function () {
        alert = di.helper.Dialog.alert;
    });    

    /**
     * Base Entity
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     * @param {Function=} options.commonParamGetter 
     *      得到公用的请求参数     
     */
    var INTERACT_ENTITY = $namespace().InteractEntity = 
        inheritsObject(
            XOBJECT,
            function (options) {

                // di开始必须
                this.$di('start', options);

                // 统一注册事件代理
                this.$di('registerEventAgent');

                // 禁用自身的notify和attach（只允许使用$di提供的）
                this.notify = this.attach = this.attachOnce =                 
                    function () {
                        throw new Error('Forbiden function');
                    };

                // 挂主cssClass
                var el = this.$di('getEl');
                var className = this.DEF.className;
                el && className && addClass(el, className);

                // 根据DEF创建model
                this.$createModelByDef(options);

                // 创建view
                this.$createView && this.$createView(options);
            }
        );
    var INTERACT_ENTITY_CLASS = INTERACT_ENTITY.prototype;
    
    /**
     * 定义信息
     */
    INTERACT_ENTITY_CLASS.DEF = {};

    /**
     * 根据定义信息，创建model
     *
     * @private
     */
    INTERACT_ENTITY_CLASS.$createModelByDef = function (options) {
        var modelDef = this.DEF.model;
        if (!modelDef) { return; }

        var clz = modelDef.clz 
            || (modelDef.clzPath && getByPath(modelDef.clzPath));
        if (!clz) { return; }

        // 创建model实例
        this._mModel = new clz(
            assign(
                {
                    commonParamGetter: this.$di('getCommonParamGetter'),
                    diFactory: this.$di('getDIFactory')
                },
                this.$createModelInitOpt(options)
            )
        );

        // 绑定默认方法   
        this._mModel.ajaxOptions = {
            defaultFailureHandler:
                bind(this.$defaultFailureHandler, this)
        };
    };

    /**
     * 得到model初始化参数
     * 由派生类自行实现
     *
     * @protected
     * @return {Object} 初始化参数
     */
    INTERACT_ENTITY_CLASS.$createModelInitOpt = function (options) {
        return {};
    };

    /**
     * 得到model
     *
     * @public
     * @return {Object} model
     */
    INTERACT_ENTITY_CLASS.getModel = function () {
        return this._mModel;
    };

    /**
     * 组装model sync的参数的统一方法
     *
     * @protected
     * @param {Object} model
     * @param {string} datasourceId
     * @param {Object} param
     * @param {Object} diEvent
     * @param {Object} opt
     */
    INTERACT_ENTITY_CLASS.$sync = function (
        model, datasourceId, param, diEvent, opt
    ) {
        var o = {
            datasourceId: datasourceId,
            args: {
                param: param,
                diEvent: diEvent
            }
        }
        assign(o.args, opt);
        return model.sync(o);
    };

    /**
     * 创建或得到dievent的方便方法
     * 用法一：$diEvent(options) 
     *      则得到options中的原有的diEvent（可能为undefined） 
     * 用法二：$diEvent('someEventName', options) 
     *      则得到事件名为'someEventName'的衍生diEvent，
     *      或者（没有使用diEvent时）得到eventnName本身
     *
     * @protected
     * @param {(string|Object)} eventName 如果为对象则表示此参数为options
     * @param {string=} options 走xdatasource的options，里面含有传递的diEvent属性
     */
    INTERACT_ENTITY_CLASS.$diEvent = function (eventName, options) {
        if (arguments.length == 1 && isObject(eventName)) {
            options = eventName;
            eventName = null;
        }

        var diEvent = options.args.diEvent;
        return eventName
            ? (diEvent ? diEvent(eventName) : eventName)
            : diEvent;
    };

    /**
     * sync时的解禁操作
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$syncEnable = function (datasourceId) {
        this.$di('syncViewDisable', 'enable', datasourceId);
        this.$di('enable', 'DI_SELF_' + datasourceId);
    };

    /**
     * sync时的禁用操作
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$syncDisable = function (datasourceId) {
        this.$di('syncViewDisable', 'disable', datasourceId);
        this.$di('disable', 'DI_SELF_' + datasourceId);
    };

    /**
     * 请求失败的默认处理
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$defaultFailureHandler = function (status, ejsonObj) {
        var eventChanel = this.$di('getEventChannel');

        switch (status) {
            case 10001: // session 过期
                eventChanel.triggerEvent('sessiontimeout');
                alert(LANG.SAD_FACE + LANG.RE_LOGIN, null, true);
                break;
            case 20001: // olap查询参数错误，由应用程序自己处理
                break;
            default:
                alert(LANG.SAD_FACE + LANG.ERROR);
        }
    };

})();
/**
 * di.shared.ui.GeneralSnippet
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 片段
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 片段
     * 
     * @class
     * @extends xui.XView
     */
    var SNIPPET = $namespace().GeneralSnippet = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var SNIPPET_CLASS = SNIPPET.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @constructor
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        // ...
    };
    
    /**
     * @override
     */
    SNIPPET_CLASS.dispose = function() {
    };

})();
/**
 * di.shared.ui.GeneralVContainer
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    VCONTAINER
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var XVIEW = xui.XView;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * VCONTAINER
     * 
     * @class
     * @extends xui.XView
     */
    var GENERAL_VCONTAINER = $namespace().GeneralVContainer = 
            inheritsObject(XVIEW, constructor);
    var GENERAL_VCONTAINER_CLASS = GENERAL_VCONTAINER.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @constructor
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        this._oOptions = assign({}, options);
    };
    
    /**
     * @override
     */
    GENERAL_VCONTAINER_CLASS.dispose = function() {
        this.$di('disposeMainEl');
    };

})();
/**
 * di.shared.ui.GeneralVPart
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    VCONTAINER
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var XVIEW = xui.XView;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * VCONTAINER
     * 
     * @class
     * @extends xui.XView
     */
    var GENERAL_VPART = $namespace().GeneralVPart = 
            inheritsObject(XVIEW, constructor);
    var GENERAL_VPART_CLASS = GENERAL_VPART.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @constructor
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        this._oOptions = assign({}, options);
    };
    
    /**
     * @override
     */
    GENERAL_VPART_CLASS.dispose = function() {
        this.$di('disposeMainEl');
    };

})();
/**
 * di.product.display.ui.LayoutPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    报表展示页面
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.product.display.ui');

(function () {
    
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var XVIEW = xui.XView;
    var SNIPPET_PARSER = di.helper.SnippetParser;
    var extend = xutil.object.extend;
    var merge = xutil.object.merge;
    var bind = xutil.fn.bind;
    var DICT = di.config.Dict;
    var ajaxRequest = baidu.ajax.request;
    var jsonParse = baidu.json.parse;
    var DI_FACTORY;
    var GLOBAL_MODEL;
    var URL;
    var COMMON_PARAM_FACTORY;
    var XOBJECT = xui.XObject;
    var DIALOG;
        
    $link(function () {
        URL = di.config.URL;
        GLOBAL_MODEL = di.shared.model.GlobalModel;
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
        DIALOG = di.helper.Dialog;
    });

    /**
     * 报表展示页面
     *
     * @class
     * @extends xui.XView
     */
    var LAYOUT_PAGE = $namespace().LayoutPage = 
            inheritsObject(XVIEW, constructor);
    var LAYOUT_PAGE_CLASS = LAYOUT_PAGE.prototype;
        
    /**
     * agent标志，表示是由stub加载的还是直接url加载的
     * 值可为'STUB'或空（默认）
     */
    var diAgent;

    /**
     * di-stub加载的情况下，prodStart开始的条件
     */
    var prodStartCond = {};

    /**
     * 是否已经初始化
     */
    var prodInitialized = false;

    /**
     * FIXME
     * 借用ecui的dom ready
     * @override
     */
    XVIEW.$domReady = ecui.dom.ready;

    /**
     * 构造函数
     *
     * @constructor
     * @public
     * @param {Object} options 初始化参数
     * @param {Object} options.externalParam 报表引擎外部传来的参数，
     *      浏览器端只回传，不识别
     */
    function constructor(options) {
        options = options || {};
        options.extraOpt = options.extraOpt || {};
        var diFactory = DI_FACTORY();
        var me = this;

        diAgent = options.diAgent;

        // web根路径
        URL.setWebRoot(options.webRoot);

        // 初始化全局模型
        GLOBAL_MODEL(options);

        var eventChannel = SNIPPET_PARSER().setupEventChannel(
            document, options, diFactory
        );

        // 对外事件通道注册
        if (eventChannel) {
            eventChannel.addEventListener('resize', bind(this.resize, this));
            eventChannel.addEventListener(
                'prodStart', 
                function () {
                    prodStartCond.prodStartEvent = true;
                    me.$prodStart();
                }
            );
        }

        // 设置功能权限
        diFactory.setFuncAuth(options.funcAuth);

        // 请求depict
        this.$prepareDepict(options)
    };

    /**
     * 生产环境开始
     *
     * @private
     */
    LAYOUT_PAGE_CLASS.$prodStart = function () {
        if (prodStartCond.prodInitFunc
            && (
                // 如果没有di-stub，则直接开始prodInit
                diAgent != 'STUB' 
                // 如果是由di-stub加载的，则依照di-stub的prodStart事件来触发开始
                // 否则不能保证保证prodInit在di-stub的iframe的onload事件完后才开始执行
                // （尤其在ie下，即便在ajax回调中，也不能保证顺序，谁快谁先）
                || prodStartCond.prodStartEvent
            )
        ) {
            prodStartCond.prodInitFunc();
        }
    };

    /**
     * 生产环境初始化
     *
     * @private
     */
    LAYOUT_PAGE_CLASS.$prodInit = function (depict, options) {
        if (prodInitialized) {
            return; 
        }
        prodInitialized = true;

        var me = this;
        var diFactory = DI_FACTORY();
        var def;

        // 全局提示
        DIALOG.setPromptDef(depict.prompt, diAgent);

        // 将每个报表特有的depict和公共定义的clzDef融合
        mergeClzDef(depict);

        // 初始化repo中的所有class
        diFactory.installClz();

        // 解析snippet生成def
        SNIPPET_PARSER().parseProdSnippet(
            document, depict, options, diFactory
        );

        var eParam = options.externalParam = options.externalParam || {};
        // prod端的标志，用于后台日志记录
        eParam._V_SRC = 'PROD';
        var commonParamFactory = new COMMON_PARAM_FACTORY(
            { externalParam: eParam }
        );

        // 创建commonParamGetter，以snippet为单位
        var paramGettterMap = {};
        diFactory.forEachEntity(
            ['SNIPPET'],
            function (def, ins, id) {
                paramGettterMap[def.id] = 
                    commonParamFactory.getGetter(
                        { reportTemplateId: def.reportTemplateId }
                    );
            }
        );

        // 对根snippet，用vm中的reportTemplateId更新
        var rootSnippet = diFactory.rootSnippet();
        paramGettterMap[rootSnippet.id].update(
            { reportTemplateId: options.reportTemplateId }
        );

        // 创健建实例
        diFactory.forEachEntity(
            [
                'SNIPPET',
                'VCONTAINER',
                'COMPONENT'
            ],
            function (def, ins, id) {
                var options = {};

                // 创建通用请求参数获取器
                if (def.clzType == 'COMPONENT') {
                    options.commonParamGetter = 
                        paramGettterMap[def.belong.snippet];

                    // 设置默认值
                    /**
                     * valueDisabledMode, 值可为：
                     *      'NORMAL'：如果disabled则不传参数
                     *      'DI'：如果disabled则传参数值为空（如asdf=&zxcv=)
                     *          （因为di中参数值为空则表示清空，不传则表示保留）
                     */
                    def.valueDisabledMode == null 
                        && (def.valueDisabledMode = 'DI');
                }

                // 创建实例
                diFactory.createIns(def, options);
            }
        );

        // rendered事件
        diFactory.forEachEntity(
            ['VCONTAINER', 'COMPONENT'],
            function (def, ins, id) {
                ins.$di(
                    'addEventListener', 
                    'rendered', 
                    me.$invalidateView, 
                    me
                );
            }
        );

        // component事件绑定
        diFactory.forEachEntity(
            'COMPONENT',
            function (def, ins, id) {
                diFactory.mountInteractions(ins);
            }
        );

        // 初始化
        diFactory.forEachEntity(
            [
                'SNIPPET',
                'VCONTAINER',
                'COMPONENT'
            ],
            function (def, ins, id) {
                ins.init();
            }
        );

        diFactory.addEntity(
            def = {
                "clzType": "COMPONENT",
                "id": diFactory.INIT_EVENT_AGENT_ID,
                "clzKey": "GENERAL_COMPONENT"
            },
            'DEF'
        );
        def = diFactory.getEntity(def.id, 'DEF');
        var initEventAgent = diFactory.createIns(def);

        // 初始化后行为
        diFactory.forEachEntity(
            'COMPONENT',
            function (def, ins, id) {
                if (def.init) {
                    diFactory.mountInteraction(
                        ins, 
                        extend(
                            {
                                event: { 
                                    rid: diFactory.INIT_EVENT_AGENT_ID,
                                    name: diFactory.INIT_EVENT_NAME 
                                }
                            },
                            def.init
                        )
                    );
                }
            }
        );

        // 功能权限验证
        diFactory.forEachEntity(
            [ 'COMPONENT' ],
            function (def, ins, id) {
                ins.$di('funcAuthVerify');
            }
        );

        // 触发init事件
        initEventAgent.$di('dispatchEvent', diFactory.INIT_EVENT_NAME);
    }

    /**
     * @override
     */
    LAYOUT_PAGE_CLASS.dispose = function () {
        GLOBAL_MODEL().dispose();

        // 析构unit控件
        // TODO

        LAYOUT_PAGE.superClass.$dispose.call(this);
    };

    /**
     * 设置视图过期
     * 
     * @private
     */
    LAYOUT_PAGE_CLASS.$invalidateView = function () {
        var me = this;

        /**
         * resize处理器
         *
         * @private
         */
        if (!this._hResizeHandler) {
            this._hResizeHandler = setTimeout(
                function () {
                    // resize
                    var eventChannel = DI_FACTORY().getEventChannel();
                    if (eventChannel) {
                        eventChannel.triggerEvent('resize');
                    }

                    me._hResizeHandler = null;
                },
                0
            )
        }
    };

    /**
     * 窗口改变重新计算大小
     * resize不能再触发rendered
     * 
     * @public
     */
    LAYOUT_PAGE_CLASS.resize = function () {
        DI_FACTORY().forEachEntity(
            'COMPONENT',
            function (def, ins, id) {
                ins.resize && ins.resize();
            }
        );
    };

    /**
     * 获得depict的内容
     * 
     * @public
     */
    LAYOUT_PAGE_CLASS.$prepareDepict = function (options) {
        var me = this;
        var remoteDepictRef = getRemoteDepictRef(options);
        var got = [];

        for (var i = 0; i < remoteDepictRef.length; i ++) {
            if (!remoteDepictRef[i]) {
                alert('depictRef 定义错误: ' + remoteDepictRef);
                break;
            }

            // 请求depict
            var url = [
                options.webRoot,
                DICT.VTPL_ROOT,
                options.bizKey,
                options.phase || 'release',
                remoteDepictRef[i]
            ].join('/') + '?__v__=' + options.repoVersion;

            ajaxRequest(
                url,
                {
                    method: 'GET',
                    onsuccess: onsuccess,
                    onfailure: bind(onfailure, null, url)
                }
            );
        }

        function onsuccess(xhr, rspText) {
            got.push(jsonParse(rspText));

            // depicts已经全部获取时
            if (got.length >= remoteDepictRef.length) {

                prodStartCond.prodInitFunc = bind(
                    me.$prodInit,
                    me,
                    mergeDepict(),
                    options
                );

                me.$prodStart();
            }
        }

        function onfailure(url, xhr, rspText) {
            alert(
                '获取depict失败：url=' + url
                + ' status=' + xhr.status
            );
        }

        function getRemoteDepictRef() {
            // 先extraOpt，后默认reportTemplateId
            var depictRef = (options.extraOpt.depictRef || []).slice();
            depictRef.push(options.persistentReportTemplateId + '.json');
            return depictRef;
        };

        function mergeDepict() {
            // 定义在snippet文件中的depict优先级最高
            got.splice(0, 0, options.extraOpt.depict || {});

            var rootSnippet;
            var prompt = {};
            var clzDefsMap = {};
            var entityDefsMap = [];
            var key;

            for (var i = 0, de; i < got.length; i ++) {
                if (de = got[i]) {
                    if (de.rootSnippet) {
                        rootSnippet = de.rootSnippet;
                    }
                    if (de.prompt) {
                        merge(prompt, de.prompt);
                    }

                    var j;
                    var def;
                    var o;

                    for (j = 0; j < (de.clzDefs || []).length; j ++) {
                        // clz定义
                        if ((def = de.clzDefs[j]) && (key = def.clzKey)) {
                            if (!(o = clzDefsMap[key])) {
                                o = clzDefsMap[key] = {};
                            }
                            merge(o, def);
                        }
                    }

                    for (j = 0; j < (de.entityDefs || []).length; j ++) {
                        // entity定义
                        if ((def = de.entityDefs[j]) && (key = def.id)) {
                            if (!(o = entityDefsMap[key])) {
                                o = entityDefsMap[key] = {};
                            }
                            merge(o, def);
                        }
                    }
                }
            }

            var clzDefs = [];
            for (key in clzDefsMap) {
                clzDefs.push(clzDefsMap[key]);
            }
            var entityDefs = [];
            for (key in entityDefsMap) {
                entityDefs.push(entityDefsMap[key]);
            }

            return {
                rootSnippet: rootSnippet,
                prompt: prompt,
                clzDefs: clzDefs,
                entityDefs: entityDefs
            };
        }
    };

    /**
     * 融合clzDef
     *
     * @private
     */
    function mergeClzDef(depict) {
        var clzDefs = depict.clzDefs || [];
        var clzDefMap = {};
        for (var i = 0, clzDef; clzDef = clzDefs[i]; i ++) {
            clzDefMap[clzDef.clzKey] = clzDef;
        }
        merge(DICT.CLZ, clzDefMap);  
    }

})();


/**
 * xui-ui
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    简单的ui
 *           这些ui是项目中不成体系的ui、简单的ui的集合
 * @author:  sushuang(sushuang@baidu.com)
 */

/**
 * @namespace
 */
xui.ui = {};

/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!memory;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( window.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.style.width = "2px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = marginDiv = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
		vb = "visibility:hidden;border:0;";
		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
		html = "<div " + style + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Figure out if the W3C box model works as expected
		div.innerHTML = "";
		div.style.width = div.style.paddingLeft = "1px";
		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
		}

		div.style.cssText = ptlm + vb;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		body.removeChild( container );
		div  = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, attr, name,
			data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var self = jQuery( this ),
					args = [ parts[0], value ];

				self.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;

					// See #9699 for explanation of this approach (setting first, then removal)
					jQuery.attr( elem, name, "" );
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( rboolean.test( name ) && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Determine handlers that should run if there are delegated events
		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
				selMatch = {};
				matches = [];
				jqcur[0] = cur;
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];
					sel = handleObj.selector;

					if ( selMatch[ sel ] === undefined ) {
						selMatch[ sel ] = (
							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
						);
					}
					if ( selMatch[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, matches: matches });
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						// If form was submitted by the user, bubble the event up the tree
						if ( this.parentNode && !event.isTrigger ) {
							jQuery.event.simulate( "submit", this.parentNode, event, true );
						}
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on.call( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					doneName = match[0];
					parent = elem.parentNode;
	
					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent[ expando ] = doneName;
					}
					
					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( 
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ? 
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret === null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight,
		i = 0,
		len = which.length;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i++ ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i++ ) {
			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
			}
		}
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			for ( p in prop ) {

				// property name normalization
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Adds width/height step functions
// Do not set anything below 0
jQuery.each([ "width", "height" ], function( i, prop ) {
	jQuery.fx.step[ prop ] = function( fx ) {
		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
	};
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if ( !elem ) {
				return null;
			}

			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

		// Set the scroll offset
		return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i ? val : jQuery( win ).scrollLeft(),
					 i ? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ],
				body = elem.document.body;
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNumeric( ret ) ? ret : orig;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

// Customized highstock. (any problem, contact sushuang@baidu.com)
// All modifications are marked as [CUSTOMIZED].
// Change log:
// (1) tooltip move: forbiden animation in IE6/7/8
// (2) fix bug: rangeSelector button sometimes does not be set unselect 
//     (this bug is fixed in 1.1.6, but there are another bug in 1.1.6 (#1105), so we still use 1.1.5)
// (3) add quarter format support in dateFormat
// (4) add support of user defined rangeSelector
// (5) fix reflow bug: execute resize (by setTimeout) after chart is destroyed.

// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS

/**
 * @license Highstock JS v1.1.5 (2012-03-15)
 *
 * (c) 2009-2011 Torstein Hønsi
 *
 * License: www.highcharts.com/license
 */

// JSLint options:
/*global Highcharts, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console */

(function () {
// encapsulated variables
var UNDEFINED,
	doc = document,
	win = window,
	math = Math,
	mathRound = math.round,
	mathFloor = math.floor,
	mathCeil = math.ceil,
	mathMax = math.max,
	mathMin = math.min,
	mathAbs = math.abs,
	mathCos = math.cos,
	mathSin = math.sin,
	mathPI = math.PI,
	deg2rad = mathPI * 2 / 360,


	// some variables
	userAgent = navigator.userAgent,
	isIE = /msie/i.test(userAgent) && !win.opera,
	ieVersion = /msie (\d+\.\d+)/i.test(userAgent) ? (document.documentMode || + RegExp['\x241']) : undefined,
	docMode8 = doc.documentMode === 8,
	isWebKit = /AppleWebKit/.test(userAgent),
	isFirefox = /Firefox/.test(userAgent),
	SVG_NS = 'http://www.w3.org/2000/svg',
	hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
	useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
	Renderer,
	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED,
	symbolSizes = {},
	idCounter = 0,
	garbageBin,
	defaultOptions,
	dateFormat, // function
	globalAnimation,
	pathAnim,
	timeUnits,

	// some constants for frequently used strings
	DIV = 'div',
	ABSOLUTE = 'absolute',
	RELATIVE = 'relative',
	HIDDEN = 'hidden',
	PREFIX = 'highcharts-',
	VISIBLE = 'visible',
	PX = 'px',
	NONE = 'none',
	M = 'M',
	L = 'L',
	/*
	 * Empirical lowest possible opacities for TRACKER_FILL
	 * IE6: 0.002
	 * IE7: 0.002
	 * IE8: 0.002
	 * IE9: 0.00000000001 (unlimited)
	 * FF: 0.00000000001 (unlimited)
	 * Chrome: 0.000001
	 * Safari: 0.000001
	 * Opera: 0.00000000001 (unlimited)
	 */
	TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.000001 : 0.002) + ')', // invisible but clickable
	//TRACKER_FILL = 'rgba(192,192,192,0.5)',
	NORMAL_STATE = '',
	HOVER_STATE = 'hover',
	SELECT_STATE = 'select',
	MILLISECOND = 'millisecond',
	SECOND = 'second',
	MINUTE = 'minute',
	HOUR = 'hour',
	DAY = 'day',
	WEEK = 'week',
	MONTH = 'month',
	YEAR = 'year',

	// constants for attributes
	FILL = 'fill',
	LINEAR_GRADIENT = 'linearGradient',
	STOPS = 'stops',
	STROKE = 'stroke',
	STROKE_WIDTH = 'stroke-width',

	// time methods, changed based on whether or not UTC is used
	makeTime,
	getMinutes,
	getHours,
	getDay,
	getDate,
	getMonth,
	getFullYear,
	setMinutes,
	setHours,
	setDate,
	setMonth,
	setFullYear,

	// check for a custom HighchartsAdapter defined prior to this file
	globalAdapter = win.HighchartsAdapter,
	adapter = globalAdapter || {},

	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
	// and all the utility functions will be null. In that case they are populated by the
	// default adapters below.
	getScript = adapter.getScript,
	each = adapter.each,
	grep = adapter.grep,
	offset = adapter.offset,
	map = adapter.map,
	merge = adapter.merge,
	addEvent = adapter.addEvent,
	removeEvent = adapter.removeEvent,
	fireEvent = adapter.fireEvent,
	animate = adapter.animate,
	stop = adapter.stop,

	// lookup over the types and the associated classes
	seriesTypes = {};

// The Highcharts namespace
win.Highcharts = {};

/**
 * Extend an object with the members of another
 * @param {Object} a The object to be extended
 * @param {Object} b The object to add to the first one
 */
function extend(a, b) {
	var n;
	if (!a) {
		a = {};
	}
	for (n in b) {
		a[n] = b[n];
	}
	return a;
}

/**
 * Take an array and turn into a hash with even number arguments as keys and odd numbers as
 * values. Allows creating constants for commonly used style properties, attributes etc.
 * Avoid it in performance critical situations like looping
 */
function hash() {
	var i = 0,
		args = arguments,
		length = args.length,
		obj = {};
	for (; i < length; i++) {
		obj[args[i++]] = args[i];
	}
	return obj;
}

/**
 * Shortcut for parseInt
 * @param {Object} s
 * @param {Number} mag Magnitude
 */
function pInt(s, mag) {
	return parseInt(s, mag || 10);
}

/**
 * Check for string
 * @param {Object} s
 */
function isString(s) {
	return typeof s === 'string';
}

/**
 * Check for object
 * @param {Object} obj
 */
function isObject(obj) {
	return typeof obj === 'object';
}

/**
 * Check for array
 * @param {Object} obj
 */
function isArray(obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
}

/**
 * Check for number
 * @param {Object} n
 */
function isNumber(n) {
	return typeof n === 'number';
}

function log2lin(num) {
	return math.log(num) / math.LN10;
}
function lin2log(num) {
	return math.pow(10, num);
}

/**
 * Remove last occurence of an item from an array
 * @param {Array} arr
 * @param {Mixed} item
 */
function erase(arr, item) {
	var i = arr.length;
	while (i--) {
		if (arr[i] === item) {
			arr.splice(i, 1);
			break;
		}
	}
	//return arr;
}

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== UNDEFINED && obj !== null;
}

/**
 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
 * it attempts to set expando properties on the SVG element, which is not allowed.
 *
 * @param {Object} elem The DOM element to receive the attribute(s)
 * @param {String|Object} prop The property or an abject of key-value pairs
 * @param {String} value The value if a single property is set
 */
function attr(elem, prop, value) {
	var key,
		setAttribute = 'setAttribute',
		ret;

	// if the prop is a string
	if (isString(prop)) {
		// set the value
		if (defined(value)) {

			elem[setAttribute](prop, value);

		// get the value
		} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
			ret = elem.getAttribute(prop);
		}

	// else if prop is defined, it is a hash of key/value pairs
	} else if (defined(prop) && isObject(prop)) {
		for (key in prop) {
			elem[setAttribute](key, prop[key]);
		}
	}
	return ret;
}
/**
 * Check if an element is an array, and if not, make it into an array. Like
 * MooTools' $.splat.
 */
function splat(obj) {
	return isArray(obj) ? obj : [obj];
}


/**
 * Return the first value that is defined. Like MooTools' $.pick.
 */
function pick() {
	var args = arguments,
		i,
		arg,
		length = args.length;
	for (i = 0; i < length; i++) {
		arg = args[i];
		if (typeof arg !== 'undefined' && arg !== null) {
			return arg;
		}
	}
}

/**
 * Set CSS on a given element
 * @param {Object} el
 * @param {Object} styles Style object with camel case property names
 */
function css(el, styles) {
	if (isIE) {
		if (styles && styles.opacity !== UNDEFINED) {
			styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
		}
	}
	extend(el.style, styles);
}

/**
 * Utility function to create element with attributes and styles
 * @param {Object} tag
 * @param {Object} attribs
 * @param {Object} styles
 * @param {Object} parent
 * @param {Object} nopad
 */
function createElement(tag, attribs, styles, parent, nopad) {
	var el = doc.createElement(tag);
	if (attribs) {
		extend(el, attribs);
	}
	if (nopad) {
		css(el, {padding: 0, border: NONE, margin: 0});
	}
	if (styles) {
		css(el, styles);
	}
	if (parent) {
		parent.appendChild(el);
	}
	return el;
}

/**
 * Extend a prototyped class by new members
 * @param {Object} parent
 * @param {Object} members
 */
function extendClass(parent, members) {
	var object = function () {};
	object.prototype = new parent();
	extend(object.prototype, members);
	return object;
}

/**
 * Format a number and return a string based on input settings
 * @param {Number} number The input number to format
 * @param {Number} decimals The amount of decimals
 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
 */
function numberFormat(number, decimals, decPoint, thousandsSep) {
	var lang = defaultOptions.lang,
		// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
		n = number,
		c = isNaN(decimals = mathAbs(decimals)) ? 2 : decimals,
		d = decPoint === undefined ? lang.decimalPoint : decPoint,
		t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
		s = n < 0 ? "-" : "",
		i = String(pInt(n = mathAbs(+n || 0).toFixed(c))),
		j = i.length > 3 ? i.length % 3 : 0;

	return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
		(c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
}

/**
 * Pad a string to a given length by adding 0 to the beginning
 * @param {Number} number
 * @param {Number} length
 */
function pad(number, length) {
	// Create an array of the remaining length +1 and join it with 0's
	return new Array((length || 2) + 1 - String(number).length).join(0) + number;
}

/**
 * Based on http://www.php.net/manual/en/function.strftime.php
 * @param {String} format
 * @param {Number} timestamp
 * @param {Boolean} capitalize
 */
dateFormat = function (format, timestamp, capitalize) {
	if (!defined(timestamp) || isNaN(timestamp)) {
		return 'Invalid date';
	}
	format = pick(format, '%Y-%m-%d %H:%M:%S');

	var date = new Date(timestamp),
		key, // used in for constuct below
		// get the basic time values
		hours = date[getHours](),
		day = date[getDay](),
		dayOfMonth = date[getDate](),
		month = date[getMonth](),
		fullYear = date[getFullYear](),
		lang = defaultOptions.lang,
		langWeekdays = lang.weekdays,
		/* // uncomment this and the 'W' format key below to enable week numbers
		weekNumber = function () {
			var clone = new Date(date.valueOf()),
				day = clone[getDay]() == 0 ? 7 : clone[getDay](),
				dayNumber;
			clone.setDate(clone[getDate]() + 4 - day);
			dayNumber = mathFloor((clone.getTime() - new Date(clone[getFullYear](), 0, 1, -6)) / 86400000);
			return 1 + mathFloor(dayNumber / 7);
		},
		*/

		// list all format keys
		replacements = {

			// Day
			'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
			'A': langWeekdays[day], // Long weekday, like 'Monday'
			'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
			'e': dayOfMonth, // Day of the month, 1 through 31

			// Week (none implemented)
			//'W': weekNumber(),

			// Month
			'b': lang.shortMonths[month], // Short month, like 'Jan'
			'B': lang.months[month], // Long month, like 'January'
			'm': pad(month + 1), // Two digit month number, 01 through 12

            // Quarter
            // [CUSTOMIZED]
            'q': 'Q' + (Math.floor(month / 3) + 1),

			// Year
			'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
			'Y': fullYear, // Four digits year, like 2009

			// Time
			'H': pad(hours), // Two digits hours in 24h format, 00 through 23
			'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
			'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
			'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
			'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
			'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
			'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
			'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
		};


	// do the replaces
	for (key in replacements) {
		format = format.replace('%' + key, replacements[key]);
	}

	// Optionally capitalize the string and return
	return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
};

/**
 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
 * @param {Number} interval
 * @param {Array} multiples
 * @param {Number} magnitude
 * @param {Object} options
 */
function normalizeTickInterval(interval, multiples, magnitude, options) {
	var normalized, i;

	// round to a tenfold of 1, 2, 2.5 or 5
	magnitude = pick(magnitude, 1);
	normalized = interval / magnitude;

	// multiples for a linear scale
	if (!multiples) {
		multiples = [1, 2, 2.5, 5, 10];

		// the allowDecimals option
		if (options && options.allowDecimals === false) {
			if (magnitude === 1) {
				multiples = [1, 2, 5, 10];
			} else if (magnitude <= 0.1) {
				multiples = [1 / magnitude];
			}
		}
	}

	// normalize the interval to the nearest multiple
	for (i = 0; i < multiples.length; i++) {
		interval = multiples[i];
		if (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
			break;
		}
	}

	// multiply back to the correct magnitude
	interval *= magnitude;

	return interval;
}

/**
 * Get a normalized tick interval for dates. Returns a configuration object with
 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
 * of segments in stock charts, the normalizing logic was extracted in order to 
 * prevent it for running over again for each segment having the same interval. 
 * #662, #697.
 */
function normalizeTimeTickInterval(tickInterval, unitsOption) {
	var units = unitsOption || [[
				MILLISECOND, // unit name
				[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
			], [
				SECOND,
				[1, 2, 5, 10, 15, 30]
			], [
				MINUTE,
				[1, 2, 5, 10, 15, 30]
			], [
				HOUR,
				[1, 2, 3, 4, 6, 8, 12]
			], [
				DAY,
				[1, 2]
			], [
				WEEK,
				[1, 2]
			], [
				MONTH,
				[1, 2, 3, 4, 6]
			], [
				YEAR,
				null
			]],
		unit = units[units.length - 1], // default unit is years
		interval = timeUnits[unit[0]],
		multiples = unit[1],
		count,
		i;
		
	// loop through the units to find the one that best fits the tickInterval
	for (i = 0; i < units.length; i++) {
		unit = units[i];
		interval = timeUnits[unit[0]];
		multiples = unit[1];


		if (units[i + 1]) {
			// lessThan is in the middle between the highest multiple and the next unit.
			var lessThan = (interval * multiples[multiples.length - 1] +
						timeUnits[units[i + 1][0]]) / 2;

			// break and keep the current unit
			if (tickInterval <= lessThan) {
				break;
			}
		}
	}

	// prevent 2.5 years intervals, though 25, 250 etc. are allowed
	if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
		multiples = [1, 2, 5];
	}
	
	// prevent 2.5 years intervals, though 25, 250 etc. are allowed
	if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
		multiples = [1, 2, 5];
	}

	// get the count
	count = normalizeTickInterval(tickInterval / interval, multiples);
	
	return {
		unitRange: interval,
		count: count,
		unitName: unit[0]
	};
}

/**
 * Set the tick positions to a time unit that makes sense, for example
 * on the first of each month or on every Monday. Return an array
 * with the time positions. Used in datetime axes as well as for grouping
 * data on a datetime axis.
 *
 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
 * @param {Number} min The minimum in axis values
 * @param {Number} max The maximum in axis values
 * @param {Number} startOfWeek
 */
function getTimeTicks(normalizedInterval, min, max, startOfWeek) {
	var tickPositions = [],
		i,
		higherRanks = {},
		useUTC = defaultOptions.global.useUTC,
		minYear, // used in months and years as a basis for Date.UTC()
		minDate = new Date(min),
		interval = normalizedInterval.unitRange,
		count = normalizedInterval.count;

	

	if (interval >= timeUnits[SECOND]) { // second
		minDate.setMilliseconds(0);
		minDate.setSeconds(interval >= timeUnits[MINUTE] ? 0 :
			count * mathFloor(minDate.getSeconds() / count));
	}

	if (interval >= timeUnits[MINUTE]) { // minute
		minDate[setMinutes](interval >= timeUnits[HOUR] ? 0 :
			count * mathFloor(minDate[getMinutes]() / count));
	}

	if (interval >= timeUnits[HOUR]) { // hour
		minDate[setHours](interval >= timeUnits[DAY] ? 0 :
			count * mathFloor(minDate[getHours]() / count));
	}

	if (interval >= timeUnits[DAY]) { // day
		minDate[setDate](interval >= timeUnits[MONTH] ? 1 :
			count * mathFloor(minDate[getDate]() / count));
	}

	if (interval >= timeUnits[MONTH]) { // month
		minDate[setMonth](interval >= timeUnits[YEAR] ? 0 :
			count * mathFloor(minDate[getMonth]() / count));
		minYear = minDate[getFullYear]();
	}

	if (interval >= timeUnits[YEAR]) { // year
		minYear -= minYear % count;
		minDate[setFullYear](minYear);
	}

	// week is a special case that runs outside the hierarchy
	if (interval === timeUnits[WEEK]) {
		// get start of current week, independent of count
		minDate[setDate](minDate[getDate]() - minDate[getDay]() +
			pick(startOfWeek, 1));
	}


	// get tick positions
	i = 1;
	minYear = minDate[getFullYear]();
	var time = minDate.getTime(),
		minMonth = minDate[getMonth](),
		minDateDate = minDate[getDate]();

	// iterate and add tick positions at appropriate values
	while (time < max) {
		tickPositions.push(time);

		// if the interval is years, use Date.UTC to increase years
		if (interval === timeUnits[YEAR]) {
			time = makeTime(minYear + i * count, 0);

		// if the interval is months, use Date.UTC to increase months
		} else if (interval === timeUnits[MONTH]) {
			time = makeTime(minYear, minMonth + i * count);

		// if we're using global time, the interval is not fixed as it jumps
		// one hour at the DST crossover
		} else if (!useUTC && (interval === timeUnits[DAY] || interval === timeUnits[WEEK])) {
			time = makeTime(minYear, minMonth, minDateDate +
				i * count * (interval === timeUnits[DAY] ? 1 : 7));

		// else, the interval is fixed and we use simple addition
		} else {
			time += interval * count;
			
			// mark new days if the time is dividable by day
			if (interval <= timeUnits[HOUR] && time % timeUnits[DAY] === 0) {
				higherRanks[time] = DAY;
			}
		}

		i++;
	}
	
	// push the last time
	tickPositions.push(time);

	// record information on the chosen unit - for dynamic label formatter
	tickPositions.info = extend(normalizedInterval, {
		higherRanks: higherRanks,
		totalRange: interval * count
	});

	return tickPositions;
}

/**
 * Helper class that contains variuos counters that are local to the chart.
 */
function ChartCounters() {
	this.color = 0;
	this.symbol = 0;
}

ChartCounters.prototype =  {
	/**
	 * Wraps the color counter if it reaches the specified length.
	 */
	wrapColor: function (length) {
		if (this.color >= length) {
			this.color = 0;
		}
	},

	/**
	 * Wraps the symbol counter if it reaches the specified length.
	 */
	wrapSymbol: function (length) {
		if (this.symbol >= length) {
			this.symbol = 0;
		}
	}
};

/**
 * Utility method extracted from Tooltip code that places a tooltip in a chart without spilling over
 * and not covering the point it self.
 */
function placeBox(boxWidth, boxHeight, outerLeft, outerTop, outerWidth, outerHeight, point, distance, preferRight) {
	
	// keep the box within the chart area
	var pointX = point.x,
		pointY = point.y,
		x = pointX + outerLeft + (preferRight ? distance : -boxWidth - distance),
		y = pointY - boxHeight + outerTop + 15, // 15 means the point is 15 pixels up from the bottom of the tooltip
		alignedRight;

	// it is too far to the left, adjust it
	if (x < 7) {
		x = outerLeft + pointX + distance;
	}

	// Test to see if the tooltip is too far to the right,
	// if it is, move it back to be inside and then up to not cover the point.
	if ((x + boxWidth) > (outerLeft + outerWidth)) {
		x -= (x + boxWidth) - (outerLeft + outerWidth);
		y = pointY - boxHeight + outerTop - distance;
		alignedRight = true;
	}

	// if it is now above the plot area, align it to the top of the plot area
	if (y < outerTop + 5) {
		y = outerTop + 5;

		// If the tooltip is still covering the point, move it below instead
		if (alignedRight && pointY >= y && pointY <= (y + boxHeight)) {
			y = pointY + outerTop + distance; // below
		}
	} else if (y + boxHeight > outerTop + outerHeight) {
		y = outerTop + outerHeight - boxHeight - distance; // below
	}

	return {x: x, y: y};
}

/**
 * Utility method that sorts an object array and keeping the order of equal items.
 * ECMA script standard does not specify the behaviour when items are equal.
 */
function stableSort(arr, sortFunction) {
	var length = arr.length,
		sortValue,
		i;

	// Add index to each item
	for (i = 0; i < length; i++) {
		arr[i].ss_i = i; // stable sort index
	}

	arr.sort(function (a, b) {
		sortValue = sortFunction(a, b);
		return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
	});

	// Remove index from items
	for (i = 0; i < length; i++) {
		delete arr[i].ss_i; // stable sort index
	}
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMin(data) {
	var i = data.length,
		min = data[0];

	while (i--) {
		if (data[i] < min) {
			min = data[i];
		}
	}
	return min;
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMax(data) {
	var i = data.length,
		max = data[0];

	while (i--) {
		if (data[i] > max) {
			max = data[i];
		}
	}
	return max;
}

/**
 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
 * It loops all properties and invokes destroy if there is a destroy method. The property is
 * then delete'ed.
 */
function destroyObjectProperties(obj) {
	var n;
	for (n in obj) {
		// If the object is non-null and destroy is defined
		if (obj[n] && obj[n].destroy) {
			// Invoke the destroy
			obj[n].destroy();
		}

		// Delete the property from the object.
		delete obj[n];
	}
}


/**
 * Discard an element by moving it to the bin and delete
 * @param {Object} The HTML node to discard
 */
function discardElement(element) {
	// create a garbage bin element, not part of the DOM
	if (!garbageBin) {
		garbageBin = createElement(DIV);
	}

	// move the node and empty bin
	if (element) {
		garbageBin.appendChild(element);
	}
	garbageBin.innerHTML = '';
}

/**
 * Provide error messages for debugging, with links to online explanation 
 */
function error(code, stop) {
	var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
	if (stop) {
		throw msg;
	} else if (win.console) {
		console.log(msg);
	}
}

/**
 * Fix JS round off float errors
 * @param {Number} num
 */
function correctFloat(num) {
	return parseFloat(
		num.toPrecision(14)
	);
}

/**
 * The time unit lookup
 */
/*jslint white: true*/
timeUnits = hash(
	MILLISECOND, 1,
	SECOND, 1000,
	MINUTE, 60000,
	HOUR, 3600000,
	DAY, 24 * 3600000,
	WEEK, 7 * 24 * 3600000,
	MONTH, 30 * 24 * 3600000,
	YEAR, 31556952000
);
/*jslint white: false*/
/**
 * Path interpolation algorithm used across adapters
 */
pathAnim = {
	/**
	 * Prepare start and end values so that the path can be animated one to one
	 */
	init: function (elem, fromD, toD) {
		fromD = fromD || '';
		var shift = elem.shift,
			bezier = fromD.indexOf('C') > -1,
			numParams = bezier ? 7 : 3,
			endLength,
			slice,
			i,
			start = fromD.split(' '),
			end = [].concat(toD), // copy
			startBaseLine,
			endBaseLine,
			sixify = function (arr) { // in splines make move points have six parameters like bezier curves
				i = arr.length;
				while (i--) {
					if (arr[i] === M) {
						arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
					}
				}
			};

		if (bezier) {
			sixify(start);
			sixify(end);
		}

		// pull out the base lines before padding
		if (elem.isArea) {
			startBaseLine = start.splice(start.length - 6, 6);
			endBaseLine = end.splice(end.length - 6, 6);
		}

		// if shifting points, prepend a dummy point to the end path
		if (shift === 1) {

			end = [].concat(end).splice(0, numParams).concat(end);
		}
		elem.shift = 0; // reset for following animations

		// copy and append last point until the length matches the end length
		if (start.length) {
			endLength = end.length;
			while (start.length < endLength) {

				//bezier && sixify(start);
				slice = [].concat(start).splice(start.length - numParams, numParams);
				if (bezier) { // disable first control point
					slice[numParams - 6] = slice[numParams - 2];
					slice[numParams - 5] = slice[numParams - 1];
				}
				start = start.concat(slice);
			}
		}

		if (startBaseLine) { // append the base lines for areas
			start = start.concat(startBaseLine);
			end = end.concat(endBaseLine);
		}
		return [start, end];
	},

	/**
	 * Interpolate each value of the path and return the array
	 */
	step: function (start, end, pos, complete) {
		var ret = [],
			i = start.length,
			startVal;

		if (pos === 1) { // land on the final path without adjustment points appended in the ends
			ret = complete;

		} else if (i === end.length && pos < 1) {
			while (i--) {
				startVal = parseFloat(start[i]);
				ret[i] =
					isNaN(startVal) ? // a letter instruction like M or L
						start[i] :
						pos * (parseFloat(end[i] - startVal)) + startVal;

			}
		} else { // if animation is finished or length not matching, land on right value
			ret = end;
		}
		return ret;
	}
};


/**
 * Set the global animation to either a given value, or fall back to the
 * given chart's animation option
 * @param {Object} animation
 * @param {Object} chart
 */
function setAnimation(animation, chart) {
	globalAnimation = pick(animation, chart.animation);
}

/*
 * Define the adapter for frameworks. If an external adapter is not defined,
 * Highcharts reverts to the built-in jQuery adapter.
 */
if (globalAdapter && globalAdapter.init) {
	// Initialize the adapter with the pathAnim object that takes care
	// of path animations.
	globalAdapter.init(pathAnim);
}
if (!globalAdapter && win.jQuery) {
	var jQ = jQuery;

	/**
	 * Downloads a script and executes a callback when done.
	 * @param {String} scriptLocation
	 * @param {Function} callback
	 */
	getScript = jQ.getScript;

	/**
	 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
	 * @param {Array} arr
	 * @param {Function} fn
	 */
	each = function (arr, fn) {
		var i = 0,
			len = arr.length;
		for (; i < len; i++) {
			if (fn.call(arr[i], arr[i], i, arr) === false) {
				return i;
			}
		}
	};

	/**
	 * Filter an array
	 */
	grep = jQ.grep;

	/**
	 * Map an array
	 * @param {Array} arr
	 * @param {Function} fn
	 */
	map = function (arr, fn) {
		//return jQuery.map(arr, fn);
		var results = [],
			i = 0,
			len = arr.length;
		for (; i < len; i++) {
			results[i] = fn.call(arr[i], arr[i], i, arr);
		}
		return results;

	};

	/**
	 * Deep merge two objects and return a third object
	 */
	merge = function () {
		var args = arguments;
		return jQ.extend(true, null, args[0], args[1], args[2], args[3]);
	};

	/**
	 * Get the position of an element relative to the top left of the page
	 */
	offset = function (el) {
		return jQ(el).offset();
	};

	/**
	 * Add an event listener
	 * @param {Object} el A HTML element or custom object
	 * @param {String} event The event type
	 * @param {Function} fn The event handler
	 */
	addEvent = function (el, event, fn) {
		jQ(el).bind(event, fn);
	};

	/**
	 * Remove event added with addEvent
	 * @param {Object} el The object
	 * @param {String} eventType The event type. Leave blank to remove all events.
	 * @param {Function} handler The function to remove
	 */
	removeEvent = function (el, eventType, handler) {
		// workaround for jQuery issue with unbinding custom events:
		// http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
		var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
		if (doc[func] && !el[func]) {
			el[func] = function () {};
		}

		jQ(el).unbind(eventType, handler);
	};

	/**
	 * Fire an event on a custom object
	 * @param {Object} el
	 * @param {String} type
	 * @param {Object} eventArguments
	 * @param {Function} defaultFunction
	 */
	fireEvent = function (el, type, eventArguments, defaultFunction) {
		var event = jQ.Event(type),
			detachedType = 'detached' + type,
			defaultPrevented;

		extend(event, eventArguments);

		// Prevent jQuery from triggering the object method that is named the
		// same as the event. For example, if the event is 'select', jQuery
		// attempts calling el.select and it goes into a loop.
		if (el[type]) {
			el[detachedType] = el[type];
			el[type] = null;
		}

		// Wrap preventDefault and stopPropagation in try/catch blocks in
		// order to prevent JS errors when cancelling events on non-DOM
		// objects. #615.
		each(['preventDefault', 'stopPropagation'], function (fn) {
			var base = event[fn];
			event[fn] = function () {
				try {
					base.call(event);
				} catch (e) {
					if (fn === 'preventDefault') {
						defaultPrevented = true;
					}
				}
			};
		});

		// trigger it
		jQ(el).trigger(event);

		// attach the method
		if (el[detachedType]) {
			el[type] = el[detachedType];
			el[detachedType] = null;
		}

		if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
			defaultFunction(event);
		}
	};

	/**
	 * Animate a HTML element or SVG element wrapper
	 * @param {Object} el
	 * @param {Object} params
	 * @param {Object} options jQuery-like animation options: duration, easing, callback
	 */
	animate = function (el, params, options) {
		var $el = jQ(el);
		if (params.d) {
			el.toD = params.d; // keep the array form for paths, used in jQ.fx.step.d
			params.d = 1; // because in jQuery, animating to an array has a different meaning
		}

		$el.stop();
		$el.animate(params, options);

	};
	/**
	 * Stop running animation
	 */
	stop = function (el) {
		jQ(el).stop();
	};


	//=== Extend jQuery on init

	/*jslint unparam: true*//* allow unused param x in this function */
	jQ.extend(jQ.easing, {
		easeOutQuad: function (x, t, b, c, d) {
			return -c * (t /= d) * (t - 2) + b;
		}
	});
	/*jslint unparam: false*/

	// extend the animate function to allow SVG animations
	var jFx = jQuery.fx,
		jStep = jFx.step;

	// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
	each(['cur', '_default', 'width', 'height'], function (fn, i) {
		var obj = i ? jStep : jFx.prototype, // 'cur', the getter' relates to jFx.prototype
			base = obj[fn],
			elem;

		if (base) { // step.width and step.height don't exist in jQuery < 1.7

			// create the extended function replacement
			obj[fn] = function (fx) {

				// jFx.prototype.cur does not use fx argument
				fx = i ? fx : this;

				// shortcut
				elem = fx.elem;

				// jFX.prototype.cur returns the current value. The other ones are setters
				// and returning a value has no effect.
				return elem.attr ? // is SVG element wrapper
					elem.attr(fx.prop, fx.now) : // apply the SVG wrapper's method
					base.apply(this, arguments); // use jQuery's built-in method
			};
		}
	});

	// animate paths
	jStep.d = function (fx) {
		var elem = fx.elem;


		// Normally start and end should be set in state == 0, but sometimes,
		// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
		// in these cases
		if (!fx.started) {
			var ends = pathAnim.init(elem, elem.d, elem.toD);
			fx.start = ends[0];
			fx.end = ends[1];
			fx.started = true;
		}


		// interpolate each value of the path
		elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));

	};
}

/* ****************************************************************************
 * Handle the options                                                         *
 *****************************************************************************/
var

defaultLabelOptions = {
	enabled: true,
	// rotation: 0,
	align: 'center',
	x: 0,
	y: 15,
	/*formatter: function () {
		return this.value;
	},*/
	style: {
		color: '#666',
		fontSize: '11px',
		lineHeight: '14px'
	}
};

defaultOptions = {
	colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
		'#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],
	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	lang: {
		loading: 'Loading...',
		months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
				'August', 'September', 'October', 'November', 'December'],
		shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		decimalPoint: '.',
		resetZoom: 'Reset zoom',
		resetZoomTitle: 'Reset zoom level 1:1',
		thousandsSep: ','
	},
	global: {
		useUTC: true,
		canvasToolsURL: 'http://code.highcharts.com/stock/1.1.5/modules/canvas-tools.js'
	},
	chart: {
		//animation: true,
		//alignTicks: false,
		//reflow: true,
		//className: null,
		//events: { load, selection },
		//margin: [null],
		//marginTop: null,
		//marginRight: null,
		//marginBottom: null,
		//marginLeft: null,
		borderColor: '#4572A7',
		//borderWidth: 0,
		borderRadius: 5,
		defaultSeriesType: 'line',
		ignoreHiddenSeries: true,
		//inverted: false,
		//shadow: false,
		spacingTop: 10,
		spacingRight: 10,
		spacingBottom: 15,
		spacingLeft: 10,
		style: {
			fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
			fontSize: '12px'
		},
		backgroundColor: '#FFFFFF',
		//plotBackgroundColor: null,
		plotBorderColor: '#C0C0C0',
		//plotBorderWidth: 0,
		//plotShadow: false,
		//zoomType: ''
		resetZoomButton: {
			theme: {
				zIndex: 20
			},
			position: {
				align: 'right',
				x: -10,
				//verticalAlign: 'top',
				y: 10
			}
			// relativeTo: 'plot'
		}
	},
	title: {
		text: 'Chart title',
		align: 'center',
		// floating: false,
		// margin: 15,
		// x: 0,
		// verticalAlign: 'top',
		y: 15,
		style: {
			color: '#3E576F',
			fontSize: '16px'
		}

	},
	subtitle: {
		text: '',
		align: 'center',
		// floating: false
		// x: 0,
		// verticalAlign: 'top',
		y: 30,
		style: {
			color: '#6D869F'
		}
	},

	plotOptions: {
		line: { // base series options
			allowPointSelect: false,
			showCheckbox: false,
			animation: {
				duration: 1000
			},
			//connectNulls: false,
			//cursor: 'default',
			//clip: true,
			//dashStyle: null,
			//enableMouseTracking: true,
			events: {},
			//legendIndex: 0,
			lineWidth: 2,
			shadow: true,
			// stacking: null,
			marker: {
				enabled: true,
				//symbol: null,
				lineWidth: 0,
				radius: 4,
				lineColor: '#FFFFFF',
				//fillColor: null,
				states: { // states for a single point
					hover: {
						//radius: base + 2
					},
					select: {
						fillColor: '#FFFFFF',
						lineColor: '#000000',
						lineWidth: 2
					}
				}
			},
			point: {
				events: {}
			},
			dataLabels: merge(defaultLabelOptions, {
				enabled: false,
				y: -6,
				formatter: function () {
					return this.y;
				}
				// backgroundColor: undefined,
				// borderColor: undefined,
				// borderRadius: undefined,
				// borderWidth: undefined,
				// padding: 3,
				// shadow: false
			}),
			cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
			pointRange: 0,
			//pointStart: 0,
			//pointInterval: 1,
			showInLegend: true,
			states: { // states for the entire series
				hover: {
					//enabled: false,
					//lineWidth: base + 1,
					marker: {
						// lineWidth: base + 1,
						// radius: base + 1
					}
				},
				select: {
					marker: {}
				}
			},
			stickyTracking: true
			//tooltip: {
				//pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b>'
				//valueDecimals: null,
				//xDateFormat: '%A, %b %e, %Y',
				//valuePrefix: '',
				//ySuffix: ''				
			//}
			// turboThreshold: 1000
			// zIndex: null
		}
	},
	labels: {
		//items: [],
		style: {
			//font: defaultFont,
			position: ABSOLUTE,
			color: '#3E576F'
		}
	},
	legend: {
		enabled: true,
		align: 'center',
		//floating: false,
		layout: 'horizontal',
		labelFormatter: function () {
			return this.name;
		},
		borderWidth: 1,
		borderColor: '#909090',
		borderRadius: 5,
		// margin: 10,
		// reversed: false,
		shadow: false,
		// backgroundColor: null,
		style: {
			padding: '5px'
		},
		itemStyle: {
			cursor: 'pointer',
			color: '#3E576F'
		},
		itemHoverStyle: {
			//cursor: 'pointer', removed as of #601
			color: '#000000'
		},
		itemHiddenStyle: {
			color: '#C0C0C0'
		},
		itemCheckboxStyle: {
			position: ABSOLUTE,
			width: '13px', // for IE precision
			height: '13px'
		},
		// itemWidth: undefined,
		symbolWidth: 16,
		symbolPadding: 5,
		verticalAlign: 'bottom',
		// width: undefined,
		x: 0,
		y: 0
	},

	loading: {
		// hideDuration: 100,
		labelStyle: {
			fontWeight: 'bold',
			position: RELATIVE,
			top: '1em'
		},
		// showDuration: 0,
		style: {
			position: ABSOLUTE,
			backgroundColor: 'white',
			opacity: 0.5,
			textAlign: 'center'
		}
	},

	tooltip: {
		enabled: true,
		//crosshairs: null,
		backgroundColor: 'rgba(255, 255, 255, .85)',
		borderWidth: 2,
		borderRadius: 5,
		//formatter: defaultFormatter,
		headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
		pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>',
		shadow: true,
		shared: useCanVG,
		snap: hasTouch ? 25 : 10,
		style: {
			color: '#333333',
			fontSize: '12px',
			padding: '5px',
			whiteSpace: 'nowrap'
		}
		//xDateFormat: '%A, %b %e, %Y',
		//valueDecimals: null,
		//valuePrefix: '',
		//valueSuffix: ''
	},

	credits: {
		enabled: true,
		text: 'Highcharts.com',
		href: 'http://www.highcharts.com',
		position: {
			align: 'right',
			x: -10,
			verticalAlign: 'bottom',
			y: -5
		},
		style: {
			cursor: 'pointer',
			color: '#909090',
			fontSize: '10px'
		}
	}
};

// Axis defaults
/*jslint white: true*/
var defaultXAxisOptions = {
	// allowDecimals: null,
	// alternateGridColor: null,
	// categories: [],
	dateTimeLabelFormats: hash(
		MILLISECOND, '%H:%M:%S.%L',
		SECOND, '%H:%M:%S',
		MINUTE, '%H:%M',
		HOUR, '%H:%M',
		DAY, '%e. %b',
		WEEK, '%e. %b',
		MONTH, '%b \'%y',
		YEAR, '%Y'
	),
	endOnTick: false,
	gridLineColor: '#C0C0C0',
	// gridLineDashStyle: 'solid',
	// gridLineWidth: 0,
	// reversed: false,

	labels: defaultLabelOptions,
		// { step: null },
	lineColor: '#C0D0E0',
	lineWidth: 1,
	//linkedTo: null,
	max: null,
	min: null,
	minPadding: 0.01,
	maxPadding: 0.01,
	//minRange: null,
	minorGridLineColor: '#E0E0E0',
	// minorGridLineDashStyle: null,
	minorGridLineWidth: 1,
	minorTickColor: '#A0A0A0',
	//minorTickInterval: null,
	minorTickLength: 2,
	minorTickPosition: 'outside', // inside or outside
	//minorTickWidth: 0,
	//opposite: false,
	//offset: 0,
	//plotBands: [{
	//	events: {},
	//	zIndex: 1,
	//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	//}],
	//plotLines: [{
	//	events: {}
	//  dashStyle: {}
	//	zIndex:
	//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	//}],
	//reversed: false,
	// showFirstLabel: true,
	// showLastLabel: true,
	startOfWeek: 1,
	startOnTick: false,
	tickColor: '#C0D0E0',
	//tickInterval: null,
	tickLength: 5,
	tickmarkPlacement: 'between', // on or between
	tickPixelInterval: 100,
	tickPosition: 'outside',
	tickWidth: 1,
	title: {
		//text: null,
		align: 'middle', // low, middle or high
		//margin: 0 for horizontal, 10 for vertical axes,
		//rotation: 0,
		//side: 'outside',
		style: {
			color: '#6D869F',
			//font: defaultFont.replace('normal', 'bold')
			fontWeight: 'bold'
		}
		//x: 0,
		//y: 0
	},
	type: 'linear' // linear, logarithmic or datetime
},

defaultYAxisOptions = merge(defaultXAxisOptions, {
	endOnTick: true,
	gridLineWidth: 1,
	tickPixelInterval: 72,
	showLastLabel: true,
	labels: {
		align: 'right',
		x: -8,
		y: 3
	},
	lineWidth: 0,
	maxPadding: 0.05,
	minPadding: 0.05,
	startOnTick: true,
	tickWidth: 0,
	title: {
		rotation: 270,
		text: 'Y-values'
	},
	stackLabels: {
		enabled: false,
		//align: dynamic,
		//y: dynamic,
		//x: dynamic,
		//verticalAlign: dynamic,
		//textAlign: dynamic,
		//rotation: 0,
		formatter: function () {
			return this.total;
		},
		style: defaultLabelOptions.style
	}
}),

defaultLeftAxisOptions = {
	labels: {
		align: 'right',
		x: -8,
		y: null
	},
	title: {
		rotation: 270
	}
},
defaultRightAxisOptions = {
	labels: {
		align: 'left',
		x: 8,
		y: null
	},
	title: {
		rotation: 90
	}
},
defaultBottomAxisOptions = { // horizontal axis
	labels: {
		align: 'center',
		x: 0,
		y: 14,
		overflow: 'justify' // docs
		// staggerLines: null
	},
	title: {
		rotation: 0
	}
},
defaultTopAxisOptions = merge(defaultBottomAxisOptions, {
	labels: {
		y: -5,
		overflow: 'justify'
		// staggerLines: null
	}
});
/*jslint white: false*/



// Series defaults
var defaultPlotOptions = defaultOptions.plotOptions,
	defaultSeriesOptions = defaultPlotOptions.line;
//defaultPlotOptions.line = merge(defaultSeriesOptions);
defaultPlotOptions.spline = merge(defaultSeriesOptions);
defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
	lineWidth: 0,
	states: {
		hover: {
			lineWidth: 0
		}
	},
	tooltip: {
		headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>',
		pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
	}
});
defaultPlotOptions.area = merge(defaultSeriesOptions, {
	threshold: 0
	// lineColor: null, // overrides color, but lets fillColor be unaltered
	// fillOpacity: 0.75,
	// fillColor: null

});
defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
defaultPlotOptions.column = merge(defaultSeriesOptions, {
	borderColor: '#FFFFFF',
	borderWidth: 1,
	borderRadius: 0,
	//colorByPoint: undefined,
	groupPadding: 0.2,
	marker: null, // point options are specified in the base options
	pointPadding: 0.1,
	//pointWidth: null,
	minPointLength: 0,
	cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
	pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
	states: {
		hover: {
			brightness: 0.1,
			shadow: false
		},
		select: {
			color: '#C0C0C0',
			borderColor: '#000000',
			shadow: false
		}
	},
	dataLabels: {
		y: null,
		verticalAlign: null
	},
	threshold: 0
});
defaultPlotOptions.bar = merge(defaultPlotOptions.column, {
	dataLabels: {
		align: 'left',
		x: 5,
		y: null,
		verticalAlign: 'middle'
	}
});
defaultPlotOptions.pie = merge(defaultSeriesOptions, {
	//dragType: '', // n/a
	borderColor: '#FFFFFF',
	borderWidth: 1,
	center: ['50%', '50%'],
	colorByPoint: true, // always true for pies
	dataLabels: {
		// align: null,
		// connectorWidth: 1,
		// connectorColor: point.color,
		// connectorPadding: 5,
		distance: 30,
		enabled: true,
		formatter: function () {
			return this.point.name;
		},
		// softConnector: true,
		y: 5
	},
	//innerSize: 0,
	legendType: 'point',
	marker: null, // point options are specified in the base options
	size: '75%',
	showInLegend: false,
	slicedOffset: 10,
	states: {
		hover: {
			brightness: 0.1,
			shadow: false
		}
	}

});

// set the default time methods
setTimeMethods();



/**
 * Set the time methods globally based on the useUTC option. Time method can be either
 * local time or UTC (default).
 */
function setTimeMethods() {
	var useUTC = defaultOptions.global.useUTC,
		GET = useUTC ? 'getUTC' : 'get',
		SET = useUTC ? 'setUTC' : 'set';

	makeTime = useUTC ? Date.UTC : function (year, month, date, hours, minutes, seconds) {
		return new Date(
			year,
			month,
			pick(date, 1),
			pick(hours, 0),
			pick(minutes, 0),
			pick(seconds, 0)
		).getTime();
	};
	getMinutes =  GET + 'Minutes';
	getHours =    GET + 'Hours';
	getDay =      GET + 'Day';
	getDate =     GET + 'Date';
	getMonth =    GET + 'Month';
	getFullYear = GET + 'FullYear';
	setMinutes =  SET + 'Minutes';
	setHours =    SET + 'Hours';
	setDate =     SET + 'Date';
	setMonth =    SET + 'Month';
	setFullYear = SET + 'FullYear';

}

/**
 * Merge the default options with custom options and return the new options structure
 * @param {Object} options The new custom options
 */
function setOptions(options) {
	
	// Pull out axis options and apply them to the respective default axis options 
	defaultXAxisOptions = merge(defaultXAxisOptions, options.xAxis);
	defaultYAxisOptions = merge(defaultYAxisOptions, options.yAxis);
	options.xAxis = options.yAxis = UNDEFINED;
	
	// Merge in the default options
	defaultOptions = merge(defaultOptions, options);
	
	// Apply UTC
	setTimeMethods();

	return defaultOptions;
}

/**
 * Get the updated default options. Merely exposing defaultOptions for outside modules
 * isn't enough because the setOptions method creates a new object.
 */
function getOptions() {
	return defaultOptions;
}



/**
 * Handle color operations. The object methods are chainable.
 * @param {String} input The input color in either rbga or hex format
 */
var Color = function (input) {
	// declare variables
	var rgba = [], result;

	/**
	 * Parse the input color to rgba array
	 * @param {String} input
	 */
	function init(input) {

		// rgba
		result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
		if (result) {
			rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
		} else { // hex
			result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
			if (result) {
				rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
			}
		}

	}
	/**
	 * Return the color a specified format
	 * @param {String} format
	 */
	function get(format) {
		var ret;

		// it's NaN if gradient colors on a column chart
		if (rgba && !isNaN(rgba[0])) {
			if (format === 'rgb') {
				ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
			} else if (format === 'a') {
				ret = rgba[3];
			} else {
				ret = 'rgba(' + rgba.join(',') + ')';
			}
		} else {
			ret = input;
		}
		return ret;
	}

	/**
	 * Brighten the color
	 * @param {Number} alpha
	 */
	function brighten(alpha) {
		if (isNumber(alpha) && alpha !== 0) {
			var i;
			for (i = 0; i < 3; i++) {
				rgba[i] += pInt(alpha * 255);

				if (rgba[i] < 0) {
					rgba[i] = 0;
				}
				if (rgba[i] > 255) {
					rgba[i] = 255;
				}
			}
		}
		return this;
	}
	/**
	 * Set the color's opacity to a given alpha value
	 * @param {Number} alpha
	 */
	function setOpacity(alpha) {
		rgba[3] = alpha;
		return this;
	}

	// initialize: parse the input
	init(input);

	// public methods
	return {
		get: get,
		brighten: brighten,
		setOpacity: setOpacity
	};
};


/**
 * A wrapper object for SVG elements
 */
function SVGElement() {}

SVGElement.prototype = {
	/**
	 * Initialize the SVG renderer
	 * @param {Object} renderer
	 * @param {String} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this;
		wrapper.element = nodeName === 'span' ?
			createElement(nodeName) :
			doc.createElementNS(SVG_NS, nodeName);
		wrapper.renderer = renderer;
		/**
		 * A collection of attribute setters. These methods, if defined, are called right before a certain
		 * attribute is set on an element wrapper. Returning false prevents the default attribute
		 * setter to run. Returning a value causes the default setter to set that value. Used in
		 * Renderer.label.
		 */
		wrapper.attrSetters = {};
	},
	/**
	 * Animate a given attribute
	 * @param {Object} params
	 * @param {Number} options The same options as in jQuery animation
	 * @param {Function} complete Function to perform at the end of animation
	 */
	animate: function (params, options, complete) {
		var animOptions = pick(options, globalAnimation, true);
		stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
		if (animOptions) {
			animOptions = merge(animOptions);
			if (complete) { // allows using a callback with the global animation without overwriting it
				animOptions.complete = complete;
			}
			animate(this, params, animOptions);
		} else {
			this.attr(params);
			if (complete) {
				complete();
			}
		}
	},
	/**
	 * Set or get a given attribute
	 * @param {Object|String} hash
	 * @param {Mixed|Undefined} val
	 */
	attr: function (hash, val) {
		var wrapper = this,
			key,
			value,
			result,
			i,
			child,
			element = wrapper.element,
			nodeName = element.nodeName,
			renderer = wrapper.renderer,
			skipAttr,
			attrSetters = wrapper.attrSetters,
			shadows = wrapper.shadows,
			hasSetSymbolSize,
			ret = wrapper;

		// single key-value pair
		if (isString(hash) && defined(val)) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter: first argument is a string, second is undefined
		if (isString(hash)) {
			key = hash;
			if (nodeName === 'circle') {
				key = { x: 'cx', y: 'cy' }[key] || key;
			} else if (key === 'strokeWidth') {
				key = 'stroke-width';
			}
			ret = attr(element, key) || wrapper[key] || 0;

			if (key !== 'd' && key !== 'visibility') { // 'd' is string in animation step
				ret = parseFloat(ret);
			}

		// setter
		} else {

			for (key in hash) {
				skipAttr = false; // reset
				value = hash[key];

				// check for a specific attribute setter
				result = attrSetters[key] && attrSetters[key](value, key);

				if (result !== false) {

					if (result !== UNDEFINED) {
						value = result; // the attribute setter has returned a new value to set
					}

					// paths
					if (key === 'd') {
						if (value && value.join) { // join path
							value = value.join(' ');
						}
						if (/(NaN| {2}|^$)/.test(value)) {
							value = 'M 0 0';
						}
						wrapper.d = value; // shortcut for animations

					// update child tspans x values
					} else if (key === 'x' && nodeName === 'text') {
						for (i = 0; i < element.childNodes.length; i++) {
							child = element.childNodes[i];
							// if the x values are equal, the tspan represents a linebreak
							if (attr(child, 'x') === attr(element, 'x')) {
								//child.setAttribute('x', value);
								attr(child, 'x', value);
							}
						}

						if (wrapper.rotation) {
							attr(element, 'transform', 'rotate(' + wrapper.rotation + ' ' + value + ' ' +
								pInt(hash.y || attr(element, 'y')) + ')');
						}

					// apply gradients
					} else if (key === 'fill') {
						value = renderer.color(value, element, key);

					// circle x and y
					} else if (nodeName === 'circle' && (key === 'x' || key === 'y')) {
						key = { x: 'cx', y: 'cy' }[key] || key;

					// rectangle border radius
					} else if (nodeName === 'rect' && key === 'r') {
						attr(element, {
							rx: value,
							ry: value
						});
						skipAttr = true;

					// translation and text rotation
					} else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'verticalAlign') {
						wrapper[key] = value;
						wrapper.updateTransform();
						skipAttr = true;

					// apply opacity as subnode (required by legacy WebKit and Batik)
					} else if (key === 'stroke') {
						value = renderer.color(value, element, key);

					// emulate VML's dashstyle implementation
					} else if (key === 'dashstyle') {
						key = 'stroke-dasharray';
						value = value && value.toLowerCase();
						if (value === 'solid') {
							value = NONE;
						} else if (value) {
							value = value
								.replace('shortdashdotdot', '3,1,1,1,1,1,')
								.replace('shortdashdot', '3,1,1,1')
								.replace('shortdot', '1,1,')
								.replace('shortdash', '3,1,')
								.replace('longdash', '8,3,')
								.replace(/dot/g, '1,3,')
								.replace('dash', '4,3,')
								.replace(/,$/, '')
								.split(','); // ending comma

							i = value.length;
							while (i--) {
								value[i] = pInt(value[i]) * hash['stroke-width'];
							}
							value = value.join(',');
						}

					// special
					} else if (key === 'isTracker') {
						wrapper[key] = value;

					// IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2
					// is unable to cast them. Test again with final IE9.
					} else if (key === 'width') {
						value = pInt(value);

					// Text alignment
					} else if (key === 'align') {
						key = 'text-anchor';
						value = { left: 'start', center: 'middle', right: 'end' }[value];

					// Title requires a subnode, #431
					} else if (key === 'title') {
						var title = doc.createElementNS(SVG_NS, 'title');
						title.appendChild(doc.createTextNode(value));
						element.appendChild(title);
					}

					// jQuery animate changes case
					if (key === 'strokeWidth') {
						key = 'stroke-width';
					}

					// Chrome/Win < 6 bug (http://code.google.com/p/chromium/issues/detail?id=15461)
					if (isWebKit && key === 'stroke-width' && value === 0) {
						value = 0.000001;
					}

					// symbols
					if (wrapper.symbolName && /^(x|y|r|start|end|innerR|anchorX|anchorY)/.test(key)) {


						if (!hasSetSymbolSize) {
							wrapper.symbolAttr(hash);
							hasSetSymbolSize = true;
						}
						skipAttr = true;
					}

					// let the shadow follow the main element
					if (shadows && /^(width|height|visibility|x|y|d|transform)$/.test(key)) {
						i = shadows.length;
						while (i--) {
							attr(shadows[i], key, value);
						}
					}

					// validate heights
					if ((key === 'width' || key === 'height') && nodeName === 'rect' && value < 0) {
						value = 0;
					}




					if (key === 'text') {
						// only one node allowed
						wrapper.textStr = value;
						if (wrapper.added) {
							renderer.buildText(wrapper);
						}
					} else if (!skipAttr) {
						attr(element, key, value);
					}

				}

			}

		}
		
		// Workaround for our #732, WebKit's issue https://bugs.webkit.org/show_bug.cgi?id=78385
		// TODO: If the WebKit team fix this bug before the final release of Chrome 18, remove the workaround.
		if (isWebKit && /Chrome\/(18|19)/.test(userAgent)) {
			if (nodeName === 'text' && (hash.x !== UNDEFINED || hash.y !== UNDEFINED)) {
				var parent = element.parentNode,
					next = element.nextSibling;
			
				if (parent) {
					parent.removeChild(element);
					if (next) {
						parent.insertBefore(element, next);
					} else {
						parent.appendChild(element);
					}
				}
			}
		}
		// End of workaround for #732
		
		return ret;
	},

	/**
	 * If one of the symbol size affecting parameters are changed,
	 * check all the others only once for each call to an element's
	 * .attr() method
	 * @param {Object} hash
	 */
	symbolAttr: function (hash) {
		var wrapper = this;

		each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
			wrapper[key] = pick(hash[key], wrapper[key]);
		});

		wrapper.attr({
			d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
		});
	},

	/**
	 * Apply a clipping path to this object
	 * @param {String} id
	 */
	clip: function (clipRect) {
		return this.attr('clip-path', 'url(' + this.renderer.url + '#' + clipRect.id + ')');
	},

	/**
	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
	 * calculated attributes
	 * @param {Number} strokeWidth
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	crisp: function (strokeWidth, x, y, width, height) {

		var wrapper = this,
			key,
			attribs = {},
			values = {},
			normalizer;

		strokeWidth = strokeWidth || wrapper.strokeWidth || (wrapper.attr && wrapper.attr('stroke-width')) || 0;
		normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

		// normalize for crisp edges
		values.x = mathFloor(x || wrapper.x || 0) + normalizer;
		values.y = mathFloor(y || wrapper.y || 0) + normalizer;
		values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
		values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
		values.strokeWidth = strokeWidth;

		for (key in values) {
			if (wrapper[key] !== values[key]) { // only set attribute if changed
				wrapper[key] = attribs[key] = values[key];
			}
		}

		return attribs;
	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: function (styles) {
		/*jslint unparam: true*//* allow unused param a in the regexp function below */
		var elemWrapper = this,
			elem = elemWrapper.element,
			textWidth = styles && styles.width && elem.nodeName === 'text',
			n,
			serializedCss = '',
			hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
		/*jslint unparam: false*/

		// convert legacy
		if (styles && styles.color) {
			styles.fill = styles.color;
		}

		// Merge the new styles with the old ones
		styles = extend(
			elemWrapper.styles,
			styles
		);

		// store object
		elemWrapper.styles = styles;

		// serialize and set style attribute
		if (isIE && !hasSVG) { // legacy IE doesn't support setting style attribute
			if (textWidth) {
				delete styles.width;
			}
			css(elemWrapper.element, styles);
		} else {
			for (n in styles) {
				serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
			}
			elemWrapper.attr({
				style: serializedCss
			});
		}


		// re-build text
		if (textWidth && elemWrapper.added) {
			elemWrapper.renderer.buildText(elemWrapper);
		}

		return elemWrapper;
	},

	/**
	 * Add an event listener
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		var fn = handler;
		// touch
		if (hasTouch && eventType === 'click') {
			eventType = 'touchstart';
			fn = function (e) {
				e.preventDefault();
				handler();
			};
		}
		// simplest possible event model for internal use
		this.element['on' + eventType] = fn;
		return this;
	},


	/**
	 * Move an object and its children by x and y values
	 * @param {Number} x
	 * @param {Number} y
	 */
	translate: function (x, y) {
		return this.attr({
			translateX: x,
			translateY: y
		});
	},

	/**
	 * Invert a group, rotate and flip
	 */
	invert: function () {
		var wrapper = this;
		wrapper.inverted = true;
		wrapper.updateTransform();
		return wrapper;
	},

	/**
	 * Apply CSS to HTML elements. This is used in text within SVG rendering and
	 * by the VML renderer
	 */
	htmlCss: function (styles) {
		var wrapper = this,
			element = wrapper.element,
			textWidth = styles && element.tagName === 'SPAN' && styles.width;

		if (textWidth) {
			delete styles.width;
			wrapper.textWidth = textWidth;
			wrapper.updateTransform();
		}

		wrapper.styles = extend(wrapper.styles, styles);
		css(wrapper.element, styles);

		return wrapper;
	},



	/**
	 * VML and useHTML method for calculating the bounding box based on offsets
	 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
	 * use the cached value
	 *
	 * @return {Object} A hash containing values for x, y, width and height
	 */

	htmlGetBBox: function (refresh) {
		var wrapper = this,
			element = wrapper.element,
			bBox = wrapper.bBox;

		// faking getBBox in exported SVG in legacy IE
		if (!bBox || refresh) {
			// faking getBBox in exported SVG in legacy IE
			if (element.nodeName === 'text') {
				element.style.position = ABSOLUTE;
			}

			bBox = wrapper.bBox = {
				x: element.offsetLeft,
				y: element.offsetTop,
				width: element.offsetWidth,
				height: element.offsetHeight
			};
		}

		return bBox;
	},

	/**
	 * VML override private method to update elements based on internal
	 * properties based on SVG transform
	 */
	htmlUpdateTransform: function () {
		// aligning non added elements is expensive
		if (!this.added) {
			this.alignOnAdd = true;
			return;
		}

		var wrapper = this,
			renderer = wrapper.renderer,
			elem = wrapper.element,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			x = wrapper.x || 0,
			y = wrapper.y || 0,
			align = wrapper.textAlign || 'left',
			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
			nonLeft = align && align !== 'left',
			shadows = wrapper.shadows;

		// apply translate
		if (translateX || translateY) {
			css(elem, {
				marginLeft: translateX,
				marginTop: translateY
			});
			if (shadows) { // used in labels/tooltip
				each(shadows, function (shadow) {
					css(shadow, {
						marginLeft: translateX + 1,
						marginTop: translateY + 1
					});
				});
			}
		}

		// apply inversion
		if (wrapper.inverted) { // wrapper is a group
			each(elem.childNodes, function (child) {
				renderer.invertChild(child, elem);
			});
		}

		if (elem.tagName === 'SPAN') {

			var width, height,
				rotation = wrapper.rotation,
				baseline,
				radians = 0,
				costheta = 1,
				sintheta = 0,
				quad,
				textWidth = pInt(wrapper.textWidth),
				xCorr = wrapper.xCorr || 0,
				yCorr = wrapper.yCorr || 0,
				currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

			if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed

				if (defined(rotation)) {
					radians = rotation * deg2rad; // deg to rad
					costheta = mathCos(radians);
					sintheta = mathSin(radians);

					// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
					// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
					// has support for CSS3 transform. The getBBox method also needs to be updated
					// to compensate for the rotation, like it currently does for SVG.
					// Test case: http://highcharts.com/tests/?file=text-rotation
					css(elem, {
						filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
							', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
							', sizingMethod=\'auto expand\')'].join('') : NONE
					});
				}

				width = pick(wrapper.elemWidth, elem.offsetWidth);
				height = pick(wrapper.elemHeight, elem.offsetHeight);

				// update textWidth
				if (width > textWidth) {
					css(elem, {
						width: textWidth + PX,
						display: 'block',
						whiteSpace: 'normal'
					});
					width = textWidth;
				}

				// correct x and y
				baseline = renderer.fontMetrics(elem.style.fontSize).b;
				xCorr = costheta < 0 && -width;
				yCorr = sintheta < 0 && -height;

				// correct for baseline and corners spilling out after rotation
				quad = costheta * sintheta < 0;
				xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
				yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);

				// correct for the length/height of the text
				if (nonLeft) {
					xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
					if (rotation) {
						yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
					}
					css(elem, {
						textAlign: align
					});
				}

				// record correction
				wrapper.xCorr = xCorr;
				wrapper.yCorr = yCorr;
			}

			// apply position with correction
			css(elem, {
				left: (x + xCorr) + PX,
				top: (y + yCorr) + PX
			});

			// record current text transform
			wrapper.cTT = currentTextTransform;
		}
	},

	/**
	 * Private method to update the transform attribute based on internal
	 * properties
	 */
	updateTransform: function () {
		var wrapper = this,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			inverted = wrapper.inverted,
			rotation = wrapper.rotation,
			transform = [];

		// flipping affects translate as adjustment for flipping around the group's axis
		if (inverted) {
			translateX += wrapper.attr('width');
			translateY += wrapper.attr('height');
		}

		// apply translate
		if (translateX || translateY) {
			transform.push('translate(' + translateX + ',' + translateY + ')');
		}

		// apply rotation
		if (inverted) {
			transform.push('rotate(90) scale(-1,1)');
		} else if (rotation) { // text rotation
			transform.push('rotate(' + rotation + ' ' + wrapper.x + ' ' + wrapper.y + ')');
		}

		if (transform.length) {
			attr(wrapper.element, 'transform', transform.join(' '));
		}
	},
	/**
	 * Bring the element to the front
	 */
	toFront: function () {
		var element = this.element;
		element.parentNode.appendChild(element);
		return this;
	},


	/**
	 * Break down alignment options like align, verticalAlign, x and y
	 * to x and y relative to the chart.
	 *
	 * @param {Object} alignOptions
	 * @param {Boolean} alignByTranslate
	 * @param {Object} box The box to align to, needs a width and height
	 *
	 */
	align: function (alignOptions, alignByTranslate, box) {
		var elemWrapper = this;

		if (!alignOptions) { // called on resize
			alignOptions = elemWrapper.alignOptions;
			alignByTranslate = elemWrapper.alignByTranslate;
		} else { // first call on instanciate
			elemWrapper.alignOptions = alignOptions;
			elemWrapper.alignByTranslate = alignByTranslate;
			if (!box) { // boxes other than renderer handle this internally
				elemWrapper.renderer.alignedObjects.push(elemWrapper);
			}
		}

		box = pick(box, elemWrapper.renderer);

		var align = alignOptions.align,
			vAlign = alignOptions.verticalAlign,
			x = (box.x || 0) + (alignOptions.x || 0), // default: left align
			y = (box.y || 0) + (alignOptions.y || 0), // default: top align
			attribs = {};


		// align
		if (/^(right|center)$/.test(align)) {
			x += (box.width - (alignOptions.width || 0)) /
					{ right: 1, center: 2 }[align];
		}
		attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


		// vertical align
		if (/^(bottom|middle)$/.test(vAlign)) {
			y += (box.height - (alignOptions.height || 0)) /
					({ bottom: 1, middle: 2 }[vAlign] || 1);

		}
		attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

		// animate only if already placed
		elemWrapper[elemWrapper.placed ? 'animate' : 'attr'](attribs);
		elemWrapper.placed = true;
		elemWrapper.alignAttr = attribs;

		return elemWrapper;
	},

	/**
	 * Get the bounding box (width, height, x and y) for the element
	 */
	getBBox: function (refresh) {
		var wrapper = this,
			bBox,
			width,
			height,
			rotation = wrapper.rotation,
			element = wrapper.element,
			rad = rotation * deg2rad;

		// SVG elements
		if (element.namespaceURI === SVG_NS) {
			try { // Fails in Firefox if the container has display: none.
				
				bBox = element.getBBox ?
					// SVG: use extend because IE9 is not allowed to change width and height in case
					// of rotation (below)
					extend({}, element.getBBox()) :
					// Canvas renderer: // TODO: can this be removed now that we're checking for the SVG NS?
					{
						width: element.offsetWidth,
						height: element.offsetHeight
					};
			} catch (e) {}
			
			// If the bBox is not set, the try-catch block above failed. The other condition
			// is for Opera that returns a width of -Infinity on hidden elements.
			if (!bBox || bBox.width < 0) {
				bBox = { width: 0, height: 0 };
			}
			
			width = bBox.width;
			height = bBox.height;

			// adjust for rotated text
			if (rotation) {
				bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
				bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
			}

		// VML Renderer or useHTML within SVG
		} else {
			bBox = wrapper.htmlGetBBox(refresh);
		}

		return bBox;
	},

	/**
	 * Show the element
	 */
	show: function () {
		return this.attr({ visibility: VISIBLE });
	},

	/**
	 * Hide the element
	 */
	hide: function () {
		return this.attr({ visibility: HIDDEN });
	},

	/**
	 * Add the element
	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
	 *    to append the element to the renderer.box.
	 */
	add: function (parent) {

		var renderer = this.renderer,
			parentWrapper = parent || renderer,
			parentNode = parentWrapper.element || renderer.box,
			childNodes = parentNode.childNodes,
			element = this.element,
			zIndex = attr(element, 'zIndex'),
			otherElement,
			otherZIndex,
			i,
			inserted;

		// mark as inverted
		this.parentInverted = parent && parent.inverted;

		// build formatted text
		if (this.textStr !== undefined) {
			renderer.buildText(this);
		}

		// mark the container as having z indexed children
		if (zIndex) {
			parentWrapper.handleZ = true;
			zIndex = pInt(zIndex);
		}

		// insert according to this and other elements' zIndex
		if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
			for (i = 0; i < childNodes.length; i++) {
				otherElement = childNodes[i];
				otherZIndex = attr(otherElement, 'zIndex');
				if (otherElement !== element && (
						// insert before the first element with a higher zIndex
						pInt(otherZIndex) > zIndex ||
						// if no zIndex given, insert before the first element with a zIndex
						(!defined(zIndex) && defined(otherZIndex))

						)) {
					parentNode.insertBefore(element, otherElement);
					inserted = true;
					break;
				}
			}
		}

		// default: append at the end
		if (!inserted) {
			parentNode.appendChild(element);
		}

		// mark as added
		this.added = true;

		// fire an event for internal hooks
		fireEvent(this, 'add');

		return this;
	},

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		var parentNode = element.parentNode;
		if (parentNode) {
			parentNode.removeChild(element);
		}
	},

	/**
	 * Destroy the element and element wrapper
	 */
	destroy: function () {
		var wrapper = this,
			element = wrapper.element || {},
			shadows = wrapper.shadows,
			box = wrapper.box,
			key,
			i;

		// remove events
		element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = null;
		stop(wrapper); // stop running animations

		if (wrapper.clipPath) {
			wrapper.clipPath = wrapper.clipPath.destroy();
		}

		// Destroy stops in case this is a gradient object
		if (wrapper.stops) {
			for (i = 0; i < wrapper.stops.length; i++) {
				wrapper.stops[i] = wrapper.stops[i].destroy();
			}
			wrapper.stops = null;
		}

		// remove element
		wrapper.safeRemoveChild(element);

		// destroy shadows
		if (shadows) {
			each(shadows, function (shadow) {
				wrapper.safeRemoveChild(shadow);
			});
		}

		// destroy label box
		if (box) {
			box.destroy();
		}

		// remove from alignObjects
		erase(wrapper.renderer.alignedObjects, wrapper);

		for (key in wrapper) {
			delete wrapper[key];
		}

		return null;
	},

	/**
	 * Empty a group element
	 */
	empty: function () {
		var element = this.element,
			childNodes = element.childNodes,
			i = childNodes.length;

		while (i--) {
			element.removeChild(childNodes[i]);
		}
	},

	/**
	 * Add a shadow to the element. Must be done after the element is added to the DOM
	 * @param {Boolean} apply
	 */
	shadow: function (apply, group) {
		var shadows = [],
			i,
			shadow,
			element = this.element,

			// compensate for inverted plot area
			transform = this.parentInverted ? '(-1,-1)' : '(1,1)';


		if (apply) {
			for (i = 1; i <= 3; i++) {
				shadow = element.cloneNode(0);
				attr(shadow, {
					'isShadow': 'true',
					'stroke': 'rgb(0, 0, 0)',
					'stroke-opacity': 0.05 * i,
					'stroke-width': 7 - 2 * i,
					'transform': 'translate' + transform,
					'fill': NONE
				});

				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				shadows.push(shadow);
			}

			this.shadows = shadows;
		}
		return this;

	}
};


/**
 * The default SVG renderer
 */
var SVGRenderer = function () {
	this.init.apply(this, arguments);
};
SVGRenderer.prototype = {
	Element: SVGElement,

	/**
	 * Initialize the SVGRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Boolean} forExport
	 */
	init: function (container, width, height, forExport) {
		var renderer = this,
			loc = location,
			boxWrapper;

		boxWrapper = renderer.createElement('svg')
			.attr({
				xmlns: SVG_NS,
				version: '1.1'
			});
		container.appendChild(boxWrapper.element);

		// object properties
		renderer.isSVG = true;
		renderer.box = boxWrapper.element;
		renderer.boxWrapper = boxWrapper;
		renderer.alignedObjects = [];
		renderer.url = isIE ? '' : loc.href.replace(/#.*?$/, '')
			.replace(/([\('\)])/g, '\\$1'); // Page url used for internal references. #24, #672.
		renderer.defs = this.createElement('defs').add();
		renderer.forExport = forExport;
		renderer.gradients = {}; // Object where gradient SvgElements are stored

		renderer.setSize(width, height, false);
	},

	/**
	 * Destroys the renderer and its allocated members.
	 */
	destroy: function () {
		var renderer = this,
			rendererDefs = renderer.defs;
		renderer.box = null;
		renderer.boxWrapper = renderer.boxWrapper.destroy();

		// Call destroy on all gradient elements
		destroyObjectProperties(renderer.gradients || {});
		renderer.gradients = null;

		// Defs are null in VMLRenderer
		// Otherwise, destroy them here.
		if (rendererDefs) {
			renderer.defs = rendererDefs.destroy();
		}

		renderer.alignedObjects = null;

		return null;
	},

	/**
	 * Create a wrapper for an SVG element
	 * @param {Object} nodeName
	 */
	createElement: function (nodeName) {
		var wrapper = new this.Element();
		wrapper.init(this, nodeName);
		return wrapper;
	},

	/**
	 * Dummy function for use in canvas renderer
	 */
	draw: function () {},

	/**
	 * Parse a simple HTML string into SVG tspans
	 *
	 * @param {Object} textNode The parent text SVG node
	 */
	buildText: function (wrapper) {
		var textNode = wrapper.element,
			lines = pick(wrapper.textStr, '').toString()
				.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
				.replace(/<(i|em)>/g, '<span style="font-style:italic">')
				.replace(/<a/g, '<span')
				.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
				.split(/<br.*?>/g),
			childNodes = textNode.childNodes,
			styleRegex = /style="([^"]+)"/,
			hrefRegex = /href="([^"]+)"/,
			parentX = attr(textNode, 'x'),
			textStyles = wrapper.styles,
			width = textStyles && pInt(textStyles.width),
			textLineHeight = textStyles && textStyles.lineHeight,
			lastLine,
			GET_COMPUTED_STYLE = 'getComputedStyle',
			i = childNodes.length;

		// remove old text
		while (i--) {
			textNode.removeChild(childNodes[i]);
		}

		if (width && !wrapper.added) {
			this.box.appendChild(textNode); // attach it to the DOM to read offset width
		}

		// remove empty line at end
		if (lines[lines.length - 1] === '') {
			lines.pop();
		}

		// build the lines
		each(lines, function (line, lineNo) {
			var spans, spanNo = 0, lineHeight;

			line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
			spans = line.split('|||');

			each(spans, function (span) {
				if (span !== '' || spans.length === 1) {
					var attributes = {},
						tspan = doc.createElementNS(SVG_NS, 'tspan');
					if (styleRegex.test(span)) {
						attr(
							tspan,
							'style',
							span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2')
						);
					}
					if (hrefRegex.test(span)) {
						attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
						css(tspan, { cursor: 'pointer' });
					}

					span = (span.replace(/<(.|\n)*?>/g, '') || ' ')
						.replace(/&lt;/g, '<')
						.replace(/&gt;/g, '>');

					// issue #38 workaround.
					/*if (reverse) {
						arr = [];
						i = span.length;
						while (i--) {
							arr.push(span.charAt(i));
						}
						span = arr.join('');
					}*/

					// add the text node
					tspan.appendChild(doc.createTextNode(span));

					if (!spanNo) { // first span in a line, align it to the left
						attributes.x = parentX;
					} else {
						// Firefox ignores spaces at the front or end of the tspan
						attributes.dx = 3; // space
					}

					// first span on subsequent line, add the line height
					if (!spanNo) {
						if (lineNo) {

							// allow getting the right offset height in exporting in IE
							if (!hasSVG && wrapper.renderer.forExport) {
								css(tspan, { display: 'block' });
							}

							// Webkit and opera sometimes return 'normal' as the line height. In that
							// case, webkit uses offsetHeight, while Opera falls back to 18
							lineHeight = win[GET_COMPUTED_STYLE] &&
								pInt(win[GET_COMPUTED_STYLE](lastLine, null).getPropertyValue('line-height'));

							if (!lineHeight || isNaN(lineHeight)) {
								lineHeight = textLineHeight || lastLine.offsetHeight || 18;
							}
							attr(tspan, 'dy', lineHeight);
						}
						lastLine = tspan; // record for use in next line
					}

					// add attributes
					attr(tspan, attributes);

					// append it
					textNode.appendChild(tspan);

					spanNo++;

					// check width and apply soft breaks
					if (width) {
						var words = span.replace(/-/g, '- ').split(' '),
							tooLong,
							actualWidth,
							rest = [];

						while (words.length || rest.length) {
							actualWidth = wrapper.getBBox().width;
							tooLong = actualWidth > width;
							if (!tooLong || words.length === 1) { // new line needed
								words = rest;
								rest = [];
								if (words.length) {
									tspan = doc.createElementNS(SVG_NS, 'tspan');
									attr(tspan, {
										dy: textLineHeight || 16,
										x: parentX
									});
									textNode.appendChild(tspan);

									if (actualWidth > width) { // a single word is pressing it out
										width = actualWidth;
									}
								}
							} else { // append to existing line tspan
								tspan.removeChild(tspan.firstChild);
								rest.unshift(words.pop());
							}
							if (words.length) {
								tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
							}
						}
					}
				}
			});
		});
	},

	/**
	 * Create a button with preset states
	 * @param {String} text
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Function} callback
	 * @param {Object} normalState
	 * @param {Object} hoverState
	 * @param {Object} pressedState
	 */
	button: function (text, x, y, callback, normalState, hoverState, pressedState) {
		var label = this.label(text, x, y),
			curState = 0,
			stateOptions,
			stateStyle,
			normalStyle,
			hoverStyle,
			pressedStyle,
			STYLE = 'style',
			verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

		// prepare the attributes
		/*jslint white: true*/
		normalState = merge(hash(
			STROKE_WIDTH, 1,
			STROKE, '#999',
			FILL, hash(
				LINEAR_GRADIENT, verticalGradient,
				STOPS, [
					[0, '#FFF'],
					[1, '#DDD']
				]
			),
			'r', 3,
			'padding', 3,
			STYLE, hash(
				'color', 'black'
			)
		), normalState);
		/*jslint white: false*/
		normalStyle = normalState[STYLE];
		delete normalState[STYLE];

		/*jslint white: true*/
		hoverState = merge(normalState, hash(
			STROKE, '#68A',
			FILL, hash(
				LINEAR_GRADIENT, verticalGradient,
				STOPS, [
					[0, '#FFF'],
					[1, '#ACF']
				]
			)
		), hoverState);
		/*jslint white: false*/
		hoverStyle = hoverState[STYLE];
		delete hoverState[STYLE];

		/*jslint white: true*/
		pressedState = merge(normalState, hash(
			STROKE, '#68A',
			FILL, hash(
				LINEAR_GRADIENT, verticalGradient,
				STOPS, [
					[0, '#9BD'],
					[1, '#CDF']
				]
			)
		), pressedState);
		/*jslint white: false*/
		pressedStyle = pressedState[STYLE];
		delete pressedState[STYLE];

		// add the events
		addEvent(label.element, 'mouseenter', function () {
			label.attr(hoverState)
				.css(hoverStyle);
		});
		addEvent(label.element, 'mouseleave', function () {
			stateOptions = [normalState, hoverState, pressedState][curState];
			stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
			label.attr(stateOptions)
				.css(stateStyle);
		});

		label.setState = function (state) {
			curState = state;
			if (!state) {
				label.attr(normalState)
					.css(normalStyle);
			} else if (state === 2) {
				label.attr(pressedState)
					.css(pressedStyle);
			}
		};

		return label
			.on('click', function () {
				callback.call(label);
			})
			.attr(normalState)
			.css(extend({ cursor: 'default' }, normalStyle));
	},

	/**
	 * Make a straight line crisper by not spilling out to neighbour pixels
	 * @param {Array} points
	 * @param {Number} width
	 */
	crispLine: function (points, width) {
		// points format: [M, 0, 0, L, 100, 0]
		// normalize to a crisp line
		if (points[1] === points[4]) {
			points[1] = points[4] = mathRound(points[1]) + (width % 2 / 2);
		}
		if (points[2] === points[5]) {
			points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
		}
		return points;
	},


	/**
	 * Draw a path
	 * @param {Array} path An SVG path in array form
	 */
	path: function (path) {
		return this.createElement('path').attr({
			d: path,
			fill: NONE
		});
	},

	/**
	 * Draw and return an SVG circle
	 * @param {Number} x The x position
	 * @param {Number} y The y position
	 * @param {Number} r The radius
	 */
	circle: function (x, y, r) {
		var attr = isObject(x) ?
			x :
			{
				x: x,
				y: y,
				r: r
			};

		return this.createElement('circle').attr(attr);
	},

	/**
	 * Draw and return an arc
	 * @param {Number} x X position
	 * @param {Number} y Y position
	 * @param {Number} r Radius
	 * @param {Number} innerR Inner radius like used in donut charts
	 * @param {Number} start Starting angle
	 * @param {Number} end Ending angle
	 */
	arc: function (x, y, r, innerR, start, end) {
		// arcs are defined as symbols for the ability to set
		// attributes in attr and animate

		if (isObject(x)) {
			y = x.y;
			r = x.r;
			innerR = x.innerR;
			start = x.start;
			end = x.end;
			x = x.x;
		}
		return this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
			innerR: innerR || 0,
			start: start || 0,
			end: end || 0
		});
	},

	/**
	 * Draw and return a rectangle
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Number} r Border corner radius
	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
	 */
	rect: function (x, y, width, height, r, strokeWidth) {
		if (isObject(x)) {
			y = x.y;
			width = x.width;
			height = x.height;
			r = x.r;
			strokeWidth = x.strokeWidth;
			x = x.x;
		}
		var wrapper = this.createElement('rect').attr({
			rx: r,
			ry: r,
			fill: NONE
		});

		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
	},

	/**
	 * Resize the box and re-align all aligned elements
	 * @param {Object} width
	 * @param {Object} height
	 * @param {Boolean} animate
	 *
	 */
	setSize: function (width, height, animate) {
		var renderer = this,
			alignedObjects = renderer.alignedObjects,
			i = alignedObjects.length;

		renderer.width = width;
		renderer.height = height;

		renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
			width: width,
			height: height
		});

		while (i--) {
			alignedObjects[i].align();
		}
	},

	/**
	 * Create a group
	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
	 *     This can be used for styling and scripting.
	 */
	g: function (name) {
		var elem = this.createElement('g');
		return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
	},

	/**
	 * Display an image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var attribs = {
				preserveAspectRatio: NONE
			},
			elemWrapper;

		// optional properties
		if (arguments.length > 1) {
			extend(attribs, {
				x: x,
				y: y,
				width: width,
				height: height
			});
		}

		elemWrapper = this.createElement('image').attr(attribs);

		// set the href in the xlink namespace
		if (elemWrapper.element.setAttributeNS) {
			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
				'href', src);
		} else {
			// could be exporting in IE
			// using href throws "not supported" in ie7 and under, requries regex shim to fix later
			elemWrapper.element.setAttribute('hc-svg-href', src);
	}

		return elemWrapper;
	},

	/**
	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
	 *
	 * @param {Object} symbol
	 * @param {Object} x
	 * @param {Object} y
	 * @param {Object} radius
	 * @param {Object} options
	 */
	symbol: function (symbol, x, y, width, height, options) {

		var obj,

			// get the symbol definition function
			symbolFn = this.symbols[symbol],

			// check if there's a path defined for this symbol
			path = symbolFn && symbolFn(
				mathRound(x),
				mathRound(y),
				width,
				height,
				options
			),

			imageRegex = /^url\((.*?)\)$/,
			imageSrc,
			imageSize;

		if (path) {

			obj = this.path(path);
			// expando properties for use in animate and attr
			extend(obj, {
				symbolName: symbol,
				x: x,
				y: y,
				width: width,
				height: height
			});
			if (options) {
				extend(obj, options);
			}


		// image symbols
		} else if (imageRegex.test(symbol)) {

			var centerImage = function (img, size) {
				img.attr({
					width: size[0],
					height: size[1]
				}).translate(
					-mathRound(size[0] / 2),
					-mathRound(size[1] / 2)
				);
			};

			imageSrc = symbol.match(imageRegex)[1];
			imageSize = symbolSizes[imageSrc];

			// create the image synchronously, add attribs async
			obj = this.image(imageSrc)
				.attr({
					x: x,
					y: y
				});

			if (imageSize) {
				centerImage(obj, imageSize);
			} else {
				// initialize image to be 0 size so export will still function if there's no cached sizes
				obj.attr({ width: 0, height: 0 });

				// create a dummy JavaScript image to get the width and height
				createElement('img', {
					onload: function () {
						var img = this;

						centerImage(obj, symbolSizes[imageSrc] = [img.width, img.height]);
					},
					src: imageSrc
				});
			}
		}

		return obj;
	},

	/**
	 * An extendable collection of functions for defining symbol paths.
	 */
	symbols: {
		'circle': function (x, y, w, h) {
			var cpw = 0.166 * w;
			return [
				M, x + w / 2, y,
				'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
				'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
				'Z'
			];
		},

		'square': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle-down': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w / 2, y + h,
				'Z'
			];
		},
		'diamond': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h / 2,
				x + w / 2, y + h,
				x, y + h / 2,
				'Z'
			];
		},
		'arc': function (x, y, w, h, options) {
			var start = options.start,
				radius = options.r || w || h,
				end = options.end - 0.000001, // to prevent cos and sin of start and end from becoming equal on 360 arcs
				innerRadius = options.innerR,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				longArc = options.end - start < mathPI ? 0 : 1;

			return [
				M,
				x + radius * cosStart,
				y + radius * sinStart,
				'A', // arcTo
				radius, // x radius
				radius, // y radius
				0, // slanting
				longArc, // long or short arc
				1, // clockwise
				x + radius * cosEnd,
				y + radius * sinEnd,
				L,
				x + innerRadius * cosEnd,
				y + innerRadius * sinEnd,
				'A', // arcTo
				innerRadius, // x radius
				innerRadius, // y radius
				0, // slanting
				longArc, // long or short arc
				0, // clockwise
				x + innerRadius * cosStart,
				y + innerRadius * sinStart,

				'Z' // close
			];
		}
	},

	/**
	 * Define a clipping rectangle
	 * @param {String} id
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {
		var wrapper,
			id = PREFIX + idCounter++,

			clipPath = this.createElement('clipPath').attr({
				id: id
			}).add(this.defs);

		wrapper = this.rect(x, y, width, height, 0).add(clipPath);
		wrapper.id = id;
		wrapper.clipPath = clipPath;

		return wrapper;
	},


	/**
	 * Take a color and return it if it's a string, make it a gradient if it's a
	 * gradient configuration object. Prior to Highstock, an array was used to define
	 * a linear gradient with pixel positions relative to the SVG. In newer versions
	 * we change the coordinates to apply relative to the shape, using coordinates
	 * 0-1 within the shape. To preserve backwards compatibility, linearGradient
	 * in this definition is an object of x1, y1, x2 and y2.
	 *
	 * @param {Object} color The color or config object
	 */
	color: function (color, elem, prop) {
		var colorObject,
			regexRgba = /^rgba/;
		if (color && color.linearGradient) {
			var renderer = this,
				linearGradient = color[LINEAR_GRADIENT],
				relativeToShape = !isArray(linearGradient), // keep backwards compatibility
				id,
				gradients = renderer.gradients,
				gradientObject,
				x1 = linearGradient.x1 || linearGradient[0] || 0,
				y1 = linearGradient.y1 || linearGradient[1] || 0,
				x2 = linearGradient.x2 || linearGradient[2] || 0,
				y2 = linearGradient.y2 || linearGradient[3] || 0,
				stopColor,
				stopOpacity,
				// Create a unique key in order to reuse gradient objects. #671.
				key = [relativeToShape, x1, y1, x2, y2, color.stops.join(',')].join(',');

			// If the gradient with the same setup is already created, reuse it
			if (gradients[key]) {
				id = attr(gradients[key].element, 'id');

			// If not, create a new one and keep the reference.
			} else {
				id = PREFIX + idCounter++;
				gradientObject = renderer.createElement(LINEAR_GRADIENT)
					.attr(extend({
						id: id,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2
					}, relativeToShape ? null : { gradientUnits: 'userSpaceOnUse' }))
					.add(renderer.defs);

				// The gradient needs to keep a list of stops to be able to destroy them
				gradientObject.stops = [];
				each(color.stops, function (stop) {
					var stopObject;
					if (regexRgba.test(stop[1])) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}
					stopObject = renderer.createElement('stop').attr({
						offset: stop[0],
						'stop-color': stopColor,
						'stop-opacity': stopOpacity
					}).add(gradientObject);

					// Add the stop element to the gradient
					gradientObject.stops.push(stopObject);
				});

				// Keep a reference to the gradient object so it is possible to reuse it and
				// destroy it later
				gradients[key] = gradientObject;
			}

			return 'url(' + this.url + '#' + id + ')';

		// Webkit and Batik can't show rgba.
		} else if (regexRgba.test(color)) {
			colorObject = Color(color);
			attr(elem, prop + '-opacity', colorObject.get('a'));

			return colorObject.get('rgb');


		} else {
			// Remove the opacity attribute added above. Does not throw if the attribute is not there.
			elem.removeAttribute(prop + '-opacity');

			return color;
		}

	},


	/**
	 * Add text to the SVG object
	 * @param {String} str
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Boolean} useHTML Use HTML to render the text
	 */
	text: function (str, x, y, useHTML) {

		// declare variables
		var renderer = this,
			defaultChartStyle = defaultOptions.chart.style,
			wrapper;

		if (useHTML && !renderer.forExport) {
			return renderer.html(str, x, y);
		}

		x = mathRound(pick(x, 0));
		y = mathRound(pick(y, 0));

		wrapper = renderer.createElement('text')
			.attr({
				x: x,
				y: y,
				text: str
			})
			.css({
				fontFamily: defaultChartStyle.fontFamily,
				fontSize: defaultChartStyle.fontSize
			});

		wrapper.x = x;
		wrapper.y = y;
		return wrapper;
	},


	/**
	 * Create HTML text node. This is used by the VML renderer as well as the SVG
	 * renderer through the useHTML option.
	 *
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	html: function (str, x, y) {
		var defaultChartStyle = defaultOptions.chart.style,
			wrapper = this.createElement('span'),
			attrSetters = wrapper.attrSetters,
			element = wrapper.element,
			renderer = wrapper.renderer;

		// Text setter
		attrSetters.text = function (value) {
			element.innerHTML = value;
			return false;
		};

		// Various setters which rely on update transform
		attrSetters.x = attrSetters.y = attrSetters.align = function (value, key) {
			if (key === 'align') {
				key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
			}
			wrapper[key] = value;
			wrapper.htmlUpdateTransform();
			return false;
		};

		// Set the default attributes
		wrapper.attr({
				text: str,
				x: mathRound(x),
				y: mathRound(y)
			})
			.css({
				position: ABSOLUTE,
				whiteSpace: 'nowrap',
				fontFamily: defaultChartStyle.fontFamily,
				fontSize: defaultChartStyle.fontSize
			});

		// Use the HTML specific .css method
		wrapper.css = wrapper.htmlCss;

		// This is specific for HTML within SVG
		if (renderer.isSVG) {
			wrapper.add = function (svgGroupWrapper) {

				var htmlGroup,
					htmlGroupStyle,
					container = renderer.box.parentNode;

				// Create a mock group to hold the HTML elements
				if (svgGroupWrapper) {
					htmlGroup = svgGroupWrapper.div;
					if (!htmlGroup) {
						htmlGroup = svgGroupWrapper.div = createElement(DIV, {
							className: attr(svgGroupWrapper.element, 'class')
						}, {
							position: ABSOLUTE,
							left: svgGroupWrapper.attr('translateX') + PX,
							top: svgGroupWrapper.attr('translateY') + PX
						}, container);

						// Ensure dynamic updating position
						htmlGroupStyle = htmlGroup.style;
						extend(svgGroupWrapper.attrSetters, {
							translateX: function (value) {
								htmlGroupStyle.left = value + PX;
							},
							translateY: function (value) {
								htmlGroupStyle.top = value + PX;
							},
							visibility: function (value, key) {
								htmlGroupStyle[key] = value;
							}
						});

					}
				} else {
					htmlGroup = container;
				}

				htmlGroup.appendChild(element);

				// Shared with VML:
				wrapper.added = true;
				if (wrapper.alignOnAdd) {
					wrapper.htmlUpdateTransform();
				}

				return wrapper;
			};
		}
		return wrapper;
	},

	/**
	 * Utility to return the baseline offset and total line height from the font size
	 */
	fontMetrics: function (fontSize) {
		fontSize = pInt(fontSize || 11);
		
		// Empirical values found by comparing font size and bounding box height.
		// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
		var lineHeight = fontSize < 24 ? fontSize + 4 : mathRound(fontSize * 1.2),
			baseline = mathRound(lineHeight * 0.8);
		
		return {
			h: lineHeight, 
			b: baseline
		};
	},

	/**
	 * Add a label, a text item that can hold a colored or gradient background
	 * as well as a border and shadow.
	 * @param {string} str
	 * @param {Number} x
	 * @param {Number} y
	 * @param {String} shape
	 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
	 *    coordinates it should be pinned to
	 * @param {Number} anchorY
	 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
	 *    like renderer.text, or to the upper border of the rectangle. 
	 */
	label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline) {

		var renderer = this,
			wrapper = renderer.g(),
			text = renderer.text('', 0, 0, useHTML)
				.attr({
					zIndex: 1
				})
				.add(wrapper),
			box,
			bBox,
			align = 'left',
			padding = 3,
			width,
			height,
			wrapperX,
			wrapperY,
			crispAdjust = 0,
			deferredAttr = {},
			baselineOffset,
			attrSetters = wrapper.attrSetters;

		/**
		 * This function runs after the label is added to the DOM (when the bounding box is
		 * available), and after the text of the label is updated to detect the new bounding
		 * box and reflect it in the border box.
		 */
		function updateBoxSize() {
			var boxY,
				style = text.element.style;
				
			bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) &&
				text.getBBox(true);
			wrapper.width = (width || bBox.width) + 2 * padding;
			wrapper.height = (height || bBox.height) + 2 * padding;
			
			// update the label-scoped y offset
			baselineOffset = padding + renderer.fontMetrics(style && style.fontSize).b;
			
			
			// create the border box if it is not already present
			if (!box) {
				boxY = baseline ? -baselineOffset : 0;
			
				wrapper.box = box = shape ?
					renderer.symbol(shape, 0, boxY, wrapper.width, wrapper.height) :
					renderer.rect(0, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
				box.add(wrapper);
			}

			// apply the box attributes
			box.attr(merge({
				width: wrapper.width,
				height: wrapper.height
			}, deferredAttr));
			deferredAttr = null;
		}

		/**
		 * This function runs after setting text or padding, but only if padding is changed
		 */
		function updateTextPadding() {
			var styles = wrapper.styles,
				textAlign = styles && styles.textAlign,
				x = padding,
				y;
			
			// determin y based on the baseline
			y = baseline ? 0 : baselineOffset;

			// compensate for alignment
			if (defined(width) && (textAlign === 'center' || textAlign === 'right')) {
				x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
			}

			// update if anything changed
			if (x !== text.x || y !== text.y) {
				text.attr({
					x: x,
					y: y
				});
			}

			// record current values
			text.x = x;
			text.y = y;
		}

		/**
		 * Set a box attribute, or defer it if the box is not yet created
		 * @param {Object} key
		 * @param {Object} value
		 */
		function boxAttr(key, value) {
			if (box) {
				box.attr(key, value);
			} else {
				deferredAttr[key] = value;
			}
		}

		function getSizeAfterAdd() {
			wrapper.attr({
				text: str, // alignment is available now
				x: x,
				y: y,
				anchorX: anchorX,
				anchorY: anchorY
			});
		}

		/**
		 * After the text element is added, get the desired size of the border box
		 * and add it before the text in the DOM.
		 */
		addEvent(wrapper, 'add', getSizeAfterAdd);

		/*
		 * Add specific attribute setters.
		 */

		// only change local variables
		attrSetters.width = function (value) {
			width = value;
			return false;
		};
		attrSetters.height = function (value) {
			height = value;
			return false;
		};
		attrSetters.padding = function (value) {
			if (defined(value) && value !== padding) {
				padding = value;
				updateTextPadding();
			}

			return false;
		};

		// change local variable and set attribue as well
		attrSetters.align = function (value) {
			align = value;
			return false; // prevent setting text-anchor on the group
		};
		
		// apply these to the box and the text alike
		attrSetters.text = function (value, key) {
			text.attr(key, value);
			updateBoxSize();
			updateTextPadding();
			return false;
		};

		// apply these to the box but not to the text
		attrSetters[STROKE_WIDTH] = function (value, key) {
			crispAdjust = value % 2 / 2;
			boxAttr(key, value);
			return false;
		};
		attrSetters.stroke = attrSetters.fill = attrSetters.r = function (value, key) {
			boxAttr(key, value);
			return false;
		};
		attrSetters.anchorX = function (value, key) {
			anchorX = value;
			boxAttr(key, value + crispAdjust - wrapperX);
			return false;
		};
		attrSetters.anchorY = function (value, key) {
			anchorY = value;
			boxAttr(key, value - wrapperY);
			return false;
		};
		
		// rename attributes
		attrSetters.x = function (value) {
			value -= { left: 0, center: 0.5, right: 1 }[align] * ((width || bBox.width) + padding);
			wrapperX = wrapper.x = mathRound(value); // wrapper.x is for animation getter
			
			wrapper.attr('translateX', wrapperX);
			return false;
		};
		attrSetters.y = function (value) {
			wrapperY = wrapper.y = mathRound(value);
			wrapper.attr('translateY', value);
			return false;
		};

		// Redirect certain methods to either the box or the text
		var baseCss = wrapper.css;
		return extend(wrapper, {
			/**
			 * Pick up some properties and apply them to the text instead of the wrapper
			 */
			css: function (styles) {
				if (styles) {
					var textStyles = {};
					styles = merge({}, styles); // create a copy to avoid altering the original object (#537)
					each(['fontSize', 'fontWeight', 'fontFamily', 'color', 'lineHeight', 'width'], function (prop) {
						if (styles[prop] !== UNDEFINED) {
							textStyles[prop] = styles[prop];
							delete styles[prop];
						}
					});
					text.css(textStyles);
				}
				return baseCss.call(wrapper, styles);
			},
			/**
			 * Return the bounding box of the box, not the group
			 */
			getBBox: function () {
				return box.getBBox();
			},
			/**
			 * Apply the shadow to the box
			 */
			shadow: function (b) {
				box.shadow(b);
				return wrapper;
			},
			/**
			 * Destroy and release memory.
			 */
			destroy: function () {
				removeEvent(wrapper, 'add', getSizeAfterAdd);

				// Added by button implementation
				removeEvent(wrapper.element, 'mouseenter');
				removeEvent(wrapper.element, 'mouseleave');

				if (text) {
					// Destroy the text element
					text = text.destroy();
				}
				// Call base implementation to destroy the rest
				SVGElement.prototype.destroy.call(wrapper);
			}
		});
	}
}; // end SVGRenderer


// general renderer
Renderer = SVGRenderer;


/* ****************************************************************************
 *                                                                            *
 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
 *                                                                            *
 * For applications and websites that don't need IE support, like platform    *
 * targeted mobile apps and web apps, this code can be removed.               *
 *                                                                            *
 *****************************************************************************/

/**
 * @constructor
 */
var VMLRenderer;
if (!hasSVG && !useCanVG) {

/**
 * The VML element wrapper.
 */
var VMLElement = {

	/**
	 * Initialize a new VML element wrapper. It builds the markup as a string
	 * to minimize DOM traffic.
	 * @param {Object} renderer
	 * @param {Object} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this,
			markup =  ['<', nodeName, ' filled="f" stroked="f"'],
			style = ['position: ', ABSOLUTE, ';'];

		// divs and shapes need size
		if (nodeName === 'shape' || nodeName === DIV) {
			style.push('left:0;top:0;width:10px;height:10px;');
		}
		if (docMode8) {
			style.push('visibility: ', nodeName === DIV ? HIDDEN : VISIBLE);
		}

		markup.push(' style="', style.join(''), '"/>');

		// create element with default attributes and style
		if (nodeName) {
			markup = nodeName === DIV || nodeName === 'span' || nodeName === 'img' ?
				markup.join('')
				: renderer.prepVML(markup);
			wrapper.element = createElement(markup);
		}

		wrapper.renderer = renderer;
		wrapper.attrSetters = {};
	},

	/**
	 * Add the node to the given parent
	 * @param {Object} parent
	 */
	add: function (parent) {
		var wrapper = this,
			renderer = wrapper.renderer,
			element = wrapper.element,
			box = renderer.box,
			inverted = parent && parent.inverted,

			// get the parent node
			parentNode = parent ?
				parent.element || parent :
				box;


		// if the parent group is inverted, apply inversion on all children
		if (inverted) { // only on groups
			renderer.invertChild(element, parentNode);
		}

		// issue #140 workaround - related to #61 and #74
		if (docMode8 && parentNode.gVis === HIDDEN) {
			css(element, { visibility: HIDDEN });
		}

		// append it
		parentNode.appendChild(element);

		// align text after adding to be able to read offset
		wrapper.added = true;
		if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
			wrapper.updateTransform();
		}

		// fire an event for internal hooks
		fireEvent(wrapper, 'add');

		return wrapper;
	},

	/**
	 * In IE8 documentMode 8, we need to recursively set the visibility down in the DOM
	 * tree for nested groups. Related to #61, #586.
	 */
	toggleChildren: function (element, visibility) {
		var childNodes = element.childNodes,
			i = childNodes.length;
			
		while (i--) {
			
			// apply the visibility
			css(childNodes[i], { visibility: visibility });
			
			// we have a nested group, apply it to its children again
			if (childNodes[i].nodeName === 'DIV') {
				this.toggleChildren(childNodes[i], visibility);
			}
		}
	},

	/**
	 * VML always uses htmlUpdateTransform
	 */
	updateTransform: SVGElement.prototype.htmlUpdateTransform,

	/**
	 * Get or set attributes
	 */
	attr: function (hash, val) {
		var wrapper = this,
			key,
			value,
			i,
			result,
			element = wrapper.element || {},
			elemStyle = element.style,
			nodeName = element.nodeName,
			renderer = wrapper.renderer,
			symbolName = wrapper.symbolName,
			hasSetSymbolSize,
			shadows = wrapper.shadows,
			skipAttr,
			attrSetters = wrapper.attrSetters,
			ret = wrapper;

		// single key-value pair
		if (isString(hash) && defined(val)) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter, val is undefined
		if (isString(hash)) {
			key = hash;
			if (key === 'strokeWidth' || key === 'stroke-width') {
				ret = wrapper.strokeweight;
			} else {
				ret = wrapper[key];
			}

		// setter
		} else {
			for (key in hash) {
				value = hash[key];
				skipAttr = false;

				// check for a specific attribute setter
				result = attrSetters[key] && attrSetters[key](value, key);

				if (result !== false && value !== null) { // #620

					if (result !== UNDEFINED) {
						value = result; // the attribute setter has returned a new value to set
					}


					// prepare paths
					// symbols
					if (symbolName && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(key)) {
						// if one of the symbol size affecting parameters are changed,
						// check all the others only once for each call to an element's
						// .attr() method
						if (!hasSetSymbolSize) {
							wrapper.symbolAttr(hash);

							hasSetSymbolSize = true;
						}
						skipAttr = true;

					} else if (key === 'd') {
						value = value || [];
						wrapper.d = value.join(' '); // used in getter for animation

						// convert paths
						i = value.length;
						var convertedPath = [];
						while (i--) {

							// Multiply by 10 to allow subpixel precision.
							// Substracting half a pixel seems to make the coordinates
							// align with SVG, but this hasn't been tested thoroughly
							if (isNumber(value[i])) {
								convertedPath[i] = mathRound(value[i] * 10) - 5;
							} else if (value[i] === 'Z') { // close the path
								convertedPath[i] = 'x';
							} else {
								convertedPath[i] = value[i];
							}

						}
						value = convertedPath.join(' ') || 'x';
						element.path = value;

						// update shadows
						if (shadows) {
							i = shadows.length;
							while (i--) {
								shadows[i].path = value;
							}
						}
						skipAttr = true;

					// directly mapped to css
					} else if (key === 'zIndex' || key === 'visibility') {

						// workaround for #61 and #586
						if (docMode8 && key === 'visibility' && nodeName === 'DIV') {
							element.gVis = value;
							wrapper.toggleChildren(element, value);
							if (value === VISIBLE) { // #74
								value = null;
							}
						}

						if (value) {
							elemStyle[key] = value;
						}



						skipAttr = true;

					// width and height
					} else if (key === 'width' || key === 'height') {
						
						value = mathMax(0, value); // don't set width or height below zero (#311)
						
						this[key] = value; // used in getter

						// clipping rectangle special
						if (wrapper.updateClipping) {
							wrapper[key] = value;
							wrapper.updateClipping();
						} else {
							// normal
							elemStyle[key] = value;
						}

						skipAttr = true;

					// x and y
					} else if (key === 'x' || key === 'y') {

						wrapper[key] = value; // used in getter
						elemStyle[{ x: 'left', y: 'top' }[key]] = value;

					// class name
					} else if (key === 'class') {
						// IE8 Standards mode has problems retrieving the className
						element.className = value;

					// stroke
					} else if (key === 'stroke') {

						value = renderer.color(value, element, key);

						key = 'strokecolor';

					// stroke width
					} else if (key === 'stroke-width' || key === 'strokeWidth') {
						element.stroked = value ? true : false;
						key = 'strokeweight';
						wrapper[key] = value; // used in getter, issue #113
						if (isNumber(value)) {
							value += PX;
						}

					// dashStyle
					} else if (key === 'dashstyle') {
						var strokeElem = element.getElementsByTagName('stroke')[0] ||
							createElement(renderer.prepVML(['<stroke/>']), null, null, element);
						strokeElem[key] = value || 'solid';
						wrapper.dashstyle = value; /* because changing stroke-width will change the dash length
							and cause an epileptic effect */
						skipAttr = true;

					// fill
					} else if (key === 'fill') {

						if (nodeName === 'SPAN') { // text color
							elemStyle.color = value;
						} else {
							element.filled = value !== NONE ? true : false;

							value = renderer.color(value, element, key);

							key = 'fillcolor';
						}

					// translation for animation
					} else if (key === 'translateX' || key === 'translateY' || key === 'rotation') {
						wrapper[key] = value;
						wrapper.updateTransform();

						skipAttr = true;

					// text for rotated and non-rotated elements
					} else if (key === 'text') {
						this.bBox = null;
						element.innerHTML = value;
						skipAttr = true;
					}

					// let the shadow follow the main element
					if (shadows && key === 'visibility') {
						i = shadows.length;
						while (i--) {
							shadows[i].style[key] = value;
						}
					}



					if (!skipAttr) {
						if (docMode8) { // IE8 setAttribute bug
							element[key] = value;
						} else {
							attr(element, key, value);
						}
					}

				}
			}
		}
		return ret;
	},

	/**
	 * Set the element's clipping to a predefined rectangle
	 *
	 * @param {String} id The id of the clip rectangle
	 */
	clip: function (clipRect) {
		var wrapper = this,
			clipMembers = clipRect.members;

		clipMembers.push(wrapper);
		wrapper.destroyClip = function () {
			erase(clipMembers, wrapper);
		};
		return wrapper.css(clipRect.getCSS(wrapper.inverted));
	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: SVGElement.prototype.htmlCss,

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		// discardElement will detach the node from its parent before attaching it
		// to the garbage bin. Therefore it is important that the node is attached and have parent.
		var parentNode = element.parentNode;
		if (parentNode) {
			discardElement(element);
		}
	},

	/**
	 * Extend element.destroy by removing it from the clip members array
	 */
	destroy: function () {
		var wrapper = this;

		if (wrapper.destroyClip) {
			wrapper.destroyClip();
		}

		return SVGElement.prototype.destroy.apply(wrapper);
	},

	/**
	 * Remove all child nodes of a group, except the v:group element
	 */
	empty: function () {
		var element = this.element,
			childNodes = element.childNodes,
			i = childNodes.length,
			node;

		while (i--) {
			node = childNodes[i];
			node.parentNode.removeChild(node);
		}
	},

	/**
	 * Add an event listener. VML override for normalizing event parameters.
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		// simplest possible event model for internal use
		this.element['on' + eventType] = function () {
			var evt = win.event;
			evt.target = evt.srcElement;
			handler(evt);
		};
		return this;
	},

	/**
	 * Apply a drop shadow by copying elements and giving them different strokes
	 * @param {Boolean} apply
	 */
	shadow: function (apply, group) {
		var shadows = [],
			i,
			element = this.element,
			renderer = this.renderer,
			shadow,
			elemStyle = element.style,
			markup,
			path = element.path;

		// some times empty paths are not strings
		if (path && typeof path.value !== 'string') {
			path = 'x';
		}

		if (apply) {
			for (i = 1; i <= 3; i++) {
				markup = ['<shape isShadow="true" strokeweight="', (7 - 2 * i),
					'" filled="false" path="', path,
					'" coordsize="100,100" style="', element.style.cssText, '" />'];
				shadow = createElement(renderer.prepVML(markup),
					null, {
						left: pInt(elemStyle.left) + 1,
						top: pInt(elemStyle.top) + 1
					}
				);

				// apply the opacity
				markup = ['<stroke color="black" opacity="', (0.05 * i), '"/>'];
				createElement(renderer.prepVML(markup), null, null, shadow);


				// insert it
				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				// record it
				shadows.push(shadow);

			}

			this.shadows = shadows;
		}
		return this;

	}
};
VMLElement = extendClass(SVGElement, VMLElement);

/**
 * The VML renderer
 */
var VMLRendererExtension = { // inherit SVGRenderer

	Element: VMLElement,
	isIE8: userAgent.indexOf('MSIE 8.0') > -1,


	/**
	 * Initialize the VMLRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 */
	init: function (container, width, height) {
		var renderer = this,
			boxWrapper,
			box;

		renderer.alignedObjects = [];

		boxWrapper = renderer.createElement(DIV);
		box = boxWrapper.element;
		box.style.position = RELATIVE; // for freeform drawing using renderer directly
		container.appendChild(boxWrapper.element);


		// generate the containing box
		renderer.box = box;
		renderer.boxWrapper = boxWrapper;


		renderer.setSize(width, height, false);

		// The only way to make IE6 and IE7 print is to use a global namespace. However,
		// with IE8 the only way to make the dynamic shapes visible in screen and print mode
		// seems to be to add the xmlns attribute and the behaviour style inline.
		if (!doc.namespaces.hcv) {

			doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

			// setup default css
			doc.createStyleSheet().cssText =
				'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
				'{ behavior:url(#default#VML); display: inline-block; } ';

		}
	},

	/**
	 * Define a clipping rectangle. In VML it is accomplished by storing the values
	 * for setting the CSS style to all associated members.
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {

		// create a dummy element
		var clipRect = this.createElement();

		// mimic a rectangle with its style object for automatic updating in attr
		return extend(clipRect, {
			members: [],
			left: x,
			top: y,
			width: width,
			height: height,
			getCSS: function (inverted) {
				var rect = this,//clipRect.element.style,
					top = rect.top,
					left = rect.left,
					right = left + rect.width,
					bottom = top + rect.height,
					ret = {
						clip: 'rect(' +
							mathRound(inverted ? left : top) + 'px,' +
							mathRound(inverted ? bottom : right) + 'px,' +
							mathRound(inverted ? right : bottom) + 'px,' +
							mathRound(inverted ? top : left) + 'px)'
					};

				// issue 74 workaround
				if (!inverted && docMode8) {
					extend(ret, {
						width: right + PX,
						height: bottom + PX
					});
				}
				return ret;
			},

			// used in attr and animation to update the clipping of all members
			updateClipping: function () {
				each(clipRect.members, function (member) {
					member.css(clipRect.getCSS(member.inverted));
				});
			}
		});

	},


	/**
	 * Take a color and return it if it's a string, make it a gradient if it's a
	 * gradient configuration object, and apply opacity.
	 *
	 * @param {Object} color The color or config object
	 */
	color: function (color, elem, prop) {
		var colorObject,
			regexRgba = /^rgba/,
			markup;

		if (color && color[LINEAR_GRADIENT]) {

			var stopColor,
				stopOpacity,
				linearGradient = color[LINEAR_GRADIENT],
				x1 = linearGradient.x1 || linearGradient[0] || 0,
				y1 = linearGradient.y1 || linearGradient[1] || 0,
				x2 = linearGradient.x2 || linearGradient[2] || 0,
				y2 = linearGradient.y2 || linearGradient[3] || 0,
				angle,
				color1,
				opacity1,
				color2,
				opacity2;

			each(color.stops, function (stop, i) {
				if (regexRgba.test(stop[1])) {
					colorObject = Color(stop[1]);
					stopColor = colorObject.get('rgb');
					stopOpacity = colorObject.get('a');
				} else {
					stopColor = stop[1];
					stopOpacity = 1;
				}

				if (!i) { // first
					color1 = stopColor;
					opacity1 = stopOpacity;
				} else {
					color2 = stopColor;
					opacity2 = stopOpacity;
				}
			});

			// Apply the gradient to fills only.
			if (prop === 'fill') {
				// calculate the angle based on the linear vector
				angle = 90  - math.atan(
					(y2 - y1) / // y vector
					(x2 - x1) // x vector
					) * 180 / mathPI;
	
	
				// when colors attribute is used, the meanings of opacity and o:opacity2
				// are reversed.
				markup = ['<fill colors="0% ', color1, ',100% ', color2, '" angle="', angle,
					'" opacity="', opacity2, '" o:opacity2="', opacity1,
					'" type="gradient" focus="100%" method="sigma" />'];
				createElement(this.prepVML(markup), null, null, elem);
			
			// Gradients are not supported for VML stroke, return the first color. #722.
			} else {
				return stopColor;
			}


		// if the color is an rgba color, split it and add a fill node
		// to hold the opacity component
		} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

			colorObject = Color(color);

			markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
			createElement(this.prepVML(markup), null, null, elem);

			return colorObject.get('rgb');


		} else {
			var strokeNodes = elem.getElementsByTagName(prop);
			if (strokeNodes.length) {
				strokeNodes[0].opacity = 1;
			}
			return color;
		}

	},

	/**
	 * Take a VML string and prepare it for either IE8 or IE6/IE7.
	 * @param {Array} markup A string array of the VML markup to prepare
	 */
	prepVML: function (markup) {
		var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
			isIE8 = this.isIE8;

		markup = markup.join('');

		if (isIE8) { // add xmlns and style inline
			markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
			if (markup.indexOf('style="') === -1) {
				markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
			} else {
				markup = markup.replace('style="', 'style="' + vmlStyle);
			}

		} else { // add namespace
			markup = markup.replace('<', '<hcv:');
		}

		return markup;
	},

	/**
	 * Create rotated and aligned text
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	text: SVGRenderer.prototype.html,

	/**
	 * Create and return a path element
	 * @param {Array} path
	 */
	path: function (path) {
		// create the shape
		return this.createElement('shape').attr({
			// subpixel precision down to 0.1 (width and height = 10px)
			coordsize: '100 100',
			d: path
		});
	},

	/**
	 * Create and return a circle element. In VML circles are implemented as
	 * shapes, which is faster than v:oval
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} r
	 */
	circle: function (x, y, r) {
		return this.symbol('circle').attr({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });
	},

	/**
	 * Create a group using an outer div and an inner v:group to allow rotating
	 * and flipping. A simple v:group would have problems with positioning
	 * child HTML elements and CSS clip.
	 *
	 * @param {String} name The name of the group
	 */
	g: function (name) {
		var wrapper,
			attribs;

		// set the class name
		if (name) {
			attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
		}

		// the div to hold HTML and clipping
		wrapper = this.createElement(DIV).attr(attribs);

		return wrapper;
	},

	/**
	 * VML override to create a regular HTML image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var obj = this.createElement('img')
			.attr({ src: src });

		if (arguments.length > 1) {
			obj.css({
				left: x,
				top: y,
				width: width,
				height: height
			});
		}
		return obj;
	},

	/**
	 * VML uses a shape for rect to overcome bugs and rotation problems
	 */
	rect: function (x, y, width, height, r, strokeWidth) {

		if (isObject(x)) {
			y = x.y;
			width = x.width;
			height = x.height;
			strokeWidth = x.strokeWidth;
			x = x.x;
		}
		var wrapper = this.symbol('rect');
		wrapper.r = r;

		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
	},

	/**
	 * In the VML renderer, each child of an inverted div (group) is inverted
	 * @param {Object} element
	 * @param {Object} parentNode
	 */
	invertChild: function (element, parentNode) {
		var parentStyle = parentNode.style;

		css(element, {
			flip: 'x',
			left: pInt(parentStyle.width) - 10,
			top: pInt(parentStyle.height) - 10,
			rotation: -90
		});
	},

	/**
	 * Symbol definitions that override the parent SVG renderer's symbols
	 *
	 */
	symbols: {
		// VML specific arc function
		arc: function (x, y, w, h, options) {
			var start = options.start,
				end = options.end,
				radius = options.r || w || h,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				innerRadius = options.innerR,
				circleCorrection = 0.08 / radius, // #760
				innerCorrection = (innerRadius && 0.25 / innerRadius) || 0;

			if (end - start === 0) { // no angle, don't show it.
				return ['x'];

			} else if (2 * mathPI - end + start < circleCorrection) { // full circle
				// empirical correction found by trying out the limits for different radii
				cosEnd = -circleCorrection;
			} else if (end - start < innerCorrection) { // issue #186, another mysterious VML arc problem
				cosEnd = mathCos(start + innerCorrection);
			}

			return [
				'wa', // clockwise arc to
				x - radius, // left
				y - radius, // top
				x + radius, // right
				y + radius, // bottom
				x + radius * cosStart, // start x
				y + radius * sinStart, // start y
				x + radius * cosEnd, // end x
				y + radius * sinEnd, // end y


				'at', // anti clockwise arc to
				x - innerRadius, // left
				y - innerRadius, // top
				x + innerRadius, // right
				y + innerRadius, // bottom
				x + innerRadius * cosEnd, // start x
				y + innerRadius * sinEnd, // start y
				x + innerRadius * cosStart, // end x
				y + innerRadius * sinStart, // end y

				'x', // finish path
				'e' // close
			];

		},
		// Add circle symbol path. This performs significantly faster than v:oval.
		circle: function (x, y, w, h) {

			return [
				'wa', // clockwisearcto
				x, // left
				y, // top
				x + w, // right
				y + h, // bottom
				x + w, // start x
				y + h / 2,     // start y
				x + w, // end x
				y + h / 2,     // end y
				//'x', // finish path
				'e' // close
			];
		},
		/**
		 * Add rectangle symbol path which eases rotation and omits arcsize problems
		 * compared to the built-in VML roundrect shape
		 *
		 * @param {Number} left Left position
		 * @param {Number} top Top position
		 * @param {Number} r Border radius
		 * @param {Object} options Width and height
		 */

		rect: function (left, top, width, height, options) {
			/*for (var n in r) {
				logTime && console .log(n)
				}*/

			if (!defined(options)) {
				return [];
			}
			var right = left + width,
				bottom = top + height,
				r = mathMin(options.r || 0, width, height);

			return [
				M,
				left + r, top,

				L,
				right - r, top,
				'wa',
				right - 2 * r, top,
				right, top + 2 * r,
				right - r, top,
				right, top + r,

				L,
				right, bottom - r,
				'wa',
				right - 2 * r, bottom - 2 * r,
				right, bottom,
				right, bottom - r,
				right - r, bottom,

				L,
				left + r, bottom,
				'wa',
				left, bottom - 2 * r,
				left + 2 * r, bottom,
				left + r, bottom,
				left, bottom - r,

				L,
				left, top + r,
				'wa',
				left, top,
				left + 2 * r, top + 2 * r,
				left, top + r,
				left + r, top,


				'x',
				'e'
			];

		}
	}
};
VMLRenderer = function () {
	this.init.apply(this, arguments);
};
VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

	// general renderer
	Renderer = VMLRenderer;
}

/* ****************************************************************************
 *                                                                            *
 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
 *                                                                            *
 *****************************************************************************/
/* ****************************************************************************
 *                                                                            *
 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
 * TARGETING THAT SYSTEM.                                                     *
 *                                                                            *
 *****************************************************************************/
var CanVGRenderer,
	CanVGController;

if (useCanVG) {
	/**
	 * The CanVGRenderer is empty from start to keep the source footprint small.
	 * When requested, the CanVGController downloads the rest of the source packaged
	 * together with the canvg library.
	 */
	CanVGRenderer = function () {
		// Empty constructor
	};

	/**
	 * Handles on demand download of canvg rendering support.
	 */
	CanVGController = (function () {
		// List of renderering calls
		var deferredRenderCalls = [];

		/**
		 * When downloaded, we are ready to draw deferred charts.
		 */
		function drawDeferred() {
			var callLength = deferredRenderCalls.length,
				callIndex;

			// Draw all pending render calls
			for (callIndex = 0; callIndex < callLength; callIndex++) {
				deferredRenderCalls[callIndex]();
			}
			// Clear the list
			deferredRenderCalls = [];
		}

		return {
			push: function (func, scriptLocation) {
				// Only get the script once
				if (deferredRenderCalls.length === 0) {
					getScript(scriptLocation, drawDeferred);
				}
				// Register render call
				deferredRenderCalls.push(func);
			}
		};
	}());
} // end CanVGRenderer

/* ****************************************************************************
 *                                                                            *
 * END OF ANDROID < 3 SPECIFIC CODE                                           *
 *                                                                            *
 *****************************************************************************/

/**
 * General renderer
 */
Renderer = VMLRenderer || CanVGRenderer || SVGRenderer;

/**
 * The chart class
 * @param {Object} options
 * @param {Function} callback Function to run when the chart has loaded
 */
function Chart(userOptions, callback) {

	// Handle regular options
	var options,
		seriesOptions = userOptions.series; // skip merging data points to increase performance
	userOptions.series = null;
	options = merge(defaultOptions, userOptions); // do the merge
	options.series = userOptions.series = seriesOptions; // set back the series data
	
	var optionsChart = options.chart,
		optionsMargin = optionsChart.margin,
		margin = isObject(optionsMargin) ?
			optionsMargin :
			[optionsMargin, optionsMargin, optionsMargin, optionsMargin],
		optionsMarginTop = pick(optionsChart.marginTop, margin[0]),
		optionsMarginRight = pick(optionsChart.marginRight, margin[1]),
		optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]),
		optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]),
		spacingTop = optionsChart.spacingTop,
		spacingRight = optionsChart.spacingRight,
		spacingBottom = optionsChart.spacingBottom,
		spacingLeft = optionsChart.spacingLeft,
		spacingBox,
		chartTitleOptions,
		chartSubtitleOptions,
		plotTop,
		marginRight,
		marginBottom,
		plotLeft,
		axisOffset,
		renderTo,
		renderToClone,
		container,
		containerId,
		containerWidth,
		containerHeight,
		chartWidth,
		chartHeight,
		oldChartWidth,
		oldChartHeight,
		chartBackground,
		plotBackground,
		plotBGImage,
		plotBorder,
		chart = this,
		chartEvents = optionsChart.events,
		runChartClick = chartEvents && !!chartEvents.click,
		eventType,
		isInsidePlot, // function
		tooltip,
		mouseIsDown,
		loadingDiv,
		loadingSpan,
		loadingShown,
		plotHeight,
		plotWidth,
		tracker,
		trackerGroup,
		legend,
		legendWidth,
		legendHeight,
		chartPosition,
		hasCartesianSeries = optionsChart.showAxes,
		isResizing = 0,
		axes = [],
		maxTicks, // handle the greatest amount of ticks on grouped axes
		series = [],
		inverted,
		renderer,
		tooltipTick,
		tooltipInterval,
		hoverX,
		drawChartBox, // function
		getMargins, // function
		resetMargins, // function
		setChartSize, // function
		resize,
		zoom, // function
		zoomOut; // function


	/**
	 * Create a new axis object
	 * @param {Object} options
	 */
	function Axis(userOptions) {

		// Define variables
		var isXAxis = userOptions.isX,
			opposite = userOptions.opposite, // needed in setOptions
			horiz = inverted ? !isXAxis : isXAxis,
			side = horiz ?
				(opposite ? 0 : 2) : // top : bottom
				(opposite ? 1 : 3),  // right : left
			stacks = {},

			options = merge(
				isXAxis ? defaultXAxisOptions : defaultYAxisOptions,
				[defaultTopAxisOptions, defaultRightAxisOptions,
					defaultBottomAxisOptions, defaultLeftAxisOptions][side],
				userOptions
			),

			axis = this,
			axisTitle,
			type = options.type,
			isDatetimeAxis = type === 'datetime',
			isLog = type === 'logarithmic',
			offset = options.offset || 0,
			xOrY = isXAxis ? 'x' : 'y',
			axisLength = 0,
			oldAxisLength,
			transA, // translation factor
			transB, // translation addend
			oldTransA, // used for prerendering
			axisLeft,
			axisTop,
			axisWidth,
			axisHeight,
			axisBottom,
			axisRight,
			translate, // fn
			setAxisTranslation, // fn
			getPlotLinePath, // fn
			axisGroup,
			gridGroup,
			axisLine,
			dataMin,
			dataMax,
			minRange = options.minRange || options.maxZoom,
			range = options.range,
			userMin,
			userMax,
			oldUserMin,
			oldUserMax,
			max = null,
			min = null,
			oldMin,
			oldMax,
			minPadding = options.minPadding,
			maxPadding = options.maxPadding,
			minPixelPadding = 0,
			isLinked = defined(options.linkedTo),
			linkedParent,
			ignoreMinPadding, // can be set to true by a column or bar series
			ignoreMaxPadding,
			usePercentage,
			events = options.events,
			eventType,
			plotLinesAndBands = [],
			tickInterval,
			minorTickInterval,
			magnitude,
			tickPositions, // array containing predefined positions
			tickPositioner = options.tickPositioner,
			ticks = {},
			minorTicks = {},
			alternateBands = {},
			tickAmount,
			labelOffset,
			axisTitleMargin,// = options.title.margin,
			categories = options.categories,
			labelFormatter = options.labels.formatter ||  // can be overwritten by dynamic format
				function () {
					var value = this.value,
						dateTimeLabelFormat = this.dateTimeLabelFormat,
						ret;

					if (dateTimeLabelFormat) { // datetime axis
						ret = dateFormat(dateTimeLabelFormat, value);

					} else if (tickInterval % 1000000 === 0) { // use M abbreviation
						ret = (value / 1000000) + 'M';

					} else if (tickInterval % 1000 === 0) { // use k abbreviation
						ret = (value / 1000) + 'k';

					} else if (!categories && value >= 1000) { // add thousands separators
						ret = numberFormat(value, 0);

					} else { // strings (categories) and small numbers
						ret = value;
					}
					return ret;
				},

			staggerLines = horiz && options.labels.staggerLines,
			reversed = options.reversed,
			tickmarkOffset = (categories && options.tickmarkPlacement === 'between') ? 0.5 : 0;

		/**
		 * The Tick class
		 */
		function Tick(pos, type) {
			var tick = this;
			tick.pos = pos;
			tick.type = type || '';
			tick.isNew = true;

			if (!type) {
				tick.addLabel();
			}
		}
		Tick.prototype = {

			/**
			 * Write the tick label
			 */
			addLabel: function () {
				var tick = this,
					pos = tick.pos,
					labelOptions = options.labels,
					str,
					width = (categories && horiz && categories.length &&
						!labelOptions.step && !labelOptions.staggerLines &&
						!labelOptions.rotation &&
						plotWidth / categories.length) ||
						(!horiz && plotWidth / 2),
					isFirst = pos === tickPositions[0],
					isLast = pos === tickPositions[tickPositions.length - 1],
					css,
					value = categories && defined(categories[pos]) ? categories[pos] : pos,
					label = tick.label,
					tickPositionInfo = tickPositions.info,
					dateTimeLabelFormat;

				// Set the datetime label format. If a higher rank is set for this position, use that. If not,
				// use the general format.
				if (isDatetimeAxis && tickPositionInfo) {
					dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
				}

				// set properties for access in render method
				tick.isFirst = isFirst;
				tick.isLast = isLast;

				// get the string
				str = labelFormatter.call({
					axis: axis,
					chart: chart,
					isFirst: isFirst,
					isLast: isLast,
					dateTimeLabelFormat: dateTimeLabelFormat,
					value: isLog ? correctFloat(lin2log(value)) : value
				});


				// prepare CSS
				css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
				css = extend(css, labelOptions.style);

				// first call
				if (!defined(label)) {
					tick.label =
						defined(str) && labelOptions.enabled ?
							renderer.text(
									str,
									0,
									0,
									labelOptions.useHTML
								)
								.attr({
									align: labelOptions.align,
									rotation: labelOptions.rotation
								})
								// without position absolute, IE export sometimes is wrong
								.css(css)
								.add(axisGroup) :
							null;

				// update
				} else if (label) {
					label.attr({
							text: str
						})
						.css(css);
				}
			},
			/**
			 * Get the offset height or width of the label
			 */
			getLabelSize: function () {
				var label = this.label;
				return label ?
					((this.labelBBox = label.getBBox()))[horiz ? 'height' : 'width'] :
					0;
			},
			
			/**
			 * Find how far the labels extend to the right and left of the tick's x position. Used for anti-collision
			 * detection with overflow logic.
			 */
			getLabelSides: function () {
				var bBox = this.labelBBox, // assume getLabelSize has run at this point
					labelOptions = options.labels,
					width = bBox.width,
					leftSide = width * { left: 0, center: 0.5, right: 1 }[labelOptions.align] - labelOptions.x;
					
				return [-leftSide, width - leftSide];				
			},
			
			/**
			 * Handle the label overflow by adjusting the labels to the left and right edge, or
			 * hide them if they collide into the neighbour label.
			 */
			handleOverflow: function (index) {
				var show = true,
					isFirst = this.isFirst,
					isLast = this.isLast,
					label = this.label,
					x = label.x;
					
				if (isFirst || isLast) {
					
					var sides = this.getLabelSides(),
						leftSide = sides[0],
						rightSide = sides[1],
						plotLeft = chart.plotLeft,
						plotRight = plotLeft + axis.len,
						neighbour = ticks[tickPositions[index + (isFirst ? 1 : -1)]],
						neighbourEdge = neighbour && neighbour.label.x + neighbour.getLabelSides()[isFirst ? 0 : 1];
					
					if ((isFirst && !reversed) || (isLast && reversed)) {
						// Is the label spilling out to the left of the plot area?
						if (x + leftSide < plotLeft) {
							
							// Align it to plot left
							x = plotLeft - leftSide;
							
							// Hide it if it now overlaps the neighbour label
							if (neighbour && x + rightSide > neighbourEdge) {
								show = false;
							}
						}
										
					} else {
						// Is the label spilling out to the right of the plot area?
						if (x + rightSide > plotRight) {
							
							// Align it to plot right
							x = plotRight - rightSide;
							
							// Hide it if it now overlaps the neighbour label
							if (neighbour && x + leftSide < neighbourEdge) {
								show = false;
							}
							
						}
					}
					
					// Set the modified x position of the label
					label.x = x;
				}
				return show;
			},
			
			/**
			 * Put everything in place
			 *
			 * @param index {Number}
			 * @param old {Boolean} Use old coordinates to prepare an animation into new position
			 */
			render: function (index, old) {
				var tick = this,
					type = tick.type,
					label = tick.label,
					pos = tick.pos,
					labelOptions = options.labels,
					gridLine = tick.gridLine,
					gridPrefix = type ? type + 'Grid' : 'grid',
					tickPrefix = type ? type + 'Tick' : 'tick',
					gridLineWidth = options[gridPrefix + 'LineWidth'],
					gridLineColor = options[gridPrefix + 'LineColor'],
					dashStyle = options[gridPrefix + 'LineDashStyle'],
					tickLength = options[tickPrefix + 'Length'],
					tickWidth = options[tickPrefix + 'Width'] || 0,
					tickColor = options[tickPrefix + 'Color'],
					tickPosition = options[tickPrefix + 'Position'],
					gridLinePath,
					mark = tick.mark,
					markPath,
					step = labelOptions.step,
					cHeight = (old && oldChartHeight) || chartHeight,
					attribs,
					show = true,
					x,
					y;

				// get x and y position for ticks and labels
				x = horiz ?
					translate(pos + tickmarkOffset, null, null, old) + transB :
					axisLeft + offset + (opposite ? ((old && oldChartWidth) || chartWidth) - axisRight - axisLeft : 0);

				y = horiz ?
					cHeight - axisBottom + offset - (opposite ? axisHeight : 0) :
					cHeight - translate(pos + tickmarkOffset, null, null, old) - transB;

				// create the grid line
				if (gridLineWidth) {
					gridLinePath = getPlotLinePath(pos + tickmarkOffset, gridLineWidth, old);

					if (gridLine === UNDEFINED) {
						attribs = {
							stroke: gridLineColor,
							'stroke-width': gridLineWidth
						};
						if (dashStyle) {
							attribs.dashstyle = dashStyle;
						}
						if (!type) {
							attribs.zIndex = 1;
						}
						tick.gridLine = gridLine =
							gridLineWidth ?
								renderer.path(gridLinePath)
									.attr(attribs).add(gridGroup) :
								null;
					}

					// If the parameter 'old' is set, the current call will be followed
					// by another call, therefore do not do any animations this time
					if (!old && gridLine && gridLinePath) {
						gridLine.animate({
							d: gridLinePath
						});
					}
				}

				// create the tick mark
				if (tickWidth) {

					// negate the length
					if (tickPosition === 'inside') {
						tickLength = -tickLength;
					}
					if (opposite) {
						tickLength = -tickLength;
					}

					markPath = renderer.crispLine([
						M,
						x,
						y,
						L,
						x + (horiz ? 0 : -tickLength),
						y + (horiz ? tickLength : 0)
					], tickWidth);

					if (mark) { // updating
						mark.animate({
							d: markPath
						});
					} else { // first time
						tick.mark = renderer.path(
							markPath
						).attr({
							stroke: tickColor,
							'stroke-width': tickWidth
						}).add(axisGroup);
					}
				}

				// the label is created on init - now move it into place
				if (label && !isNaN(x)) {
					x = x + labelOptions.x - (tickmarkOffset && horiz ?
						tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
					y = y + labelOptions.y - (tickmarkOffset && !horiz ?
						tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

					// vertically centered
					if (!defined(labelOptions.y)) {
						y += pInt(label.styles.lineHeight) * 0.9 - label.getBBox().height / 2;
					}


					// correct for staggered labels
					if (staggerLines) {
						y += (index / (step || 1) % staggerLines) * 16;
					}
					
					// Cache x and y to be able to read final position before animation
					label.x = x;
					label.y = y;

					// apply show first and show last
					if ((tick.isFirst && !pick(options.showFirstLabel, 1)) ||
							(tick.isLast && !pick(options.showLastLabel, 1))) {
						show = false;
						
					// Handle label overflow and show or hide accordingly
					} else if (!staggerLines && horiz && labelOptions.overflow === 'justify' && !tick.handleOverflow(index)) {						
						show = false;
					}

					// apply step
					if (step && index % step) {
						// show those indices dividable by step
						show = false;
					}
					
					// Set the new position, and show or hide
					if (show) {
						label[tick.isNew ? 'attr' : 'animate']({
							x: label.x,
							y: label.y
						});
						label.show();
						tick.isNew = false;
					} else {
						label.hide();
					}
				}

				
			},
			
			/**
			 * Destructor for the tick prototype
			 */
			destroy: function () {
				destroyObjectProperties(this);
			}
		};

		/**
		 * The object wrapper for plot lines and plot bands
		 * @param {Object} options
		 */
		function PlotLineOrBand(options) {
			var plotLine = this;
			if (options) {
				plotLine.options = options;
				plotLine.id = options.id;
			}

			//plotLine.render()
			return plotLine;
		}

		PlotLineOrBand.prototype = {

		/**
		 * Render the plot line or plot band. If it is already existing,
		 * move it.
		 */
		render: function () {
			var plotLine = this,
				halfPointRange = (axis.pointRange || 0) / 2,
				options = plotLine.options,
				optionsLabel = options.label,
				label = plotLine.label,
				width = options.width,
				to = options.to,
				from = options.from,
				value = options.value,
				toPath, // bands only
				dashStyle = options.dashStyle,
				svgElem = plotLine.svgElem,
				path = [],
				addEvent,
				eventType,
				xs,
				ys,
				x,
				y,
				color = options.color,
				zIndex = options.zIndex,
				events = options.events,
				attribs;

			// logarithmic conversion
			if (isLog) {
				from = log2lin(from);
				to = log2lin(to);
				value = log2lin(value);
			}

			// plot line
			if (width) {
				path = getPlotLinePath(value, width);
				attribs = {
					stroke: color,
					'stroke-width': width
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
			} else if (defined(from) && defined(to)) { // plot band
				// keep within plot area
				from = mathMax(from, min - halfPointRange);
				to = mathMin(to, max + halfPointRange);

				toPath = getPlotLinePath(to);
				path = getPlotLinePath(from);
				if (path && toPath) {
					path.push(
						toPath[4],
						toPath[5],
						toPath[1],
						toPath[2]
					);
				} else { // outside the axis area
					path = null;
				}
				attribs = {
					fill: color
				};
			} else {
				return;
			}
			// zIndex
			if (defined(zIndex)) {
				attribs.zIndex = zIndex;
			}

			// common for lines and bands
			if (svgElem) {
				if (path) {
					svgElem.animate({
						d: path
					}, null, svgElem.onGetPath);
				} else {
					svgElem.hide();
					svgElem.onGetPath = function () {
						svgElem.show();
					};
				}
			} else if (path && path.length) {
				plotLine.svgElem = svgElem = renderer.path(path)
					.attr(attribs).add();

				// events
				if (events) {
					addEvent = function (eventType) {
						svgElem.on(eventType, function (e) {
							events[eventType].apply(plotLine, [e]);
						});
					};
					for (eventType in events) {
						addEvent(eventType);
					}
				}
			}

			// the plot band/line label
			if (optionsLabel && defined(optionsLabel.text) && path && path.length && axisWidth > 0 && axisHeight > 0) {
				// apply defaults
				optionsLabel = merge({
					align: horiz && toPath && 'center',
					x: horiz ? !toPath && 4 : 10,
					verticalAlign : !horiz && toPath && 'middle',
					y: horiz ? toPath ? 16 : 10 : toPath ? 6 : -4,
					rotation: horiz && !toPath && 90
				}, optionsLabel);

				// add the SVG element
				if (!label) {
					plotLine.label = label = renderer.text(
							optionsLabel.text,
							0,
							0
						)
						.attr({
							align: optionsLabel.textAlign || optionsLabel.align,
							rotation: optionsLabel.rotation,
							zIndex: zIndex
						})
						.css(optionsLabel.style)
						.add();
				}

				// get the bounding box and align the label
				xs = [path[1], path[4], pick(path[6], path[1])];
				ys = [path[2], path[5], pick(path[7], path[2])];
				x = arrayMin(xs);
				y = arrayMin(ys);

				label.align(optionsLabel, false, {
					x: x,
					y: y,
					width: arrayMax(xs) - x,
					height: arrayMax(ys) - y
				});
				label.show();

			} else if (label) { // move out of sight
				label.hide();
			}

			// chainable
			return plotLine;
		},

		/**
		 * Remove the plot line or band
		 */
		destroy: function () {
			var obj = this;

			destroyObjectProperties(obj);

			// remove it from the lookup
			erase(plotLinesAndBands, obj);
		}
		};

		/**
		 * The class for stack items
		 */
		function StackItem(options, isNegative, x, stackOption) {
			var stackItem = this;

			// Tells if the stack is negative
			stackItem.isNegative = isNegative;

			// Save the options to be able to style the label
			stackItem.options = options;

			// Save the x value to be able to position the label later
			stackItem.x = x;

			// Save the stack option on the series configuration object
			stackItem.stack = stackOption;

			// The align options and text align varies on whether the stack is negative and
			// if the chart is inverted or not.
			// First test the user supplied value, then use the dynamic.
			stackItem.alignOptions = {
				align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
				verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
				y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
				x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
			};

			stackItem.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
		}

		StackItem.prototype = {
			destroy: function () {
				destroyObjectProperties(this);
			},

			/**
			 * Sets the total of this stack. Should be called when a serie is hidden or shown
			 * since that will affect the total of other stacks.
			 */
			setTotal: function (total) {
				this.total = total;
				this.cum = total;
			},

			/**
			 * Renders the stack total label and adds it to the stack label group.
			 */
			render: function (group) {
				var stackItem = this,									// aliased this
					str = stackItem.options.formatter.call(stackItem);  // format the text in the label

				// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
				if (stackItem.label) {
					stackItem.label.attr({text: str, visibility: HIDDEN});
				// Create new label
				} else {
					stackItem.label =
						chart.renderer.text(str, 0, 0)				// dummy positions, actual position updated with setOffset method in columnseries
							.css(stackItem.options.style)			// apply style
							.attr({align: stackItem.textAlign,			// fix the text-anchor
								rotation: stackItem.options.rotation,	// rotation
								visibility: HIDDEN })					// hidden until setOffset is called
							.add(group);							// add to the labels-group
				}
			},

			/**
			 * Sets the offset that the stack has from the x value and repositions the label.
			 */
			setOffset: function (xOffset, xWidth) {
				var stackItem = this,										// aliased this
					neg = stackItem.isNegative,								// special treatment is needed for negative stacks
					y = axis.translate(stackItem.total, 0, 0, 0, 1),		// stack value translated mapped to chart coordinates
					yZero = axis.translate(0),								// stack origin
					h = mathAbs(y - yZero),									// stack height
					x = chart.xAxis[0].translate(stackItem.x) + xOffset,	// stack x position
					plotHeight = chart.plotHeight,
					stackBox = {	// this is the box for the complete stack
							x: inverted ? (neg ? y : y - h) : x,
							y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
							width: inverted ? h : xWidth,
							height: inverted ? xWidth : h
					};

				if (stackItem.label) {
					stackItem.label
						.align(stackItem.alignOptions, null, stackBox)	// align the label to the box
						.attr({visibility: VISIBLE});					// set visibility
				}
			}
		};

		/**
		 * Get the minimum and maximum for the series of each axis
		 */
		function getSeriesExtremes() {
			var posStack = [],
				negStack = [],
				i;

			// reset dataMin and dataMax in case we're redrawing
			dataMin = dataMax = null;

			// loop through this axis' series
			each(axis.series, function (series) {

				if (series.visible || !optionsChart.ignoreHiddenSeries) {

					var seriesOptions = series.options,
						stacking,
						posPointStack,
						negPointStack,
						stackKey,
						stackOption,
						negKey,
						xData,
						yData,
						x,
						y,
						threshold = seriesOptions.threshold,
						yDataLength,
						activeYData = [],
						activeCounter = 0;
						
					// Validate threshold in logarithmic axes
					if (isLog && threshold <= 0) {
						threshold = seriesOptions.threshold = null;
					}

					// Get dataMin and dataMax for X axes
					if (isXAxis) {
						xData = series.xData;
						if (xData.length) {
							dataMin = mathMin(pick(dataMin, xData[0]), arrayMin(xData));
							dataMax = mathMax(pick(dataMax, xData[0]), arrayMax(xData));
						}

					// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
					} else {
						var isNegative,
							pointStack,
							key,
							cropped = series.cropped,
							xExtremes = series.xAxis.getExtremes(),
							//findPointRange,
							//pointRange,
							j,
							hasModifyValue = !!series.modifyValue;


						// Handle stacking
						stacking = seriesOptions.stacking;
						usePercentage = stacking === 'percent';

						// create a stack for this particular series type
						if (stacking) {
							stackOption = seriesOptions.stack;
							stackKey = series.type + pick(stackOption, '');
							negKey = '-' + stackKey;
							series.stackKey = stackKey; // used in translate

							posPointStack = posStack[stackKey] || []; // contains the total values for each x
							posStack[stackKey] = posPointStack;

							negPointStack = negStack[negKey] || [];
							negStack[negKey] = negPointStack;
						}
						if (usePercentage) {
							dataMin = 0;
							dataMax = 99;
						}


						// processData can alter series.pointRange, so this goes after
						//findPointRange = series.pointRange === null;

						xData = series.processedXData;
						yData = series.processedYData;
						yDataLength = yData.length;

						// loop over the non-null y values and read them into a local array
						for (i = 0; i < yDataLength; i++) {
							x = xData[i];
							y = yData[i];
							if (y !== null && y !== UNDEFINED) {

								// read stacked values into a stack based on the x value,
								// the sign of y and the stack key
								if (stacking) {
									isNegative = y < threshold;
									pointStack = isNegative ? negPointStack : posPointStack;
									key = isNegative ? negKey : stackKey;

									y = pointStack[x] =
										defined(pointStack[x]) ?
										pointStack[x] + y : y;


									// add the series
									if (!stacks[key]) {
										stacks[key] = {};
									}

									// If the StackItem is there, just update the values,
									// if not, create one first
									if (!stacks[key][x]) {
										stacks[key][x] = new StackItem(options.stackLabels, isNegative, x, stackOption);
									}
									stacks[key][x].setTotal(y);


								// general hook, used for Highstock compare values feature
								} else if (hasModifyValue) {
									y = series.modifyValue(y);
								}

								// get the smallest distance between points
								/*if (i) {
									distance = mathAbs(xData[i] - xData[i - 1]);
									pointRange = pointRange === UNDEFINED ? distance : mathMin(distance, pointRange);
								}*/

								// for points within the visible range, including the first point outside the
								// visible range, consider y extremes
								if (cropped || ((xData[i + 1] || x) >= xExtremes.min && (xData[i - 1] || x) <= xExtremes.max)) {

									j = y.length;
									if (j) { // array, like ohlc data
										while (j--) {
											if (y[j] !== null) {
												activeYData[activeCounter++] = y[j];
											}
										}
									} else {
										activeYData[activeCounter++] = y;
									}
								}
							}
						}

						// record the least unit distance
						/*if (findPointRange) {
							series.pointRange = pointRange || 1;
						}
						series.closestPointRange = pointRange;*/

						// Get the dataMin and dataMax so far. If percentage is used, the min and max are
						// always 0 and 100. If the length of activeYData is 0, continue with null values.
						if (!usePercentage && activeYData.length) {
							dataMin = mathMin(pick(dataMin, activeYData[0]), arrayMin(activeYData));
							dataMax = mathMax(pick(dataMax, activeYData[0]), arrayMax(activeYData));
						}

						// Adjust to threshold
						if (defined(threshold)) {
							if (dataMin >= threshold) {
								dataMin = threshold;
								ignoreMinPadding = true;
							} else if (dataMax < threshold) {
								dataMax = threshold;
								ignoreMaxPadding = true;
							}
						}
					}
				}
			});

		}

		/**
		 * Translate from axis value to pixel position on the chart, or back
		 *
		 */
		translate = function (val, backwards, cvsCoord, old, handleLog) {
			
			var sign = 1,
				cvsOffset = 0,
				localA = old ? oldTransA : transA,
				localMin = old ? oldMin : min,
				returnValue,
				postTranslate = options.ordinal || (isLog && handleLog);

			if (!localA) {
				localA = transA;
			}

			if (cvsCoord) {
				sign *= -1; // canvas coordinates inverts the value
				cvsOffset = axisLength;
			}
			if (reversed) { // reversed axis
				sign *= -1;
				cvsOffset -= sign * axisLength;
			}

			if (backwards) { // reverse translation
				if (reversed) {
					val = axisLength - val;
				}
				returnValue = val / localA + localMin; // from chart pixel to value
				if (postTranslate) { // log and ordinal axes
					returnValue = axis.lin2val(returnValue);
				}

			} else { // normal translation, from axis value to pixel, relative to plot
				if (postTranslate) { // log and ordinal axes
					val = axis.val2lin(val);
				}

				returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding);
			}

			return returnValue;
		};

		/**
		 * Create the path for a plot line that goes from the given value on
		 * this axis, across the plot to the opposite side
		 * @param {Number} value
		 * @param {Number} lineWidth Used for calculation crisp line
		 * @param {Number] old Use old coordinates (for resizing and rescaling)
		 */
		getPlotLinePath = function (value, lineWidth, old) {
			var x1,
				y1,
				x2,
				y2,
				translatedValue = translate(value, null, null, old),
				cHeight = (old && oldChartHeight) || chartHeight,
				cWidth = (old && oldChartWidth) || chartWidth,
				skip;

			x1 = x2 = mathRound(translatedValue + transB);
			y1 = y2 = mathRound(cHeight - translatedValue - transB);

			if (isNaN(translatedValue)) { // no min or max
				skip = true;

			} else if (horiz) {
				y1 = axisTop;
				y2 = cHeight - axisBottom;
				if (x1 < axisLeft || x1 > axisLeft + axisWidth) {
					skip = true;
				}
			} else {
				x1 = axisLeft;
				x2 = cWidth - axisRight;

				if (y1 < axisTop || y1 > axisTop + axisHeight) {
					skip = true;
				}
			}
			return skip ?
				null :
				renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);
		};

		/**
		 * Set the tick positions of a linear axis to round values like whole tens or every five.
		 */
		function getLinearTickPositions(tickInterval, min, max) {

			var pos,
				lastPos,
				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
				tickPositions = [];

			// Populate the intermediate values
			pos = roundedMin;
			while (pos <= roundedMax) {

				// Place the tick on the rounded value
				tickPositions.push(pos);

				// Always add the raw tickInterval, not the corrected one.
				pos = correctFloat(pos + tickInterval);

				// If the interval is not big enough in the current min - max range to actually increase
				// the loop variable, we need to break out to prevent endless loop. Issue #619
				if (pos === lastPos) {
					break;
				}

				// Record the last value
				lastPos = pos;
			}
			return tickPositions;
		}
		
		/**
		 * Set the tick positions of a logarithmic axis
		 */
		function getLogTickPositions(interval, min, max, minor) {
			
			// Since we use this method for both major and minor ticks,
			// use a local variable and return the result
			var positions = []; 
			
			// Reset
			if (!minor) {
				axis._minorAutoInterval = null;
			}
			
			// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
			if (interval >= 0.5) {
				interval = mathRound(interval);
				positions = getLinearTickPositions(interval, min, max);
				
			// Second case: We need intermediary ticks. For example 
			// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
			} else if (interval >= 0.08) {
				var roundedMin = mathFloor(min),
					intermediate,
					i,
					j,
					len,
					pos,
					lastPos,
					break2;
					
				if (interval > 0.3) {
					intermediate = [1, 2, 4];
				} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
					intermediate = [1, 2, 4, 6, 8];
				} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
					intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
				}
				
				for (i = roundedMin; i < max + 1 && !break2; i++) {
					len = intermediate.length;
					for (j = 0; j < len && !break2; j++) {
						pos = log2lin(lin2log(i) * intermediate[j]);
						
						if (pos > min) {
							positions.push(lastPos);
						}
						
						if (lastPos > max) {
							break2 = true;
						}
						lastPos = pos;
					}
				}
				
			// Third case: We are so deep in between whole logarithmic values that
			// we might as well handle the tick positions like a linear axis. For
			// example 1.01, 1.02, 1.03, 1.04.
			} else {
				var realMin = lin2log(min),
					realMax = lin2log(max),
					tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
					filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
					tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
					totalPixelLength = minor ? axisLength / tickPositions.length : axisLength;
				
				interval = pick(
					filteredTickIntervalOption,
					axis._minorAutoInterval,
					(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
				);
				
				interval = normalizeTickInterval(
					interval, 
					null, 
					math.pow(10, mathFloor(math.log(interval) / math.LN10))
				);
				
				positions = map(getLinearTickPositions(
					interval, 
					realMin,
					realMax	
				), log2lin);
				
				if (!minor) {
					axis._minorAutoInterval = interval / 5;
				}
			}
			
			// Set the axis-level tickInterval variable 
			if (!minor) {
				tickInterval = interval;
			}
			return positions;
		}
		
		/**
		 * Return the minor tick positions. For logarithmic axes, reuse the same logic
		 * as for major ticks.
		 */
		function getMinorTickPositions() {
			var minorTickPositions = [],
				pos,
				i,
				len;
			
			if (isLog) {
				len = tickPositions.length;
				for (i = 1; i < len; i++) {
					minorTickPositions = minorTickPositions.concat(
						getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
					);	
				}
			
			} else {			
				for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
					minorTickPositions.push(pos);	
				}
			}
			
			return minorTickPositions;
		}

		/**
		 * Adjust the min and max for the minimum range. Keep in mind that the series data is 
		 * not yet processed, so we don't have information on data cropping and grouping, or 
		 * updated axis.pointRange or series.pointRange. The data can't be processed until
		 * we have finally established min and max.
		 */
		function adjustForMinRange() {
			var zoomOffset,
				spaceAvailable = dataMax - dataMin >= minRange,
				closestDataRange,
				i,
				distance,
				xData,
				loopLength,
				minArgs,
				maxArgs;
				
			// Set the automatic minimum range based on the closest point distance
			if (isXAxis && minRange === UNDEFINED && !isLog) {
				
				if (defined(options.min) || defined(options.max)) {
					minRange = null; // don't do this again

				} else {

					// Find the closest distance between raw data points, as opposed to
					// closestPointRange that applies to processed points (cropped and grouped)
					each(axis.series, function (series) {
						xData = series.xData;
						loopLength = series.xIncrement ? 1 : xData.length - 1;
						for (i = loopLength; i > 0; i--) {
							distance = xData[i] - xData[i - 1];
							if (closestDataRange === UNDEFINED || distance < closestDataRange) {
								closestDataRange = distance;
							}
						}
					});
					minRange = mathMin(closestDataRange * 5, dataMax - dataMin);
				}
			}
			
			// if minRange is exceeded, adjust
			if (max - min < minRange) {

				zoomOffset = (minRange - max + min) / 2;

				// if min and max options have been set, don't go beyond it
				minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
				if (spaceAvailable) { // if space is available, stay within the data range
					minArgs[2] = dataMin;
				}
				min = arrayMax(minArgs);

				maxArgs = [min + minRange, pick(options.max, min + minRange)];
				if (spaceAvailable) { // if space is availabe, stay within the data range
					maxArgs[2] = dataMax;
				}
				
				max = arrayMin(maxArgs);

				// now if the max is adjusted, adjust the min back
				if (max - min < minRange) {
					minArgs[0] = max - minRange;
					minArgs[1] = pick(options.min, max - minRange);
					min = arrayMax(minArgs);
				}
			}
		}

		/**
		 * Set the tick positions to round values and optionally extend the extremes
		 * to the nearest tick
		 */
		function setTickPositions(secondPass) {

			var length,
				linkedParentExtremes,
				tickIntervalOption = options.tickInterval,
				tickPixelIntervalOption = options.tickPixelInterval;

			// linked axis gets the extremes from the parent axis
			if (isLinked) {
				linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];
				linkedParentExtremes = linkedParent.getExtremes();
				min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
				max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
				if (options.type !== linkedParent.options.type) {
					error(11, 1); // Can't link axes of different type
				}
			} else { // initial min and max from the extreme data values
				min = pick(userMin, options.min, dataMin);
				max = pick(userMax, options.max, dataMax);
			}

			if (isLog) {
				if (!secondPass && mathMin(min, dataMin) <= 0) {
					error(10, 1); // Can't plot negative values on log axis
				}
				min = log2lin(min);
				max = log2lin(max);
			}

			// handle zoomed range
			if (range) {
				userMin = min = mathMax(min, max - range); // #618
				userMax = max;
				if (secondPass) {
					range = null;  // don't use it when running setExtremes
				}
			}

			// adjust min and max for the minimum range
			adjustForMinRange();

			// pad the values to get clear of the chart's edges
			if (!categories && !usePercentage && !isLinked && defined(min) && defined(max)) {
				length = (max - min) || 1;
				if (!defined(options.min) && !defined(userMin) && minPadding && (dataMin < 0 || !ignoreMinPadding)) {
					min -= length * minPadding;
				}
				if (!defined(options.max) && !defined(userMax)  && maxPadding && (dataMax > 0 || !ignoreMaxPadding)) {
					max += length * maxPadding;
				}
			}

			// get tickInterval
			if (min === max || min === undefined || max === undefined) {
				tickInterval = 1;
			} else if (isLinked && !tickIntervalOption &&
					tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
				tickInterval = linkedParent.tickInterval;
			} else {
				tickInterval = pick(
					tickIntervalOption,
					categories ? // for categoried axis, 1 is default, for linear axis use tickPix
						1 :
						(max - min) * tickPixelIntervalOption / (axisLength || 1)
				);
			}

			// Now we're finished detecting min and max, crop and group series data. This
			// is in turn needed in order to find tick positions in ordinal axes. 
			if (isXAxis && !secondPass) {
				each(axis.series, function (series) {
					series.processData(min !== oldMin || max !== oldMax);             
				});
			}

			// set the translation factor used in translate function
			setAxisTranslation();

			// hook for ordinal axes. To do: merge with below
			if (axis.beforeSetTickPositions) {
				axis.beforeSetTickPositions();
			}
			
			// hook for extensions, used in Highstock ordinal axes
			if (axis.postProcessTickInterval) {
				tickInterval = axis.postProcessTickInterval(tickInterval);				
			}

			// for linear axes, get magnitude and normalize the interval
			if (!isDatetimeAxis && !isLog) { // linear
				magnitude = math.pow(10, mathFloor(math.log(tickInterval) / math.LN10));
				if (!defined(options.tickInterval)) {
					tickInterval = normalizeTickInterval(tickInterval, null, magnitude, options);
				}
			}

			// record the tick interval for linked axis
			axis.tickInterval = tickInterval;

			// get minorTickInterval
			minorTickInterval = options.minorTickInterval === 'auto' && tickInterval ?
					tickInterval / 5 : options.minorTickInterval;

			// find the tick positions
			tickPositions = options.tickPositions || (tickPositioner && tickPositioner.apply(axis, [min, max]));
			if (!tickPositions) {
				if (isDatetimeAxis) {
					tickPositions = (axis.getNonLinearTimeTicks || getTimeTicks)(
						normalizeTimeTickInterval(tickInterval, options.units),
						min,
						max,
						options.startOfWeek,
						axis.ordinalPositions,
						axis.closestPointRange,
						true
					);
				} else if (isLog) {
					tickPositions = getLogTickPositions(tickInterval, min, max);
				} else {
					tickPositions = getLinearTickPositions(tickInterval, min, max);
				}
			}

			if (!isLinked) {

				// reset min/max or remove extremes based on start/end on tick
				var roundedMin = tickPositions[0],
					roundedMax = tickPositions[tickPositions.length - 1];

				if (options.startOnTick) {
					min = roundedMin;
				} else if (min > roundedMin) {
					tickPositions.shift();
				}

				if (options.endOnTick) {
					max = roundedMax;
				} else if (max < roundedMax) {
					tickPositions.pop();
				}

				// record the greatest number of ticks for multi axis
				if (!maxTicks) { // first call, or maxTicks have been reset after a zoom operation
					maxTicks = {
						x: 0,
						y: 0
					};
				}

				if (!isDatetimeAxis && tickPositions.length > maxTicks[xOrY] && options.alignTicks !== false) {
					maxTicks[xOrY] = tickPositions.length;
				}
			}
		}

		/**
		 * When using multiple axes, adjust the number of ticks to match the highest
		 * number of ticks in that group
		 */
		function adjustTickAmount() {

			if (maxTicks && maxTicks[xOrY] && !isDatetimeAxis && !categories && !isLinked && options.alignTicks !== false) { // only apply to linear scale
				var oldTickAmount = tickAmount,
					calculatedTickAmount = tickPositions.length;

				// set the axis-level tickAmount to use below
				tickAmount = maxTicks[xOrY];

				if (calculatedTickAmount < tickAmount) {
					while (tickPositions.length < tickAmount) {
						tickPositions.push(correctFloat(
							tickPositions[tickPositions.length - 1] + tickInterval
						));
					}
					transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
					max = tickPositions[tickPositions.length - 1];

				}
				if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
					axis.isDirty = true;
				}
			}


		}

		/**
		 * Set the scale based on data min and max, user set min and max or options
		 *
		 */
		function setScale() {
			var type,
				i,
				isDirtyData,
				isDirtyAxisLength;
				
			oldMin = min;
			oldMax = max;
			oldAxisLength = axisLength;

			// set the new axisLength
			axisLength = horiz ? axisWidth : axisHeight;
			isDirtyAxisLength = axisLength !== oldAxisLength;

			// is there new data?
			each(axis.series, function (series) {
				if (series.isDirtyData || series.isDirty ||
						series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
					isDirtyData = true;
				}
			});

			// do we really need to go through all this?
			if (isDirtyAxisLength || isDirtyData || isLinked ||
				userMin !== oldUserMin || userMax !== oldUserMax) {

				// get data extremes if needed
				getSeriesExtremes();

				// get fixed positions based on tickInterval
				setTickPositions();

				// record old values to decide whether a rescale is necessary later on (#540)
				oldUserMin = userMin;
				oldUserMax = userMax;

				// reset stacks
				if (!isXAxis) {
					for (type in stacks) {
						for (i in stacks[type]) {
							stacks[type][i].cum = stacks[type][i].total;
						}
					}
				}

				// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
				if (!axis.isDirty) {
					axis.isDirty = isDirtyAxisLength || min !== oldMin || max !== oldMax;
				}
			}
		}

		/**
		 * Set the extremes and optionally redraw
		 * @param {Number} newMin
		 * @param {Number} newMax
		 * @param {Boolean} redraw
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 * @param {Object} eventArguments 
		 *
		 */
		function setExtremes(newMin, newMax, redraw, animation, eventArguments) {

			redraw = pick(redraw, true); // defaults to true
			
			// Extend the arguments with min and max
			eventArguments = extend(eventArguments, {
				min: newMin,
				max: newMax
			});

			// Fire the event
			fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

				userMin = newMin;
				userMax = newMax;
				
				// Mark for running afterSetExtremes
				axis.isDirtyExtremes = true;
				
				// redraw
				if (redraw) {
					chart.redraw(animation);
				}
			});
		}
		
		/**
		 * Update translation information
		 */
		setAxisTranslation = function () {
			var range = max - min,
				pointRange = 0,
				closestPointRange,
				seriesClosestPointRange;
			
			// adjust translation for padding
			if (isXAxis) {
				if (isLinked) {
					pointRange = linkedParent.pointRange;
				} else {
					each(axis.series, function (series) {
						pointRange = mathMax(pointRange, series.pointRange);
						seriesClosestPointRange = series.closestPointRange;
						if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
							closestPointRange = defined(closestPointRange) ?
								mathMin(closestPointRange, seriesClosestPointRange) :
								seriesClosestPointRange;
						}
					});
				}
				
				// pointRange means the width reserved for each point, like in a column chart
				axis.pointRange = pointRange;

				// closestPointRange means the closest distance between points. In columns
				// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
				// is some other value
				axis.closestPointRange = closestPointRange;
			}

			// secondary values
			oldTransA = transA;
			axis.translationSlope = transA = axisLength / ((range + pointRange) || 1);
			transB = horiz ? axisLeft : axisBottom; // translation addend
			minPixelPadding = transA * (pointRange / 2);
		};

		/**
		 * Update the axis metrics
		 */
		function setAxisSize() {

			var offsetLeft = options.offsetLeft || 0,
				offsetRight = options.offsetRight || 0;

			// basic values
			axisLeft = pick(options.left, plotLeft + offsetLeft);
			axisTop = pick(options.top, plotTop);
			axisWidth = pick(options.width, plotWidth - offsetLeft + offsetRight);
			axisHeight = pick(options.height, plotHeight);
			axisBottom = chartHeight - axisHeight - axisTop;
			axisRight = chartWidth - axisWidth - axisLeft;
			axisLength = horiz ? axisWidth : axisHeight;

			// expose to use in Series object and navigator
			axis.left = axisLeft;
			axis.top = axisTop;
			axis.len = axisLength;

		}

		/**
		 * Get the actual axis extremes
		 */
		function getExtremes() {
			return {
				min: isLog ? correctFloat(lin2log(min)) : min,
				max: isLog ? correctFloat(lin2log(max)) : max,
				dataMin: dataMin,
				dataMax: dataMax,
				userMin: userMin,
				userMax: userMax
			};
		}

		/**
		 * Get the zero plane either based on zero or on the min or max value.
		 * Used in bar and area plots
		 */
		function getThreshold(threshold) {
			var realMin = isLog ? lin2log(min) : min,
				realMax = isLog ? lin2log(max) : max;
			
			if (realMin > threshold || threshold === null) {
				threshold = realMin;
			} else if (realMax < threshold) {
				threshold = realMax;
			}

			return translate(threshold, 0, 1, 0, 1);
		}

		/**
		 * Add a plot band or plot line after render time
		 *
		 * @param options {Object} The plotBand or plotLine configuration object
		 */
		function addPlotBandOrLine(options) {
			var obj = new PlotLineOrBand(options).render();
			plotLinesAndBands.push(obj);
			return obj;
		}

		/**
		 * Render the tick labels to a preliminary position to get their sizes
		 */
		function getOffset() {

			var hasData = axis.series.length && defined(min) && defined(max),
				showAxis = hasData || pick(options.showEmpty, true),
				titleOffset = 0,
				titleOffsetOption,
				titleMargin = 0,
				axisTitleOptions = options.title,
				labelOptions = options.labels,
				directionFactor = [-1, 1, 1, -1][side],
				n;

			if (!axisGroup) {
				axisGroup = renderer.g('axis')
					.attr({ zIndex: 7 })
					.add();
				gridGroup = renderer.g('grid')
					.attr({ zIndex: options.gridZIndex || 1 })
					.add();
			}

			labelOffset = 0; // reset

			if (hasData || isLinked) {
				each(tickPositions, function (pos) {
					if (!ticks[pos]) {
						ticks[pos] = new Tick(pos);
					} else {
						ticks[pos].addLabel(); // update labels depending on tick interval
					}

				});

				each(tickPositions, function (pos) {
					// left side must be align: right and right side must have align: left for labels
					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === labelOptions.align) {

						// get the highest offset
						labelOffset = mathMax(
							ticks[pos].getLabelSize(),
							labelOffset
						);
					}

				});

				if (staggerLines) {
					labelOffset += (staggerLines - 1) * 16;
				}

			} else { // doesn't have data
				for (n in ticks) {
					ticks[n].destroy();
					delete ticks[n];
				}
			}

			if (axisTitleOptions && axisTitleOptions.text) {
				if (!axisTitle) {
					axisTitle = axis.axisTitle = renderer.text(
						axisTitleOptions.text,
						0,
						0,
						axisTitleOptions.useHTML
					)
					.attr({
						zIndex: 7,
						rotation: axisTitleOptions.rotation || 0,
						align:
							axisTitleOptions.textAlign ||
							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
					})
					.css(axisTitleOptions.style)
					.add();
					axisTitle.isNew = true;
				}

				if (showAxis) {
					titleOffset = axisTitle.getBBox()[horiz ? 'height' : 'width'];
					titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);
					titleOffsetOption = axisTitleOptions.offset;
				}

				// hide or show the title depending on whether showEmpty is set
				axisTitle[showAxis ? 'show' : 'hide']();


			}

			// handle automatic or user set offset
			offset = directionFactor * pick(options.offset, axisOffset[side]);

			axisTitleMargin =
				pick(titleOffsetOption,
					labelOffset + titleMargin +
					(side !== 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x'])
				);

			axisOffset[side] = mathMax(
				axisOffset[side],
				axisTitleMargin + titleOffset + directionFactor * offset
			);

		}

		/**
		 * Render the axis
		 */
		function render() {
			var axisTitleOptions = options.title,
				stackLabelOptions = options.stackLabels,
				alternateGridColor = options.alternateGridColor,
				lineWidth = options.lineWidth,
				lineLeft,
				lineTop,
				linePath,
				hasRendered = chart.hasRendered,
				slideInTicks = hasRendered && defined(oldMin) && !isNaN(oldMin),
				hasData = axis.series.length && defined(min) && defined(max),
				showAxis = hasData || pick(options.showEmpty, true),
				from,
				to;

			// If the series has data draw the ticks. Else only the line and title
			if (hasData || isLinked) {

				// minor ticks
				if (minorTickInterval && !categories) {
					each(getMinorTickPositions(), function (pos) {
						if (!minorTicks[pos]) {
							minorTicks[pos] = new Tick(pos, 'minor');
						}

						// render new ticks in old position
						if (slideInTicks && minorTicks[pos].isNew) {
							minorTicks[pos].render(null, true);
						}


						minorTicks[pos].isActive = true;
						minorTicks[pos].render();
					});
				}

				// Major ticks. Pull out the first item and render it last so that
				// we can get the position of the neighbour label. #808.
				each(tickPositions.slice(1).concat([tickPositions[0]]), function (pos, i) {
					
					// Reorganize the indices
					i = (i === tickPositions.length - 1) ? 0 : i + 1;
					
					// linked axes need an extra check to find out if
					if (!isLinked || (pos >= min && pos <= max)) {

						if (!ticks[pos]) {
							ticks[pos] = new Tick(pos);
						}

						// render new ticks in old position
						if (slideInTicks && ticks[pos].isNew) {
							ticks[pos].render(i, true);
						}

						ticks[pos].isActive = true;
						ticks[pos].render(i);
					}

				});

				// alternate grid color
				if (alternateGridColor) {
					each(tickPositions, function (pos, i) {
						if (i % 2 === 0 && pos < max) {
							if (!alternateBands[pos]) {
								alternateBands[pos] = new PlotLineOrBand();
							}
							from = pos;
							to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max;
							alternateBands[pos].options = {
								from: isLog ? lin2log(from) : from,
								to: isLog ? lin2log(to) : to,
								color: alternateGridColor
							};
							alternateBands[pos].render();
							alternateBands[pos].isActive = true;
						}
					});
				}

				// custom plot lines and bands
				if (!axis._addedPlotLB) { // only first time
					each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
						//plotLinesAndBands.push(new PlotLineOrBand(plotLineOptions).render());
						addPlotBandOrLine(plotLineOptions);
					});
					axis._addedPlotLB = true;
				}



			} // end if hasData

			// remove inactive ticks
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos;
				for (pos in coll) {
					if (!coll[pos].isActive) {
						coll[pos].destroy();
						delete coll[pos];
					} else {
						coll[pos].isActive = false; // reset
					}
				}
			});




			// Static items. As the axis group is cleared on subsequent calls
			// to render, these items are added outside the group.
			// axis line
			if (lineWidth) {
				lineLeft = axisLeft + (opposite ? axisWidth : 0) + offset;
				lineTop = chartHeight - axisBottom - (opposite ? axisHeight : 0) + offset;

				linePath = renderer.crispLine([
						M,
						horiz ?
							axisLeft :
							lineLeft,
						horiz ?
							lineTop :
							axisTop,
						L,
						horiz ?
							chartWidth - axisRight :
							lineLeft,
						horiz ?
							lineTop :
							chartHeight - axisBottom
					], lineWidth);
				if (!axisLine) {
					axisLine = renderer.path(linePath)
						.attr({
							stroke: options.lineColor,
							'stroke-width': lineWidth,
							zIndex: 7
						})
						.add();
				} else {
					axisLine.animate({ d: linePath });
				}

				// show or hide the line depending on options.showEmpty
				axisLine[showAxis ? 'show' : 'hide']();

			}

			if (axisTitle && showAxis) {
				// compute anchor points for each of the title align options
				var margin = horiz ? axisLeft : axisTop,
					fontSize = pInt(axisTitleOptions.style.fontSize || 12),
				// the position in the length direction of the axis
				alongAxis = {
					low: margin + (horiz ? 0 : axisLength),
					middle: margin + axisLength / 2,
					high: margin + (horiz ? axisLength : 0)
				}[axisTitleOptions.align],

				// the position in the perpendicular direction of the axis
				offAxis = (horiz ? axisTop + axisHeight : axisLeft) +
					(horiz ? 1 : -1) * // horizontal axis reverses the margin
					(opposite ? -1 : 1) * // so does opposite axes
					axisTitleMargin +
					(side === 2 ? fontSize : 0);

				axisTitle[axisTitle.isNew ? 'attr' : 'animate']({
					x: horiz ?
						alongAxis :
						offAxis + (opposite ? axisWidth : 0) + offset +
							(axisTitleOptions.x || 0), // x
					y: horiz ?
						offAxis - (opposite ? axisHeight : 0) + offset :
						alongAxis + (axisTitleOptions.y || 0) // y
				});
				axisTitle.isNew = false;
			}

			// Stacked totals:
			if (stackLabelOptions && stackLabelOptions.enabled) {
				var stackKey, oneStack, stackCategory,
					stackTotalGroup = axis.stackTotalGroup;

				// Create a separate group for the stack total labels
				if (!stackTotalGroup) {
					axis.stackTotalGroup = stackTotalGroup =
						renderer.g('stack-labels')
							.attr({
								visibility: VISIBLE,
								zIndex: 6
							})
							.translate(plotLeft, plotTop)
							.add();
				}

				// Render each stack total
				for (stackKey in stacks) {
					oneStack = stacks[stackKey];
					for (stackCategory in oneStack) {
						oneStack[stackCategory].render(stackTotalGroup);
					}
				}
			}
			// End stacked totals

			axis.isDirty = false;
		}

		/**
		 * Remove a plot band or plot line from the chart by id
		 * @param {Object} id
		 */
		function removePlotBandOrLine(id) {
			var i = plotLinesAndBands.length;
			while (i--) {
				if (plotLinesAndBands[i].id === id) {
					plotLinesAndBands[i].destroy();
				}
			}
		}
		
		/**
		 * Update the axis title by options
		 */
		function setTitle(newTitleOptions, redraw) {
			options.title = merge(options.title, newTitleOptions);
			
			axisTitle = axisTitle.destroy();
			axis.isDirty = true;
			
			if (pick(redraw, true)) {
				chart.redraw();
			}
		}

		/**
		 * Redraw the axis to reflect changes in the data or axis extremes
		 */
		function redraw() {

			// hide tooltip and hover states
			if (tracker.resetTracker) {
				tracker.resetTracker();
			}

			// render the axis
			render();

			// move plot lines and bands
			each(plotLinesAndBands, function (plotLine) {
				plotLine.render();
			});

			// mark associated series as dirty and ready for redraw
			each(axis.series, function (series) {
				series.isDirty = true;
			});

		}

		/**
		 * Set new axis categories and optionally redraw
		 * @param {Array} newCategories
		 * @param {Boolean} doRedraw
		 */
		function setCategories(newCategories, doRedraw) {
				// set the categories
				axis.categories = userOptions.categories = categories = newCategories;

				// force reindexing tooltips
				each(axis.series, function (series) {
					series.translate();
					series.setTooltipPoints(true);
				});


				// optionally redraw
				axis.isDirty = true;

				if (pick(doRedraw, true)) {
					chart.redraw();
				}
		}

		/**
		 * Destroys an Axis instance.
		 */
		function destroy() {
			var stackKey;

			// Remove the events
			removeEvent(axis);

			// Destroy each stack total
			for (stackKey in stacks) {
				destroyObjectProperties(stacks[stackKey]);

				stacks[stackKey] = null;
			}

			// Destroy stack total group
			if (axis.stackTotalGroup) {
				axis.stackTotalGroup = axis.stackTotalGroup.destroy();
			}

			// Destroy collections
			each([ticks, minorTicks, alternateBands, plotLinesAndBands], function (coll) {
				destroyObjectProperties(coll);
			});

			// Destroy local variables
			each([axisLine, axisGroup, gridGroup, axisTitle], function (obj) {
				if (obj) {
					obj.destroy();
				}
			});
			axisLine = axisGroup = gridGroup = axisTitle = null;
		}


		// Run Axis

		// Register
		axes.push(axis);
		chart[isXAxis ? 'xAxis' : 'yAxis'].push(axis);

		// inverted charts have reversed xAxes as default
		if (inverted && isXAxis && reversed === UNDEFINED) {
			reversed = true;
		}


		// expose some variables
		extend(axis, {
			addPlotBand: addPlotBandOrLine,
			addPlotLine: addPlotBandOrLine,
			adjustTickAmount: adjustTickAmount,
			categories: categories,
			getExtremes: getExtremes,
			getPlotLinePath: getPlotLinePath,
			getThreshold: getThreshold,
			isXAxis: isXAxis,
			options: options,
			plotLinesAndBands: plotLinesAndBands,
			getOffset: getOffset,
			render: render,
			setAxisSize: setAxisSize,
			setAxisTranslation: setAxisTranslation,
			setCategories: setCategories,
			setExtremes: setExtremes,
			setScale: setScale,
			setTickPositions: setTickPositions,
			translate: translate,
			redraw: redraw,
			removePlotBand: removePlotBandOrLine,
			removePlotLine: removePlotBandOrLine,
			reversed: reversed,
			setTitle: setTitle,
			series: [], // populated by Series
			stacks: stacks,
			destroy: destroy
		});

		// register event listeners
		for (eventType in events) {
			addEvent(axis, eventType, events[eventType]);
		}

		// extend logarithmic axis
		if (isLog) {
			axis.val2lin = log2lin;
			axis.lin2val = lin2log;
		}

	} // end Axis


	/**
	 * The tooltip object
	 * @param {Object} options Tooltip options
	 */
	function Tooltip(options) {
		var currentSeries,
			borderWidth = options.borderWidth,
			crosshairsOptions = options.crosshairs,
			crosshairs = [],
			style = options.style,
			shared = options.shared,
			padding = pInt(style.padding),
			tooltipIsHidden = true,
			currentX = 0,
			currentY = 0;

		// remove padding CSS and apply padding on box instead
		style.padding = 0;

		// create the label
		var label = renderer.label('', 0, 0, null, null, null, options.useHTML)
			.attr({
				padding: padding,
				fill: options.backgroundColor,
				'stroke-width': borderWidth,
				r: options.borderRadius,
				zIndex: 8
			})
			.css(style)
			.hide()
			.add();

		// When using canVG the shadow shows up as a gray circle
		// even if the tooltip is hidden.
		if (!useCanVG) {
			label.shadow(options.shadow);
		}

		/**
		 * Destroy the tooltip and its elements.
		 */
		function destroy() {
			each(crosshairs, function (crosshair) {
				if (crosshair) {
					crosshair.destroy();
				}
			});

			// Destroy and clear local variables
			if (label) {
				label = label.destroy();
			}
		}

		/**
		 * In case no user defined formatter is given, this will be used
		 */
		function defaultFormatter() {
			var pThis = this,
				items = pThis.points || splat(pThis),
				series = items[0].series,
				s;

			// build the header
			s = [series.tooltipHeaderFormatter(items[0].key)];

			// build the values
			each(items, function (item) {
				series = item.series;
				s.push((series.tooltipFormatter && series.tooltipFormatter(item)) ||
					item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
			});
			
			// footer
			s.push(options.footerFormat || '');
			
			return s.join('');
		}

		/**
		 * Provide a soft movement for the tooltip
		 *
		 * @param {Number} finalX
		 * @param {Number} finalY
		 */
		function move(finalX, finalY) {

			// get intermediate values for animation
			currentX = tooltipIsHidden ? finalX : (2 * currentX + finalX) / 3;
			currentY = tooltipIsHidden ? finalY : (currentY + finalY) / 2;
			
			// [CUSTOMIZED] forbiden annimation in IE8 or earlier.
			if (ieVersion <= 8) {
				label.attr({ x: finalX, y: currentY });
				return;
			}

			// move to the intermediate value
			label.attr({ x: currentX, y: currentY });

			// run on next tick of the mouse tracker
			if (mathAbs(finalX - currentX) > 1 || mathAbs(finalY - currentY) > 1) {
				tooltipTick = function () {
					move(finalX, finalY);
				};
			} else {
				tooltipTick = null;
			}
		}

		/**
		 * Hide the tooltip
		 */
		function hide() {
			if (!tooltipIsHidden) {
				var hoverPoints = chart.hoverPoints;

				label.hide();

				// hide previous hoverPoints and set new
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}
				chart.hoverPoints = null;


				tooltipIsHidden = true;
			}

		}

		/**
		 * Hide the crosshairs
		 */
		function hideCrosshairs() {
			each(crosshairs, function (crosshair) {
				if (crosshair) {
					crosshair.hide();
				}
			});
		}

		/**
		 * Refresh the tooltip's text and position.
		 * @param {Object} point
		 *
		 */
		function refresh(point) {
			var x,
				y,
				show,
				plotX,
				plotY,
				textConfig = {},
				text,
				pointConfig = [],
				tooltipPos = point.tooltipPos,
				formatter = options.formatter || defaultFormatter,
				hoverPoints = chart.hoverPoints,
				placedTooltipPoint,
				borderColor;

			// shared tooltip, array is sent over
			if (shared && !(point.series && point.series.noSharedTooltip)) {
				plotY = 0;

				// hide previous hoverPoints and set new
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}
				chart.hoverPoints = point;

				each(point, function (item) {
					item.setState(HOVER_STATE);
					plotY += item.plotY; // for average

					pointConfig.push(item.getLabelConfig());
				});

				plotX = point[0].plotX;
				plotY = mathRound(plotY) / point.length; // mathRound because Opera 10 has problems here

				textConfig = {
					x: point[0].category
				};
				textConfig.points = pointConfig;
				point = point[0];

			// single point tooltip
			} else {
				textConfig = point.getLabelConfig();
			}
			text = formatter.call(textConfig);

			// register the current series
			currentSeries = point.series;

			// get the reference point coordinates (pie charts use tooltipPos)
			plotX = pick(plotX, point.plotX);
			plotY = pick(plotY, point.plotY);

			x = mathRound(tooltipPos ? tooltipPos[0] : (inverted ? plotWidth - plotY : plotX));
			y = mathRound(tooltipPos ? tooltipPos[1] : (inverted ? plotHeight - plotX : plotY));


			// For line type series, hide tooltip if the point falls outside the plot
			show = shared || !currentSeries.isCartesian || currentSeries.tooltipOutsidePlot || isInsidePlot(x, y);

			// update the inner HTML
			if (text === false || !show) {
				hide();
			} else {

				// show it
				if (tooltipIsHidden) {
					label.show();
					tooltipIsHidden = false;
				}

				// update text
				label.attr({
					text: text
				});

				// set the stroke color of the box
				borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
				label.attr({
					stroke: borderColor
				});

				placedTooltipPoint = placeBox(
					label.width,
					label.height,
					plotLeft,
					plotTop,
					plotWidth,
					plotHeight,
					{x: x, y: y},
					pick(options.distance, 12),
					inverted
				);

				// do the move
				move(mathRound(placedTooltipPoint.x), mathRound(placedTooltipPoint.y));
			}


			// crosshairs
			if (crosshairsOptions) {
				crosshairsOptions = splat(crosshairsOptions); // [x, y]

				var path,
					i = crosshairsOptions.length,
					attribs,
					axis;

				while (i--) {
					axis = point.series[i ? 'yAxis' : 'xAxis'];
					if (crosshairsOptions[i] && axis) {
						path = axis.getPlotLinePath(
							i ? pick(point.stackY, point.y) : point.x, // #814 
							1
						);
						if (crosshairs[i]) {
							crosshairs[i].attr({ d: path, visibility: VISIBLE });

						} else {
							attribs = {
								'stroke-width': crosshairsOptions[i].width || 1,
								stroke: crosshairsOptions[i].color || '#C0C0C0',
								zIndex: crosshairsOptions[i].zIndex || 2
							};
							if (crosshairsOptions[i].dashStyle) {
								attribs.dashstyle = crosshairsOptions[i].dashStyle;
							}
							crosshairs[i] = renderer.path(path)
								.attr(attribs)
								.add();
						}
					}
				}
			}
			fireEvent(chart, 'tooltipRefresh', {
					text: text,
					x: x + plotLeft,
					y: y + plotTop,
					borderColor: borderColor
				});
		}



		// public members
		return {
			shared: shared,
			refresh: refresh,
			hide: hide,
			hideCrosshairs: hideCrosshairs,
			destroy: destroy
		};
	}

	/**
	 * The mouse tracker object
	 * @param {Object} options
	 */
	function MouseTracker(options) {


		var mouseDownX,
			mouseDownY,
			hasDragged,
			selectionMarker,
			zoomType = useCanVG ? '' : optionsChart.zoomType,
			zoomX = /x/.test(zoomType),
			zoomY = /y/.test(zoomType),
			zoomHor = (zoomX && !inverted) || (zoomY && inverted),
			zoomVert = (zoomY && !inverted) || (zoomX && inverted);

		/**
		 * Add crossbrowser support for chartX and chartY
		 * @param {Object} e The event object in standard browsers
		 */
		function normalizeMouseEvent(e) {
			var ePos,
				chartPosLeft,
				chartPosTop,
				chartX,
				chartY;

			// common IE normalizing
			e = e || win.event;
			if (!e.target) {
				e.target = e.srcElement;
			}

			// jQuery only copies over some properties. IE needs e.x and iOS needs touches.
			if (e.originalEvent) {
				e = e.originalEvent;
			}

			// The same for MooTools. It renames e.pageX to e.page.x. #445.
			if (e.event) {
				e = e.event;
			}

			// iOS
			ePos = e.touches ? e.touches.item(0) : e;

			// get mouse position
			chartPosition = offset(container);
			chartPosLeft = chartPosition.left;
			chartPosTop = chartPosition.top;

			// chartX and chartY
			if (isIE) { // IE including IE9 that has pageX but in a different meaning
				chartX = e.x;
				chartY = e.y;
			} else {
				chartX = ePos.pageX - chartPosLeft;
				chartY = ePos.pageY - chartPosTop;
			}

			return extend(e, {
				chartX: mathRound(chartX),
				chartY: mathRound(chartY)
			});
		}

		/**
		 * Get the click position in terms of axis values.
		 *
		 * @param {Object} e A mouse event
		 */
		function getMouseCoordinates(e) {
			var coordinates = {
				xAxis: [],
				yAxis: []
			};
			each(axes, function (axis) {
				var translate = axis.translate,
					isXAxis = axis.isXAxis,
					isHorizontal = inverted ? !isXAxis : isXAxis;

				coordinates[isXAxis ? 'xAxis' : 'yAxis'].push({
					axis: axis,
					value: translate(
						isHorizontal ?
							e.chartX - plotLeft  :
							plotHeight - e.chartY + plotTop,
						true
					)
				});
			});
			return coordinates;
		}

		/**
		 * With line type charts with a single tracker, get the point closest to the mouse
		 */
		function onmousemove(e) {
			var point,
				points,
				hoverPoint = chart.hoverPoint,
				hoverSeries = chart.hoverSeries,
				i,
				j,
				distance = chartWidth,
				index = inverted ? e.chartY : e.chartX - plotLeft; // wtf?

			// shared tooltip
			if (tooltip && options.shared && !(hoverSeries && hoverSeries.noSharedTooltip)) {
				points = [];

				// loop over all series and find the ones with points closest to the mouse
				i = series.length;
				for (j = 0; j < i; j++) {
					if (series[j].visible &&
							series[j].options.enableMouseTracking !== false &&
							!series[j].noSharedTooltip && series[j].tooltipPoints.length) {
						point = series[j].tooltipPoints[index];
						point._dist = mathAbs(index - point.plotX);
						distance = mathMin(distance, point._dist);
						points.push(point);
					}
				}
				// remove furthest points
				i = points.length;
				while (i--) {
					if (points[i]._dist > distance) {
						points.splice(i, 1);
					}
				}
				// refresh the tooltip if necessary
				if (points.length && (points[0].plotX !== hoverX)) {
					tooltip.refresh(points);
					hoverX = points[0].plotX;
				}
			}

			// separate tooltip and general mouse events
			if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker

				// get the point
				point = hoverSeries.tooltipPoints[index];

				// a new point is hovered, refresh the tooltip
				if (point && point !== hoverPoint) {

					// trigger the events
					point.onMouseOver();

				}
			}
		}



		/**
		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
		 */
		function resetTracker() {
			var hoverSeries = chart.hoverSeries,
				hoverPoint = chart.hoverPoint;

			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			if (hoverSeries) {
				hoverSeries.onMouseOut();
			}

			if (tooltip) {
				tooltip.hide();
				tooltip.hideCrosshairs();
			}

			hoverX = null;
		}

		/**
		 * Mouse up or outside the plot area
		 */
		function drop() {
			if (selectionMarker) {
				var selectionData = {
						xAxis: [],
						yAxis: []
					},
					selectionBox = selectionMarker.getBBox(),
					selectionLeft = selectionBox.x - plotLeft,
					selectionTop = selectionBox.y - plotTop;


				// a selection has been made
				if (hasDragged) {

					// record each axis' min and max
					each(axes, function (axis) {
						if (axis.options.zoomEnabled !== false) {
							var translate = axis.translate,
								isXAxis = axis.isXAxis,
								isHorizontal = inverted ? !isXAxis : isXAxis,
								selectionMin = translate(
									isHorizontal ?
										selectionLeft :
										plotHeight - selectionTop - selectionBox.height,
									true,
									0,
									0,
									1
								),
								selectionMax = translate(
									isHorizontal ?
										selectionLeft + selectionBox.width :
										plotHeight - selectionTop,
									true,
									0,
									0,
									1
								);

								selectionData[isXAxis ? 'xAxis' : 'yAxis'].push({
									axis: axis,
									min: mathMin(selectionMin, selectionMax), // for reversed axes,
									max: mathMax(selectionMin, selectionMax)
								});
						}
					});
					fireEvent(chart, 'selection', selectionData, zoom);

				}
				selectionMarker = selectionMarker.destroy();
			}

			css(container, { cursor: 'auto' });

			chart.mouseIsDown = mouseIsDown = hasDragged = false;
			removeEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);

		}

		/**
		 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
		 */
		function hideTooltipOnMouseMove(e) {
			var pageX = defined(e.pageX) ? e.pageX : e.page.x, // In mootools the event is wrapped and the page x/y position is named e.page.x
				pageY = defined(e.pageX) ? e.pageY : e.page.y; // Ref: http://mootools.net/docs/core/Types/DOMEvent

			if (chartPosition &&
					!isInsidePlot(pageX - chartPosition.left - plotLeft,
						pageY - chartPosition.top - plotTop)) {
				resetTracker();
			}
		}

		/**
		 * When mouse leaves the container, hide the tooltip.
		 */
		function hideTooltipOnMouseLeave() {
			resetTracker();
			chartPosition = null; // also reset the chart position, used in #149 fix
		}

		/**
		 * Set the JS events on the container element
		 */
		function setDOMEvents() {
			var lastWasOutsidePlot = true;
			/*
			 * Record the starting position of a dragoperation
			 */
			container.onmousedown = function (e) {
				e = normalizeMouseEvent(e);

				// issue #295, dragging not always working in Firefox
				if (!hasTouch && e.preventDefault) {
					e.preventDefault();
				}

				// record the start position
				chart.mouseIsDown = mouseIsDown = true;
				chart.mouseDownX = mouseDownX = e.chartX;
				mouseDownY = e.chartY;

				addEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
			};

			// The mousemove, touchmove and touchstart event handler
			var mouseMove = function (e) {

				// let the system handle multitouch operations like two finger scroll
				// and pinching
				if (e && e.touches && e.touches.length > 1) {
					return;
				}

				// normalize
				e = normalizeMouseEvent(e);
				if (!hasTouch) { // not for touch devices
					e.returnValue = false;
				}

				var chartX = e.chartX,
					chartY = e.chartY,
					isOutsidePlot = !isInsidePlot(chartX - plotLeft, chartY - plotTop);

				// on touch devices, only trigger click if a handler is defined
				if (hasTouch && e.type === 'touchstart') {
					if (attr(e.target, 'isTracker')) {
						if (!chart.runTrackerClick) {
							e.preventDefault();
						}
					} else if (!runChartClick && !isOutsidePlot) {
						e.preventDefault();
					}
				}

				// cancel on mouse outside
				if (isOutsidePlot) {

					/*if (!lastWasOutsidePlot) {
						// reset the tracker
						resetTracker();
					}*/

					// drop the selection if any and reset mouseIsDown and hasDragged
					//drop();
					if (chartX < plotLeft) {
						chartX = plotLeft;
					} else if (chartX > plotLeft + plotWidth) {
						chartX = plotLeft + plotWidth;
					}

					if (chartY < plotTop) {
						chartY = plotTop;
					} else if (chartY > plotTop + plotHeight) {
						chartY = plotTop + plotHeight;
					}

				}

				if (mouseIsDown && e.type !== 'touchstart') { // make selection

					// determine if the mouse has moved more than 10px
					hasDragged = Math.sqrt(
						Math.pow(mouseDownX - chartX, 2) +
						Math.pow(mouseDownY - chartY, 2)
					);
					if (hasDragged > 10) {
						var clickedInside = isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

						// make a selection
						if (hasCartesianSeries && (zoomX || zoomY) && clickedInside) {
							if (!selectionMarker) {
								selectionMarker = renderer.rect(
									plotLeft,
									plotTop,
									zoomHor ? 1 : plotWidth,
									zoomVert ? 1 : plotHeight,
									0
								)
								.attr({
									fill: optionsChart.selectionMarkerFill || 'rgba(69,114,167,0.25)',
									zIndex: 7
								})
								.add();
							}
						}

						// adjust the width of the selection marker
						if (selectionMarker && zoomHor) {
							var xSize = chartX - mouseDownX;
							selectionMarker.attr({
								width: mathAbs(xSize),
								x: (xSize > 0 ? 0 : xSize) + mouseDownX
							});
						}
						// adjust the height of the selection marker
						if (selectionMarker && zoomVert) {
							var ySize = chartY - mouseDownY;
							selectionMarker.attr({
								height: mathAbs(ySize),
								y: (ySize > 0 ? 0 : ySize) + mouseDownY
							});
						}

						// panning
						if (clickedInside && !selectionMarker && optionsChart.panning) {
							chart.pan(chartX);
						}
					}

				} else if (!isOutsidePlot) {
					// show the tooltip
					onmousemove(e);
				}

				lastWasOutsidePlot = isOutsidePlot;

				// when outside plot, allow touch-drag by returning true
				return isOutsidePlot || !hasCartesianSeries;
			};

			/*
			 * When the mouse enters the container, run mouseMove
			 */
			container.onmousemove = mouseMove;

			/*
			 * When the mouse leaves the container, hide the tracking (tooltip).
			 */
			addEvent(container, 'mouseleave', hideTooltipOnMouseLeave);

			// issue #149 workaround
			// The mouseleave event above does not always fire. Whenever the mouse is moving
			// outside the plotarea, hide the tooltip
			addEvent(doc, 'mousemove', hideTooltipOnMouseMove);

			container.ontouchstart = function (e) {
				// For touch devices, use touchmove to zoom
				if (zoomX || zoomY) {
					container.onmousedown(e);
				}
				// Show tooltip and prevent the lower mouse pseudo event
				mouseMove(e);
			};

			/*
			 * Allow dragging the finger over the chart to read the values on touch
			 * devices
			 */
			container.ontouchmove = mouseMove;

			/*
			 * Allow dragging the finger over the chart to read the values on touch
			 * devices
			 */
			container.ontouchend = function () {
				if (hasDragged) {
					resetTracker();
				}
			};


			// MooTools 1.2.3 doesn't fire this in IE when using addEvent
			container.onclick = function (e) {
				var hoverPoint = chart.hoverPoint;
				e = normalizeMouseEvent(e);

				e.cancelBubble = true; // IE specific


				if (!hasDragged) {
					
					// Detect clicks on trackers or tracker groups, #783 
					if (hoverPoint && (attr(e.target, 'isTracker') || attr(e.target.parentNode, 'isTracker'))) {
						var plotX = hoverPoint.plotX,
							plotY = hoverPoint.plotY;

						// add page position info
						extend(hoverPoint, {
							pageX: chartPosition.left + plotLeft +
								(inverted ? plotWidth - plotY : plotX),
							pageY: chartPosition.top + plotTop +
								(inverted ? plotHeight - plotX : plotY)
						});

						// the series click event
						fireEvent(hoverPoint.series, 'click', extend(e, {
							point: hoverPoint
						}));

						// the point click event
						hoverPoint.firePointEvent('click', e);

					} else {
						extend(e, getMouseCoordinates(e));

						// fire a click event in the chart
						if (isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
							fireEvent(chart, 'click', e);
						}
					}


				}
				// reset mouseIsDown and hasDragged
				hasDragged = false;
			};

		}

		/**
		 * Destroys the MouseTracker object and disconnects DOM events.
		 */
		function destroy() {
			// Destroy the tracker group element
			if (chart.trackerGroup) {
				chart.trackerGroup = trackerGroup = chart.trackerGroup.destroy();
			}

			removeEvent(container, 'mouseleave', hideTooltipOnMouseLeave);
			removeEvent(doc, 'mousemove', hideTooltipOnMouseMove);
			container.onclick = container.onmousedown = container.onmousemove = container.ontouchstart = container.ontouchend = container.ontouchmove = null;
		}

		
		// Run MouseTracker
		
		if (!trackerGroup) {
			chart.trackerGroup = trackerGroup = renderer.g('tracker')
				.attr({ zIndex: 9 })
				.add();
		}
		
		if (options.enabled) {
			chart.tooltip = tooltip = Tooltip(options);

			// set the fixed interval ticking for the smooth tooltip
			tooltipInterval = setInterval(function () {
				if (tooltipTick) {
					tooltipTick();
				}
			}, 32);
		}

		setDOMEvents();

		// expose properties
		extend(this, {
			zoomX: zoomX,
			zoomY: zoomY,
			resetTracker: resetTracker,
			normalizeMouseEvent: normalizeMouseEvent,
			destroy: destroy
		});
	}



	/**
	 * The overview of the chart's series
	 */
	var Legend = function () {

		var options = chart.options.legend;

		if (!options.enabled) {
			return;
		}

		var horizontal = options.layout === 'horizontal',
			symbolWidth = options.symbolWidth,
			symbolPadding = options.symbolPadding,
			allItems,
			style = options.style,
			itemStyle = options.itemStyle,
			itemHoverStyle = options.itemHoverStyle,
			itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle),
			padding = options.padding || pInt(style.padding),
			ltr = !options.rtl,
			itemMarginTop = options.itemMarginTop || 0,
			itemMarginBottom = options.itemMarginBottom || 0,
			y = 18,
			maxItemWidth = 0,
			initialItemX = 4 + padding + symbolWidth + symbolPadding,
			initialItemY = padding + itemMarginTop + y - 5, // 5 is the number of pixels above the text
			itemX,
			itemY,
			lastItemY,
			itemHeight = 0,
			box,
			legendBorderWidth = options.borderWidth,
			legendBackgroundColor = options.backgroundColor,
			legendGroup,
			offsetWidth,
			widthOption = options.width,
			series = chart.series,
			reversedLegend = options.reversed;



		/**
		 * Set the colors for the legend item
		 * @param {Object} item A Series or Point instance
		 * @param {Object} visible Dimmed or colored
		 */
		function colorizeItem(item, visible) {
			var legendItem = item.legendItem,
				legendLine = item.legendLine,
				legendSymbol = item.legendSymbol,
				hiddenColor = itemHiddenStyle.color,
				textColor = visible ? options.itemStyle.color : hiddenColor,
				symbolColor = visible ? item.color : hiddenColor;

			if (legendItem) {
				legendItem.css({ fill: textColor });
			}
			if (legendLine) {
				legendLine.attr({ stroke: symbolColor });
			}
			if (legendSymbol) {
				legendSymbol.attr({
					stroke: symbolColor,
					fill: symbolColor
				});
			}
		}

		/**
		 * Position the legend item
		 * @param {Object} item A Series or Point instance
		 * @param {Object} visible Dimmed or colored
		 */
		function positionItem(item) {
			var legendItem = item.legendItem,
				legendLine = item.legendLine,
				legendItemPos = item._legendItemPos,
				itemX = legendItemPos[0],
				itemY = legendItemPos[1],
				legendSymbol = item.legendSymbol,
				symbolX,
				checkbox = item.checkbox;
			
			if (legendItem) {
				legendItem.attr({
					x: ltr ? itemX : legendWidth - itemX,
					y: itemY
				});
			}
			if (legendLine) {
				legendLine.translate(
					ltr ? itemX : legendWidth - itemX,
					itemY - 4
				);
			}
			if (legendSymbol) {
				symbolX = itemX + legendSymbol.xOff;
				legendSymbol.attr({
					x: ltr ? symbolX : legendWidth - symbolX,
					y: itemY + legendSymbol.yOff
				});
			}
			if (checkbox) {
				checkbox.x = itemX;
				checkbox.y = itemY;
			}
		}

		/**
		 * Destroy a single legend item
		 * @param {Object} item The series or point
		 */
		function destroyItem(item) {
			var checkbox = item.checkbox;

			// destroy SVG elements
			each(['legendItem', 'legendLine', 'legendSymbol'], function (key) {
				if (item[key]) {
					item[key].destroy();
				}
			});

			if (checkbox) {
				discardElement(item.checkbox);
			}


		}

		/**
		 * Destroys the legend.
		 */
		function destroy() {
			if (box) {
				box = box.destroy();
			}

			if (legendGroup) {
				legendGroup = legendGroup.destroy();
			}
		}

		/**
		 * Position the checkboxes after the width is determined
		 */
		function positionCheckboxes() {
			each(allItems, function (item) {
				var checkbox = item.checkbox,
					alignAttr = legendGroup.alignAttr;
				if (checkbox) {
					css(checkbox, {
						left: (alignAttr.translateX + item.legendItemWidth + checkbox.x - 40) + PX,
						top: (alignAttr.translateY + checkbox.y - 11) + PX
					});
				}
			});
		}

		/**
		 * Render a single specific legend item
		 * @param {Object} item A series or point
		 */
		function renderItem(item) {
			var bBox,
				itemWidth,
				legendSymbol,
				symbolX,
				symbolY,
				simpleSymbol,
				radius,
				li = item.legendItem,
				series = item.series || item,
				itemOptions = series.options,
				strokeWidth = (itemOptions && itemOptions.borderWidth) || 0;


			if (!li) { // generate it once, later move it

				// let these series types use a simple symbol
				simpleSymbol = /^(bar|pie|area|column)$/.test(series.type);

				// generate the list item text
				item.legendItem = li = renderer.text(
						options.labelFormatter.call(item),
						0,
						0,
						options.useHTML
					)
					.css(item.visible ? itemStyle : itemHiddenStyle)
					.on('mouseover', function () {
						item.setState(HOVER_STATE);
						li.css(itemHoverStyle);
					})
					.on('mouseout', function () {
						li.css(item.visible ? itemStyle : itemHiddenStyle);
						item.setState();
					})
					.on('click', function () {
						var strLegendItemClick = 'legendItemClick',
							fnLegendItemClick = function () {
								item.setVisible();
							};

						// click the name or symbol
						if (item.firePointEvent) { // point
							item.firePointEvent(strLegendItemClick, null, fnLegendItemClick);
						} else {
							fireEvent(item, strLegendItemClick, null, fnLegendItemClick);
						}
					})
					.attr({
						align: ltr ? 'left' : 'right',
						zIndex: 2
					})
					.add(legendGroup);

				// draw the line
				if (!simpleSymbol && itemOptions && itemOptions.lineWidth) {
					var attrs = {
							'stroke-width': itemOptions.lineWidth,
							zIndex: 2
						};
					if (itemOptions.dashStyle) {
						attrs.dashstyle = itemOptions.dashStyle;
					}
					item.legendLine = renderer.path([
						M,
						(-symbolWidth - symbolPadding) * (ltr ? 1 : -1),
						0,
						L,
						(-symbolPadding) * (ltr ? 1 : -1),
						0
					])
					.attr(attrs)
					.add(legendGroup);
				}

				// draw a simple symbol
				if (simpleSymbol) { // bar|pie|area|column

					legendSymbol = renderer.rect(
						(symbolX = -symbolWidth - symbolPadding),
						(symbolY = -11),
						symbolWidth,
						12,
						2
					).attr({
						//'stroke-width': 0,
						zIndex: 3
					}).add(legendGroup);
					
					if (!ltr) {
						symbolX += symbolWidth;
					}
					
				} else if (itemOptions && itemOptions.marker && itemOptions.marker.enabled) { // draw the marker
					radius = itemOptions.marker.radius;
					legendSymbol = renderer.symbol(
						item.symbol,
						(symbolX = -symbolWidth / 2 - symbolPadding - radius),
						(symbolY = -4 - radius),
						2 * radius,
						2 * radius
					)
					.attr(item.pointAttr[NORMAL_STATE])
					.attr({ zIndex: 3 })
					.add(legendGroup);
					
					if (!ltr) {
						symbolX += symbolWidth / 2;
					}

				}
				if (legendSymbol) {
					
					legendSymbol.xOff = symbolX + (strokeWidth % 2 / 2);
					legendSymbol.yOff = symbolY + (strokeWidth % 2 / 2);
				}

				item.legendSymbol = legendSymbol;

				// colorize the items
				colorizeItem(item, item.visible);


				// add the HTML checkbox on top
				if (itemOptions && itemOptions.showCheckbox) {
					item.checkbox = createElement('input', {
						type: 'checkbox',
						checked: item.selected,
						defaultChecked: item.selected // required by IE7
					}, options.itemCheckboxStyle, container);

					addEvent(item.checkbox, 'click', function (event) {
						var target = event.target;
						fireEvent(item, 'checkboxClick', {
								checked: target.checked
							},
							function () {
								item.select();
							}
						);
					});
				}
			}


			// calculate the positions for the next line
			bBox = li.getBBox();

			itemWidth = item.legendItemWidth =
				options.itemWidth || symbolWidth + symbolPadding + bBox.width + padding;
			itemHeight = bBox.height;

			// if the item exceeds the width, start a new line
			if (horizontal && itemX - initialItemX + itemWidth >
					(widthOption || (chartWidth - 2 * padding - initialItemX))) {
				itemX = initialItemX;
				itemY += itemMarginTop + itemHeight + itemMarginBottom;
			}
			
			// If the item exceeds the height, start a new column
			if (!horizontal && itemY + options.y + itemHeight > chartHeight - spacingTop - spacingBottom) {
				itemY = initialItemY;
				itemX += maxItemWidth;
				maxItemWidth = 0;
			}

			// Set the edge positions
			maxItemWidth = mathMax(maxItemWidth, itemWidth);
			lastItemY = mathMax(lastItemY, itemY + itemMarginBottom);
			
			// cache the position of the newly generated or reordered items
			item._legendItemPos = [itemX, itemY];

			// advance
			if (horizontal) {
				itemX += itemWidth;
			} else {
				itemY += itemMarginTop + itemHeight + itemMarginBottom;
			}

			// the width of the widest item
			offsetWidth = widthOption || mathMax(
				(itemX - initialItemX) + (horizontal ? 0 : itemWidth),
				offsetWidth
			);

		}

		/**
		 * Render the legend. This method can be called both before and after
		 * chart.render. If called after, it will only rearrange items instead
		 * of creating new ones.
		 */
		function renderLegend() {
			itemX = initialItemX;
			itemY = initialItemY;
			offsetWidth = 0;
			lastItemY = 0;

			if (!legendGroup) {
				legendGroup = renderer.g('legend')
					// #414, #759. Trackers will be drawn above the legend, but we have 
					// to sacrifice that because tooltips need to be above the legend
					// and trackers above tooltips
					.attr({ zIndex: 7 }) 
					.add();
			}


			// add each series or point
			allItems = [];
			each(series, function (serie) {
				var seriesOptions = serie.options;

				if (!seriesOptions.showInLegend) {
					return;
				}

				// use points or series for the legend item depending on legendType
				allItems = allItems.concat(
						serie.legendItems ||
						(seriesOptions.legendType === 'point' ?
								serie.data :
								serie)
				);

			});

			// sort by legendIndex
			stableSort(allItems, function (a, b) {
				return (a.options.legendIndex || 0) - (b.options.legendIndex || 0);
			});

			// reversed legend
			if (reversedLegend) {
				allItems.reverse();
			}

			// render the items
			each(allItems, renderItem);


			// Draw the border
			legendWidth = widthOption || offsetWidth;
			legendHeight = lastItemY - y + itemHeight;

			if (legendBorderWidth || legendBackgroundColor) {
				legendWidth += 2 * padding;
				legendHeight += 2 * padding;

				if (!box) {
					box = renderer.rect(
						0,
						0,
						legendWidth,
						legendHeight,
						options.borderRadius,
						legendBorderWidth || 0
					).attr({
						stroke: options.borderColor,
						'stroke-width': legendBorderWidth || 0,
						fill: legendBackgroundColor || NONE
					})
					.add(legendGroup)
					.shadow(options.shadow);
					box.isNew = true;

				} else if (legendWidth > 0 && legendHeight > 0) {
					box[box.isNew ? 'attr' : 'animate'](
						box.crisp(null, null, null, legendWidth, legendHeight)
					);
					box.isNew = false;
				}

				// hide the border if no items
				box[allItems.length ? 'show' : 'hide']();
			}
			
			// Now that the legend width and height are extablished, put the items in the 
			// final position
			each(allItems, positionItem);

			// 1.x compatibility: positioning based on style
			var props = ['left', 'right', 'top', 'bottom'],
				prop,
				i = 4;
			while (i--) {
				prop = props[i];
				if (style[prop] && style[prop] !== 'auto') {
					options[i < 2 ? 'align' : 'verticalAlign'] = prop;
					options[i < 2 ? 'x' : 'y'] = pInt(style[prop]) * (i % 2 ? -1 : 1);
				}
			}

			if (allItems.length) {
				legendGroup.align(extend(options, {
					width: legendWidth,
					height: legendHeight
				}), true, spacingBox);
			}

			if (!isResizing) {
				positionCheckboxes();
			}
		}


		// run legend
		renderLegend();

		// move checkboxes
		addEvent(chart, 'endResize', positionCheckboxes);

		// expose
		return {
			colorizeItem: colorizeItem,
			destroyItem: destroyItem,
			renderLegend: renderLegend,
			destroy: destroy
		};
	};






	/**
	 * Initialize an individual series, called internally before render time
	 */
	function initSeries(options) {
		var type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
			typeClass = seriesTypes[type],
			serie,
			hasRendered = chart.hasRendered;

		// an inverted chart can't take a column series and vice versa
		if (hasRendered) {
			if (inverted && type === 'column') {
				typeClass = seriesTypes.bar;
			} else if (!inverted && type === 'bar') {
				typeClass = seriesTypes.column;
			}
		}

		serie = new typeClass();

		serie.init(chart, options);

		// set internal chart properties
		if (!hasRendered && serie.inverted) {
			inverted = true;
		}
		if (serie.isCartesian) {
			hasCartesianSeries = serie.isCartesian;
		}

		series.push(serie);

		return serie;
	}

	/**
	 * Add a series dynamically after  time
	 *
	 * @param {Object} options The config options
	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 * @return {Object} series The newly created series object
	 */
	function addSeries(options, redraw, animation) {
		var series;

		if (options) {
			setAnimation(animation, chart);
			redraw = pick(redraw, true); // defaults to true

			fireEvent(chart, 'addSeries', { options: options }, function () {
				series = initSeries(options);
				series.isDirty = true;

				chart.isDirtyLegend = true; // the series array is out of sync with the display
				if (redraw) {
					chart.redraw();
				}
			});
		}

		return series;
	}

	/**
	 * Check whether a given point is within the plot area
	 *
	 * @param {Number} x Pixel x relative to the plot area
	 * @param {Number} y Pixel y relative to the plot area
	 */
	isInsidePlot = function (x, y) {
		return x >= 0 &&
			x <= plotWidth &&
			y >= 0 &&
			y <= plotHeight;
	};

	/**
	 * Adjust all axes tick amounts
	 */
	function adjustTickAmounts() {
		if (optionsChart.alignTicks !== false) {
			each(axes, function (axis) {
				axis.adjustTickAmount();
			});
		}
		maxTicks = null;
	}

	/**
	 * Redraw legend, axes or series based on updated data
	 *
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	function redraw(animation) {
		var redrawLegend = chart.isDirtyLegend,
			hasStackedSeries,
			isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
			seriesLength = series.length,
			i = seriesLength,
			clipRect = chart.clipRect,
			serie;

		setAnimation(animation, chart);

		// link stacked series
		while (i--) {
			serie = series[i];
			if (serie.isDirty && serie.options.stacking) {
				hasStackedSeries = true;
				break;
			}
		}
		if (hasStackedSeries) { // mark others as dirty
			i = seriesLength;
			while (i--) {
				serie = series[i];
				if (serie.options.stacking) {
					serie.isDirty = true;
				}
			}
		}

		// handle updated data in the series
		each(series, function (serie) {
			if (serie.isDirty) { // prepare the data so axis can read it
				if (serie.options.legendType === 'point') {
					redrawLegend = true;
				}
			}
		});

		// handle added or removed series
		if (redrawLegend && legend.renderLegend) { // series or pie points are added or removed
			// draw legend graphics
			legend.renderLegend();

			chart.isDirtyLegend = false;
		}


		if (hasCartesianSeries) {
			if (!isResizing) {

				// reset maxTicks
				maxTicks = null;

				// set axes scales
				each(axes, function (axis) {
					axis.setScale();
				});
			}
			adjustTickAmounts();
			getMargins();

			// redraw axes
			each(axes, function (axis) {
				
				// Fire 'afterSetExtremes' only if extremes are set
				if (axis.isDirtyExtremes) { // #821
					axis.isDirtyExtremes = false;
					fireEvent(axis, 'afterSetExtremes', axis.getExtremes()); // #747, #751
				}
								
				if (axis.isDirty || isDirtyBox) {					
					axis.redraw();
					isDirtyBox = true; // #792
				}
			});


		}

		// the plot areas size has changed
		if (isDirtyBox) {
			drawChartBox();

			// move clip rect
			if (clipRect) {
				stop(clipRect);
				clipRect.animate({ // for chart resize
					width: chart.plotSizeX,
					height: chart.plotSizeY + 1
				});
			}

		}


		// redraw affected series
		each(series, function (serie) {
			if (serie.isDirty && serie.visible &&
					(!serie.isCartesian || serie.xAxis)) { // issue #153
				serie.redraw();
			}
		});


		// hide tooltip and hover states
		if (tracker && tracker.resetTracker) {
			tracker.resetTracker();
		}

		// redraw if canvas
		renderer.draw();

		// fire the event
		fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
	}



	/**
	 * Dim the chart and show a loading text or symbol
	 * @param {String} str An optional text to show in the loading label instead of the default one
	 */
	function showLoading(str) {
		var loadingOptions = options.loading;

		// create the layer at the first call
		if (!loadingDiv) {
			loadingDiv = createElement(DIV, {
				className: PREFIX + 'loading'
			}, extend(loadingOptions.style, {
				left: plotLeft + PX,
				top: plotTop + PX,
				width: plotWidth + PX,
				height: plotHeight + PX,
				zIndex: 10,
				display: NONE
			}), container);

			loadingSpan = createElement(
				'span',
				null,
				loadingOptions.labelStyle,
				loadingDiv
			);

		}

		// update text
		loadingSpan.innerHTML = str || options.lang.loading;

		// show it
		if (!loadingShown) {
			css(loadingDiv, { opacity: 0, display: '' });
			animate(loadingDiv, {
				opacity: loadingOptions.style.opacity
			}, {
				duration: loadingOptions.showDuration || 0
			});
			loadingShown = true;
		}
	}
	/**
	 * Hide the loading layer
	 */
	function hideLoading() {
		if (loadingDiv) {
			animate(loadingDiv, {
				opacity: 0
			}, {
				duration: options.loading.hideDuration || 100,
				complete: function () {
					css(loadingDiv, { display: NONE });
				}
			});
		}
		loadingShown = false;
	}

	/**
	 * Get an axis, series or point object by id.
	 * @param id {String} The id as given in the configuration options
	 */
	function get(id) {
		var i,
			j,
			points;

		// search axes
		for (i = 0; i < axes.length; i++) {
			if (axes[i].options.id === id) {
				return axes[i];
			}
		}

		// search series
		for (i = 0; i < series.length; i++) {
			if (series[i].options.id === id) {
				return series[i];
			}
		}

		// search points
		for (i = 0; i < series.length; i++) {
			points = series[i].points || [];
			for (j = 0; j < points.length; j++) {
				if (points[j].id === id) {
					return points[j];
				}
			}
		}
		return null;
	}

	/**
	 * Create the Axis instances based on the config options
	 */
	function getAxes() {
		var xAxisOptions = options.xAxis || {},
			yAxisOptions = options.yAxis || {},
			optionsArray,
			axis;

		// make sure the options are arrays and add some members
		xAxisOptions = splat(xAxisOptions);
		each(xAxisOptions, function (axis, i) {
			axis.index = i;
			axis.isX = true;
		});

		yAxisOptions = splat(yAxisOptions);
		each(yAxisOptions, function (axis, i) {
			axis.index = i;
		});

		// concatenate all axis options into one array
		optionsArray = xAxisOptions.concat(yAxisOptions);

		each(optionsArray, function (axisOptions) {
			axis = new Axis(axisOptions);
		});

		adjustTickAmounts();
	}


	/**
	 * Get the currently selected points from all series
	 */
	function getSelectedPoints() {
		var points = [];
		each(series, function (serie) {
			points = points.concat(grep(serie.points, function (point) {
				return point.selected;
			}));
		});
		return points;
	}

	/**
	 * Get the currently selected series
	 */
	function getSelectedSeries() {
		return grep(series, function (serie) {
			return serie.selected;
		});
	}

	/**
	 * Display the zoom button
	 */
	function showResetZoom() {
		var lang = defaultOptions.lang,
			btnOptions = optionsChart.resetZoomButton,
			theme = btnOptions.theme,
			states = theme.states,
			box = btnOptions.relativeTo === 'chart' ? null : {
				x: plotLeft,
				y: plotTop,
				width: plotWidth,
				height: plotHeight
			};
		chart.resetZoomButton = renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)
			.attr({
				align: btnOptions.position.align,
				title: lang.resetZoomTitle
			})
			.add()
			.align(btnOptions.position, false, box);
	}

	/**
	 * Zoom out to 1:1
	 */
	zoomOut = function () {
		var resetZoomButton = chart.resetZoomButton;

		fireEvent(chart, 'selection', { resetSelection: true }, zoom);
		if (resetZoomButton) {
			chart.resetZoomButton = resetZoomButton.destroy();
		}
	};
	/**
	 * Zoom into a given portion of the chart given by axis coordinates
	 * @param {Object} event
	 */
	zoom = function (event) {

		// add button to reset selection
		var hasZoomed;

		if (chart.resetZoomEnabled !== false && !chart.resetZoomButton) { // hook for Stock charts etc.
			showResetZoom();
		}

		// if zoom is called with no arguments, reset the axes
		if (!event || event.resetSelection) {
			each(axes, function (axis) {
				if (axis.options.zoomEnabled !== false) {
					axis.setExtremes(null, null, false);
					hasZoomed = true;
				}
			});
		} else { // else, zoom in on all axes
			each(event.xAxis.concat(event.yAxis), function (axisData) {
				var axis = axisData.axis;

				// don't zoom more than minRange
				if (chart.tracker[axis.isXAxis ? 'zoomX' : 'zoomY']) {
					axis.setExtremes(axisData.min, axisData.max, false);
					hasZoomed = true;
				}
			});
		}

		// Redraw
		if (hasZoomed) {
			redraw( 
				pick(optionsChart.animation, chart.pointCount < 100) // animation
			);
		}
	};

	/**
	 * Pan the chart by dragging the mouse across the pane. This function is called
	 * on mouse move, and the distance to pan is computed from chartX compared to
	 * the first chartX position in the dragging operation.
	 */
	chart.pan = function (chartX) {

		var xAxis = chart.xAxis[0],
			mouseDownX = chart.mouseDownX,
			halfPointRange = xAxis.pointRange / 2,
			extremes = xAxis.getExtremes(),
			newMin = xAxis.translate(mouseDownX - chartX, true) + halfPointRange,
			newMax = xAxis.translate(mouseDownX + plotWidth - chartX, true) - halfPointRange,
			hoverPoints = chart.hoverPoints;

		// remove active points for shared tooltip
		if (hoverPoints) {
			each(hoverPoints, function (point) {
				point.setState();
			});
		}

		if (newMin > mathMin(extremes.dataMin, extremes.min) && newMax < mathMax(extremes.dataMax, extremes.max)) {
			xAxis.setExtremes(newMin, newMax, true, false);
		}

		chart.mouseDownX = chartX; // set new reference for next run
		css(container, { cursor: 'move' });
	};

	/**
	 * Show the title and subtitle of the chart
	 *
	 * @param titleOptions {Object} New title options
	 * @param subtitleOptions {Object} New subtitle options
	 *
	 */
	function setTitle(titleOptions, subtitleOptions) {

		chartTitleOptions = merge(options.title, titleOptions);
		chartSubtitleOptions = merge(options.subtitle, subtitleOptions);

		// add title and subtitle
		each([
			['title', titleOptions, chartTitleOptions],
			['subtitle', subtitleOptions, chartSubtitleOptions]
		], function (arr) {
			var name = arr[0],
				title = chart[name],
				titleOptions = arr[1],
				chartTitleOptions = arr[2];

			if (title && titleOptions) {
				title = title.destroy(); // remove old
			}
			if (chartTitleOptions && chartTitleOptions.text && !title) {
				chart[name] = renderer.text(
					chartTitleOptions.text,
					0,
					0,
					chartTitleOptions.useHTML
				)
				.attr({
					align: chartTitleOptions.align,
					'class': PREFIX + name,
					zIndex: chartTitleOptions.zIndex || 4
				})
				.css(chartTitleOptions.style)
				.add()
				.align(chartTitleOptions, false, spacingBox);
			}
		});

	}

	/**
	 * Get chart width and height according to options and container size
	 */
	function getChartSize() {

		containerWidth = (renderToClone || renderTo).offsetWidth;
		containerHeight = (renderToClone || renderTo).offsetHeight;
		chart.chartWidth = chartWidth = optionsChart.width || containerWidth || 600;
		chart.chartHeight = chartHeight = optionsChart.height ||
			// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
			(containerHeight > 19 ? containerHeight : 400);
	}


	/**
	 * Get the containing element, determine the size and create the inner container
	 * div to hold the chart
	 */
	function getContainer() {
		renderTo = optionsChart.renderTo;
		containerId = PREFIX + idCounter++;

		if (isString(renderTo)) {
			renderTo = doc.getElementById(renderTo);
		}
		
		// Display an error if the renderTo is wrong
		if (!renderTo) {
			error(13, true);
		}

		// remove previous chart
		renderTo.innerHTML = '';

		// If the container doesn't have an offsetWidth, it has or is a child of a node
		// that has display:none. We need to temporarily move it out to a visible
		// state to determine the size, else the legend and tooltips won't render
		// properly
		if (!renderTo.offsetWidth) {
			renderToClone = renderTo.cloneNode(0);
			css(renderToClone, {
				position: ABSOLUTE,
				top: '-9999px',
				display: ''
			});
			doc.body.appendChild(renderToClone);
		}

		// get the width and height
		getChartSize();

		// create the inner container
		chart.container = container = createElement(DIV, {
				className: PREFIX + 'container' +
					(optionsChart.className ? ' ' + optionsChart.className : ''),
				id: containerId
			}, extend({
				position: RELATIVE,
				overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
					// content overflow in IE
				width: chartWidth + PX,
				height: chartHeight + PX,
				textAlign: 'left',
				lineHeight: 'normal' // #427
			}, optionsChart.style),
			renderToClone || renderTo
		);

		chart.renderer = renderer =
			optionsChart.forExport ? // force SVG, used for SVG export
				new SVGRenderer(container, chartWidth, chartHeight, true) :
				new Renderer(container, chartWidth, chartHeight);

		if (useCanVG) {
			// If we need canvg library, extend and configure the renderer
			// to get the tracker for translating mouse events
			renderer.create(chart, container, chartWidth, chartHeight);
		}

		// Issue 110 workaround:
		// In Firefox, if a div is positioned by percentage, its pixel position may land
		// between pixels. The container itself doesn't display this, but an SVG element
		// inside this container will be drawn at subpixel precision. In order to draw
		// sharp lines, this must be compensated for. This doesn't seem to work inside
		// iframes though (like in jsFiddle).
		var subPixelFix, rect;
		if (isFirefox && container.getBoundingClientRect) {
			subPixelFix = function () {
				css(container, { left: 0, top: 0 });
				rect = container.getBoundingClientRect();
				css(container, {
					left: (-(rect.left - pInt(rect.left))) + PX,
					top: (-(rect.top - pInt(rect.top))) + PX
				});
			};

			// run the fix now
			subPixelFix();

			// run it on resize
			addEvent(win, 'resize', subPixelFix);

			// remove it on chart destroy
			addEvent(chart, 'destroy', function () {
				removeEvent(win, 'resize', subPixelFix);
			});
		}
	}

	/**
	 * Calculate margins by rendering axis labels in a preliminary position. Title,
	 * subtitle and legend have already been rendered at this stage, but will be
	 * moved into their final positions
	 */
	getMargins = function () {
		var legendOptions = options.legend,
			legendMargin = pick(legendOptions.margin, 10),
			legendX = legendOptions.x,
			legendY = legendOptions.y,
			align = legendOptions.align,
			verticalAlign = legendOptions.verticalAlign,
			titleOffset;

		resetMargins();

		// adjust for title and subtitle
		if ((chart.title || chart.subtitle) && !defined(optionsMarginTop)) {
			titleOffset = mathMax(
				(chart.title && !chartTitleOptions.floating && !chartTitleOptions.verticalAlign && chartTitleOptions.y) || 0,
				(chart.subtitle && !chartSubtitleOptions.floating && !chartSubtitleOptions.verticalAlign && chartSubtitleOptions.y) || 0
			);
			if (titleOffset) {
				plotTop = mathMax(plotTop, titleOffset + pick(chartTitleOptions.margin, 15) + spacingTop);
			}
		}
		// adjust for legend
		if (legendOptions.enabled && !legendOptions.floating) {
			if (align === 'right') { // horizontal alignment handled first
				if (!defined(optionsMarginRight)) {
					marginRight = mathMax(
						marginRight,
						legendWidth - legendX + legendMargin + spacingRight
					);
				}
			} else if (align === 'left') {
				if (!defined(optionsMarginLeft)) {
					plotLeft = mathMax(
						plotLeft,
						legendWidth + legendX + legendMargin + spacingLeft
					);
				}

			} else if (verticalAlign === 'top') {
				if (!defined(optionsMarginTop)) {
					plotTop = mathMax(
						plotTop,
						legendHeight + legendY + legendMargin + spacingTop
					);
				}

			} else if (verticalAlign === 'bottom') {
				if (!defined(optionsMarginBottom)) {
					marginBottom = mathMax(
						marginBottom,
						legendHeight - legendY + legendMargin + spacingBottom
					);
				}
			}
		}

		// adjust for scroller
		if (chart.extraBottomMargin) {
			marginBottom += chart.extraBottomMargin;
		}
		if (chart.extraTopMargin) {
			plotTop += chart.extraTopMargin;
		}

		// pre-render axes to get labels offset width
		if (hasCartesianSeries) {
			each(axes, function (axis) {
				axis.getOffset();
			});
		}

		if (!defined(optionsMarginLeft)) {
			plotLeft += axisOffset[3];
		}
		if (!defined(optionsMarginTop)) {
			plotTop += axisOffset[0];
		}
		if (!defined(optionsMarginBottom)) {
			marginBottom += axisOffset[2];
		}
		if (!defined(optionsMarginRight)) {
			marginRight += axisOffset[1];
		}

		setChartSize();

	};

	/**
	 * Add the event handlers necessary for auto resizing
	 *
	 */
	function initReflow() {
		var reflowTimeout;
		function reflow(e) {
			var width = optionsChart.width || renderTo.offsetWidth,
				height = optionsChart.height || renderTo.offsetHeight,
				target = e ? e.target : win; // #805 - MooTools doesn't supply e
				
			// Width and height checks for display:none. Target is doc in IE8 and Opera,
			// win in Firefox, Chrome and IE9.
			if (width && height && (target === win || target === doc)) {
				
				if (width !== containerWidth || height !== containerHeight) {
					clearTimeout(reflowTimeout);
					reflowTimeout = setTimeout(function () {
						resize(width, height, false);
					}, 100);
				}
				containerWidth = width;
				containerHeight = height;
			}
		}
		addEvent(win, 'resize', reflow);
		addEvent(chart, 'destroy', function () {
			removeEvent(win, 'resize', reflow);
		});
	}

	/**
	 * Fires endResize event on chart instance.
	 */
	function fireEndResize() {
		if (chart) {
			fireEvent(chart, 'endResize', null, function () {
				isResizing -= 1;
			});
		}
	}

	/**
	 * Resize the chart to a given width and height
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Object|Boolean} animation
	 */
	resize = function (width, height, animation) {
        // [CUSTOMIZED]
        // chart may be destroyed when invoke resize by setTimeout
        if (!chart) {
            return;
        }
        
		var chartTitle = chart.title,
			chartSubtitle = chart.subtitle;

		isResizing += 1;

		// set the animation for the current process
		setAnimation(animation, chart);

		oldChartHeight = chartHeight;
		oldChartWidth = chartWidth;
		if (defined(width)) {
			chart.chartWidth = chartWidth = mathRound(width);
		}
		if (defined(height)) {
			chart.chartHeight = chartHeight = mathRound(height);
		}

		css(container, {
			width: chartWidth + PX,
			height: chartHeight + PX
		});
		renderer.setSize(chartWidth, chartHeight, animation);

		// update axis lengths for more correct tick intervals:
		plotWidth = chartWidth - plotLeft - marginRight;
		plotHeight = chartHeight - plotTop - marginBottom;

		// handle axes
		maxTicks = null;
		each(axes, function (axis) {
			axis.isDirty = true;
			axis.setScale();
		});

		// make sure non-cartesian series are also handled
		each(series, function (serie) {
			serie.isDirty = true;
		});

		chart.isDirtyLegend = true; // force legend redraw
		chart.isDirtyBox = true; // force redraw of plot and chart border

		getMargins();

		// move titles
		if (chartTitle) {
			chartTitle.align(null, null, spacingBox);
		}
		if (chartSubtitle) {
			chartSubtitle.align(null, null, spacingBox);
		}

		redraw(animation);


		oldChartHeight = null;
		fireEvent(chart, 'resize');

		// fire endResize and set isResizing back
		// If animation is disabled, fire without delay
		if (globalAnimation === false) {
			fireEndResize();
		} else { // else set a timeout with the animation duration
			setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
		}
	};

	/**
	 * Set the public chart properties. This is done before and after the pre-render
	 * to determine margin sizes
	 */
	setChartSize = function () {

		chart.plotLeft = plotLeft = mathRound(plotLeft);
		chart.plotTop = plotTop = mathRound(plotTop);
		chart.plotWidth = plotWidth = mathRound(chartWidth - plotLeft - marginRight);
		chart.plotHeight = plotHeight = mathRound(chartHeight - plotTop - marginBottom);

		chart.plotSizeX = inverted ? plotHeight : plotWidth;
		chart.plotSizeY = inverted ? plotWidth : plotHeight;

		spacingBox = {
			x: spacingLeft,
			y: spacingTop,
			width: chartWidth - spacingLeft - spacingRight,
			height: chartHeight - spacingTop - spacingBottom
		};

		each(axes, function (axis) {
			axis.setAxisSize();
			axis.setAxisTranslation();
		});
	};

	/**
	 * Initial margins before auto size margins are applied
	 */
	resetMargins = function () {
		plotTop = pick(optionsMarginTop, spacingTop);
		marginRight = pick(optionsMarginRight, spacingRight);
		marginBottom = pick(optionsMarginBottom, spacingBottom);
		plotLeft = pick(optionsMarginLeft, spacingLeft);
		axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
	};

	/**
	 * Draw the borders and backgrounds for chart and plot area
	 */
	drawChartBox = function () {
		var chartBorderWidth = optionsChart.borderWidth || 0,
			chartBackgroundColor = optionsChart.backgroundColor,
			plotBackgroundColor = optionsChart.plotBackgroundColor,
			plotBackgroundImage = optionsChart.plotBackgroundImage,
			mgn,
			plotSize = {
				x: plotLeft,
				y: plotTop,
				width: plotWidth,
				height: plotHeight
			};

		// Chart area
		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

		if (chartBorderWidth || chartBackgroundColor) {
			if (!chartBackground) {
				chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
						optionsChart.borderRadius, chartBorderWidth)
					.attr({
						stroke: optionsChart.borderColor,
						'stroke-width': chartBorderWidth,
						fill: chartBackgroundColor || NONE
					})
					.add()
					.shadow(optionsChart.shadow);
			} else { // resize
				chartBackground.animate(
					chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn)
				);
			}
		}


		// Plot background
		if (plotBackgroundColor) {
			if (!plotBackground) {
				plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
					.attr({
						fill: plotBackgroundColor
					})
					.add()
					.shadow(optionsChart.plotShadow);
			} else {
				plotBackground.animate(plotSize);
			}
		}
		if (plotBackgroundImage) {
			if (!plotBGImage) {
				plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
					.add();
			} else {
				plotBGImage.animate(plotSize);
			}
		}

		// Plot area border
		if (optionsChart.plotBorderWidth) {
			if (!plotBorder) {
				plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, optionsChart.plotBorderWidth)
					.attr({
						stroke: optionsChart.plotBorderColor,
						'stroke-width': optionsChart.plotBorderWidth,
						zIndex: 4
					})
					.add();
			} else {
				plotBorder.animate(
					plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight)
				);
			}
		}

		// reset
		chart.isDirtyBox = false;
	};

	/**
	 * Detect whether the chart is inverted, either by setting the chart.inverted option
	 * or adding a bar series to the configuration options
	 */
	function setInverted() {
		var BAR = 'bar',
			isInverted = (
				inverted || // it is set before
				optionsChart.inverted ||
				optionsChart.type === BAR || // default series type
				optionsChart.defaultSeriesType === BAR // backwards compatible
			),
			seriesOptions = options.series,
			i = seriesOptions && seriesOptions.length;

		// check if a bar series is present in the config options
		while (!isInverted && i--) {
			if (seriesOptions[i].type === BAR) {
				isInverted = true;
			}
		}

		// set the chart property and the chart scope variable
		chart.inverted = inverted = isInverted;
	}

	/**
	 * Render all graphics for the chart
	 */
	function render() {
		var labels = options.labels,
			credits = options.credits,
			creditsHref;

		// Title
		setTitle();


		// Legend
		legend = chart.legend = new Legend();

		// Get margins by pre-rendering axes
		// set axes scales
		each(axes, function (axis) {
			axis.setScale();
		});
		getMargins();
		each(axes, function (axis) {
			axis.setTickPositions(true); // update to reflect the new margins
		});
		adjustTickAmounts();
		getMargins(); // second pass to check for new labels


		// Draw the borders and backgrounds
		drawChartBox();

		// Axes
		if (hasCartesianSeries) {
			each(axes, function (axis) {
				axis.render();
			});
		}


		// The series
		if (!chart.seriesGroup) {
			chart.seriesGroup = renderer.g('series-group')
				.attr({ zIndex: 3 })
				.add();
		}
		each(series, function (serie) {
			serie.translate();
			serie.setTooltipPoints();
			serie.render();
		});


		// Labels
		if (labels.items) {
			each(labels.items, function () {
				var style = extend(labels.style, this.style),
					x = pInt(style.left) + plotLeft,
					y = pInt(style.top) + plotTop + 12;

				// delete to prevent rewriting in IE
				delete style.left;
				delete style.top;

				renderer.text(
					this.html,
					x,
					y
				)
				.attr({ zIndex: 2 })
				.css(style)
				.add();

			});
		}

		// Credits
		if (credits.enabled && !chart.credits) {
			creditsHref = credits.href;
			chart.credits = renderer.text(
				credits.text,
				0,
				0
			)
			.on('click', function () {
				if (creditsHref) {
					location.href = creditsHref;
				}
			})
			.attr({
				align: credits.position.align,
				zIndex: 8
			})
			.css(credits.style)
			.add()
			.align(credits.position);
		}

		// Set flag
		chart.hasRendered = true;

	}

	/**
	 * Clean up memory usage
	 */
	function destroy() {
		var i,
			parentNode = container && container.parentNode;

		// If the chart is destroyed already, do nothing.
		// This will happen if if a script invokes chart.destroy and
		// then it will be called again on win.unload
		if (chart === null) {
			return;
		}

		// fire the chart.destoy event
		fireEvent(chart, 'destroy');

		// remove events
		removeEvent(chart);

		// ==== Destroy collections:
		// Destroy axes
		i = axes.length;
		while (i--) {
			axes[i] = axes[i].destroy();
		}

		// Destroy each series
		i = series.length;
		while (i--) {
			series[i] = series[i].destroy();
		}

		// ==== Destroy chart properties:
		each(['title', 'subtitle', 'seriesGroup', 'clipRect', 'credits', 'tracker', 'scroller', 'rangeSelector'], function (name) {
			var prop = chart[name];

			if (prop) {
				chart[name] = prop.destroy();
			}
		});

		// ==== Destroy local variables:
		each([chartBackground, plotBorder, plotBackground, legend, tooltip, renderer, tracker], function (obj) {
			if (obj && obj.destroy) {
				obj.destroy();
			}
		});
		chartBackground = plotBorder = plotBackground = legend = tooltip = renderer = tracker = null;

		// remove container and all SVG
		if (container) { // can break in IE when destroyed before finished loading
			container.innerHTML = '';
			removeEvent(container);
			if (parentNode) {
				discardElement(container);
			}

			// IE6 leak
			container = null;
		}

		// memory and CPU leak
		clearInterval(tooltipInterval);

		// clean it all up
		for (i in chart) {
			delete chart[i];
		}

		chart = null;
		options = null;
	}
	/**
	 * Prepare for first rendering after all data are loaded
	 */
	function firstRender() {
		// VML namespaces can't be added until after complete. Listening
		// for Perini's doScroll hack is not enough.
		var ONREADYSTATECHANGE = 'onreadystatechange',
		COMPLETE = 'complete';
		// Note: in spite of JSLint's complaints, win == win.top is required
		/*jslint eqeq: true*/
		if ((!hasSVG && (win == win.top && doc.readyState !== COMPLETE)) || (useCanVG && !win.canvg)) {
		/*jslint eqeq: false*/
			if (useCanVG) {
				// Delay rendering until canvg library is downloaded and ready
				CanVGController.push(firstRender, options.global.canvasToolsURL);
			} else {
				doc.attachEvent(ONREADYSTATECHANGE, function () {
					doc.detachEvent(ONREADYSTATECHANGE, firstRender);
					if (doc.readyState === COMPLETE) {
						firstRender();
					}
				});
			}
			return;
		}

		// create the container
		getContainer();

		// Run an early event after the container and renderer are established
		fireEvent(chart, 'init');

		// Initialize range selector for stock charts
		if (Highcharts.RangeSelector && options.rangeSelector.enabled) {
			chart.rangeSelector = new Highcharts.RangeSelector(chart);
		}

		resetMargins();
		setChartSize();

		// Set the common inversion and transformation for inverted series after initSeries
		setInverted();

		// get axes
		getAxes();

		// Initialize the series
		each(options.series || [], function (serieOptions) {
			initSeries(serieOptions);
		});

		// Run an event where series and axes can be added
		//fireEvent(chart, 'beforeRender');

		// Initialize scroller for stock charts
		if (Highcharts.Scroller && (options.navigator.enabled || options.scrollbar.enabled)) {
			chart.scroller = new Highcharts.Scroller(chart);
		}

		chart.render = render;

		// depends on inverted and on margins being set
		chart.tracker = tracker = new MouseTracker(options.tooltip);


		render();

		// add canvas
		renderer.draw();
		// run callbacks
		if (callback) {
			callback.apply(chart, [chart]);
		}
		each(chart.callbacks, function (fn) {
			fn.apply(chart, [chart]);
		});
		
		
		// If the chart was rendered outside the top container, put it back in
		if (renderToClone) {
			renderTo.appendChild(container);
			discardElement(renderToClone);
		}

		fireEvent(chart, 'load');

	}

	// Run chart

	// Set up auto resize
	if (optionsChart.reflow !== false) {
		addEvent(chart, 'load', initReflow);
	}

	// Chart event handlers
	if (chartEvents) {
		for (eventType in chartEvents) {
			addEvent(chart, eventType, chartEvents[eventType]);
		}
	}


	chart.options = options;
	chart.series = series;


	chart.xAxis = [];
	chart.yAxis = [];




	// Expose methods and variables
	chart.addSeries = addSeries;
	chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
	chart.Axis = Axis;
	chart.destroy = destroy;
	chart.get = get;
	chart.getSelectedPoints = getSelectedPoints;
	chart.getSelectedSeries = getSelectedSeries;
	chart.hideLoading = hideLoading;
	chart.initSeries = initSeries;
	chart.isInsidePlot = isInsidePlot;
	chart.redraw = redraw;
	chart.setSize = resize;
	chart.setTitle = setTitle;
	chart.showLoading = showLoading;
	chart.pointCount = 0;
	chart.counters = new ChartCounters();
	/*
	if ($) $(function () {
		$container = $('#container');
		var origChartWidth,
			origChartHeight;
		if ($container) {
			$('<button>+</button>')
				.insertBefore($container)
				.click(function () {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(chartWidth *= 1.1, chartHeight *= 1.1);
				});
			$('<button>-</button>')
				.insertBefore($container)
				.click(function () {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(chartWidth *= 0.9, chartHeight *= 0.9);
				});
			$('<button>1:1</button>')
				.insertBefore($container)
				.click(function () {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(origChartWidth, origChartHeight);
				});
		}
	})
	*/




	firstRender();


} // end Chart

// Hook for exporting module
Chart.prototype.callbacks = [];
/**
 * The Point object and prototype. Inheritable and used as base for PiePoint
 */
var Point = function () {};
Point.prototype = {

	/**
	 * Initialize the point
	 * @param {Object} series The series object containing this point
	 * @param {Object} options The data in either number, array or object format
	 */
	init: function (series, options, x) {
		var point = this,
			counters = series.chart.counters,
			defaultColors;
		point.series = series;
		point.applyOptions(options, x);
		point.pointAttr = {};

		if (series.options.colorByPoint) {
			defaultColors = series.chart.options.colors;
			if (!point.options) {
				point.options = {};
			}
			point.color = point.options.color = point.color || defaultColors[counters.color++];

			// loop back to zero
			counters.wrapColor(defaultColors.length);
		}

		series.chart.pointCount++;
		return point;
	},
	/**
	 * Apply the options containing the x and y data and possible some extra properties.
	 * This is called on point init or from point.update.
	 *
	 * @param {Object} options
	 */
	applyOptions: function (options, x) {
		var point = this,
			series = point.series,
			optionsType = typeof options;

		point.config = options;

		// onedimensional array input
		if (optionsType === 'number' || options === null) {
			point.y = options;
		} else if (typeof options[0] === 'number') { // two-dimentional array
			point.x = options[0];
			point.y = options[1];
		} else if (optionsType === 'object' && typeof options.length !== 'number') { // object input
			// copy options directly to point
			extend(point, options);
			point.options = options;
			
			// This is the fastest way to detect if there are individual point dataLabels that need 
			// to be considered in drawDataLabels. These can only occur in object configs.
			if (options.dataLabels) {
				series._hasPointLabels = true;
			}
		} else if (typeof options[0] === 'string') { // categorized data with name in first position
			point.name = options[0];
			point.y = options[1];
		}
		
		/*
		 * If no x is set by now, get auto incremented value. All points must have an
		 * x value, however the y value can be null to create a gap in the series
		 */
		// todo: skip this? It is only used in applyOptions, in translate it should not be used
		if (point.x === UNDEFINED) {
			point.x = x === UNDEFINED ? series.autoIncrement() : x;
		}
		
		

	},

	/**
	 * Destroy a point to clear memory. Its reference still stays in series.data.
	 */
	destroy: function () {
		var point = this,
			series = point.series,
			hoverPoints = series.chart.hoverPoints,
			prop;

		series.chart.pointCount--;

		if (hoverPoints) {
			point.setState();
			erase(hoverPoints, point);
		}
		if (point === series.chart.hoverPoint) {
			point.onMouseOut();
		}
		series.chart.hoverPoints = null;

		// remove all events
		if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
			removeEvent(point);
			point.destroyElements();
		}

		if (point.legendItem) { // pies have legend items
			point.series.chart.legend.destroyItem(point);
		}

		for (prop in point) {
			point[prop] = null;
		}


	},

	/**
	 * Destroy SVG elements associated with the point
	 */
	destroyElements: function () {
		var point = this,
			props = ['graphic', 'tracker', 'dataLabel', 'group', 'connector', 'shadowGroup'],
			prop,
			i = 6;
		while (i--) {
			prop = props[i];
			if (point[prop]) {
				point[prop] = point[prop].destroy();
			}
		}
	},

	/**
	 * Return the configuration hash needed for the data label and tooltip formatters
	 */
	getLabelConfig: function () {
		var point = this;
		return {
			x: point.category,
			y: point.y,
			key: point.name || point.category,
			series: point.series,
			point: point,
			percentage: point.percentage,
			total: point.total || point.stackTotal
		};
	},

	/**
	 * Toggle the selection status of a point
	 * @param {Boolean} selected Whether to select or unselect the point.
	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
	 *     this happens if the control key (Cmd on Mac) was pressed during clicking.
	 */
	select: function (selected, accumulate) {
		var point = this,
			series = point.series,
			chart = series.chart;

		selected = pick(selected, !point.selected);

		// fire the event with the defalut handler
		point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
			point.selected = selected;
			point.setState(selected && SELECT_STATE);

			// unselect all other points unless Ctrl or Cmd + click
			if (!accumulate) {
				each(chart.getSelectedPoints(), function (loopPoint) {
					if (loopPoint.selected && loopPoint !== point) {
						loopPoint.selected = false;
						loopPoint.setState(NORMAL_STATE);
						loopPoint.firePointEvent('unselect');
					}
				});
			}
		});
	},

	onMouseOver: function () {
		var point = this,
			series = point.series,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		// set normal state to previous series
		if (hoverPoint && hoverPoint !== point) {
			hoverPoint.onMouseOut();
		}

		// trigger the event
		point.firePointEvent('mouseOver');

		// update the tooltip
		if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
			tooltip.refresh(point);
		}

		// hover this
		point.setState(HOVER_STATE);
		chart.hoverPoint = point;
	},

	onMouseOut: function () {
		var point = this;
		point.firePointEvent('mouseOut');

		point.setState();
		point.series.chart.hoverPoint = null;
	},

	/**
	 * Extendable method for formatting each point's tooltip line
	 *
	 * @return {String} A string to be concatenated in to the common tooltip text
	 */
	tooltipFormatter: function (pointFormat) {
		var point = this,
			series = point.series,
			seriesTooltipOptions = series.tooltipOptions,
			split = String(point.y).split('.'),
			originalDecimals = split[1] ? split[1].length : 0,
			match = pointFormat.match(/\{(series|point)\.[a-zA-Z]+\}/g),
			splitter = /[{\.}]/,
			obj,
			key,
			replacement,
			parts,
			prop,
			i;

		// loop over the variables defined on the form {series.name}, {point.y} etc
		for (i in match) {
			key = match[i];
			if (isString(key) && key !== pointFormat) { // IE matches more than just the variables
				
				// Split it further into parts
				parts = (' ' + key).split(splitter); // add empty string because IE and the rest handles it differently
				obj = { 'point': point, 'series': series }[parts[1]];
				prop = parts[2];
				
				// Add some preformatting
				if (obj === point && (prop === 'y' || prop === 'open' || prop === 'high' || 
						prop === 'low' || prop === 'close')) { 
					replacement = (seriesTooltipOptions.valuePrefix || seriesTooltipOptions.yPrefix || '') + 
						numberFormat(point[prop], pick(seriesTooltipOptions.valueDecimals, seriesTooltipOptions.yDecimals, originalDecimals)) +
						(seriesTooltipOptions.valueSuffix || seriesTooltipOptions.ySuffix || '');
				
				// Automatic replacement
				} else {
					replacement = obj[prop];
				}
				
				pointFormat = pointFormat.replace(key, replacement);
			}
		}
		
		return pointFormat;
	},

	/**
	 * Update the point with new options (typically x/y data) and optionally redraw the series.
	 *
	 * @param {Object} options Point options as defined in the series.data array
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 */
	update: function (options, redraw, animation) {
		var point = this,
			series = point.series,
			graphic = point.graphic,
			i,
			data = series.data,
			dataLength = data.length,
			chart = series.chart;

		redraw = pick(redraw, true);

		// fire the event with a default handler of doing the update
		point.firePointEvent('update', { options: options }, function () {

			point.applyOptions(options);

			// update visuals
			if (isObject(options)) {
				series.getAttribs();
				if (graphic) {
					graphic.attr(point.pointAttr[series.state]);
				}
			}

			// record changes in the parallel arrays
			for (i = 0; i < dataLength; i++) {
				if (data[i] === point) {
					series.xData[i] = point.x;
					series.yData[i] = point.y;
					series.options.data[i] = options;
					break;
				}
			}

			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				chart.redraw(animation);
			}
		});
	},

	/**
	 * Remove a point and optionally redraw the series and if necessary the axes
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	remove: function (redraw, animation) {
		var point = this,
			series = point.series,
			chart = series.chart,
			i,
			data = series.data,
			dataLength = data.length;

		setAnimation(animation, chart);
		redraw = pick(redraw, true);

		// fire the event with a default handler of removing the point
		point.firePointEvent('remove', null, function () {

			//erase(series.data, point);

			for (i = 0; i < dataLength; i++) {
				if (data[i] === point) {

					// splice all the parallel arrays
					data.splice(i, 1);
					series.options.data.splice(i, 1);
					series.xData.splice(i, 1);
					series.yData.splice(i, 1);
					break;
				}
			}

			point.destroy();


			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				chart.redraw();
			}
		});


	},

	/**
	 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
	 * causes a name clash in MooTools
	 * @param {String} eventType
	 * @param {Object} eventArgs Additional event arguments
	 * @param {Function} defaultFunction Default event handler
	 */
	firePointEvent: function (eventType, eventArgs, defaultFunction) {
		var point = this,
			series = this.series,
			seriesOptions = series.options;

		// load event handlers on demand to save time on mouseover/out
		if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
			this.importEvents();
		}

		// add default handler if in selection mode
		if (eventType === 'click' && seriesOptions.allowPointSelect) {
			defaultFunction = function (event) {
				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
				point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
			};
		}

		fireEvent(this, eventType, eventArgs, defaultFunction);
	},
	/**
	 * Import events from the series' and point's options. Only do it on
	 * demand, to save processing time on hovering.
	 */
	importEvents: function () {
		if (!this.hasImportedEvents) {
			var point = this,
				options = merge(point.series.options.point, point.options),
				events = options.events,
				eventType;

			point.events = events;

			for (eventType in events) {
				addEvent(point, eventType, events[eventType]);
			}
			this.hasImportedEvents = true;

		}
	},

	/**
	 * Set the point's state
	 * @param {String} state
	 */
	setState: function (state) {
		var point = this,
			plotX = point.plotX,
			plotY = point.plotY,
			series = point.series,
			stateOptions = series.options.states,
			markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
			normalDisabled = markerOptions && !markerOptions.enabled,
			markerStateOptions = markerOptions && markerOptions.states[state],
			stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
			stateMarkerGraphic = series.stateMarkerGraphic,
			chart = series.chart,
			radius,
			pointAttr = point.pointAttr;

		state = state || NORMAL_STATE; // empty string

		if (
				// already has this state
				state === point.state ||
				// selected points don't respond to hover
				(point.selected && state !== SELECT_STATE) ||
				// series' state options is disabled
				(stateOptions[state] && stateOptions[state].enabled === false) ||
				// point marker's state options is disabled
				(state && (stateDisabled || (normalDisabled && !markerStateOptions.enabled)))

			) {
			return;
		}

		// apply hover styles to the existing point
		if (point.graphic) {
			radius = markerOptions && point.graphic.symbolName && pointAttr[state].r;
			point.graphic.attr(merge(
				pointAttr[state],
				radius ? { // new symbol attributes (#507, #612)
					x: plotX - radius,
					y: plotY - radius,
					width: 2 * radius,
					height: 2 * radius
				} : {}
			));
		} else {
			// if a graphic is not applied to each point in the normal state, create a shared
			// graphic for the hover state
			if (state) {
				if (!stateMarkerGraphic) {
					radius = markerOptions.radius;
					series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
						series.symbol,
						-radius,
						-radius,
						2 * radius,
						2 * radius
					)
					.attr(pointAttr[state])
					.add(series.group);
				}

				stateMarkerGraphic.translate(
					plotX,
					plotY
				);
			}

			if (stateMarkerGraphic) {
				stateMarkerGraphic[state ? 'show' : 'hide']();
			}
		}

		point.state = state;
	}
};

/**
 * @classDescription The base function which all other series types inherit from. The data in the series is stored
 * in various arrays.
 *
 * - First, series.options.data contains all the original config options for
 * each point whether added by options or methods like series.addPoint.
 * - Next, series.data contains those values converted to points, but in case the series data length
 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
 * only contains the points that have been created on demand.
 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
 * compared to series.data and series.options.data. If however the series data is grouped, these can't
 * be correlated one to one.
 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
 *
 * @param {Object} chart
 * @param {Object} options
 */
var Series = function () {};

Series.prototype = {

	isCartesian: true,
	type: 'line',
	pointClass: Point,
	sorted: true, // requires the data to be sorted
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'lineColor',
		'stroke-width': 'lineWidth',
		fill: 'fillColor',
		r: 'radius'
	},
	init: function (chart, options) {
		var series = this,
			eventType,
			events,
			//pointEvent,
			index = chart.series.length;

		series.chart = chart;
		series.options = options = series.setOptions(options); // merge with plotOptions
		
		// bind the axes
		series.bindAxes();

		// set some variables
		extend(series, {
			index: index,
			name: options.name || 'Series ' + (index + 1),
			state: NORMAL_STATE,
			pointAttr: {},
			visible: options.visible !== false, // true by default
			selected: options.selected === true // false by default
		});
		
		// special
		if (useCanVG) {
			options.animation = false;
		}

		// register event listeners
		events = options.events;
		for (eventType in events) {
			addEvent(series, eventType, events[eventType]);
		}
		if (
			(events && events.click) ||
			(options.point && options.point.events && options.point.events.click) ||
			options.allowPointSelect
		) {
			chart.runTrackerClick = true;
		}

		series.getColor();
		series.getSymbol();

		// set the data
		series.setData(options.data, false);

	},
	
	
	
	/**
	 * Set the xAxis and yAxis properties of cartesian series, and register the series
	 * in the axis.series array
	 */
	bindAxes: function () {
		var series = this,
			seriesOptions = series.options,
			chart = series.chart,
			axisOptions;
			
		if (series.isCartesian) {
			
			each(['xAxis', 'yAxis'], function (AXIS) { // repeat for xAxis and yAxis
				
				each(chart[AXIS], function (axis) { // loop through the chart's axis objects
					
					axisOptions = axis.options;
					
					// apply if the series xAxis or yAxis option mathches the number of the 
					// axis, or if undefined, use the first axis
					if ((seriesOptions[AXIS] === axisOptions.index) ||
							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {
						
						// register this series in the axis.series lookup
						axis.series.push(series);
						
						// set this series.xAxis or series.yAxis reference
						series[AXIS] = axis;
						
						// mark dirty for redraw
						axis.isDirty = true;
					}
				});
				
			});
		}
	},


	/**
	 * Return an auto incremented x value based on the pointStart and pointInterval options.
	 * This is only used if an x value is not given for the point that calls autoIncrement.
	 */
	autoIncrement: function () {
		var series = this,
			options = series.options,
			xIncrement = series.xIncrement;

		xIncrement = pick(xIncrement, options.pointStart, 0);

		series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);

		series.xIncrement = xIncrement + series.pointInterval;
		return xIncrement;
	},

	/**
	 * Divide the series data into segments divided by null values.
	 */
	getSegments: function () {
		var series = this,
			lastNull = -1,
			segments = [],
			i,
			points = series.points,
			pointsLength = points.length;

		if (pointsLength) { // no action required for []
			
			// if connect nulls, just remove null points
			if (series.options.connectNulls) {
				i = pointsLength;
				while (i--) {
					if (points[i].y === null) {
						points.splice(i, 1);
					}
				}
				if (points.length) {
					segments = [points];
				}
				
			// else, split on null points
			} else {
				each(points, function (point, i) {
					if (point.y === null) {
						if (i > lastNull + 1) {
							segments.push(points.slice(lastNull + 1, i));
						}
						lastNull = i;
					} else if (i === pointsLength - 1) { // last value
						segments.push(points.slice(lastNull + 1, i + 1));
					}
				});
			}
		}
		
		// register it
		series.segments = segments;
	},
	/**
	 * Set the series options by merging from the options tree
	 * @param {Object} itemOptions
	 */
	setOptions: function (itemOptions) {
		var series = this,
			chart = series.chart,
			chartOptions = chart.options,
			plotOptions = chartOptions.plotOptions,
			data = itemOptions.data,
			options;

		itemOptions.data = null; // remove from merge to prevent looping over the data set

		options = merge(
			plotOptions[this.type],
			plotOptions.series,
			itemOptions
		);
		
		// Re-insert the data array to the options and the original config (#717)
		options.data = itemOptions.data = data;
		
		// the tooltip options are merged between global and series specific options
		series.tooltipOptions = merge(chartOptions.tooltip, options.tooltip);
		
		return options;

	},
	/**
	 * Get the series' color
	 */
	getColor: function () {
		var defaultColors = this.chart.options.colors,
			counters = this.chart.counters;
		this.color = this.options.color || defaultColors[counters.color++] || '#0000ff';
		counters.wrapColor(defaultColors.length);
	},
	/**
	 * Get the series' symbol
	 */
	getSymbol: function () {
		var series = this,
			seriesMarkerOption = series.options.marker,
			chart = series.chart,
			defaultSymbols = chart.options.symbols,
			counters = chart.counters;
		series.symbol = seriesMarkerOption.symbol || defaultSymbols[counters.symbol++];
		
		// don't substract radius in image symbols (#604)
		if (/^url/.test(series.symbol)) {
			seriesMarkerOption.radius = 0;
		}
		counters.wrapSymbol(defaultSymbols.length);
	},

	/**
	 * Add a point dynamically after chart load time
	 * @param {Object} options Point options as given in series.data
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean} shift If shift is true, a point is shifted off the start
	 *    of the series as one is appended to the end.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	addPoint: function (options, redraw, shift, animation) {
		var series = this,
			data = series.data,
			graph = series.graph,
			area = series.area,
			chart = series.chart,
			xData = series.xData,
			yData = series.yData,
			currentShift = (graph && graph.shift) || 0,
			dataOptions = series.options.data,
			point;
			//point = (new series.pointClass()).init(series, options);

		setAnimation(animation, chart);

		// Make graph animate sideways
		if (graph && shift) { 
			graph.shift = currentShift + 1;
		}
		if (area) {
			if (shift) { // #780
				area.shift = currentShift + 1;
			}
			area.isArea = true; // needed in animation, both with and without shift
		}
		
		// Optional redraw, defaults to true
		redraw = pick(redraw, true);

		// Get options and push the point to xData, yData and series.options. In series.generatePoints
		// the Point instance will be created on demand and pushed to the series.data array.
		point = { series: series };
		series.pointClass.prototype.applyOptions.apply(point, [options]);
		xData.push(point.x);
		yData.push(series.valueCount === 4 ? [point.open, point.high, point.low, point.close] : point.y);
		dataOptions.push(options);


		// Shift the first point off the parallel arrays
		// todo: consider series.removePoint(i) method
		if (shift) {
			if (data[0] && data[0].remove) {
				data[0].remove(false);
			} else {
				data.shift();
				xData.shift();
				yData.shift();
				dataOptions.shift();
			}
		}
		series.getAttribs();

		// redraw
		series.isDirty = true;
		series.isDirtyData = true;
		if (redraw) {
			chart.redraw();
		}
	},

	/**
	 * Replace the series data with a new set of data
	 * @param {Object} data
	 * @param {Object} redraw
	 */
	setData: function (data, redraw) {
		var series = this,
			oldData = series.points,
			options = series.options,
			initialColor = series.initialColor,
			chart = series.chart,
			firstPoint = null,
			i;

		// reset properties
		series.xIncrement = null;
		series.pointRange = (series.xAxis && series.xAxis.categories && 1) || options.pointRange;
		
		if (defined(initialColor)) { // reset colors for pie
			chart.counters.color = initialColor;
		}
		
		// parallel arrays
		var xData = [],
			yData = [],
			dataLength = data ? data.length : [],
			turboThreshold = options.turboThreshold || 1000,
			pt,
			ohlc = series.valueCount === 4;

		// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
		// first value is tested, and we assume that all the rest are defined the same
		// way. Although the 'for' loops are similar, they are repeated inside each
		// if-else conditional for max performance.
		if (dataLength > turboThreshold) {
			
			// find the first non-null point
			i = 0;
			while (firstPoint === null && i < dataLength) {
				firstPoint = data[i];
				i++;
			}
		
		
			if (isNumber(firstPoint)) { // assume all points are numbers
				var x = pick(options.pointStart, 0),
					pointInterval = pick(options.pointInterval, 1);

				for (i = 0; i < dataLength; i++) {
					xData[i] = x;
					yData[i] = data[i];
					x += pointInterval;
				}
				series.xIncrement = x;
			} else if (isArray(firstPoint)) { // assume all points are arrays
				if (ohlc) { // [x, o, h, l, c]
					for (i = 0; i < dataLength; i++) {
						pt = data[i];
						xData[i] = pt[0];
						yData[i] = pt.slice(1, 5);
					}
				} else { // [x, y]
					for (i = 0; i < dataLength; i++) {
						pt = data[i];
						xData[i] = pt[0];
						yData[i] = pt[1];
					}
				}
			} /* else {
				error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
			}*/
		} else {
			for (i = 0; i < dataLength; i++) {
				pt = { series: series };
				series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
				xData[i] = pt.x;
				yData[i] = ohlc ? [pt.open, pt.high, pt.low, pt.close] : pt.y;
			}
		}

		series.data = [];
		series.options.data = data;
		series.xData = xData;
		series.yData = yData;

		// destroy old points
		i = (oldData && oldData.length) || 0;
		while (i--) {
			if (oldData[i] && oldData[i].destroy) {
				oldData[i].destroy();
			}
		}

		// redraw
		series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
		if (pick(redraw, true)) {
			chart.redraw(false);
		}
	},

	/**
	 * Remove a series and optionally redraw the chart
	 *
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */

	remove: function (redraw, animation) {
		var series = this,
			chart = series.chart;
		redraw = pick(redraw, true);

		if (!series.isRemoving) {  /* prevent triggering native event in jQuery
				(calling the remove function from the remove event) */
			series.isRemoving = true;

			// fire the event with a default handler of removing the point
			fireEvent(series, 'remove', null, function () {


				// destroy elements
				series.destroy();


				// redraw
				chart.isDirtyLegend = chart.isDirtyBox = true;
				if (redraw) {
					chart.redraw(animation);
				}
			});

		}
		series.isRemoving = false;
	},

	/**
	 * Process the data by cropping away unused data points if the series is longer
	 * than the crop threshold. This saves computing time for lage series.
	 */
	processData: function (force) {
		var series = this,
			processedXData = series.xData, // copied during slice operation below
			processedYData = series.yData,
			dataLength = processedXData.length,
			cropStart = 0,
			cropEnd = dataLength,
			cropped,
			distance,
			closestPointRange,
			xAxis = series.xAxis,
			i, // loop variable
			options = series.options,
			cropThreshold = options.cropThreshold,
			isCartesian = series.isCartesian;

		// If the series data or axes haven't changed, don't go through this. Return false to pass
		// the message on to override methods like in data grouping. 
		if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
			return false;
		}

		// optionally filter out points outside the plot area
		if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
			var extremes = xAxis.getExtremes(),
				min = extremes.min,
				max = extremes.max;

			// it's outside current extremes
			if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
				processedXData = [];
				processedYData = [];
			
			// only crop if it's actually spilling out
			} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {

				// iterate up to find slice start
				for (i = 0; i < dataLength; i++) {
					if (processedXData[i] >= min) {
						cropStart = mathMax(0, i - 1);
						break;
					}
				}
				// proceed to find slice end
				for (; i < dataLength; i++) {
					if (processedXData[i] > max) {
						cropEnd = i + 1;
						break;
					}
					
				}
				processedXData = processedXData.slice(cropStart, cropEnd);
				processedYData = processedYData.slice(cropStart, cropEnd);
				cropped = true;
			}
		}
		
		
		// Find the closest distance between processed points
		for (i = processedXData.length - 1; i > 0; i--) {
			distance = processedXData[i] - processedXData[i - 1];
			if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
				closestPointRange = distance;
			}
		}
		
		// Record the properties
		series.cropped = cropped; // undefined or true
		series.cropStart = cropStart;
		series.processedXData = processedXData;
		series.processedYData = processedYData;
		
		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
			series.pointRange = closestPointRange || 1;
		}
		series.closestPointRange = closestPointRange;
		
	},

	/**
	 * Generate the data point after the data has been processed by cropping away
	 * unused points and optionally grouped in Highcharts Stock.
	 */
	generatePoints: function () {
		var series = this,
			options = series.options,
			dataOptions = options.data,
			data = series.data,
			dataLength,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			pointClass = series.pointClass,
			processedDataLength = processedXData.length,
			cropStart = series.cropStart || 0,
			cursor,
			hasGroupedData = series.hasGroupedData,
			point,
			points = [],
			i;

		if (!data && !hasGroupedData) {
			var arr = [];
			arr.length = dataOptions.length;
			data = series.data = arr;
		}

		for (i = 0; i < processedDataLength; i++) {
			cursor = cropStart + i;
			if (!hasGroupedData) {
				if (data[cursor]) {
					point = data[cursor];
				} else {
					data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
				}
				points[i] = point;
			} else {
				// splat the y data in case of ohlc data array
				points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
			}
		}

		// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
		// swithching view from non-grouped data to grouped data (#637)	
		if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
			for (i = 0; i < dataLength; i++) {
				if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
					i += processedDataLength;
				}
				if (data[i]) {
					data[i].destroyElements();
				}
			}
		}

		series.data = data;
		series.points = points;
	},

	/**
	 * Translate data points from raw data values to chart specific positioning data
	 * needed later in drawPoints, drawGraph and drawTracker.
	 */
	translate: function () {
		if (!this.processedXData) { // hidden series
			this.processData();
		}
		this.generatePoints();
		var series = this,
			chart = series.chart,
			options = series.options,
			stacking = options.stacking,
			xAxis = series.xAxis,
			categories = xAxis.categories,
			yAxis = series.yAxis,
			points = series.points,
			dataLength = points.length,
			hasModifyValue = !!series.modifyValue,
			isLastSeries,
			allStackSeries = yAxis.series,
			i = allStackSeries.length;
			
		// Is it the last visible series?
		while (i--) {
			if (allStackSeries[i].visible) {
				if (i === series.index) {
					isLastSeries = true;
				}
				break;
			}
		}
		
		// Translate each point
		for (i = 0; i < dataLength; i++) {
			var point = points[i],
				xValue = point.x,
				yValue = point.y,
				yBottom = point.low,
				stack = yAxis.stacks[(yValue < options.threshold ? '-' : '') + series.stackKey],
				pointStack,
				pointStackTotal;
				
			// get the plotX translation
			point.plotX = mathRound(xAxis.translate(xValue, 0, 0, 0, 1) * 10) / 10; // Math.round fixes #591

			// calculate the bottom y value for stacked series
			if (stacking && series.visible && stack && stack[xValue]) {
				pointStack = stack[xValue];
				pointStackTotal = pointStack.total;
				pointStack.cum = yBottom = pointStack.cum - yValue; // start from top
				yValue = yBottom + yValue;
				
				if (isLastSeries) {
					yBottom = options.threshold;
				}
				
				if (stacking === 'percent') {
					yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
					yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
				}

				point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
				point.stackTotal = pointStackTotal;
				point.stackY = yValue;
			}

			// Set translated yBottom or remove it
			point.yBottom = defined(yBottom) ? 
				yAxis.translate(yBottom, 0, 1, 0, 1) :
				null;
			
			// general hook, used for Highstock compare mode
			if (hasModifyValue) {
				yValue = series.modifyValue(yValue, point);
			}

			// Set the the plotY value, reset it for redraws
			point.plotY = (typeof yValue === 'number') ? 
				mathRound(yAxis.translate(yValue, 0, 1, 0, 1) * 10) / 10 : // Math.round fixes #591
				UNDEFINED;

			// set client related positions for mouse tracking
			point.clientX = chart.inverted ?
				chart.plotHeight - point.plotX :
				point.plotX; // for mouse tracking

			// some API data
			point.category = categories && categories[point.x] !== UNDEFINED ?
				categories[point.x] : point.x;


		}

		// now that we have the cropped data, build the segments
		series.getSegments();
	},
	/**
	 * Memoize tooltip texts and positions
	 */
	setTooltipPoints: function (renew) {
		var series = this,
			chart = series.chart,
			inverted = chart.inverted,
			points = [],
			pointsLength,
			plotSize = mathRound((inverted ? chart.plotTop : chart.plotLeft) + chart.plotSizeX),
			low,
			high,
			xAxis = series.xAxis,
			point,
			i,
			tooltipPoints = []; // a lookup array for each pixel in the x dimension

		// don't waste resources if tracker is disabled
		if (series.options.enableMouseTracking === false) {
			return;
		}

		// renew
		if (renew) {
			series.tooltipPoints = null;
		}

		// concat segments to overcome null values
		each(series.segments || series.points, function (segment) {
			points = points.concat(segment);
		});

		// loop the concatenated points and apply each point to all the closest
		// pixel positions
		if (xAxis && xAxis.reversed) {
			points = points.reverse();//reverseArray(points);
		}

		//each(points, function (point, i) {
		pointsLength = points.length;
		for (i = 0; i < pointsLength; i++) {
			point = points[i];
			low = points[i - 1] ? points[i - 1]._high + 1 : 0;
			high = point._high = points[i + 1] ?
				(mathFloor((point.plotX + (points[i + 1] ? points[i + 1].plotX : plotSize)) / 2)) :
				plotSize;

			while (low <= high) {
				tooltipPoints[inverted ? plotSize - low++ : low++] = point;
			}
		}
		series.tooltipPoints = tooltipPoints;
	},

	/**
	 * Format the header of the tooltip
	 */
	tooltipHeaderFormatter: function (key) {
		var series = this,
			tooltipOptions = series.tooltipOptions,
			xDateFormat = tooltipOptions.xDateFormat || '%A, %b %e, %Y',
			xAxis = series.xAxis,
			isDateTime = xAxis && xAxis.options.type === 'datetime';
		
		return tooltipOptions.headerFormat
			.replace('{point.key}', isDateTime ? dateFormat(xDateFormat, key) :  key)
			.replace('{series.name}', series.name)
			.replace('{series.color}', series.color);
	},

	/**
	 * Series mouse over handler
	 */
	onMouseOver: function () {
		var series = this,
			chart = series.chart,
			hoverSeries = chart.hoverSeries;

		if (!hasTouch && chart.mouseIsDown) {
			return;
		}

		// set normal state to previous series
		if (hoverSeries && hoverSeries !== series) {
			hoverSeries.onMouseOut();
		}

		// trigger the event, but to save processing time,
		// only if defined
		if (series.options.events.mouseOver) {
			fireEvent(series, 'mouseOver');
		}

		// hover this
		series.setState(HOVER_STATE);
		chart.hoverSeries = series;
	},

	/**
	 * Series mouse out handler
	 */
	onMouseOut: function () {
		// trigger the event only if listeners exist
		var series = this,
			options = series.options,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		// trigger mouse out on the point, which must be in this series
		if (hoverPoint) {
			hoverPoint.onMouseOut();
		}

		// fire the mouse out event
		if (series && options.events.mouseOut) {
			fireEvent(series, 'mouseOut');
		}


		// hide the tooltip
		if (tooltip && !options.stickyTracking && !tooltip.shared) {
			tooltip.hide();
		}

		// set normal state
		series.setState();
		chart.hoverSeries = null;
	},

	/**
	 * Animate in the series
	 */
	animate: function (init) {
		var series = this,
			chart = series.chart,
			clipRect = series.clipRect,
			animation = series.options.animation;

		if (animation && !isObject(animation)) {
			animation = {};
		}

		if (init) { // initialize the animation
			if (!clipRect.isAnimating) { // apply it only for one of the series
				clipRect.attr('width', 0);
				clipRect.isAnimating = true;
			}

		} else { // run the animation
			clipRect.animate({
				width: chart.plotSizeX
			}, animation);

			// delete this function to allow it only once
			this.animate = null;
		}
	},


	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			pointAttr,
			points = series.points,
			chart = series.chart,
			plotX,
			plotY,
			i,
			point,
			radius,
			symbol,
			isImage,
			graphic;

		if (series.options.marker.enabled) {
			i = points.length;
			while (i--) {
				point = points[i];
				plotX = point.plotX;
				plotY = point.plotY;
				graphic = point.graphic;

				// only draw the point if y is defined
				if (plotY !== UNDEFINED && !isNaN(plotY)) {

					// shortcuts
					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
					radius = pointAttr.r;
					symbol = pick(point.marker && point.marker.symbol, series.symbol);
					isImage = symbol.indexOf('url') === 0;

					if (graphic) { // update
						graphic.animate(extend({
							x: plotX - radius,
							y: plotY - radius
						}, graphic.symbolName ? { // don't apply to image symbols #507
							width: 2 * radius,
							height: 2 * radius
						} : {}));
					} else if (radius > 0 || isImage) {
						point.graphic = chart.renderer.symbol(
							symbol,
							plotX - radius,
							plotY - radius,
							2 * radius,
							2 * radius
						)
						.attr(pointAttr)
						.add(series.group);
					}
				}
			}
		}

	},

	/**
	 * Convert state properties from API naming conventions to SVG attributes
	 *
	 * @param {Object} options API options object
	 * @param {Object} base1 SVG attribute object to inherit from
	 * @param {Object} base2 Second level SVG attribute object to inherit from
	 */
	convertAttribs: function (options, base1, base2, base3) {
		var conversion = this.pointAttrToOptions,
			attr,
			option,
			obj = {};

		options = options || {};
		base1 = base1 || {};
		base2 = base2 || {};
		base3 = base3 || {};

		for (attr in conversion) {
			option = conversion[attr];
			obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
		}
		return obj;
	},

	/**
	 * Get the state attributes. Each series type has its own set of attributes
	 * that are allowed to change on a point's state change. Series wide attributes are stored for
	 * all series, and additionally point specific attributes are stored for all
	 * points with individual marker options. If such options are not defined for the point,
	 * a reference to the series wide attributes is stored in point.pointAttr.
	 */
	getAttribs: function () {
		var series = this,
			normalOptions = defaultPlotOptions[series.type].marker ? series.options.marker : series.options,
			stateOptions = normalOptions.states,
			stateOptionsHover = stateOptions[HOVER_STATE],
			pointStateOptionsHover,
			seriesColor = series.color,
			normalDefaults = {
				stroke: seriesColor,
				fill: seriesColor
			},
			points = series.points,
			i,
			point,
			seriesPointAttr = [],
			pointAttr,
			pointAttrToOptions = series.pointAttrToOptions,
			hasPointSpecificOptions,
			key;

		// series type specific modifications
		if (series.options.marker) { // line, spline, area, areaspline, scatter

			// if no hover radius is given, default to normal radius + 2
			stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
			stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;

		} else { // column, bar, pie

			// if no hover color is given, brighten the normal color
			stateOptionsHover.color = stateOptionsHover.color ||
				Color(stateOptionsHover.color || seriesColor)
					.brighten(stateOptionsHover.brightness).get();
		}

		// general point attributes for the series normal state
		seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

		// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
		each([HOVER_STATE, SELECT_STATE], function (state) {
			seriesPointAttr[state] =
					series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
		});

		// set it
		series.pointAttr = seriesPointAttr;


		// Generate the point-specific attribute collections if specific point
		// options are given. If not, create a referance to the series wide point
		// attributes
		i = points.length;
		while (i--) {
			point = points[i];
			normalOptions = (point.options && point.options.marker) || point.options;
			if (normalOptions && normalOptions.enabled === false) {
				normalOptions.radius = 0;
			}
			hasPointSpecificOptions = false;

			// check if the point has specific visual options
			if (point.options) {
				for (key in pointAttrToOptions) {
					if (defined(normalOptions[pointAttrToOptions[key]])) {
						hasPointSpecificOptions = true;
					}
				}
			}



			// a specific marker config object is defined for the individual point:
			// create it's own attribute collection
			if (hasPointSpecificOptions) {

				pointAttr = [];
				stateOptions = normalOptions.states || {}; // reassign for individual point
				pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

				// if no hover color is given, brighten the normal color
				if (!series.options.marker) { // column, bar, point
					pointStateOptionsHover.color =
						Color(pointStateOptionsHover.color || point.options.color)
							.brighten(pointStateOptionsHover.brightness ||
								stateOptionsHover.brightness).get();

				}

				// normal point state inherits series wide normal state
				pointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, seriesPointAttr[NORMAL_STATE]);

				// inherit from point normal and series hover
				pointAttr[HOVER_STATE] = series.convertAttribs(
					stateOptions[HOVER_STATE],
					seriesPointAttr[HOVER_STATE],
					pointAttr[NORMAL_STATE]
				);
				// inherit from point normal and series hover
				pointAttr[SELECT_STATE] = series.convertAttribs(
					stateOptions[SELECT_STATE],
					seriesPointAttr[SELECT_STATE],
					pointAttr[NORMAL_STATE]
				);



			// no marker config object is created: copy a reference to the series-wide
			// attribute collection
			} else {
				pointAttr = seriesPointAttr;
			}

			point.pointAttr = pointAttr;

		}

	},


	/**
	 * Clear DOM objects and free up memory
	 */
	destroy: function () {
		var series = this,
			chart = series.chart,
			seriesClipRect = series.clipRect,
			issue134 = /AppleWebKit\/533/.test(userAgent),
			destroy,
			i,
			data = series.data || [],
			point,
			prop,
			axis;

		// add event hook
		fireEvent(series, 'destroy');

		// remove all events
		removeEvent(series);
		
		// erase from axes
		each(['xAxis', 'yAxis'], function (AXIS) {
			axis = series[AXIS];
			if (axis) {
				erase(axis.series, series);
				axis.isDirty = true;
			}
		});

		// remove legend items
		if (series.legendItem) {
			series.chart.legend.destroyItem(series);
		}

		// destroy all points with their elements
		i = data.length;
		while (i--) {
			point = data[i];
			if (point && point.destroy) {
				point.destroy();
			}
		}
		series.points = null;

		// If this series clipRect is not the global one (which is removed on chart.destroy) we
		// destroy it here.
		if (seriesClipRect && seriesClipRect !== chart.clipRect) {
			series.clipRect = seriesClipRect.destroy();
		}

		// destroy all SVGElements associated to the series
		each(['area', 'graph', 'dataLabelsGroup', 'group', 'tracker'], function (prop) {
			if (series[prop]) {

				// issue 134 workaround
				destroy = issue134 && prop === 'group' ?
					'hide' :
					'destroy';

				series[prop][destroy]();
			}
		});

		// remove from hoverSeries
		if (chart.hoverSeries === series) {
			chart.hoverSeries = null;
		}
		erase(chart.series, series);

		// clear all members
		for (prop in series) {
			delete series[prop];
		}
	},

	/**
	 * Draw the data labels
	 */
	drawDataLabels: function () {
		
		var series = this,
			seriesOptions = series.options,
			options = seriesOptions.dataLabels;
		
		if (options.enabled || series._hasPointLabels) {
			var x,
				y,
				points = series.points,
				pointOptions,
				generalOptions,
				str,
				dataLabelsGroup = series.dataLabelsGroup,
				chart = series.chart,
				xAxis = series.xAxis,
				groupLeft = xAxis ? xAxis.left : chart.plotLeft,
				yAxis = series.yAxis,
				groupTop = yAxis ? yAxis.top : chart.plotTop,
				renderer = chart.renderer,
				inverted = chart.inverted,
				seriesType = series.type,
				stacking = seriesOptions.stacking,
				isBarLike = seriesType === 'column' || seriesType === 'bar',
				vAlignIsNull = options.verticalAlign === null,
				yIsNull = options.y === null,
				fontMetrics = renderer.fontMetrics(options.style.fontSize), // height and baseline
				fontLineHeight = fontMetrics.h,
				fontBaseline = fontMetrics.b,
				dataLabel,
				enabled;

			if (isBarLike) {
				var defaultYs = {
					top: fontBaseline, 
					middle: fontBaseline - fontLineHeight / 2, 
					bottom: -fontLineHeight + fontBaseline
				};
				if (stacking) {
					// In stacked series the default label placement is inside the bars
					if (vAlignIsNull) {
						options = merge(options, {verticalAlign: 'middle'});
					}

					// If no y delta is specified, try to create a good default
					if (yIsNull) {
						options = merge(options, { y: defaultYs[options.verticalAlign]});
					}
				} else {
					// In non stacked series the default label placement is on top of the bars
					if (vAlignIsNull) {
						options = merge(options, {verticalAlign: 'top'});
					
					// If no y delta is specified, try to create a good default (like default bar)
					} else if (yIsNull) {
						options = merge(options, { y: defaultYs[options.verticalAlign]});
					}
					
				}
			}


			// create a separate group for the data labels to avoid rotation
			if (!dataLabelsGroup) {
				dataLabelsGroup = series.dataLabelsGroup =
					renderer.g('data-labels')
						.attr({
							visibility: series.visible ? VISIBLE : HIDDEN,
							zIndex: 6
						})
						.translate(groupLeft, groupTop)
						.add();
			} else {
				dataLabelsGroup.translate(groupLeft, groupTop);
			}
			
			// make the labels for each point
			generalOptions = options;
			each(points, function (point) {
				
				dataLabel = point.dataLabel;
				
				// Merge in individual options from point
				options = generalOptions; // reset changes from previous points
				pointOptions = point.options;
				if (pointOptions && pointOptions.dataLabels) {
					options = merge(options, pointOptions.dataLabels);
				}
				enabled = options.enabled;
				
				// Get the positions
				if (enabled) {
					var plotX = (point.barX && point.barX + point.barW / 2) || pick(point.plotX, -999),
						plotY = pick(point.plotY, -999),
						
						// if options.y is null, which happens by default on column charts, set the position
						// above or below the column depending on the threshold
						individualYDelta = options.y === null ? 
							(point.y >= seriesOptions.threshold ? 
								-fontLineHeight + fontBaseline : // below the threshold 
								fontBaseline) : // above the threshold
							options.y;
					
					x = (inverted ? chart.plotWidth - plotY : plotX) + options.x;
					y = mathRound((inverted ? chart.plotHeight - plotX : plotY) + individualYDelta);
					
				}
				
				// If the point is outside the plot area, destroy it. #678, #820
				if (dataLabel && series.isCartesian && (!chart.isInsidePlot(x, y) || !enabled)) {
					point.dataLabel = dataLabel.destroy();
				
				// Individual labels are disabled if the are explicitly disabled 
				// in the point options, or if they fall outside the plot area.
				} else if (enabled) {
					
					var align = options.align;
				
					// Get the string
					str = options.formatter.call(point.getLabelConfig(), options);
					
					// in columns, align the string to the column
					if (seriesType === 'column') {
						x += { left: -1, right: 1 }[align] * point.barW / 2 || 0;
					}
	
					if (!stacking && inverted && point.y < 0) {
						align = 'right';
						x -= 10;
					}
					
					// Determine the color
					options.style.color = pick(options.color, options.style.color, series.color, 'black');
	
					
					// update existing label
					if (dataLabel) {
						// vertically centered
						dataLabel
							.attr({
								text: str
							}).animate({
								x: x,
								y: y
							});
					// create new label
					} else if (defined(str)) {
						dataLabel = point.dataLabel = renderer[options.rotation ? 'text' : 'label']( // labels don't support rotation
							str,
							x,
							y,
							null,
							null,
							null,
							options.useHTML,
							true // baseline for backwards compat
						)
						.attr({
							align: align,
							fill: options.backgroundColor,
							stroke: options.borderColor,
							'stroke-width': options.borderWidth,
							r: options.borderRadius,
							rotation: options.rotation,
							padding: options.padding,
							zIndex: 1
						})
						.css(options.style)
						.add(dataLabelsGroup)
						.shadow(options.shadow);
					}
	
					if (isBarLike && seriesOptions.stacking && dataLabel) {
						var barX = point.barX,
							barY = point.barY,
							barW = point.barW,
							barH = point.barH;
	
						dataLabel.align(options, null,
							{
								x: inverted ? chart.plotWidth - barY - barH : barX,
								y: inverted ? chart.plotHeight - barX - barW : barY,
								width: inverted ? barH : barW,
								height: inverted ? barW : barH
							});
					}
					
					
				}
			});
		}
	},

	/**
	 * Draw the actual graph
	 */
	drawGraph: function () {
		var series = this,
			options = series.options,
			chart = series.chart,
			graph = series.graph,
			graphPath = [],
			fillColor,
			area = series.area,
			group = series.group,
			color = options.lineColor || series.color,
			lineWidth = options.lineWidth,
			dashStyle =  options.dashStyle,
			segmentPath,
			renderer = chart.renderer,
			translatedThreshold = series.yAxis.getThreshold(options.threshold),
			useArea = /^area/.test(series.type),
			singlePoints = [], // used in drawTracker
			areaPath = [],
			attribs;


		// divide into segments and build graph and area paths
		each(series.segments, function (segment) {
			segmentPath = [];

			// build the segment line
			each(segment, function (point, i) {

				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

				} else {

					// moveTo or lineTo
					segmentPath.push(i ? L : M);

					// step line?
					if (i && options.step) {
						var lastPoint = segment[i - 1];
						segmentPath.push(
							point.plotX,
							lastPoint.plotY
						);
					}

					// normal line to next point
					segmentPath.push(
						point.plotX,
						point.plotY
					);
				}
			});

			// add the segment to the graph, or a single point for tracking
			if (segment.length > 1) {
				graphPath = graphPath.concat(segmentPath);
			} else {
				singlePoints.push(segment[0]);
			}

			// build the area
			if (useArea) {
				var areaSegmentPath = [],
					i,
					segLength = segmentPath.length;
				for (i = 0; i < segLength; i++) {
					areaSegmentPath.push(segmentPath[i]);
				}
				if (segLength === 3) { // for animation from 1 to two points
					areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
				}
				if (options.stacking && series.type !== 'areaspline') {
					
					// Follow stack back. Todo: implement areaspline. A general solution could be to 
					// reverse the entire graphPath of the previous series, though may be hard with
					// splines and with series with different extremes
					for (i = segment.length - 1; i >= 0; i--) {
					
						// step line?
						if (i < segment.length - 1 && options.step) {
							areaSegmentPath.push(segment[i + 1].plotX, segment[i].yBottom);
						}
						
						areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
					}

				} else { // follow zero line back
					areaSegmentPath.push(
						L,
						segment[segment.length - 1].plotX,
						translatedThreshold,
						L,
						segment[0].plotX,
						translatedThreshold
					);
				}
				areaPath = areaPath.concat(areaSegmentPath);
			}
		});

		// used in drawTracker:
		series.graphPath = graphPath;
		series.singlePoints = singlePoints;

		// draw the area if area series or areaspline
		if (useArea) {
			fillColor = pick(
				options.fillColor,
				Color(series.color).setOpacity(options.fillOpacity || 0.75).get()
			);
			if (area) {
				area.animate({ d: areaPath });

			} else {
				// draw the area
				series.area = series.chart.renderer.path(areaPath)
					.attr({
						fill: fillColor
					}).add(group);
			}
		}

		// draw the graph
		if (graph) {
			stop(graph); // cancel running animations, #459
			graph.animate({ d: graphPath });

		} else {
			if (lineWidth) {
				attribs = {
					'stroke': color,
					'stroke-width': lineWidth
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}

				series.graph = renderer.path(graphPath)
					.attr(attribs).add(group).shadow(options.shadow);
			}
		}
	},

	/**
	 * Initialize and perform group inversion on series.group and series.trackerGroup
	 */
	invertGroups: function () {
		var series = this,
			group = series.group,
			trackerGroup = series.trackerGroup,
			chart = series.chart;
		
		// A fixed size is needed for inversion to work
		function setInvert() {			
			var size = {
				width: series.yAxis.len,
				height: series.xAxis.len
			};
			
			// Set the series.group size
			group.attr(size).invert();
			
			// Set the tracker group size
			if (trackerGroup) {
				trackerGroup.attr(size).invert();
			}
		}

		addEvent(chart, 'resize', setInvert); // do it on resize
		addEvent(series, 'destroy', function () {
			removeEvent(chart, 'resize', setInvert);
		});

		// Do it now
		setInvert(); // do it now
		
		// On subsequent render and redraw, just do setInvert without setting up events again
		series.invertGroups = setInvert;
	},

	/**
	 * Render the graph and markers
	 */
	render: function () {
		var series = this,
			chart = series.chart,
			group,
			options = series.options,
			doClip = options.clip !== false,
			animation = options.animation,
			doAnimation = animation && series.animate,
			duration = doAnimation ? (animation && animation.duration) || 500 : 0,
			clipRect = series.clipRect,
			renderer = chart.renderer;


		// Add plot area clipping rectangle. If this is before chart.hasRendered,
		// create one shared clipRect.

		// Todo: since creating the clip property, the clipRect is created but
		// never used when clip is false. A better way would be that the animation
		// would run, then the clipRect destroyed.
		if (!clipRect) {
			clipRect = series.clipRect = !chart.hasRendered && chart.clipRect ?
				chart.clipRect :
				renderer.clipRect(0, 0, chart.plotSizeX, chart.plotSizeY + 1);
			if (!chart.clipRect) {
				chart.clipRect = clipRect;
			}
		}
		

		// the group
		if (!series.group) {
			group = series.group = renderer.g('series');

			group.attr({
					visibility: series.visible ? VISIBLE : HIDDEN,
					zIndex: options.zIndex
				})
				.translate(series.xAxis.left, series.yAxis.top)
				.add(chart.seriesGroup);
		}

		series.drawDataLabels();

		// initiate the animation
		if (doAnimation) {
			series.animate(true);
		}

		// cache attributes for shapes
		series.getAttribs();

		// draw the graph if any
		if (series.drawGraph) {
			series.drawGraph();
		}

		// draw the points
		series.drawPoints();

		// draw the mouse tracking area
		if (series.options.enableMouseTracking !== false) {
			series.drawTracker();
		}
		
		// Handle inverted series and tracker groups
		if (chart.inverted) {
			series.invertGroups();
		}
		
		// Do the initial clipping. This must be done after inverting for VML.
		if (doClip && !series.hasRendered) {
			group.clip(clipRect);
			if (series.trackerGroup) {
				series.trackerGroup.clip(chart.clipRect);
			}
		}
			

		// run the animation
		if (doAnimation) {
			series.animate();
		}

		// finish the individual clipRect
		setTimeout(function () {
			clipRect.isAnimating = false;
			group = series.group; // can be destroyed during the timeout
			if (group && clipRect !== chart.clipRect && clipRect.renderer) {
				if (doClip) {
					group.clip((series.clipRect = chart.clipRect));
				}
				clipRect.destroy();
			}
		}, duration);

		series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		series.hasRendered = true;
	},

	/**
	 * Redraw the series after an update in the axes.
	 */
	redraw: function () {
		var series = this,
			chart = series.chart,
			wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
			group = series.group;

		// reposition on resize
		if (group) {
			if (chart.inverted) {
				group.attr({
					width: chart.plotWidth,
					height: chart.plotHeight
				});
			}

			group.animate({
				translateX: series.xAxis.left,
				translateY: series.yAxis.top
			});
		}

		series.translate();
		series.setTooltipPoints(true);

		series.render();
		if (wasDirtyData) {
			fireEvent(series, 'updatedData');
		}
	},

	/**
	 * Set the state of the graph
	 */
	setState: function (state) {
		var series = this,
			options = series.options,
			graph = series.graph,
			stateOptions = options.states,
			lineWidth = options.lineWidth;

		state = state || NORMAL_STATE;

		if (series.state !== state) {
			series.state = state;

			if (stateOptions[state] && stateOptions[state].enabled === false) {
				return;
			}

			if (state) {
				lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
			}

			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
				graph.attr({ // use attr because animate will cause any other animation on the graph to stop
					'stroke-width': lineWidth
				}, state ? 0 : 500);
			}
		}
	},

	/**
	 * Set the visibility of the graph
	 *
	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
	 *        the visibility is toggled.
	 */
	setVisible: function (vis, redraw) {
		var series = this,
			chart = series.chart,
			legendItem = series.legendItem,
			seriesGroup = series.group,
			seriesTracker = series.tracker,
			dataLabelsGroup = series.dataLabelsGroup,
			showOrHide,
			i,
			points = series.points,
			point,
			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
			oldVisibility = series.visible;

		// if called without an argument, toggle visibility
		series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
		showOrHide = vis ? 'show' : 'hide';

		// show or hide series
		if (seriesGroup) { // pies don't have one
			seriesGroup[showOrHide]();
		}

		// show or hide trackers
		if (seriesTracker) {
			seriesTracker[showOrHide]();
		} else if (points) {
			i = points.length;
			while (i--) {
				point = points[i];
				if (point.tracker) {
					point.tracker[showOrHide]();
				}
			}
		}


		if (dataLabelsGroup) {
			dataLabelsGroup[showOrHide]();
		}

		if (legendItem) {
			chart.legend.colorizeItem(series, vis);
		}


		// rescale or adapt to resized chart
		series.isDirty = true;
		// in a stack, all other series are affected
		if (series.options.stacking) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.options.stacking && otherSeries.visible) {
					otherSeries.isDirty = true;
				}
			});
		}

		if (ignoreHiddenSeries) {
			chart.isDirtyBox = true;
		}
		if (redraw !== false) {
			chart.redraw();
		}

		fireEvent(series, showOrHide);
	},

	/**
	 * Show the graph
	 */
	show: function () {
		this.setVisible(true);
	},

	/**
	 * Hide the graph
	 */
	hide: function () {
		this.setVisible(false);
	},


	/**
	 * Set the selected state of the graph
	 *
	 * @param selected {Boolean} True to select the series, false to unselect. If
	 *        UNDEFINED, the selection state is toggled.
	 */
	select: function (selected) {
		var series = this;
		// if called without an argument, toggle
		series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

		if (series.checkbox) {
			series.checkbox.checked = selected;
		}

		fireEvent(series, selected ? 'select' : 'unselect');
	},

	/**
	 * Create a group that holds the tracking object or objects. This allows for
	 * individual clipping and placement of each series tracker.
	 */
	drawTrackerGroup: function () {
		var trackerGroup = this.trackerGroup,
			chart = this.chart;
		
		if (this.isCartesian) {
		
			// Generate it on first call
			if (!trackerGroup) {	
				this.trackerGroup = trackerGroup = chart.renderer.g()
					.attr({
						zIndex: this.options.zIndex || 1
					})
					.add(chart.trackerGroup);
					
			}
			// Place it on first and subsequent (redraw) calls
			trackerGroup.translate(this.xAxis.left, this.yAxis.top);
			
		}
		
		return trackerGroup;
	},
	
	/**
	 * Draw the tracker object that sits above all data labels and markers to
	 * track mouse events on the graph or points. For the line type charts
	 * the tracker uses the same graphPath, but with a greater stroke width
	 * for better control.
	 */
	drawTracker: function () {
		var series = this,
			options = series.options,
			trackerPath = [].concat(series.graphPath),
			trackerPathLength = trackerPath.length,
			chart = series.chart,
			renderer = chart.renderer,
			snap = chart.options.tooltip.snap,
			tracker = series.tracker,
			cursor = options.cursor,
			css = cursor && { cursor: cursor },
			singlePoints = series.singlePoints,
			trackerGroup = series.drawTrackerGroup(),
			singlePoint,
			i;

		// Extend end points. A better way would be to use round linecaps,
		// but those are not clickable in VML.
		if (trackerPathLength) {
			i = trackerPathLength + 1;
			while (i--) {
				if (trackerPath[i] === M) { // extend left side
					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
				}
				if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
					trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
				}
			}
		}

		// handle single points
		for (i = 0; i < singlePoints.length; i++) {
			singlePoint = singlePoints[i];
			trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
				L, singlePoint.plotX + snap, singlePoint.plotY);
		}
		
		

		// draw the tracker
		if (tracker) {
			tracker.attr({ d: trackerPath });

		} else { // create
				
			series.tracker = renderer.path(trackerPath)
				.attr({
					isTracker: true,
					stroke: TRACKER_FILL,
					fill: NONE,
					'stroke-linejoin': 'bevel',
					'stroke-width' : options.lineWidth + 2 * snap,
					visibility: series.visible ? VISIBLE : HIDDEN
				})
				.on(hasTouch ? 'touchstart' : 'mouseover', function () {
					if (chart.hoverSeries !== series) {
						series.onMouseOver();
					}
				})
				.on('mouseout', function () {
					if (!options.stickyTracking) {
						series.onMouseOut();
					}
				})
				.css(css)
				.add(trackerGroup);
		}

	}

}; // end Series prototype


/**
 * LineSeries object
 */
var LineSeries = extendClass(Series);
seriesTypes.line = LineSeries;

/**
 * AreaSeries object
 */
var AreaSeries = extendClass(Series, {
	type: 'area'
});
seriesTypes.area = AreaSeries;




/**
 * SplineSeries object
 */
var SplineSeries = extendClass(Series, {
	type: 'spline',

	/**
	 * Draw the actual graph
	 */
	getPointSpline: function (segment, point, i) {
		var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
			denom = smoothing + 1,
			plotX = point.plotX,
			plotY = point.plotY,
			lastPoint = segment[i - 1],
			nextPoint = segment[i + 1],
			leftContX,
			leftContY,
			rightContX,
			rightContY,
			ret;

		// find control points
		if (i && i < segment.length - 1) {
			var lastX = lastPoint.plotX,
				lastY = lastPoint.plotY,
				nextX = nextPoint.plotX,
				nextY = nextPoint.plotY,
				correction;

			leftContX = (smoothing * plotX + lastX) / denom;
			leftContY = (smoothing * plotY + lastY) / denom;
			rightContX = (smoothing * plotX + nextX) / denom;
			rightContY = (smoothing * plotY + nextY) / denom;

			// have the two control points make a straight line through main point
			correction = ((rightContY - leftContY) * (rightContX - plotX)) /
				(rightContX - leftContX) + plotY - rightContY;

			leftContY += correction;
			rightContY += correction;

			// to prevent false extremes, check that control points are between
			// neighbouring points' y values
			if (leftContY > lastY && leftContY > plotY) {
				leftContY = mathMax(lastY, plotY);
				rightContY = 2 * plotY - leftContY; // mirror of left control point
			} else if (leftContY < lastY && leftContY < plotY) {
				leftContY = mathMin(lastY, plotY);
				rightContY = 2 * plotY - leftContY;
			}
			if (rightContY > nextY && rightContY > plotY) {
				rightContY = mathMax(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			} else if (rightContY < nextY && rightContY < plotY) {
				rightContY = mathMin(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			}

			// record for drawing in next point
			point.rightContX = rightContX;
			point.rightContY = rightContY;

		}

		// moveTo or lineTo
		if (!i) {
			ret = [M, plotX, plotY];
		} else { // curve from last point to this
			ret = [
				'C',
				lastPoint.rightContX || lastPoint.plotX,
				lastPoint.rightContY || lastPoint.plotY,
				leftContX || plotX,
				leftContY || plotY,
				plotX,
				plotY
			];
			lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
		}
		return ret;
	}
});
seriesTypes.spline = SplineSeries;



/**
 * AreaSplineSeries object
 */
var AreaSplineSeries = extendClass(SplineSeries, {
	type: 'areaspline'
});
seriesTypes.areaspline = AreaSplineSeries;

/**
 * ColumnSeries object
 */
var ColumnSeries = extendClass(Series, {
	type: 'column',
	tooltipOutsidePlot: true,
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		'stroke-width': 'borderWidth',
		fill: 'color',
		r: 'borderRadius'
	},
	init: function () {
		Series.prototype.init.apply(this, arguments);

		var series = this,
			chart = series.chart;

		// if the series is added dynamically, force redraw of other
		// series affected by a new column
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}
	},

	/**
	 * Translate each point to the plot area coordinate system and find shape positions
	 */
	translate: function () {
		var series = this,
			chart = series.chart,
			options = series.options,
			stacking = options.stacking,
			borderWidth = options.borderWidth,
			columnCount = 0,
			xAxis = series.xAxis,
			reversedXAxis = xAxis.reversed,
			stackGroups = {},
			stackKey,
			columnIndex;

		Series.prototype.translate.apply(series);

		// Get the total number of column type series.
		// This is called on every series. Consider moving this logic to a
		// chart.orderStacks() function and call it on init, addSeries and removeSeries
		each(chart.series, function (otherSeries) {
			if (otherSeries.type === series.type && otherSeries.visible &&
					series.options.group === otherSeries.options.group) { // used in Stock charts navigator series
				if (otherSeries.options.stacking) {
					stackKey = otherSeries.stackKey;
					if (stackGroups[stackKey] === UNDEFINED) {
						stackGroups[stackKey] = columnCount++;
					}
					columnIndex = stackGroups[stackKey];
				} else {
					columnIndex = columnCount++;
				}
				otherSeries.columnIndex = columnIndex;
			}
		});

		// calculate the width and position of each column based on
		// the number of column series in the plot, the groupPadding
		// and the pointPadding options
		var points = series.points,
			categoryWidth = mathAbs(xAxis.translationSlope) * (xAxis.ordinalSlope || xAxis.closestPointRange || 1),
			groupPadding = categoryWidth * options.groupPadding,
			groupWidth = categoryWidth - 2 * groupPadding,
			pointOffsetWidth = groupWidth / columnCount,
			optionPointWidth = options.pointWidth,
			pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
				pointOffsetWidth * options.pointPadding,
			pointWidth = mathCeil(mathMax(pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), 1 + 2 * borderWidth)),
			colIndex = (reversedXAxis ? columnCount -
				series.columnIndex : series.columnIndex) || 0,
			pointXOffset = pointPadding + (groupPadding + colIndex *
				pointOffsetWidth - (categoryWidth / 2)) *
				(reversedXAxis ? -1 : 1),
			threshold = options.threshold,
			translatedThreshold = series.yAxis.getThreshold(threshold),
			minPointLength = pick(options.minPointLength, 5);

		// record the new values
		each(points, function (point) {
			var plotY = point.plotY,
				yBottom = pick(point.yBottom, translatedThreshold),
				barX = point.plotX + pointXOffset,
				barY = mathCeil(mathMin(plotY, yBottom)),
				barH = mathCeil(mathMax(plotY, yBottom) - barY),
				stack = series.yAxis.stacks[(point.y < 0 ? '-' : '') + series.stackKey],
				shapeArgs;

			// Record the offset'ed position and width of the bar to be able to align the stacking total correctly
			if (stacking && series.visible && stack && stack[point.x]) {
				stack[point.x].setOffset(pointXOffset, pointWidth);
			}

			// handle options.minPointLength
			if (mathAbs(barH) < minPointLength) {
				if (minPointLength) {
					barH = minPointLength;
					barY =
						mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
							yBottom - minPointLength : // keep position
							translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
				}
			}

			extend(point, {
				barX: barX,
				barY: barY,
				barW: pointWidth,
				barH: barH
			});

			// create shape type and shape args that are reused in drawPoints and drawTracker
			point.shapeType = 'rect';
			shapeArgs = {
				x: barX,
				y: barY,
				width: pointWidth,
				height: barH,
				r: options.borderRadius,
				strokeWidth: borderWidth
			};
			
			if (borderWidth % 2) { // correct for shorting in crisp method, visible in stacked columns with 1px border
				shapeArgs.y -= 1;
				shapeArgs.height += 1;
			}
			point.shapeArgs = shapeArgs;

			// make small columns responsive to mouse
			point.trackerArgs = mathAbs(barH) < 3 && merge(point.shapeArgs, {
				height: 6,
				y: barY - 3
			});
		});

	},

	getSymbol: function () {
	},

	/**
	 * Columns have no graph
	 */
	drawGraph: function () {},

	/**
	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	 * apply for columns and bars. This method is inherited by scatter series.
	 *
	 */
	drawPoints: function () {
		var series = this,
			options = series.options,
			renderer = series.chart.renderer,
			graphic,
			shapeArgs;


		// draw the columns
		each(series.points, function (point) {
			var plotY = point.plotY;
			if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
				graphic = point.graphic;
				shapeArgs = point.shapeArgs;
				if (graphic) { // update
					stop(graphic);
					graphic.animate(renderer.Element.prototype.crisp.apply({}, [
						shapeArgs.strokeWidth,
						shapeArgs.x,
						shapeArgs.y,
						shapeArgs.width,
						shapeArgs.height
					]));

				} else {
					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])
						.add(series.group)
						.shadow(options.shadow);
						
				}

			}
		});
	},
	/**
	 * Draw the individual tracker elements.
	 * This method is inherited by scatter and pie charts too.
	 */
	drawTracker: function () {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			shapeArgs,
			tracker,
			trackerLabel = +new Date(),
			options = series.options,
			cursor = options.cursor,
			css = cursor && { cursor: cursor },
			trackerGroup = series.drawTrackerGroup(),
			rel;
			
		each(series.points, function (point) {
			tracker = point.tracker;
			shapeArgs = point.trackerArgs || point.shapeArgs;
			delete shapeArgs.strokeWidth;
			if (point.y !== null) {
				if (tracker) {// update
					tracker.attr(shapeArgs);

				} else {
					point.tracker =
						renderer[point.shapeType](shapeArgs)
						.attr({
							isTracker: trackerLabel,
							fill: TRACKER_FILL,
							visibility: series.visible ? VISIBLE : HIDDEN
						})
						.on(hasTouch ? 'touchstart' : 'mouseover', function (event) {
							rel = event.relatedTarget || event.fromElement;
							if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {
								series.onMouseOver();
							}
							point.onMouseOver();

						})
						.on('mouseout', function (event) {
							if (!options.stickyTracking) {
								rel = event.relatedTarget || event.toElement;
								if (attr(rel, 'isTracker') !== trackerLabel) {
									series.onMouseOut();
								}
							}
						})
						.css(css)
						.add(point.group || trackerGroup); // pies have point group - see issue #118
				}
			}
		});
	},


	/**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
	animate: function (init) {
		var series = this,
			points = series.points,
			options = series.options;

		if (!init) { // run the animation
			/*
			 * Note: Ideally the animation should be initialized by calling
			 * series.group.hide(), and then calling series.group.show()
			 * after the animation was started. But this rendered the shadows
			 * invisible in IE8 standards mode. If the columns flicker on large
			 * datasets, this is the cause.
			 */

			each(points, function (point) {
				var graphic = point.graphic,
					shapeArgs = point.shapeArgs,
					yAxis = series.yAxis,
					threshold = options.threshold;

				if (graphic) {
					// start values
					graphic.attr({
						height: 0,
						y: defined(threshold) ? 
							yAxis.getThreshold(threshold) :
							yAxis.translate(yAxis.getExtremes().min, 0, 1, 0, 1)
					});

					// animate
					graphic.animate({
						height: shapeArgs.height,
						y: shapeArgs.y
					}, options.animation);
				}
			});


			// delete this function to allow it only once
			series.animate = null;
		}

	},
	/**
	 * Remove this series from the chart
	 */
	remove: function () {
		var series = this,
			chart = series.chart;

		// column and bar series affects other series of the same type
		// as they are either stacked or grouped
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}

		Series.prototype.remove.apply(series, arguments);
	}
});
seriesTypes.column = ColumnSeries;

var BarSeries = extendClass(ColumnSeries, {
	type: 'bar',
	init: function () {
		this.inverted = true;
		ColumnSeries.prototype.init.apply(this, arguments);
	}
});
seriesTypes.bar = BarSeries;

/**
 * The scatter series class
 */
var ScatterSeries = extendClass(Series, {
	type: 'scatter',
	sorted: false,
	/**
	 * Extend the base Series' translate method by adding shape type and
	 * arguments for the point trackers
	 */
	translate: function () {
		var series = this;

		Series.prototype.translate.apply(series);

		each(series.points, function (point) {
			point.shapeType = 'circle';
			point.shapeArgs = {
				x: point.plotX,
				y: point.plotY,
				r: series.chart.options.tooltip.snap
			};
		});
	},

	/**
	 * Add tracking event listener to the series group, so the point graphics
	 * themselves act as trackers
	 */
	drawTracker: function () {
		var series = this,
			cursor = series.options.cursor,
			css = cursor && { cursor: cursor },
			points = series.points,
			i = points.length,
			graphic;

		// Set an expando property for the point index, used below
		while (i--) {
			graphic = points[i].graphic;
			if (graphic) { // doesn't exist for null points
				graphic.element._i = i; 
			}
		}
		
		// Add the event listeners, we need to do this only once
		if (!series._hasTracking) {
			series.group
				.attr({
					isTracker: true
				})
				.on(hasTouch ? 'touchstart' : 'mouseover', function (e) {
					series.onMouseOver();
					if (e.target._i !== UNDEFINED) { // undefined on graph in scatterchart
						points[e.target._i].onMouseOver();
					}
				})
				.on('mouseout', function () {
					if (!series.options.stickyTracking) {
						series.onMouseOut();
					}
				})
				.css(css);
		} else {
			series._hasTracking = true;
		}

	}
});
seriesTypes.scatter = ScatterSeries;

/**
 * Extended point object for pies
 */
var PiePoint = extendClass(Point, {
	/**
	 * Initiate the pie slice
	 */
	init: function () {

		Point.prototype.init.apply(this, arguments);

		var point = this,
			toggleSlice;

		//visible: options.visible !== false,
		extend(point, {
			visible: point.visible !== false,
			name: pick(point.name, 'Slice')
		});

		// add event listener for select
		toggleSlice = function () {
			point.slice();
		};
		addEvent(point, 'select', toggleSlice);
		addEvent(point, 'unselect', toggleSlice);

		return point;
	},

	/**
	 * Toggle the visibility of the pie slice
	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	 *    visibility is toggled
	 */
	setVisible: function (vis) {
		var point = this,
			chart = point.series.chart,
			tracker = point.tracker,
			dataLabel = point.dataLabel,
			connector = point.connector,
			shadowGroup = point.shadowGroup,
			method;

		// if called without an argument, toggle visibility
		point.visible = vis = vis === UNDEFINED ? !point.visible : vis;

		method = vis ? 'show' : 'hide';

		point.group[method]();
		if (tracker) {
			tracker[method]();
		}
		if (dataLabel) {
			dataLabel[method]();
		}
		if (connector) {
			connector[method]();
		}
		if (shadowGroup) {
			shadowGroup[method]();
		}
		if (point.legendItem) {
			chart.legend.colorizeItem(point, vis);
		}
	},

	/**
	 * Set or toggle whether the slice is cut out from the pie
	 * @param {Boolean} sliced When undefined, the slice state is toggled
	 * @param {Boolean} redraw Whether to redraw the chart. True by default.
	 */
	slice: function (sliced, redraw, animation) {
		var point = this,
			series = point.series,
			chart = series.chart,
			slicedTranslation = point.slicedTranslation,
			translation;

		setAnimation(animation, chart);

		// redraw is true by default
		redraw = pick(redraw, true);

		// if called without an argument, toggle
		sliced = point.sliced = defined(sliced) ? sliced : !point.sliced;

		translation = {
			translateX: (sliced ? slicedTranslation[0] : chart.plotLeft),
			translateY: (sliced ? slicedTranslation[1] : chart.plotTop)
		};
		point.group.animate(translation);
		if (point.shadowGroup) {
			point.shadowGroup.animate(translation);
		}

	}
});

/**
 * The Pie series class
 */
var PieSeries = extendClass(Series, {
	type: 'pie',
	isCartesian: false,
	pointClass: PiePoint,
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		'stroke-width': 'borderWidth',
		fill: 'color'
	},

	/**
	 * Pies have one color each point
	 */
	getColor: function () {
		// record first color for use in setData
		this.initialColor = this.chart.counters.color;
	},

	/**
	 * Animate the column heights one by one from zero
	 */
	animate: function () {
		var series = this,
			points = series.points;

		each(points, function (point) {
			var graphic = point.graphic,
				args = point.shapeArgs,
				up = -mathPI / 2;

			if (graphic) {
				// start values
				graphic.attr({
					r: 0,
					start: up,
					end: up
				});

				// animate
				graphic.animate({
					r: args.r,
					start: args.start,
					end: args.end
				}, series.options.animation);
			}
		});

		// delete this function to allow it only once
		series.animate = null;

	},

	/**
	 * Extend the basic setData method by running processData and generatePoints immediately,
	 * in order to access the points from the legend.
	 */
	setData: function () {
		Series.prototype.setData.apply(this, arguments);
		this.processData();
		this.generatePoints();
	},
	/**
	 * Do translation for pie slices
	 */
	translate: function () {
		this.generatePoints();
		
		var total = 0,
			series = this,
			cumulative = -0.25, // start at top
			precision = 1000, // issue #172
			options = series.options,
			slicedOffset = options.slicedOffset,
			connectorOffset = slicedOffset + options.borderWidth,
			positions = options.center.concat([options.size, options.innerSize || 0]),
			chart = series.chart,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			start,
			end,
			angle,
			points = series.points,
			circ = 2 * mathPI,
			fraction,
			smallestSize = mathMin(plotWidth, plotHeight),
			isPercent,
			radiusX, // the x component of the radius vector for a given point
			radiusY,
			labelDistance = options.dataLabels.distance;

		// get positions - either an integer or a percentage string must be given
		positions = map(positions, function (length, i) {

			isPercent = /%$/.test(length);
			return isPercent ?
				// i == 0: centerX, relative to width
				// i == 1: centerY, relative to height
				// i == 2: size, relative to smallestSize
				// i == 4: innerSize, relative to smallestSize
				[plotWidth, plotHeight, smallestSize, smallestSize][i] *
					pInt(length) / 100 :
				length;
		});

		// utility for getting the x value from a given y, used for anticollision logic in data labels
		series.getX = function (y, left) {

			angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));

			return positions[0] +
				(left ? -1 : 1) *
				(mathCos(angle) * (positions[2] / 2 + labelDistance));
		};

		// set center for later use
		series.center = positions;

		// get the total sum
		each(points, function (point) {
			total += point.y;
		});

		each(points, function (point) {
			// set start and end angle
			fraction = total ? point.y / total : 0;
			start = mathRound(cumulative * circ * precision) / precision;
			cumulative += fraction;
			end = mathRound(cumulative * circ * precision) / precision;

			// set the shape
			point.shapeType = 'arc';
			point.shapeArgs = {
				x: positions[0],
				y: positions[1],
				r: positions[2] / 2,
				innerR: positions[3] / 2,
				start: start,
				end: end
			};

			// center for the sliced out slice
			angle = (end + start) / 2;
			point.slicedTranslation = map([
				mathCos(angle) * slicedOffset + chart.plotLeft,
				mathSin(angle) * slicedOffset + chart.plotTop
			], mathRound);

			// set the anchor point for tooltips
			radiusX = mathCos(angle) * positions[2] / 2;
			radiusY = mathSin(angle) * positions[2] / 2;
			point.tooltipPos = [
				positions[0] + radiusX * 0.7,
				positions[1] + radiusY * 0.7
			];

			// set the anchor point for data labels
			point.labelPos = [
				positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
				positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
				positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
				positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
				positions[0] + radiusX, // landing point for connector
				positions[1] + radiusY, // a/a
				labelDistance < 0 ? // alignment
					'center' :
					angle < circ / 4 ? 'left' : 'right', // alignment
				angle // center angle
			];

			// API properties
			point.percentage = fraction * 100;
			point.total = total;

		});


		this.setTooltipPoints();
	},

	/**
	 * Render the slices
	 */
	render: function () {
		var series = this;

		// cache attributes for shapes
		series.getAttribs();

		this.drawPoints();

		// draw the mouse tracking area
		if (series.options.enableMouseTracking !== false) {
			series.drawTracker();
		}

		this.drawDataLabels();

		if (series.options.animation && series.animate) {
			series.animate();
		}

		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		series.isDirty = false; // means data is in accordance with what you see
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			groupTranslation,
			//center,
			graphic,
			group,
			shadow = series.options.shadow,
			shadowGroup,
			shapeArgs;

		// draw the slices
		each(series.points, function (point) {
			graphic = point.graphic;
			shapeArgs = point.shapeArgs;
			group = point.group;
			shadowGroup = point.shadowGroup;

			// put the shadow behind all points
			if (shadow && !shadowGroup) {
				shadowGroup = point.shadowGroup = renderer.g('shadow')
					.attr({ zIndex: 4 })
					.add();
			}

			// create the group the first time
			if (!group) {
				group = point.group = renderer.g('point')
					.attr({ zIndex: 5 })
					.add();
			}

			// if the point is sliced, use special translation, else use plot area traslation
			groupTranslation = point.sliced ? point.slicedTranslation : [chart.plotLeft, chart.plotTop];
			group.translate(groupTranslation[0], groupTranslation[1]);
			if (shadowGroup) {
				shadowGroup.translate(groupTranslation[0], groupTranslation[1]);
			}

			// draw the slice
			if (graphic) {
				graphic.animate(shapeArgs);
			} else {
				point.graphic =
					renderer.arc(shapeArgs)
					.attr(extend(
						point.pointAttr[NORMAL_STATE],
						{ 'stroke-linejoin': 'round' }
					))
					.add(point.group)
					.shadow(shadow, shadowGroup);
			}

			// detect point specific visibility
			if (point.visible === false) {
				point.setVisible(false);
			}

		});

	},

	/**
	 * Override the base drawDataLabels method by pie specific functionality
	 */
	drawDataLabels: function () {
		var series = this,
			data = series.data,
			point,
			chart = series.chart,
			options = series.options.dataLabels,
			connectorPadding = pick(options.connectorPadding, 10),
			connectorWidth = pick(options.connectorWidth, 1),
			connector,
			connectorPath,
			softConnector = pick(options.softConnector, true),
			distanceOption = options.distance,
			seriesCenter = series.center,
			radius = seriesCenter[2] / 2,
			centerY = seriesCenter[1],
			outside = distanceOption > 0,
			dataLabel,
			labelPos,
			labelHeight,
			halves = [// divide the points into right and left halves for anti collision
				[], // right
				[]  // left
			],
			x,
			y,
			visibility,
			rankArr,
			sort,
			i = 2,
			j;

		// get out if not enabled
		if (!options.enabled) {
			return;
		}

		// run parent method
		Series.prototype.drawDataLabels.apply(series);

		// arrange points for detection collision
		each(data, function (point) {
			if (point.dataLabel) { // it may have been cancelled in the base method (#407)
				halves[
					point.labelPos[7] < mathPI / 2 ? 0 : 1
				].push(point);
			}
		});
		halves[1].reverse();

		// define the sorting algorithm
		sort = function (a, b) {
			return b.y - a.y;
		};

		// assume equal label heights
		labelHeight = halves[0][0] && halves[0][0].dataLabel && halves[0][0].dataLabel.getBBox().height;

		/* Loop over the points in each quartile, starting from the top and bottom
		 * of the pie to detect overlapping labels.
		 */
		while (i--) {

			var slots = [],
				slotsLength,
				usedSlots = [],
				points = halves[i],
				pos,
				length = points.length,
				slotIndex;


			// build the slots
			for (pos = centerY - radius - distanceOption; pos <= centerY + radius + distanceOption; pos += labelHeight) {
				slots.push(pos);
				// visualize the slot
				/*
				var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
					slotY = pos + chart.plotTop;
				if (!isNaN(slotX)) {
					chart.renderer.rect(slotX, slotY - 7, 100, labelHeight)
						.attr({
							'stroke-width': 1,
							stroke: 'silver'
						})
						.add();
					chart.renderer.text('Slot '+ (slots.length - 1), slotX, slotY + 4)
						.attr({
							fill: 'silver'
						}).add();
				}
				// */
			}
			slotsLength = slots.length;

			// if there are more values than available slots, remove lowest values
			if (length > slotsLength) {
				// create an array for sorting and ranking the points within each quarter
				rankArr = [].concat(points);
				rankArr.sort(sort);
				j = length;
				while (j--) {
					rankArr[j].rank = j;
				}
				j = length;
				while (j--) {
					if (points[j].rank >= slotsLength) {
						points.splice(j, 1);
					}
				}
				length = points.length;
			}

			// The label goes to the nearest open slot, but not closer to the edge than
			// the label's index.
			for (j = 0; j < length; j++) {

				point = points[j];
				labelPos = point.labelPos;

				var closest = 9999,
					distance,
					slotI;

				// find the closest slot index
				for (slotI = 0; slotI < slotsLength; slotI++) {
					distance = mathAbs(slots[slotI] - labelPos[1]);
					if (distance < closest) {
						closest = distance;
						slotIndex = slotI;
					}
				}

				// if that slot index is closer to the edges of the slots, move it
				// to the closest appropriate slot
				if (slotIndex < j && slots[j] !== null) { // cluster at the top
					slotIndex = j;
				} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
					slotIndex = slotsLength - length + j;
					while (slots[slotIndex] === null) { // make sure it is not taken
						slotIndex++;
					}
				} else {
					// Slot is taken, find next free slot below. In the next run, the next slice will find the
					// slot above these, because it is the closest one
					while (slots[slotIndex] === null) { // make sure it is not taken
						slotIndex++;
					}
				}

				usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
				slots[slotIndex] = null; // mark as taken
			}
			// sort them in order to fill in from the top
			usedSlots.sort(sort);


			// now the used slots are sorted, fill them up sequentially
			for (j = 0; j < length; j++) {

				point = points[j];
				labelPos = point.labelPos;
				dataLabel = point.dataLabel;
				var slot = usedSlots.pop(),
					naturalY = labelPos[1];

				visibility = point.visible === false ? HIDDEN : VISIBLE;
				slotIndex = slot.i;

				// if the slot next to currrent slot is free, the y value is allowed
				// to fall back to the natural position
				y = slot.y;
				if ((naturalY > y && slots[slotIndex + 1] !== null) ||
						(naturalY < y &&  slots[slotIndex - 1] !== null)) {
					y = naturalY;
				}

				// get the x - use the natural x position for first and last slot, to prevent the top
				// and botton slice connectors from touching each other on either side
				x = series.getX(slotIndex === 0 || slotIndex === slots.length - 1 ? naturalY : y, i);

				// move or place the data label
				dataLabel
					.attr({
						visibility: visibility,
						align: labelPos[6]
					})[dataLabel.moved ? 'animate' : 'attr']({
						x: x + options.x +
							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
						y: y + options.y
					});
				dataLabel.moved = true;

				// draw the connector
				if (outside && connectorWidth) {
					connector = point.connector;

					connectorPath = softConnector ? [
						M,
						x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
						'C',
						x, y, // first break, next to the label
						2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
						labelPos[2], labelPos[3], // second break
						L,
						labelPos[4], labelPos[5] // base
					] : [
						M,
						x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
						L,
						labelPos[2], labelPos[3], // second break
						L,
						labelPos[4], labelPos[5] // base
					];

					if (connector) {
						connector.animate({ d: connectorPath });
						connector.attr('visibility', visibility);

					} else {
						point.connector = connector = series.chart.renderer.path(connectorPath).attr({
							'stroke-width': connectorWidth,
							stroke: options.connectorColor || point.color || '#606060',
							visibility: visibility,
							zIndex: 3
						})
						.translate(chart.plotLeft, chart.plotTop)
						.add();
					}
				}
			}
		}
	},

	/**
	 * Draw point specific tracker objects. Inherit directly from column series.
	 */
	drawTracker: ColumnSeries.prototype.drawTracker,

	/**
	 * Pies don't have point marker symbols
	 */
	getSymbol: function () {}

});
seriesTypes.pie = PieSeries;

/* ****************************************************************************
 * Start data grouping module												 *
 ******************************************************************************/
/*jslint white:true */
var DATA_GROUPING = 'dataGrouping',
	seriesProto = Series.prototype,
	baseProcessData = seriesProto.processData,
	baseGeneratePoints = seriesProto.generatePoints,
	baseDestroy = seriesProto.destroy,
	baseTooltipHeaderFormatter = seriesProto.tooltipHeaderFormatter,
	NUMBER = 'number',
	
	commonOptions = {
			approximation: 'average', // average, open, high, low, close, sum
			//forced: undefined,
			groupPixelWidth: 2,
			// the first one is the point or start value, the second is the start value if we're dealing with range,
			// the third one is the end value if dealing with a range
			dateTimeLabelFormats: hash( 
				MILLISECOND, ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
				SECOND, ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
				MINUTE, ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
				HOUR, ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
				DAY, ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
				WEEK, ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
				MONTH, ['%B %Y', '%B', '-%B %Y'],
				YEAR, ['%Y', '%Y', '-%Y']
			)
			// smoothed = false, // enable this for navigator series only
		},
		
		// units are defined in a separate array to allow complete overriding in case of a user option
		defaultDataGroupingUnits = [[
				MILLISECOND, // unit name
				[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
			], [
				SECOND,
				[1, 2, 5, 10, 15, 30]
			], [
				MINUTE,
				[1, 2, 5, 10, 15, 30]
			], [
				HOUR,
				[1, 2, 3, 4, 6, 8, 12]
			], [
				DAY,
				[1]
			], [
				WEEK,
				[1]
			], [
				MONTH,
				[1, 3, 6]
			], [
				YEAR,
				null
			]
		],
	
	/**
	 * Define the available approximation types. The data grouping approximations takes an array
	 * or numbers as the first parameter. In case of ohlc, four arrays are sent in as four parameters.
	 * Each array consists only of numbers. In case null values belong to the group, the property
	 * .hasNulls will be set to true on the array.
	 */
	approximations = {
		sum: function (arr) {
			var len = arr.length, 
				ret;
				
			// 1. it consists of nulls exclusively
			if (!len && arr.hasNulls) {
				ret = null;
			// 2. it has a length and real values
			} else if (len) {
				ret = 0;
				while (len--) {
					ret += arr[len];
				}
			}
			// 3. it has zero length, so just return undefined 
			// => doNothing()
			
			return ret;
		},
		average: function (arr) {
			var len = arr.length,
				ret = approximations.sum(arr);
				
			// If we have a number, return it divided by the length. If not, return
			// null or undefined based on what the sum method finds.
			if (typeof ret === NUMBER && len) {
				ret = ret / len;
			}
			
			return ret;
		},
		open: function (arr) {
			return arr.length ? arr[0] : (arr.hasNulls ? null : UNDEFINED);
		},
		high: function (arr) {
			return arr.length ? arrayMax(arr) : (arr.hasNulls ? null : UNDEFINED);
		},
		low: function (arr) {
			return arr.length ? arrayMin(arr) : (arr.hasNulls ? null : UNDEFINED);
		},
		close: function (arr) {
			return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : UNDEFINED);
		},
		// ohlc is a special case where a multidimensional array is input and an array is output
		ohlc: function (open, high, low, close) {
			open = approximations.open(open);
			high = approximations.high(high);
			low = approximations.low(low);
			close = approximations.close(close);
			
			if (typeof open === NUMBER || typeof high === NUMBER || typeof low === NUMBER || typeof close === NUMBER) {
				return [open, high, low, close];
			} 
			// else, return is undefined
		}
	};

/*jslint white:false */

/**
 * Takes parallel arrays of x and y data and groups the data into intervals defined by groupPositions, a collection
 * of starting x values for each group.
 */
seriesProto.groupData = function (xData, yData, groupPositions, approximation) {
	var series = this,
		data = series.data,
		dataOptions = series.options.data,
		groupedXData = [],
		groupedYData = [],
		dataLength = xData.length,
		pointX,
		pointY,
		groupedY,
		handleYData = !!yData, // when grouping the fake extended axis for panning, we don't need to consider y
		values1 = [],
		values2 = [],
		values3 = [],
		values4 = [],
		approximationFn = typeof approximation === 'function' ? approximation : approximations[approximation],
		i;
	
		for (i = 0; i <= dataLength; i++) {

			// when a new group is entered, summarize and initiate the previous group
			while ((groupPositions[1] !== UNDEFINED && xData[i] >= groupPositions[1]) ||
					i === dataLength) { // get the last group

				// get group x and y 
				pointX = groupPositions.shift();				
				groupedY = approximationFn(values1, values2, values3, values4);
				
				// push the grouped data		
				if (groupedY !== UNDEFINED) {
					groupedXData.push(pointX);
					groupedYData.push(groupedY);
				}
				
				// reset the aggregate arrays
				values1 = [];
				values2 = [];
				values3 = [];
				values4 = [];
				
				// don't loop beyond the last group
				if (i === dataLength) {
					break;
				}
			}
			
			// break out
			if (i === dataLength) {
				break;
			}
			
			// for each raw data point, push it to an array that contains all values for this specific group
			pointY = handleYData ? yData[i] : null;
			if (approximation === 'ohlc') {
				
				var index = series.cropStart + i,
					point = (data && data[index]) || series.pointClass.prototype.applyOptions.apply({}, [dataOptions[index]]),
					open = point.open,
					high = point.high,
					low = point.low,
					close = point.close;
				
				
				if (typeof open === NUMBER) {
					values1.push(open);
				} else if (open === null) {
					values1.hasNulls = true;
				}
				
				if (typeof high === NUMBER) {
					values2.push(high);
				} else if (high === null) {
					values2.hasNulls = true;
				}
				
				if (typeof low === NUMBER) {
					values3.push(low);
				} else if (low === null) {
					values3.hasNulls = true;
				}
				
				if (typeof close === NUMBER) {
					values4.push(close);
				} else if (close === null) {
					values4.hasNulls = true;
				}
			} else {
				if (typeof pointY === NUMBER) {
					values1.push(pointY);
				} else if (pointY === null) {
					values1.hasNulls = true;
				}
			}

		}
	return [groupedXData, groupedYData];
};

/**
 * Extend the basic processData method, that crops the data to the current zoom
 * range, with data grouping logic.
 */
seriesProto.processData = function () {
	var series = this,
		options = series.options,
		dataGroupingOptions = options[DATA_GROUPING],
		groupingEnabled = dataGroupingOptions && dataGroupingOptions.enabled,
		groupedData = series.groupedData,
		hasGroupedData;

	// run base method
	series.forceCrop = groupingEnabled; // #334
	
	// skip if processData returns false or if grouping is disabled (in that order)
	if (baseProcessData.apply(series, arguments) === false || !groupingEnabled) {
		return;
		
	} else {
		// clear previous groups, #622, #740
		each(groupedData || [], function (point, i) {
			if (point) {
				groupedData[i] = point.destroy ? point.destroy() : null;
			}
		});
	}
	
	var i,
		chart = series.chart,
		processedXData = series.processedXData,
		processedYData = series.processedYData,
		plotSizeX = chart.plotSizeX,
		xAxis = series.xAxis,
		groupPixelWidth = pick(xAxis.groupPixelWidth, dataGroupingOptions.groupPixelWidth),
		dataLength = processedXData.length,
		chartSeries = chart.series,
		nonGroupedPointRange = series.pointRange;

	// attempt to solve #334: if multiple series are compared on the same x axis, give them the same
	// group pixel width
	if (!xAxis.groupPixelWidth) {
		i = chartSeries.length;
		while (i--) {
			if (chartSeries[i].xAxis === xAxis && chartSeries[i].options[DATA_GROUPING]) {
				groupPixelWidth = mathMax(groupPixelWidth, chartSeries[i].options[DATA_GROUPING].groupPixelWidth);
			}
		}
		xAxis.groupPixelWidth = groupPixelWidth;
		
	}

	// Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth
	if (dataLength > (plotSizeX / groupPixelWidth) || dataGroupingOptions.forced) {
		hasGroupedData = true;

		series.points = null; // force recreation of point instances in series.translate

		var extremes = xAxis.getExtremes(),
			xMin = extremes.min,
			xMax = extremes.max,
			groupIntervalFactor = (xAxis.getGroupIntervalFactor && xAxis.getGroupIntervalFactor(xMin, xMax, processedXData)) || 1,
			interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,			
			groupPositions = (xAxis.getNonLinearTimeTicks || getTimeTicks)(
				normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
				xMin, 
				xMax, 
				null, 
				processedXData, 
				series.closestPointRange
			),
			groupedXandY = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),
			groupedXData = groupedXandY[0],
			groupedYData = groupedXandY[1];
			
		// prevent the smoothed data to spill out left and right, and make
		// sure data is not shifted to the left
		if (dataGroupingOptions.smoothed) {
			i = groupedXData.length - 1;
			groupedXData[i] = xMax;
			while (i-- && i > 0) {
				groupedXData[i] += interval / 2;
			}
			groupedXData[0] = xMin;
		}

		// record what data grouping values were used
		series.currentDataGrouping = groupPositions.info;
		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
			series.pointRange = groupPositions.info.totalRange;
		}
		series.closestPointRange = groupPositions.info.totalRange;
		
		// set series props
		series.processedXData = groupedXData;
		series.processedYData = groupedYData;
	} else {
		series.currentDataGrouping = null;
		series.pointRange = nonGroupedPointRange;
	}

	series.hasGroupedData = hasGroupedData;
};

seriesProto.generatePoints = function () {
	var series = this;

	baseGeneratePoints.apply(series);

	// record grouped data in order to let it be destroyed the next time processData runs
	series.groupedData = series.hasGroupedData ? series.points : null;
};

/**
 * Make the tooltip's header reflect the grouped range
 */
seriesProto.tooltipHeaderFormatter = function (key) {
	var series = this,
		options = series.options,
		tooltipOptions = series.tooltipOptions,
		dataGroupingOptions = options.dataGrouping,
		xDateFormat = tooltipOptions.xDateFormat,
		xDateFormatEnd,
		xAxis = series.xAxis,
		currentDataGrouping,
		dateTimeLabelFormats,
		labelFormats,
		formattedKey,
		n,
		ret;
	
	// apply only to grouped series
	if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions) {
		
		// set variables
		currentDataGrouping = series.currentDataGrouping;		
		dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;
		
		// if we have grouped data, use the grouping information to get the right format
		if (currentDataGrouping) {
			labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
			if (currentDataGrouping.count === 1) {
				xDateFormat = labelFormats[0];
			} else {
				xDateFormat = labelFormats[1];
				xDateFormatEnd = labelFormats[2];
			} 
		// if not grouped, and we don't have set the xDateFormat option, get the best fit,
		// so if the least distance between points is one minute, show it, but if the 
		// least distance is one day, skip hours and minutes etc.
		} else if (!xDateFormat) {
			for (n in timeUnits) {
				if (timeUnits[n] >= xAxis.closestPointRange) {
					xDateFormat = dateTimeLabelFormats[n][0];
					break;
				}	
			}		
		}
		
		// now format the key
		formattedKey = dateFormat(xDateFormat, key);
		if (xDateFormatEnd) {
			formattedKey += dateFormat(xDateFormatEnd, key + currentDataGrouping.totalRange - 1);
		}
		
		// return the replaced format
		ret = tooltipOptions.headerFormat.replace('{point.key}', formattedKey);
	
	// else, fall back to the regular formatter
	} else {
		ret = baseTooltipHeaderFormatter.apply(series, [key]);
	}
	
	return ret;
};

/**
 * Extend the series destroyer
 */
seriesProto.destroy = function () {
	var series = this,
		groupedData = series.groupedData || [],
		i = groupedData.length;

	while (i--) {
		if (groupedData[i]) {
			groupedData[i].destroy();
		}
	}
	baseDestroy.apply(series);
};


// Extend the plot options

// line types
defaultPlotOptions.line[DATA_GROUPING] =
	defaultPlotOptions.spline[DATA_GROUPING] =
	defaultPlotOptions.area[DATA_GROUPING] =
	defaultPlotOptions.areaspline[DATA_GROUPING] = commonOptions;

// bar-like types (OHLC and candleticks inherit this as the classes are not yet built)
defaultPlotOptions.column[DATA_GROUPING] = merge(commonOptions, {
		approximation: 'sum',
		groupPixelWidth: 10
});
/* ****************************************************************************
 * End data grouping module												   *
 ******************************************************************************//* ****************************************************************************
 * Start OHLC series code													 *
 *****************************************************************************/

// 1 - Set default options
defaultPlotOptions.ohlc = merge(defaultPlotOptions.column, {
	lineWidth: 1,
	dataGrouping: {
		approximation: 'ohlc',
		enabled: true,
		groupPixelWidth: 5 // allows to be packed tighter than candlesticks
	},
	tooltip: {
		pointFormat: '<span style="color:{series.color};font-weight:bold">{series.name}</span><br/>' +
			'Open: {point.open}<br/>' +
			'High: {point.high}<br/>' +
			'Low: {point.low}<br/>' +
			'Close: {point.close}<br/>'	
	},
	states: {
		hover: {
			lineWidth: 3
		}
	},
	threshold: null
});

// 2- Create the OHLCPoint object
var OHLCPoint = extendClass(Point, {
	/**
	 * Apply the options containing the x and OHLC data and possible some extra properties.
	 * This is called on point init or from point.update. Extends base Point by adding
	 * multiple y-like values.
	 *
	 * @param {Object} options
	 */
	applyOptions: function (options) {
		var point = this,
			series = point.series,
			i = 0;


		// object input for example:
		// { x: Date(2010, 0, 1), open: 7.88, high: 7.99, low: 7.02, close: 7.65 }
		if (typeof options === 'object' && typeof options.length !== 'number') {

			// copy options directly to point
			extend(point, options);

			point.options = options;
		} else if (options.length) { // array
			// with leading x value
			if (options.length === 5) {
				if (typeof options[0] === 'string') {
					point.name = options[0];
				} else if (typeof options[0] === 'number') {
					point.x = options[0];
				}
				i++;
			}
			point.open = options[i++];
			point.high = options[i++];
			point.low = options[i++];
			point.close = options[i++];
		}

		/*
		 * If no x is set by now, get auto incremented value. All points must have an
		 * x value, however the y value can be null to create a gap in the series
		 */
		point.y = point.high;
		if (point.x === UNDEFINED && series) {
			point.x = series.autoIncrement();
		}
		return point;
	}

});

// 3 - Create the OHLCSeries object
var OHLCSeries = extendClass(seriesTypes.column, {
	type: 'ohlc',
	valueCount: 4, // four values per point
	pointClass: OHLCPoint,

	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'color',
		'stroke-width': 'lineWidth'
	},


	/**
	 * Translate data points from raw values x and y to plotX and plotY
	 */
	translate: function () {
		var series = this,
			yAxis = series.yAxis;

		seriesTypes.column.prototype.translate.apply(series);

		// do the translation
		each(series.points, function (point) {
			// the graphics
			if (point.open !== null) {
				point.plotOpen = yAxis.translate(point.open, 0, 1, 0, 1);
			}
			if (point.close !== null) {
				point.plotClose = yAxis.translate(point.close, 0, 1, 0, 1);
			}

		});
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			points = series.points,
			chart = series.chart,
			pointAttr,
			plotOpen,
			plotClose,
			crispCorr,
			halfWidth,
			path,
			graphic,
			crispX;


		each(points, function (point) {
			if (point.plotY !== UNDEFINED) {

				graphic = point.graphic;
				pointAttr = point.pointAttr[point.selected ? 'selected' : ''];

				// crisp vector coordinates
				crispCorr = (pointAttr['stroke-width'] % 2) / 2;
				crispX = mathRound(point.plotX) + crispCorr;
				halfWidth = mathRound(point.barW / 2);

				// the vertical stem
				path = [
					'M',
					crispX, mathRound(point.yBottom),
					'L',
					crispX, mathRound(point.plotY)
				];

				// open
				if (point.open !== null) {
					plotOpen = mathRound(point.plotOpen) + crispCorr;
					path.push(
						'M',
						crispX,
						plotOpen,
						'L',
						crispX - halfWidth,
						plotOpen
					);
				}

				// close
				if (point.close !== null) {
					plotClose = mathRound(point.plotClose) + crispCorr;
					path.push(
						'M',
						crispX,
						plotClose,
						'L',
						crispX + halfWidth,
						plotClose
					);
				}

				// create and/or update the graphic
				if (graphic) {
					graphic.animate({ d: path });
				} else {
					point.graphic = chart.renderer.path(path)
						.attr(pointAttr)
						.add(series.group);
				}

			}


		});

	},

	/**
	 * Disable animation
	 */
	animate: null


});
seriesTypes.ohlc = OHLCSeries;
/* ****************************************************************************
 * End OHLC series code													   *
 *****************************************************************************/
/* ****************************************************************************
 * Start Candlestick series code											  *
 *****************************************************************************/

// 1 - set default options
defaultPlotOptions.candlestick = merge(defaultPlotOptions.column, {
	dataGrouping: {
		approximation: 'ohlc',
		enabled: true
	},
	lineColor: 'black',
	lineWidth: 1,
	states: {
		hover: {
			lineWidth: 2
		}
	},
	tooltip: defaultPlotOptions.ohlc.tooltip,
	threshold: null,
	upColor: 'white'
});

// 2 - Create the CandlestickSeries object
var CandlestickSeries = extendClass(OHLCSeries, {
	type: 'candlestick',

	/**
	 * One-to-one mapping from options to SVG attributes
	 */
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		fill: 'color',
		stroke: 'lineColor',
		'stroke-width': 'lineWidth'
	},

	/**
	 * Postprocess mapping between options and SVG attributes
	 */
	getAttribs: function () {
		OHLCSeries.prototype.getAttribs.apply(this, arguments);
		var series = this,
			options = series.options,
			stateOptions = options.states,
			upColor = options.upColor,
			seriesDownPointAttr = merge(series.pointAttr);

		seriesDownPointAttr[''].fill = upColor;
		seriesDownPointAttr.hover.fill = stateOptions.hover.upColor || upColor;
		seriesDownPointAttr.select.fill = stateOptions.select.upColor || upColor;

		each(series.points, function (point) {
			if (point.open < point.close) {
				point.pointAttr = seriesDownPointAttr;
			}
		});
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,  //state = series.state,
			points = series.points,
			chart = series.chart,
			pointAttr,
			plotOpen,
			plotClose,
			topBox,
			bottomBox,
			crispCorr,
			crispX,
			graphic,
			path,
			halfWidth;


		each(points, function (point) {

			graphic = point.graphic;
			if (point.plotY !== UNDEFINED) {

				pointAttr = point.pointAttr[point.selected ? 'selected' : ''];

				// crisp vector coordinates
				crispCorr = (pointAttr['stroke-width'] % 2) / 2;
				crispX = mathRound(point.plotX) + crispCorr;
				plotOpen = mathRound(point.plotOpen) + crispCorr;
				plotClose = mathRound(point.plotClose) + crispCorr;
				topBox = math.min(plotOpen, plotClose);
				bottomBox = math.max(plotOpen, plotClose);
				halfWidth = mathRound(point.barW / 2);

				// create the path
				path = [
					'M',
					crispX - halfWidth, bottomBox,
					'L',
					crispX - halfWidth, topBox,
					'L',
					crispX + halfWidth, topBox,
					'L',
					crispX + halfWidth, bottomBox,
					'L',
					crispX - halfWidth, bottomBox,
					'M',
					crispX, bottomBox,
					'L',
					crispX, mathRound(point.yBottom),
					'M',
					crispX, topBox,
					'L',
					crispX, mathRound(point.plotY),
					'Z'
				];

				if (graphic) {
					graphic.animate({ d: path });
				} else {
					point.graphic = chart.renderer.path(path)
						.attr(pointAttr)
						.add(series.group);
				}

			}
		});

	}


});

seriesTypes.candlestick = CandlestickSeries;

/* ****************************************************************************
 * End Candlestick series code												*
 *****************************************************************************/
/* ****************************************************************************
 * Start Flags series code													*
 *****************************************************************************/

var symbols = SVGRenderer.prototype.symbols;

// 1 - set default options
defaultPlotOptions.flags = merge(defaultPlotOptions.column, {
	dataGrouping: null,
	fillColor: 'white',
	lineWidth: 1,
	pointRange: 0, // #673
	//radius: 2,
	shape: 'flag',
	stackDistance: 7,
	states: {
		hover: {
			lineColor: 'black',
			fillColor: '#FCFFC5'
		}
	},
	style: {
		fontSize: '11px',
		fontWeight: 'bold',
		textAlign: 'center'
	},
	threshold: null,
	y: -30
});

// 2 - Create the CandlestickSeries object
seriesTypes.flags = extendClass(seriesTypes.column, {
	type: 'flags',
	sorted: false,
	noSharedTooltip: true,
	/**
	 * Inherit the initialization from base Series
	 */
	init: Series.prototype.init,

	/**
	 * One-to-one mapping from options to SVG attributes
	 */
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		fill: 'fillColor',
		stroke: 'color',
		'stroke-width': 'lineWidth',
		r: 'radius'
	},

	/**
	 * Extend the translate method by placing the point on the related series
	 */
	translate: function () {

		seriesTypes.column.prototype.translate.apply(this);

		var series = this,
			options = series.options,
			chart = series.chart,
			points = series.points,
			cursor = points.length - 1,
			point,
			lastPoint,
			optionsOnSeries = options.onSeries,
			onSeries = optionsOnSeries && chart.get(optionsOnSeries),
			step = onSeries && onSeries.options.step,
			onData = onSeries && onSeries.points,
			i = onData && onData.length,
			leftPoint,
			lastX,
			rightPoint;

		// relate to a master series
		if (onSeries && onSeries.visible && i) {
			lastX = onData[i - 1].x;

			// sort the data points
			points.sort(function (a, b) {
				return (a.x - b.x);
			});

			while (i-- && points[cursor]) {
				point = points[cursor];
				leftPoint = onData[i];
				
				
				if (leftPoint.x <= point.x && leftPoint.plotY !== UNDEFINED) {
					
					if (point.x <= lastX) { // #803
					
						point.plotY = leftPoint.plotY;
					
						// interpolate between points, #666
						if (leftPoint.x < point.x && !step) { 
							rightPoint = onData[i + 1];
							if (rightPoint && rightPoint.plotY !== UNDEFINED) {
								point.plotY += 
									((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) * // the distance ratio, between 0 and 1 
									(rightPoint.plotY - leftPoint.plotY); // the y distance
							}
						}
					}
					cursor--;
					i++; // check again for points in the same x position
					if (cursor < 0) {
						break;
					}
				}
			}
		}

		each(points, function (point, i) {
			// place on y axis or custom position
			if (point.plotY === UNDEFINED) { // either on axis, outside series range or hidden series
				point.plotY = chart.plotHeight;
			}
			// if multiple flags appear at the same x, order them into a stack
			lastPoint = points[i - 1];
			if (lastPoint && lastPoint.plotX === point.plotX) {
				if (lastPoint.stackIndex === UNDEFINED) {
					lastPoint.stackIndex = 0;
				}
				point.stackIndex = lastPoint.stackIndex + 1;
			}
					
		});


	},

	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			pointAttr,
			points = series.points,
			chart = series.chart,
			renderer = chart.renderer,
			plotX,
			plotY,
			options = series.options,
			optionsY = options.y,
			shape = options.shape,
			box,
			bBox,
			i,
			point,
			graphic,
			connector,
			stackIndex,
			crisp = (options.lineWidth % 2 / 2),
			anchorX,
			anchorY;

		i = points.length;
		while (i--) {
			point = points[i];
			plotX = point.plotX + crisp;
			stackIndex = point.stackIndex;
			plotY = point.plotY;
			if (plotY !== UNDEFINED) {
				plotY = point.plotY + optionsY + crisp - (stackIndex !== UNDEFINED && stackIndex * options.stackDistance);
			}
			anchorX = stackIndex ? UNDEFINED : point.plotX + crisp; // skip connectors for higher level stacked points
			anchorY = stackIndex ? UNDEFINED : point.plotY;

			graphic = point.graphic;
			connector = point.connector;

			// only draw the point if y is defined
			if (plotY !== UNDEFINED) {
				// shortcuts
				pointAttr = point.pointAttr[point.selected ? 'select' : ''];
				if (graphic) { // update
					graphic.attr({
						x: plotX,
						y: plotY,
						r: pointAttr.r,
						anchorX: anchorX,
						anchorY: anchorY
					});
				} else {
					graphic = point.graphic = renderer.label(
						point.options.title || options.title || 'A',
						plotX,
						plotY,
						shape,
						anchorX,
						anchorY
					)
					.css(merge(options.style, point.style))
					.attr(pointAttr)
					.attr({
						align: shape === 'flag' ? 'left' : 'center',
						width: options.width,
						height: options.height
					})
					.add(series.group)
					.shadow(options.shadow);

				}

				// get the bounding box
				box = graphic.box;
				bBox = box.getBBox();

				// set the shape arguments for the tracker element
				point.shapeArgs = extend(
					bBox,
					{
						x: plotX - (shape === 'flag' ? 0 : box.attr('width') / 2), // flags align left, else align center
						y: plotY
					}
				);

			} else if (graphic) {
				point.graphic = graphic.destroy();
			}

		}

	},

	/**
	 * Extend the column trackers with listeners to expand and contract stacks
	 */
	drawTracker: function () {
		var series = this;

		seriesTypes.column.prototype.drawTracker.apply(series);

		// put each point in front on mouse over, this allows readability of vertically
		// stacked elements as well as tight points on the x axis
		each(series.points, function (point) {
			addEvent(point.tracker.element, 'mouseover', function () {
				point.graphic.toFront();
			});
		});
	},

	/**
	 * Override the regular tooltip formatter by returning the point text given
	 * in the options
	 */
	tooltipFormatter: function (item) {
		return item.point.text;
	},

	/**
	 * Disable animation
	 */
	animate: function () {}

});

// create the flag icon with anchor
symbols.flag = function (x, y, w, h, options) {
	var anchorX = (options && options.anchorX) || x,
		anchorY = (options &&  options.anchorY) || y;

	return [
		'M', anchorX, anchorY,
		'L', x, y + h,
		x, y,
		x + w, y,
		x + w, y + h,
		x, y + h,
		'M', anchorX, anchorY,
		'Z'
	];
};

// create the circlepin and squarepin icons with anchor
each(['circle', 'square'], function (shape) {
	symbols[shape + 'pin'] = function (x, y, w, h, options) {

		var anchorX = options && options.anchorX,
			anchorY = options &&  options.anchorY,
			path = symbols[shape](x, y, w, h);

		if (anchorX && anchorY) {
			path.push('M', anchorX, y + h, 'L', anchorX, anchorY);
		}

		return path;
	};
});

// The symbol callbacks are generated on the SVGRenderer object in all browsers. Even
// VML browsers need this in order to generate shapes in export. Now share
// them with the VMLRenderer.
if (Renderer === VMLRenderer) {
	each(['flag', 'circlepin', 'squarepin'], function (shape) {
		VMLRenderer.prototype.symbols[shape] = symbols[shape];
	});
}

/* ****************************************************************************
 * End Flags series code													  *
 *****************************************************************************/

// constants
var MOUSEDOWN = hasTouch ? 'touchstart' : 'mousedown',
	MOUSEMOVE = hasTouch ? 'touchmove' : 'mousemove',
	MOUSEUP = hasTouch ? 'touchend' : 'mouseup';




/* ****************************************************************************
 * Start Scroller code														*
 *****************************************************************************/
/*jslint white:true */
var buttonGradient = hash(
		LINEAR_GRADIENT, { x1: 0, y1: 0, x2: 0, y2: 1 },
		STOPS, [
			[0, '#FFF'],
			[1, '#CCC']
		]
	),
	units = [].concat(defaultDataGroupingUnits); // copy

// add more resolution to units
units[4] = [DAY, [1, 2, 3, 4]]; // allow more days
units[5] = [WEEK, [1, 2, 3]]; // allow more weeks

extend(defaultOptions, {
	navigator: {
		//enabled: true,
		handles: {
			backgroundColor: '#FFF',
			borderColor: '#666'
		},
		height: 40,
		margin: 10,
		maskFill: 'rgba(255, 255, 255, 0.75)',
		outlineColor: '#444',
		outlineWidth: 1,
		series: {
			type: 'areaspline',
			color: '#4572A7',
			compare: null,
			fillOpacity: 0.4,
			dataGrouping: {
				approximation: 'average',
				groupPixelWidth: 2,
				smoothed: true,
				units: units
			},
			dataLabels: {
				enabled: false
			},
			id: PREFIX + 'navigator-series',
			lineColor: '#4572A7',
			lineWidth: 1,
			marker: {
				enabled: false
			},
			pointRange: 0,
			shadow: false
		},
		//top: undefined,
		xAxis: {
			tickWidth: 0,
			lineWidth: 0,
			gridLineWidth: 1,
			tickPixelInterval: 200,
			labels: {
				align: 'left',
				x: 3,
				y: -4
			}
		},
		yAxis: {
			gridLineWidth: 0,
			startOnTick: false,
			endOnTick: false,
			minPadding: 0.1,
			maxPadding: 0.1,
			labels: {
				enabled: false
			},
			title: {
				text: null
			},
			tickWidth: 0
		}
	},
	scrollbar: {
		//enabled: true
		height: hasTouch ? 20 : 14,
		barBackgroundColor: buttonGradient,
		barBorderRadius: 2,
		barBorderWidth: 1,
		barBorderColor: '#666',
		buttonArrowColor: '#666',
		buttonBackgroundColor: buttonGradient,
		buttonBorderColor: '#666',
		buttonBorderRadius: 2,
		buttonBorderWidth: 1,
		rifleColor: '#666',
		trackBackgroundColor: hash(
			LINEAR_GRADIENT, { x1: 0, y1: 0, x2: 0, y2: 1 },
			STOPS, [
				[0, '#EEE'],
				[1, '#FFF']
			]
		),
		trackBorderColor: '#CCC',
		trackBorderWidth: 1
		// trackBorderRadius: 0
	}
});
/*jslint white:false */

/**
 * The Scroller class
 * @param {Object} chart
 */
Highcharts.Scroller = function (chart) {

	var renderer = chart.renderer,
		chartOptions = chart.options,
		navigatorOptions = chartOptions.navigator,
		navigatorEnabled = navigatorOptions.enabled,
		navigatorLeft,
		navigatorWidth,
		navigatorSeries,
		navigatorData,
		scrollbarOptions = chartOptions.scrollbar,
		scrollbarEnabled = scrollbarOptions.enabled,
		grabbedLeft,
		grabbedRight,
		grabbedCenter,
		otherHandlePos,
		dragOffset,
		hasDragged,
		xAxis,
		yAxis,
		zoomedMin,
		zoomedMax,
		range,

		bodyStyle = document.body.style,
		defaultBodyCursor,

		handlesOptions = navigatorOptions.handles,
		height = navigatorEnabled ? navigatorOptions.height : 0,
		outlineWidth = navigatorOptions.outlineWidth,
		scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0,
		outlineHeight = height + scrollbarHeight,
		barBorderRadius = scrollbarOptions.barBorderRadius,
		top,
		halfOutline = outlineWidth / 2,
		outlineTop,
		scrollerLeft,
		scrollerWidth,
		rendered,
		baseSeriesOption = navigatorOptions.baseSeries,
		baseSeries = chart.series[baseSeriesOption] ||
			(typeof baseSeriesOption === 'string' && chart.get(baseSeriesOption)) ||
			chart.series[0],

		// element wrappers
		leftShade,
		rightShade,
		outline,
		handles = [],
		scrollbarGroup,
		scrollbarTrack,
		scrollbar,
		scrollbarRifles,
		scrollbarButtons = [],
		elementsToDestroy = []; // Array containing the elements to destroy when Scroller is destroyed

	chart.resetZoomEnabled = false;

	/**
	 * Return the top of the navigation 
	 */
	function getAxisTop(chartHeight) {
		return navigatorOptions.top || chartHeight - height - scrollbarHeight - chartOptions.chart.spacingBottom;
	}

	/**
	 * Draw one of the handles on the side of the zoomed range in the navigator
	 * @param {Number} x The x center for the handle
	 * @param {Number} index 0 for left and 1 for right
	 */
	function drawHandle(x, index) {

		var attr = {
				fill: handlesOptions.backgroundColor,
				stroke: handlesOptions.borderColor,
				'stroke-width': 1
			},
			tempElem;

		// create the elements
		if (!rendered) {

			// the group
			handles[index] = renderer.g()
				.css({ cursor: 'e-resize' })
				.attr({ zIndex: 4 - index }) // zIndex = 3 for right handle, 4 for left
				.add();

			// the rectangle
			tempElem = renderer.rect(-4.5, 0, 9, 16, 3, 1)
				.attr(attr)
				.add(handles[index]);
			elementsToDestroy.push(tempElem);

			// the rifles
			tempElem = renderer.path([
					'M',
					-1.5, 4,
					'L',
					-1.5, 12,
					'M',
					0.5, 4,
					'L',
					0.5, 12
				]).attr(attr)
				.add(handles[index]);
			elementsToDestroy.push(tempElem);
		}

		handles[index].translate(scrollerLeft + scrollbarHeight + parseInt(x, 10), top + height / 2 - 8);
	}

	/**
	 * Draw the scrollbar buttons with arrows
	 * @param {Number} index 0 is left, 1 is right
	 */
	function drawScrollbarButton(index) {
		var tempElem;
		if (!rendered) {

			scrollbarButtons[index] = renderer.g().add(scrollbarGroup);

			tempElem = renderer.rect(
				-0.5,
				-0.5,
				scrollbarHeight + 1, // +1 to compensate for crispifying in rect method
				scrollbarHeight + 1,
				scrollbarOptions.buttonBorderRadius,
				scrollbarOptions.buttonBorderWidth
			).attr({
				stroke: scrollbarOptions.buttonBorderColor,
				'stroke-width': scrollbarOptions.buttonBorderWidth,
				fill: scrollbarOptions.buttonBackgroundColor
			}).add(scrollbarButtons[index]);
			elementsToDestroy.push(tempElem);

			tempElem = renderer.path([
				'M',
				scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 - 3,
				'L',
				scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 + 3,
				scrollbarHeight / 2 + (index ? 2 : -2), scrollbarHeight / 2
			]).attr({
				fill: scrollbarOptions.buttonArrowColor
			}).add(scrollbarButtons[index]);
			elementsToDestroy.push(tempElem);
		}

		// adjust the right side button to the varying length of the scroll track
		if (index) {
			scrollbarButtons[index].attr({
				translateX: scrollerWidth - scrollbarHeight
			});
		}
	}

	/**
	 * Render the navigator and scroll bar
	 * @param {Number} min X axis value minimum
	 * @param {Number} max X axis value maximum
	 * @param {Number} pxMin Pixel value minimum
	 * @param {Number} pxMax Pixel value maximum
	 */
	function render(min, max, pxMin, pxMax) {

		// don't render the navigator until we have data (#486)
		if (isNaN(min)) {
			return;
		}

		var strokeWidth,
			scrollbarStrokeWidth = scrollbarOptions.barBorderWidth,
			centerBarX;

		outlineTop = top + halfOutline;
		navigatorLeft = pick(
			xAxis.left,
			chart.plotLeft + scrollbarHeight // in case of scrollbar only, without navigator
		);
		navigatorWidth = pick(xAxis.len, chart.plotWidth - 2 * scrollbarHeight);
		scrollerLeft = navigatorLeft - scrollbarHeight;
		scrollerWidth = navigatorWidth + 2 * scrollbarHeight;

		// Set the scroller x axis extremes to reflect the total. The navigator extremes
		// should always be the extremes of the union of all series in the chart as
		// well as the navigator series.
		if (xAxis.getExtremes) {
			var baseExtremes = chart.xAxis[0].getExtremes(), // the base
				noBase = baseExtremes.dataMin === null,
				navExtremes = xAxis.getExtremes(),
				newMin = mathMin(baseExtremes.dataMin, navExtremes.dataMin),
				newMax = mathMax(baseExtremes.dataMax, navExtremes.dataMax);

			if (!noBase && (newMin !== navExtremes.min || newMax !== navExtremes.max)) {
				xAxis.setExtremes(newMin, newMax, true, false);
			}
		}

		// get the pixel position of the handles
		pxMin = pick(pxMin, xAxis.translate(min));
		pxMax = pick(pxMax, xAxis.translate(max));


		// handles are allowed to cross
		zoomedMin = pInt(mathMin(pxMin, pxMax));
		zoomedMax = pInt(mathMax(pxMin, pxMax));
		range = zoomedMax - zoomedMin;

		// on first render, create all elements
		if (!rendered) {

			if (navigatorEnabled) {

				leftShade = renderer.rect()
					.attr({
						fill: navigatorOptions.maskFill,
						zIndex: 3
					}).add();
				rightShade = renderer.rect()
					.attr({
						fill: navigatorOptions.maskFill,
						zIndex: 3
					}).add();
				outline = renderer.path()
					.attr({
						'stroke-width': outlineWidth,
						stroke: navigatorOptions.outlineColor,
						zIndex: 3
					})
					.add();
			}

			if (scrollbarEnabled) {

				// draw the scrollbar group
				scrollbarGroup = renderer.g().add();

				// the scrollbar track
				strokeWidth = scrollbarOptions.trackBorderWidth;
				scrollbarTrack = renderer.rect().attr({
					y: -strokeWidth % 2 / 2,
					fill: scrollbarOptions.trackBackgroundColor,
					stroke: scrollbarOptions.trackBorderColor,
					'stroke-width': strokeWidth,
					r: scrollbarOptions.trackBorderRadius || 0,
					height: scrollbarHeight
				}).add(scrollbarGroup);

				// the scrollbar itself
				scrollbar = renderer.rect()
					.attr({
						y: -scrollbarStrokeWidth % 2 / 2,
						height: scrollbarHeight,
						fill: scrollbarOptions.barBackgroundColor,
						stroke: scrollbarOptions.barBorderColor,
						'stroke-width': scrollbarStrokeWidth,
						r: barBorderRadius
					})
					.add(scrollbarGroup);

				scrollbarRifles = renderer.path()
					.attr({
						stroke: scrollbarOptions.rifleColor,
						'stroke-width': 1
					})
					.add(scrollbarGroup);
			}
		}

		// place elements
		if (navigatorEnabled) {
			leftShade.attr({
				x: navigatorLeft,
				y: top,
				width: zoomedMin,
				height: height
			});
			rightShade.attr({
				x: navigatorLeft + zoomedMax,
				y: top,
				width: navigatorWidth - zoomedMax,
				height: height
			});
			outline.attr({ d: [
				M,
				scrollerLeft, outlineTop, // left
				L,
				navigatorLeft + zoomedMin + halfOutline, outlineTop, // upper left of zoomed range
				navigatorLeft + zoomedMin + halfOutline, outlineTop + outlineHeight - scrollbarHeight, // lower left of z.r.
				M,
				navigatorLeft + zoomedMax - halfOutline, outlineTop + outlineHeight - scrollbarHeight, // lower right of z.r.
				L,
				navigatorLeft + zoomedMax - halfOutline, outlineTop, // upper right of z.r.
				scrollerLeft + scrollerWidth, outlineTop // right
			]});
			// draw handles
			drawHandle(zoomedMin + halfOutline, 0);
			drawHandle(zoomedMax + halfOutline, 1);
		}

		// draw the scrollbar
		if (scrollbarEnabled) {

			// draw the buttons
			drawScrollbarButton(0);
			drawScrollbarButton(1);

			scrollbarGroup.translate(scrollerLeft, mathRound(outlineTop + height));

			scrollbarTrack.attr({
				width: scrollerWidth
			});

			scrollbar.attr({
				x: mathRound(scrollbarHeight + zoomedMin) + (scrollbarStrokeWidth % 2 / 2),
				width: range - scrollbarStrokeWidth
			});

			centerBarX = scrollbarHeight + zoomedMin + range / 2 - 0.5;

			scrollbarRifles.attr({ d: [
					M,
					centerBarX - 3, scrollbarHeight / 4,
					L,
					centerBarX - 3, 2 * scrollbarHeight / 3,
					M,
					centerBarX, scrollbarHeight / 4,
					L,
					centerBarX, 2 * scrollbarHeight / 3,
					M,
					centerBarX + 3, scrollbarHeight / 4,
					L,
					centerBarX + 3, 2 * scrollbarHeight / 3
				],
				visibility: range > 12 ? VISIBLE : HIDDEN
			});
		}

		rendered = true;
	}

	/**
	 * Event handler for the mouse down event.
	 */
	function mouseDownHandler(e) {
		e = chart.tracker.normalizeMouseEvent(e);
		var chartX = e.chartX,
			chartY = e.chartY,
			handleSensitivity = hasTouch ? 10 : 7,
			left,
			isOnNavigator;

		if (chartY > top && chartY < top + height + scrollbarHeight) { // we're vertically inside the navigator
			isOnNavigator = !scrollbarEnabled || chartY < top + height;

			// grab the left handle
			if (isOnNavigator && math.abs(chartX - zoomedMin - navigatorLeft) < handleSensitivity) {
				grabbedLeft = true;
				otherHandlePos = zoomedMax;

			// grab the right handle
			} else if (isOnNavigator && math.abs(chartX - zoomedMax - navigatorLeft) < handleSensitivity) {
				grabbedRight = true;
				otherHandlePos = zoomedMin;

			// grab the zoomed range
			} else if (chartX > navigatorLeft + zoomedMin && chartX < navigatorLeft + zoomedMax) {
				grabbedCenter = chartX;
				defaultBodyCursor = bodyStyle.cursor;
				bodyStyle.cursor = 'ew-resize';

				dragOffset = chartX - zoomedMin;

			// shift the range by clicking on shaded areas, scrollbar track or scrollbar buttons
			} else if (chartX > scrollerLeft && chartX < scrollerLeft + scrollerWidth) {

				if (isOnNavigator) { // center around the clicked point
					left = chartX - navigatorLeft - range / 2;
				} else { // click on scrollbar
					if (chartX < navigatorLeft) { // click left scrollbar button
						left = zoomedMin - mathMin(10, range);
					} else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {
						left = zoomedMin + mathMin(10, range);
					} else {
						// click on scrollbar track, shift the scrollbar by one range
						left = chartX < navigatorLeft + zoomedMin ? // on the left
							zoomedMin - range :
							zoomedMax;
					}
				}
				if (left < 0) {
					left = 0;
				} else if (left + range > navigatorWidth) {
					left = navigatorWidth - range;
				}
				if (left !== zoomedMin) { // it has actually moved
					chart.xAxis[0].setExtremes(
						xAxis.translate(left, true),
						xAxis.translate(left + range, true),
						true,
						false
					);
				}
			}
		}
		
	}

	/**
	 * Event handler for the mouse move event.
	 */
	function mouseMoveHandler(e) {
		e = chart.tracker.normalizeMouseEvent(e);
		var chartX = e.chartX;

		// validation for handle dragging
		if (chartX < navigatorLeft) {
			chartX = navigatorLeft;
		} else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {
			chartX = scrollerLeft + scrollerWidth - scrollbarHeight;
		}

		// drag left handle
		if (grabbedLeft) {
			hasDragged = true;
			render(0, 0, chartX - navigatorLeft, otherHandlePos);

		// drag right handle
		} else if (grabbedRight) {
			hasDragged = true;
			render(0, 0, otherHandlePos, chartX - navigatorLeft);

		// drag scrollbar or open area in navigator
		} else if (grabbedCenter) {
			hasDragged = true;
			if (chartX < dragOffset) { // outside left
				chartX = dragOffset;
			} else if (chartX > navigatorWidth + dragOffset - range) { // outside right
				chartX = navigatorWidth + dragOffset - range;
			}

			render(0, 0, chartX - dragOffset, chartX - dragOffset + range);
		}
	}

	/**
	 * Event handler for the mouse up event.
	 */
	function mouseUpHandler() {
		if (hasDragged) {
				chart.xAxis[0].setExtremes(
					xAxis.translate(zoomedMin, true),
					xAxis.translate(zoomedMax, true),
					true,
					false
				);
			}
			grabbedLeft = grabbedRight = grabbedCenter = hasDragged = dragOffset = null;
			bodyStyle.cursor = defaultBodyCursor;
	}

	function updatedDataHandler() {
		var baseXAxis = baseSeries.xAxis,
			baseExtremes = baseXAxis.getExtremes(),
			baseMin = baseExtremes.min,
			baseMax = baseExtremes.max,
			baseDataMin = baseExtremes.dataMin,
			baseDataMax = baseExtremes.dataMax,
			range = baseMax - baseMin,
			stickToMin,
			stickToMax,
			newMax,
			newMin,
			doRedraw,
			navXData = navigatorSeries.xData,
			hasSetExtremes = !!baseXAxis.setExtremes;

		// detect whether to move the range
		stickToMax = baseMax >= navXData[navXData.length - 1];
		stickToMin = baseMin <= baseDataMin;

		// set the navigator series data to the new data of the base series
		if (!navigatorData) {
			navigatorSeries.options.pointStart = baseSeries.xData[0];
			navigatorSeries.setData(baseSeries.options.data, false);
			doRedraw = true;
		}

		// if the zoomed range is already at the min, move it to the right as new data
		// comes in
		if (stickToMin) {
			newMin = baseDataMin;
			newMax = newMin + range;
		}

		// if the zoomed range is already at the max, move it to the right as new data
		// comes in
		if (stickToMax) {
			newMax = baseDataMax;
			if (!stickToMin) { // if stickToMin is true, the new min value is set above
				newMin = mathMax(newMax - range, navigatorSeries.xData[0]);
			}
		}

		// update the extremes
		if (hasSetExtremes && (stickToMin || stickToMax)) {
			baseXAxis.setExtremes(newMin, newMax, true, false);
		// if it is not at any edge, just move the scroller window to reflect the new series data
		} else {
			if (doRedraw) {
				chart.redraw(false);
			}

			render(
				mathMax(baseMin, baseDataMin),
				mathMin(baseMax, baseDataMax)
			);
		}
	}

	/**
	 * Set up the mouse and touch events for the navigator and scrollbar
	 */
	function addEvents() {
		addEvent(chart.container, MOUSEDOWN, mouseDownHandler);
		addEvent(chart.container, MOUSEMOVE, mouseMoveHandler);
		addEvent(document, MOUSEUP, mouseUpHandler);
	}

	/**
	 * Removes the event handlers attached previously with addEvents.
	 */
	function removeEvents() {
		removeEvent(chart.container, MOUSEDOWN, mouseDownHandler);
		removeEvent(chart.container, MOUSEMOVE, mouseMoveHandler);
		removeEvent(document, MOUSEUP, mouseUpHandler);
		if (navigatorEnabled) {
			removeEvent(baseSeries, 'updatedData', updatedDataHandler);
		}
	}

	/**
	 * Initiate the Scroller object
	 */
	function init() {
		var xAxisIndex = chart.xAxis.length,
			yAxisIndex = chart.yAxis.length,
			baseChartSetSize = chart.setSize;

		// make room below the chart
		chart.extraBottomMargin = outlineHeight + navigatorOptions.margin;
		// get the top offset
		top = getAxisTop(chart.chartHeight);

		if (navigatorEnabled) {
			var baseOptions = baseSeries.options,
				mergedNavSeriesOptions,
				baseData = baseOptions.data,
				navigatorSeriesOptions = navigatorOptions.series;

			// remove it to prevent merging one by one
			navigatorData = navigatorSeriesOptions.data;
			baseOptions.data = navigatorSeriesOptions.data = null;


			// an x axis is required for scrollbar also
			xAxis = new chart.Axis(merge({
				ordinal: baseSeries.xAxis.options.ordinal // inherit base xAxis' ordinal option
			}, navigatorOptions.xAxis, {
				isX: true,
				type: 'datetime',
				index: xAxisIndex,
				height: height,
				top: top,
				offset: 0,
				offsetLeft: scrollbarHeight,
				offsetRight: -scrollbarHeight,
				startOnTick: false,
				endOnTick: false,
				minPadding: 0,
				maxPadding: 0,
				zoomEnabled: false
			}));

			yAxis = new chart.Axis(merge(navigatorOptions.yAxis, {
				alignTicks: false,
				height: height,
				top: top,
				offset: 0,
				index: yAxisIndex,
				zoomEnabled: false
			}));

			// dmerge the series options
			mergedNavSeriesOptions = merge(baseSeries.options, navigatorSeriesOptions, {
				threshold: null,
				clip: false,
				enableMouseTracking: false,
				group: 'nav', // for columns
				padXAxis: false,
				xAxis: xAxisIndex,
				yAxis: yAxisIndex,
				name: 'Navigator',
				showInLegend: false,
				isInternal: true,
				visible: true
			});

			// set the data back
			baseOptions.data = baseData;
			navigatorSeriesOptions.data = navigatorData;
			mergedNavSeriesOptions.data = navigatorData || baseData;

			// add the series
			navigatorSeries = chart.initSeries(mergedNavSeriesOptions);

			// respond to updated data in the base series
			// todo: use similiar hook when base series is not yet initialized
			addEvent(baseSeries, 'updatedData', updatedDataHandler);

		// in case of scrollbar only, fake an x axis to get translation
		} else {
			xAxis = {
				translate: function (value, reverse) {
					var ext = chart.xAxis[0].getExtremes(),
						scrollTrackWidth = chart.plotWidth - 2 * scrollbarHeight,
						dataMin = ext.dataMin,
						valueRange = ext.dataMax - dataMin;

					return reverse ?
						// from pixel to value
						(value * valueRange / scrollTrackWidth) + dataMin :
						// from value to pixel
						scrollTrackWidth * (value - dataMin) / valueRange;
				}
			};
		}
		
		
		// Override the chart.setSize method to adjust the xAxis and yAxis top option as well.
		// This needs to be done prior to chart.resize
		chart.setSize = function (width, height, animation) {
			xAxis.options.top = yAxis.options.top = top = getAxisTop(height);
			baseChartSetSize.call(chart, width, height, animation);
		};

		addEvents();
	}

	/**
	 * Destroys allocated elements.
	 */
	function destroy() {
		// Disconnect events added in addEvents
		removeEvents();

		// Destroy local variables
		each([xAxis, yAxis, leftShade, rightShade, outline, scrollbarTrack, scrollbar, scrollbarRifles, scrollbarGroup], function (obj) {
			if (obj && obj.destroy) {
				obj.destroy();
			}
		});
		xAxis = yAxis = leftShade = rightShade = outline = scrollbarTrack = scrollbar = scrollbarRifles = scrollbarGroup = null;

		// Destroy elements in collection
		each([scrollbarButtons, handles, elementsToDestroy], function (coll) {
			destroyObjectProperties(coll);
		});
	}

	// Run scroller
	init();

	// Expose
	return {
		render: render,
		destroy: destroy,
		series: navigatorSeries,
		xAxis: xAxis,
		yAxis: yAxis
	};

};

/* ****************************************************************************
 * End Scroller code														  *
 *****************************************************************************/

/* ****************************************************************************
 * Start Range Selector code												  *
 *****************************************************************************/
extend(defaultOptions, {
	rangeSelector: {
		// enabled: true,
		// buttons: {Object}
		// buttonSpacing: 0,
		buttonTheme: {
			width: 28,
			height: 16,
			padding: 1,
			r: 0,
			zIndex: 10 // #484
		//	states: {
		//		hover: {},
		//		select: {}
		// }
		}
		// inputDateFormat: '%b %e, %Y',
		// inputEditDateFormat: '%Y-%m-%d',
		// inputEnabled: true,
		// inputStyle: {}
		// labelStyle: {}
		// selected: undefined
		// todo:
		// - button styles for normal, hover and select state
		// - CSS text styles
		// - styles for the inputs and labels
	}
});
defaultOptions.lang = merge(defaultOptions.lang, {
	rangeSelectorZoom: 'Zoom',
	rangeSelectorFrom: 'From:',
	rangeSelectorTo: 'To:'
});

/**
 * The object constructor for the range selector
 * @param {Object} chart
 */
Highcharts.RangeSelector = function (chart) {
	var renderer = chart.renderer,
		rendered,
		container = chart.container,
		lang = defaultOptions.lang,
		div,
		leftBox,
		rightBox,
		boxSpanElements = {},
		divAbsolute,
		divRelative,
		selected,
		zoomText,
		buttons = [],
		buttonOptions,
		options,
		defaultButtons = [{
			type: 'month',
			count: 1,
			text: '1m'
		}, {
			type: 'month',
			count: 3,
			text: '3m'
		}, {
			type: 'month',
			count: 6,
			text: '6m'
		}, {
			type: 'ytd',
			text: 'YTD'
		}, {
			type: 'year',
			count: 1,
			text: '1y'
		}, {
			type: 'all',
			text: 'All'
		}];
		chart.resetZoomEnabled = false;

	/**
	 * The method to run when one of the buttons in the range selectors is clicked
	 * @param {Number} i The index of the button
	 * @param {Object} rangeOptions
	 * @param {Boolean} redraw
	 */
	function clickButton(i, rangeOptions, redraw) {

		var baseAxis = chart.xAxis[0],
			extremes = baseAxis && baseAxis.getExtremes(),
			navAxis = chart.scroller && chart.scroller.xAxis,
			navExtremes = navAxis && navAxis.getExtremes && navAxis.getExtremes(),
			navDataMin = navExtremes && navExtremes.dataMin,
			navDataMax = navExtremes && navExtremes.dataMax,
			baseDataMin = extremes && extremes.dataMin,
			baseDataMax = extremes && extremes.dataMax,
			dataMin = mathMin(baseDataMin, pick(navDataMin, baseDataMin)),
			dataMax = mathMax(baseDataMax, pick(navDataMax, baseDataMax)),
			newMin,
            newMax = rangeOptions.by == 'max' 
                // [CUSTOMIZED]
                ? dataMax
                : baseAxis && mathMin(extremes.max, dataMax),
            now,
            date = new Date(newMax),
            type = rangeOptions.type,
			count = rangeOptions.count,
			baseXAxisOptions,
			range,
			rangeMin,
			year,
            o,
			// these time intervals have a fixed number of milliseconds, as opposed
			// to month, ytd and year
			fixedTimes = {
				millisecond: 1,
				second: 1000,
				minute: 60 * 1000,
				hour: 3600 * 1000,
				day: 24 * 3600 * 1000,
				week: 7 * 24 * 3600 * 1000
			};



		if (dataMin === null || dataMax === null || // chart has no data, base series is removed
				i === selected) { // same button is clicked twice
			return;
		}

		if (fixedTimes[type]) {
            range = fixedTimes[type] * count;
            newMin = mathMax(newMax - range, dataMin);
		} else if (type === 'month') {
            date.setMonth(date.getMonth() - count);
            newMin = mathMax(date.getTime(), dataMin);
            range = 30 * 24 * 3600 * 1000 * count;
		} else if (type === 'ytd') {
			date = new Date(0);
			now = new Date(dataMax);
			year = now.getFullYear();
			date.setFullYear(year);

			// workaround for IE6 bug, which sets year to next year instead of current
			if (String(year) !== dateFormat('%Y', date)) {
				date.setFullYear(year - 1);
			}

			newMin = rangeMin = mathMax(dataMin || 0, date.getTime());
			now = now.getTime();
			newMax = mathMin(dataMax || now, now);
		} else if (type === 'year') {
			date.setFullYear(date.getFullYear() - count);
			newMin = mathMax(dataMin, date.getTime());
			range = 365 * 24 * 3600 * 1000 * count;
		} else if (type === 'all' && baseAxis) {
			newMin = dataMin;
			newMax = dataMax;
		} else if (Object.prototype.toString.call(type) == '[object Function]') {
            // [CUSTOMIZED]
            // user defined rangeSelector
            o = type({ newMax: newMax, dataMax: dataMax });
            o.newMin != null && (newMin = o.newMin);
            o.newMax != null && (newMax = o.newMax);
            o.range != null && (range = o.range);
        }

		// mark the button pressed
		if (buttons[i]) {
			buttons[i].setState(2);
		}

		// update the chart
		if (!baseAxis) { // axis not yet instanciated
			baseXAxisOptions = chart.options.xAxis;
			baseXAxisOptions[0] = merge(
				baseXAxisOptions[0],
				{
					range: range,
					min: rangeMin
				}
			);
			selected = i;

		} else { // existing axis object; after render time
			setTimeout(function () { // make sure the visual state is set before the heavy process begins
				baseAxis.setExtremes(
					newMin,
					newMax,
					pick(redraw, 1),
					0,
					{ rangeSelectorButton: rangeOptions }
				);
				selected = i;
			}, 1);
		}

	}

	/**
	 * The handler connected to container that handles mousedown.
	 */
	function mouseDownHandler() {
		if (leftBox) {
			leftBox.blur();
		}
		if (rightBox) {
			rightBox.blur();
		}
	}

	/**
	 * Initialize the range selector
	 */
	function init() {
		chart.extraTopMargin = 25;
		options = chart.options.rangeSelector;
		buttonOptions = options.buttons || defaultButtons;


		var selectedOption = options.selected;

		addEvent(container, MOUSEDOWN, mouseDownHandler);

		// zoomed range based on a pre-selected button index
		if (selectedOption !== UNDEFINED && buttonOptions[selectedOption]) {
			clickButton(selectedOption, buttonOptions[selectedOption], false);
		}

		// normalize the pressed button whenever a new range is selected
		addEvent(chart, 'load', function () {
			addEvent(chart.xAxis[0], 'afterSetExtremes', function () {
				//if (this.isDirty) {  // [CUSTOMIZED]
					if (buttons[selected]) {
						buttons[selected].setState(0);
					}
					selected = null;
				//}
			});
		});
	}


	/**
	 * Set the internal and displayed value of a HTML input for the dates
	 * @param {Object} input
	 * @param {Number} time
	 */
	function setInputValue(input, time) {
		var format = input.hasFocus ? options.inputEditDateFormat || '%Y-%m-%d' : options.inputDateFormat || '%b %e, %Y';
		if (time) {
			input.HCTime = time;
		}
		input.value = dateFormat(format, input.HCTime);
	}

	/**
	 * Draw either the 'from' or the 'to' HTML input box of the range selector
	 * @param {Object} name
	 */
	function drawInput(name) {
		var isMin = name === 'min',
			input;

		// create the text label
		boxSpanElements[name] = createElement('span', {
			innerHTML: lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo']
		}, options.labelStyle, div);

		// create the input element
		input = createElement('input', {
			name: name,
			className: PREFIX + 'range-selector',
			type: 'text'
		}, extend({
			width: '80px',
			height: '16px',
			border: '1px solid silver',
			marginLeft: '5px',
			marginRight: isMin ? '5px' : '0',
			textAlign: 'center'
		}, options.inputStyle), div);

		input.onfocus = input.onblur = function (e) {
			e = e || window.event;
			input.hasFocus = e.type === 'focus';
			setInputValue(input);
		};

		// handle changes in the input boxes
		input.onchange = function () {
			var inputValue = input.value,
				value = Date.parse(inputValue),
				extremes = chart.xAxis[0].getExtremes();

            // if the value isn't parsed directly to a value by the browser's Date.parse method,
            // like YYYY-MM-DD in IE, try parsing it a different way
            if (isNaN(value)) {
                value = inputValue.split('-');
                // value = Date.UTC(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));
                value = makeTime(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));
            }

			// if the value isn't parsed by methods above,
			// try parsing it by quarter parser
            if (isNaN(value)) {
                value = parseQuarter(inputValue);
            }

			if (!isNaN(value) &&
				((isMin && (value >= extremes.dataMin && value <= rightBox.HCTime)) ||
				(!isMin && (value <= extremes.dataMax && value >= leftBox.HCTime)))
			) {
				chart.xAxis[0].setExtremes(
					isMin ? value : extremes.min,
					isMin ? extremes.max : value
				);
			}
		};

		return input;
	}

    /**
     * Parse quarter, i.e. parse '2012-Q1' to the first Date of the quarter
     * [CUSTOMIZED]
     */    
    function parseQuarter(dateStr) {
        var par = [0, 0, 3, 6, 9];
        dateStr = dateStr.split('-Q'); 
        return dateStr.length != 2 
            ? NaN
            : new Date(
                parseInt(dateStr[0], 10), 
                par[parseInt(dateStr[1], 10)], 
                1
            ).getTime();
    };

	/**
	 * Render the range selector including the buttons and the inputs. The first time render
	 * is called, the elements are created and positioned. On subsequent calls, they are
	 * moved and updated.
	 * @param {Number} min X axis minimum
	 * @param {Number} max X axis maximum
	 */
	function render(min, max) {
		var chartStyle = chart.options.chart.style,
			buttonTheme = options.buttonTheme,
			inputEnabled = options.inputEnabled !== false,
			states = buttonTheme && buttonTheme.states,
			plotLeft = chart.plotLeft,
			buttonLeft;

		// create the elements
		if (!rendered) {
			zoomText = renderer.text(lang.rangeSelectorZoom, plotLeft, chart.plotTop - 10)
				.css(options.labelStyle)
				.add();

			// button starting position
			buttonLeft = plotLeft + zoomText.getBBox().width + 5;

			each(buttonOptions, function (rangeOptions, i) {
				buttons[i] = renderer.button(
					rangeOptions.text,
					buttonLeft,
					chart.plotTop - 25,
					function () {
						clickButton(i, rangeOptions);
						this.isActive = true;
					},
					buttonTheme,
					states && states.hover,
					states && states.select
				)
				.css({
					textAlign: 'center'
				})
				.add();

				// increase button position for the next button
				buttonLeft += buttons[i].width + (options.buttonSpacing || 0);

				if (selected === i) {
					buttons[i].setState(2);
				}

			});

			// first create a wrapper outside the container in order to make
			// the inputs work and make export correct
			if (inputEnabled) {
				divRelative = div = createElement('div', null, {
					position: 'relative',
					height: 0,
					fontFamily: chartStyle.fontFamily,
					fontSize: chartStyle.fontSize,
					zIndex: 1 // above container
				});

				container.parentNode.insertBefore(div, container);

				// create an absolutely positionied div to keep the inputs
				divAbsolute = div = createElement('div', null, extend({
					position: 'absolute',
					top: (chart.plotTop - 25) + 'px',
					right: (chart.chartWidth - chart.plotLeft - chart.plotWidth) + 'px'
				}, options.inputBoxStyle), div);

				leftBox = drawInput('min');

				rightBox = drawInput('max');
			}
		}

		if (inputEnabled) {
			setInputValue(leftBox, min);
			setInputValue(rightBox, max);
		}


		rendered = true;
	}

	/**
	 * Destroys allocated elements.
	 */
	function destroy() {
		removeEvent(container, MOUSEDOWN, mouseDownHandler);

		// Destroy elements in collections
		each([buttons], function (coll) {
			destroyObjectProperties(coll);
		});

		// Destroy zoomText
		if (zoomText) {
			zoomText = zoomText.destroy();
		}

		// Clear input element events
		if (leftBox) {
			leftBox.onfocus = leftBox.onblur = leftBox.onchange = null;
		}
		if (rightBox) {
			rightBox.onfocus = rightBox.onblur = rightBox.onchange = null;
		}

		// Discard divs and spans
		each([leftBox, rightBox, boxSpanElements.min, boxSpanElements.max, divAbsolute, divRelative], function (item) {
			discardElement(item);
		});
		// Null the references
		leftBox = rightBox = boxSpanElements = div = divAbsolute = divRelative = null;

	}

	// Run RangeSelector
	init();

	// Expose
	return {
		render: render,
		destroy: destroy
	};
};

/* ****************************************************************************
 * End Range Selector code													*
 *****************************************************************************/



Chart.prototype.callbacks.push(function (chart) {
	var extremes,
		scroller = chart.scroller,
		rangeSelector = chart.rangeSelector;

	function renderScroller() {
		extremes = chart.xAxis[0].getExtremes();
		scroller.render(
			mathMax(extremes.min, extremes.dataMin),
			mathMin(extremes.max, extremes.dataMax)
		);
	}

	function renderRangeSelector() {
		extremes = chart.xAxis[0].getExtremes();
		rangeSelector.render(extremes.min, extremes.max);
	}

	function afterSetExtremesHandlerScroller(e) {
		scroller.render(e.min, e.max);
	}

	function afterSetExtremesHandlerRangeSelector(e) {
		rangeSelector.render(e.min, e.max);
	}

	function destroyEvents() {
		if (scroller) {
			removeEvent(chart, 'resize', renderScroller);
			removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);
		}
		if (rangeSelector) {
			removeEvent(chart, 'resize', renderRangeSelector);
			removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);
		}
	}

	// initiate the scroller
	if (scroller) {
		// redraw the scroller on setExtremes
		addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);

		// redraw the scroller chart resize
		addEvent(chart, 'resize', renderScroller);

		// do it now
		renderScroller();
	}
	if (rangeSelector) {
		// redraw the scroller on setExtremes
		addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);

		// redraw the scroller chart resize
		addEvent(chart, 'resize', renderRangeSelector);

		// do it now
		renderRangeSelector();
	}

	// Remove resize/afterSetExtremes at chart destroy
	addEvent(chart, 'destroy', destroyEvents);
});
/**
 * A wrapper for Chart with all the default values for a Stock chart
 */
Highcharts.StockChart = function (options, callback) {
	var seriesOptions = options.series, // to increase performance, don't merge the data 
		opposite,
		lineOptions = {

			marker: {
				enabled: false,
				states: {
					hover: {
						enabled: true,
						radius: 5
					}
				}
			},
			// gapSize: 0,
			shadow: false,
			states: {
				hover: {
					lineWidth: 2
				}
			},
			dataGrouping: {
				enabled: true
			}
		};

	// apply X axis options to both single and multi y axes
	options.xAxis = map(splat(options.xAxis || {}), function (xAxisOptions) {
		return merge({ // defaults
				minPadding: 0,
				maxPadding: 0,
				ordinal: true,
				title: {
					text: null
				},
				showLastLabel: true
			}, xAxisOptions, // user options 
			{ // forced options
				type: 'datetime',
				categories: null
			});
	});

	// apply Y axis options to both single and multi y axes
	options.yAxis = map(splat(options.yAxis || {}), function (yAxisOptions) {
		opposite = yAxisOptions.opposite;
		return merge({ // defaults
			labels: {
				align: opposite ? 'right' : 'left',
				x: opposite ? -2 : 2,
				y: -2
			},
			showLastLabel: false,
			title: {
				text: null
			}
		}, yAxisOptions // user options
		);
	});

	options.series = null;

	options = merge({
		chart: {
			panning: true
		},
		navigator: {
			enabled: true
		},
		scrollbar: {
			enabled: true
		},
		rangeSelector: {
			enabled: true
		},
		title: {
			text: null
		},
		tooltip: {
			shared: true,
			crosshairs: true
		},
		legend: {
			enabled: false
		},

		plotOptions: {
			line: lineOptions,
			spline: lineOptions,
			area: lineOptions,
			areaspline: lineOptions,
			column: {
				shadow: false,
				borderWidth: 0,
				dataGrouping: {
					enabled: true
				}
			}
		}

	},
	options, // user's options

	{ // forced options
		chart: {
			inverted: false
		}
	});

	options.series = seriesOptions;


	return new Chart(options, callback);
};


/* ****************************************************************************
 * Start value compare logic                                                  *
 *****************************************************************************/
 
var seriesInit = seriesProto.init, 
	seriesProcessData = seriesProto.processData,
	pointTooltipFormatter = Point.prototype.tooltipFormatter;
	
/**
 * Extend series.init by adding a method to modify the y value used for plotting
 * on the y axis. This method is called both from the axis when finding dataMin
 * and dataMax, and from the series.translate method.
 */
seriesProto.init = function () {
	
	// call base method
	seriesInit.apply(this, arguments);
	
	// local variables
	var series = this,
		compare = series.options.compare;
	
	if (compare) {
		series.modifyValue = function (value, point) {
			var compareValue = this.compareValue;
			
			// get the modified value
			value = compare === 'value' ? 
				value - compareValue : // compare value
				value = 100 * (value / compareValue) - 100; // compare percent
				
			// record for tooltip etc.
			if (point) {
				point.change = value;
			}
			
			return value;
		};
	}	
};

/**
 * Extend series.processData by finding the first y value in the plot area,
 * used for comparing the following values 
 */
seriesProto.processData = function () {
	var series = this;
	
	// call base method
	seriesProcessData.apply(this, arguments);
	
	if (series.options.compare) {
		
		// local variables
		var i = 0,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			length = processedYData.length,
			min = series.xAxis.getExtremes().min;
		
		// find the first value for comparison
		for (; i < length; i++) {
			if (typeof processedYData[i] === NUMBER && processedXData[i] >= min) {
				series.compareValue = processedYData[i];
				break;
			}
		}
	}
};

/**
 * Extend the tooltip formatter by adding support for the point.change variable
 * as well as the changeDecimals option
 */
Point.prototype.tooltipFormatter = function (pointFormat) {
	var point = this;
	
	pointFormat = pointFormat.replace(
		'{point.change}',
		(point.change > 0 ? '+' : '') + numberFormat(point.change, point.series.tooltipOptions.changeDecimals || 2)
	); 
	
	return pointTooltipFormatter.apply(this, [pointFormat]);
};

/* ****************************************************************************
 * End value compare logic                                                    *
 *****************************************************************************/

/* ****************************************************************************
 * Start ordinal axis logic                                                   *
 *****************************************************************************/

(function () {
	var baseInit = seriesProto.init,
		baseGetSegments = seriesProto.getSegments;
		
	seriesProto.init = function () {
		var series = this,
			chart,
			xAxis;
		
		// call base method
		baseInit.apply(series, arguments);
		
		// chart and xAxis are set in base init
		chart = series.chart;
		xAxis = series.xAxis;
		
		// Destroy the extended ordinal index on updated data
		if (xAxis && xAxis.options.ordinal) {
			addEvent(series, 'updatedData', function () {
				delete xAxis.ordinalIndex;
			});
		}
		
		/**
		 * Extend the ordinal axis object. If we rewrite the axis object to a prototype model,
		 * we should add these properties to the prototype instead.
		 */
		if (xAxis && xAxis.options.ordinal && !xAxis.hasOrdinalExtension) {
				
			xAxis.hasOrdinalExtension = true;
		
			/**
			 * Calculate the ordinal positions before tick positions are calculated. 
			 * TODO: When we rewrite Axis to use a prototype model, this should be implemented
			 * as a method extension to avoid overhead in the core.
			 */
			xAxis.beforeSetTickPositions = function () {
				var axis = this,
					len,
					ordinalPositions = [],
					useOrdinal = false,
					dist,
					extremes = axis.getExtremes(),
					min = extremes.min,
					max = extremes.max,
					minIndex,
					maxIndex,
					slope,
					i;
				
				// apply the ordinal logic
				if (axis.options.ordinal) {
					
					each(axis.series, function (series, i) {
						
						if (series.visible !== false) {
							
							// concatenate the processed X data into the existing positions, or the empty array 
							ordinalPositions = ordinalPositions.concat(series.processedXData);
							len = ordinalPositions.length;
							
							// if we're dealing with more than one series, remove duplicates
							if (i && len) {
							
								ordinalPositions.sort(function (a, b) {
									return a - b; // without a custom function it is sorted as strings
								});
							
								i = len - 1;
								while (i--) {
									if (ordinalPositions[i] === ordinalPositions[i + 1]) {
										ordinalPositions.splice(i, 1);
									}
								}
							}
						}
						
					});
					
					// cache the length
					len = ordinalPositions.length;					
					
					// Check if we really need the overhead of mapping axis data against the ordinal positions.
					// If the series consist of evenly spaced data any way, we don't need any ordinal logic.
					if (len > 2) { // two points have equal distance by default
						dist = ordinalPositions[1] - ordinalPositions[0]; 
						i = len - 1;
						while (i-- && !useOrdinal) {
							if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
								useOrdinal = true;
							}
						}
					}
					
					// Record the slope and offset to compute the linear values from the array index.
					// Since the ordinal positions may exceed the current range, get the start and 
					// end positions within it (#719, #665b)
					if (useOrdinal) {
						
						// Register
						axis.ordinalPositions = ordinalPositions;
						
						// This relies on the ordinalPositions being set
						minIndex = xAxis.val2lin(min, true);
						maxIndex = xAxis.val2lin(max, true);
				
						// Set the slope and offset of the values compared to the indices in the ordinal positions
						axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);
						axis.ordinalOffset = min - (minIndex * slope);
						
					} else {
						axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = UNDEFINED;
					}
				}
			};
			
			/**
			 * Translate from a linear axis value to the corresponding ordinal axis position. If there
			 * are no gaps in the ordinal axis this will be the same. The translated value is the value
			 * that the point would have if the axis were linear, using the same min and max.
			 * 
			 * @param Number val The axis value
			 * @param Boolean toIndex Whether to return the index in the ordinalPositions or the new value
			 */
			xAxis.val2lin = function (val, toIndex) {
				
				var axis = this,
					ordinalPositions = axis.ordinalPositions;
				
				if (!ordinalPositions) {
					return val;
				
				} else {
				
					var ordinalLength = ordinalPositions.length,
						i,
						distance,
						ordinalIndex;
						
					// first look for an exact match in the ordinalpositions array
					i = ordinalLength;
					while (i--) {
						if (ordinalPositions[i] === val) {
							ordinalIndex = i;
							break;
						}
					}
					
					// if that failed, find the intermediate position between the two nearest values
					i = ordinalLength - 1;
					while (i--) {
						if (val > ordinalPositions[i] || i === 0) { // interpolate
							distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]); // something between 0 and 1
							ordinalIndex = i + distance;
							break;
						}
					}
					return toIndex ?
						ordinalIndex :
						axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;
				}
			};
			
			/**
			 * Translate from linear (internal) to axis value
			 * 
			 * @param Number val The linear abstracted value
			 * @param Boolean fromIndex Translate from an index in the ordinal positions rather than a value
			 */
			xAxis.lin2val = function (val, fromIndex) {
				var axis = this,
					ordinalPositions = axis.ordinalPositions;
				
				if (!ordinalPositions) { // the visible range contains only equally spaced values
					return val;
				
				} else {
				
					var ordinalSlope = axis.ordinalSlope,
						ordinalOffset = axis.ordinalOffset,
						i = ordinalPositions.length - 1,
						linearEquivalentLeft,
						linearEquivalentRight,
						distance;
						
					
					// Handle the case where we translate from the index directly, used only 
					// when panning an ordinal axis
					if (fromIndex) {
						
						if (val < 0) { // out of range, in effect panning to the left
							val = ordinalPositions[0];
						} else if (val > i) { // out of range, panning to the right
							val = ordinalPositions[i];
						} else { // split it up
							i = mathFloor(val);
							distance = val - i; // the decimal
						}
						
					// Loop down along the ordinal positions. When the linear equivalent of i matches
					// an ordinal position, interpolate between the left and right values.
					} else {
						while (i--) {
							linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;
							if (val >= linearEquivalentLeft) {
								linearEquivalentRight = (ordinalSlope * (i + 1)) + ordinalOffset;
								distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft); // something between 0 and 1
								break;
							}
						}
					}
					
					// If the index is within the range of the ordinal positions, return the associated
					// or interpolated value. If not, just return the value
					return distance !== UNDEFINED && ordinalPositions[i] !== UNDEFINED ?
						ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) : 
						val;
				}
			};
			
			/**
			 * Get the ordinal positions for the entire data set. This is necessary in chart panning
			 * because we need to find out what points or data groups are available outside the 
			 * visible range. When a panning operation starts, if an index for the given grouping
			 * does not exists, it is created and cached. This index is deleted on updated data, so
			 * it will be regenerated the next time a panning operation starts.
			 */
			xAxis.getExtendedPositions = function () {
				var grouping = xAxis.series[0].currentDataGrouping,
					ordinalIndex = xAxis.ordinalIndex,
					key = grouping ? grouping.count + grouping.unitName : 'raw',
					extremes = xAxis.getExtremes(),
					fakeAxis,
					fakeSeries;
					
				// If this is the first time, or the ordinal index is deleted by updatedData,
				// create it.
				if (!ordinalIndex) {
					ordinalIndex = xAxis.ordinalIndex = {};
				}
				
				
				if (!ordinalIndex[key]) {
					
					// Create a fake axis object where the extended ordinal positions are emulated
					fakeAxis = {
						series: [],
						getExtremes: function () {
							return {
								min: extremes.dataMin,
								max: extremes.dataMax
							};
						},
						options: {
							ordinal: true
						}
					};
					
					// Add the fake series to hold the full data, then apply processData to it
					each(xAxis.series, function (series) {
						fakeSeries = {
							xAxis: fakeAxis,
							xData: series.xData,
							chart: chart
						};
						fakeSeries.options = {
							dataGrouping : grouping ? {
								enabled: true,
								forced: true,
								approximation: 'open', // doesn't matter which, use the fastest
								units: [[grouping.unitName, [grouping.count]]]
							} : {
								enabled: false
							}
						};
						series.processData.apply(fakeSeries);
						
						fakeAxis.series.push(fakeSeries);
					});
					
					// Run beforeSetTickPositions to compute the ordinalPositions
					xAxis.beforeSetTickPositions.apply(fakeAxis);
					
					// Cache it
					ordinalIndex[key] = fakeAxis.ordinalPositions;
				}
				return ordinalIndex[key];
			};
			
			/**
			 * Find the factor to estimate how wide the plot area would have been if ordinal
			 * gaps were included. This value is used to compute an imagined plot width in order
			 * to establish the data grouping interval. 
			 * 
			 * A real world case is the intraday-candlestick
			 * example. Without this logic, it would show the correct data grouping when viewing
			 * a range within each day, but once moving the range to include the gap between two
			 * days, the interval would include the cut-away night hours and the data grouping
			 * would be wrong. So the below method tries to compensate by identifying the most
			 * common point interval, in this case days. 
			 * 
			 * An opposite case is presented in issue #718. We have a long array of daily data,
			 * then one point is appended one hour after the last point. We expect the data grouping
			 * not to change.
			 * 
			 * In the future, if we find cases where this estimation doesn't work optimally, we
			 * might need to add a second pass to the data grouping logic, where we do another run
			 * with a greater interval if the number of data groups is more than a certain fraction
			 * of the desired group count.
			 */
			xAxis.getGroupIntervalFactor = function (xMin, xMax, processedXData) {
				var i = 0,
					len = processedXData.length, 
					distances = [],
					median;
					
				// Register all the distances in an array
				for (; i < len - 1; i++) {
					distances[i] = processedXData[i + 1] - processedXData[i];
				}
				
				// Sort them and find the median
				distances.sort(function (a, b) {
					return a - b;
				});
				median = distances[mathFloor(len / 2)];
				
				// Return the factor needed for data grouping
				return (len * median) / (xMax - xMin);
			};
			
			/**
			 * Make the tick intervals closer because the ordinal gaps make the ticks spread out or cluster
			 */
			xAxis.postProcessTickInterval = function (tickInterval) {
				// TODO: http://jsfiddle.net/highcharts/FQm4E/1/
				// This is a case where this algorithm doesn't work optimally. In this case, the 
				// tick labels are spread out per week, but all the gaps reside within weeks. So 
				// we have a situation where the labels are courser than the ordinal gaps, and 
				// thus the tick interval should not be altered				
				var ordinalSlope = this.ordinalSlope;
				
				return ordinalSlope ? 
					tickInterval / (ordinalSlope / xAxis.closestPointRange) : 
					tickInterval;
			};
			
			/**
			 * In an ordinal axis, there might be areas with dense consentrations of points, then large
			 * gaps between some. Creating equally distributed ticks over this entire range
			 * may lead to a huge number of ticks that will later be removed. So instead, break the 
			 * positions up in segments, find the tick positions for each segment then concatenize them.
			 * This method is used from both data grouping logic and X axis tick position logic. 
			 */
			xAxis.getNonLinearTimeTicks = function (normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {
				
				var start = 0,
					end = 0,
					segmentPositions,
					higherRanks = {},
					hasCrossedHigherRank,
					info,
					posLength,
					outsideMax,
					groupPositions = [],
					tickPixelIntervalOption = xAxis.options.tickPixelInterval;
					
				// The positions are not always defined, for example for ordinal positions when data
				// has regular interval
				if (!positions || min === UNDEFINED) {
					return getTimeTicks(normalizedInterval, min, max, startOfWeek);
				}
				
				// Analyze the positions array to split it into segments on gaps larger than 5 times
				// the closest distance. The closest distance is already found at this point, so 
				// we reuse that instead of computing it again.
				posLength = positions.length;
				for (; end < posLength; end++) {
					
					outsideMax = end && positions[end - 1] > max;
					
					if (positions[end] < min) { // Set the last position before min
						start = end;						
					}
					
					if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {
						
						// For each segment, calculate the tick positions from the getTimeTicks utility
						// function. The interval will be the same regardless of how long the segment is.
						segmentPositions = getTimeTicks(normalizedInterval, positions[start], positions[end], startOfWeek);		
						
						groupPositions = groupPositions.concat(segmentPositions);
						
						// Set start of next segment
						start = end + 1;						
					}
					
					if (outsideMax) {
						break;
					}
				}
				
				// Get the grouping info from the last of the segments. The info is the same for
				// all segments.
				info = segmentPositions.info;
				
				// Optionally identify ticks with higher rank, for example when the ticks
				// have crossed midnight.
				if (findHigherRanks && info.unitRange <= timeUnits[HOUR]) {
					end = groupPositions.length - 1;
					
					// Compare points two by two
					for (start = 1; start < end; start++) {
						if (new Date(groupPositions[start])[getDate]() !== new Date(groupPositions[start - 1])[getDate]()) {
							higherRanks[groupPositions[start]] = DAY;
							hasCrossedHigherRank = true;
						}
					}
					
					// If the complete array has crossed midnight, we want to mark the first
					// positions also as higher rank
					if (hasCrossedHigherRank) {
						higherRanks[groupPositions[0]] = DAY;
					}
					info.higherRanks = higherRanks;
				}
				
				// Save the info
				groupPositions.info = info;
				
				
				
				// Don't show ticks within a gap in the ordinal axis, where the space between
				// two points is greater than a portion of the tick pixel interval
				if (findHigherRanks && defined(tickPixelIntervalOption)) { // check for squashed ticks
					
					var length = groupPositions.length,
						i = length,
						itemToRemove,
						translated,
						translatedArr = [],
						lastTranslated,
						medianDistance,
						distance,
						distances = [];
						
					// Find median pixel distance in order to keep a reasonably even distance between
					// ticks (#748)
					while (i--) {
						translated = xAxis.translate(groupPositions[i]);
						if (lastTranslated) {
							distances[i] = lastTranslated - translated;
						}
						translatedArr[i] = lastTranslated = translated; 
					}
					distances.sort();
					medianDistance = distances[mathFloor(distances.length / 2)];
					if (medianDistance < tickPixelIntervalOption * 0.6) {
						medianDistance = null;
					}
					
					// Now loop over again and remove ticks where needed
					i = groupPositions[length - 1] > max ? length - 1 : length; // #817
					lastTranslated = undefined;
					while (i--) {
						translated = translatedArr[i];
						distance = lastTranslated - translated;
	
						// Remove ticks that are closer than 0.6 times the pixel interval from the one to the right,
						// but not if it is close to the median distance (#748).
						if (lastTranslated && distance < tickPixelIntervalOption * 0.8 && 
								(medianDistance === null || distance < medianDistance * 0.8)) {
							
							// Is this a higher ranked position with a normal position to the right?
							if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {
								
								// Yes: remove the lower ranked neighbour to the right
								itemToRemove = i + 1;
								lastTranslated = translated; // #709
								
							} else {
								
								// No: remove this one
								itemToRemove = i;
							}
							
							groupPositions.splice(itemToRemove, 1);
							
						} else {
							lastTranslated = translated;
						}
					}
				}
				
				return groupPositions;
			};
			
			
			/**
			 * Overrride the chart.pan method for ordinal axes. 
			 */
			
			var baseChartPan = chart.pan;
			chart.pan = function (chartX) {
				var xAxis = chart.xAxis[0],
					runBase = false;
				if (xAxis.options.ordinal) {
					
					var mouseDownX = chart.mouseDownX,
						extremes = xAxis.getExtremes(),
						dataMax = extremes.dataMax,
						min = extremes.min,
						max = extremes.max,
						newMin,
						newMax,
						hoverPoints = chart.hoverPoints,
						closestPointRange = xAxis.closestPointRange,
						pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),
						movedUnits = (mouseDownX - chartX) / pointPixelWidth, // how many ordinal units did we move?
						extendedAxis = { ordinalPositions: xAxis.getExtendedPositions() }, // get index of all the chart's points
						ordinalPositions,
						searchAxisLeft,
						lin2val = xAxis.lin2val,
						val2lin = xAxis.val2lin,
						searchAxisRight;
					
					if (!extendedAxis.ordinalPositions) { // we have an ordinal axis, but the data is equally spaced
						runBase = true;
					
					} else if (mathAbs(movedUnits) > 1) {
						
						// Remove active points for shared tooltip
						if (hoverPoints) {
							each(hoverPoints, function (point) {
								point.setState();
							});
						}
						
						if (movedUnits < 0) {
							searchAxisLeft = extendedAxis;
							searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;
						} else {
							searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;
							searchAxisRight = extendedAxis;
						}
						
						// In grouped data series, the last ordinal position represents the grouped data, which is 
						// to the left of the real data max. If we don't compensate for this, we will be allowed
						// to pan grouped data series passed the right of the plot area. 
						ordinalPositions = searchAxisRight.ordinalPositions;
						if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
							ordinalPositions.push(dataMax);
						}
						
						// Get the new min and max values by getting the ordinal index for the current extreme, 
						// then add the moved units and translate back to values. This happens on the 
						// extended ordinal positions if the new position is out of range, else it happens
						// on the current x axis which is smaller and faster.
						newMin = lin2val.apply(searchAxisLeft, [
							val2lin.apply(searchAxisLeft, [min, true]) + movedUnits, // the new index 
							true // translate from index
						]);
						newMax = lin2val.apply(searchAxisRight, [
							val2lin.apply(searchAxisRight, [max, true]) + movedUnits, // the new index 
							true // translate from index
						]);
						
						// Apply it if it is within the available data range
						if (newMin > mathMin(extremes.dataMin, min) && newMax < mathMax(dataMax, max)) {
							xAxis.setExtremes(newMin, newMax, true, false);
						}
				
						chart.mouseDownX = chartX; // set new reference for next run
						css(chart.container, { cursor: 'move' });
					}
				
				} else {
					runBase = true;
				}
				
				// revert to the linear chart.pan version
				if (runBase) {
					baseChartPan.apply(chart, arguments);
				}
			}; 
		}
	};
			
	/**
	 * Extend getSegments by identifying gaps in the ordinal data so that we can draw a gap in the 
	 * line or area
	 */
	seriesProto.getSegments = function () {
		
		var series = this,
			segments,
			gapSize = series.options.gapSize;
	
		// call base method
		baseGetSegments.apply(series);
		
		if (series.xAxis.options.ordinal && gapSize) {
		
			// properties
			segments = series.segments;
			
			// extension for ordinal breaks
			each(segments, function (segment, no) {
				var i = segment.length - 1;
				while (i--) {
					if (segment[i + 1].x - segment[i].x > series.xAxis.closestPointRange * gapSize) {
						segments.splice( // insert after this one
							no + 1,
							0,
							segment.splice(i + 1, segment.length - i)
						);
					}
				}
			});
		}
	};
}());

/* ****************************************************************************
 * End ordinal axis logic                                                   *
 *****************************************************************************/
// global variables
extend(Highcharts, {
	Chart: Chart,
	dateFormat: dateFormat,
	pathAnim: pathAnim,
	getOptions: getOptions,
	hasBidiBug: hasBidiBug,
	numberFormat: numberFormat,
	Point: Point,
	Color: Color,
	Renderer: Renderer,
	SVGRenderer: SVGRenderer,
	VMLRenderer: VMLRenderer,
	CanVGRenderer: CanVGRenderer,
	seriesTypes: seriesTypes,
	setOptions: setOptions,
	Series: Series,

	// Expose utility funcitons for modules
	addEvent: addEvent,
	removeEvent: removeEvent,
	createElement: createElement,
	discardElement: discardElement,
	css: css,
	each: each,
	extend: extend,
	map: map,
	merge: merge,
	pick: pick,
	splat: splat,
	extendClass: extendClass,
	placeBox: placeBox,
	product: 'Highstock',
	version: '1.1.5'
});
}());

/**
 * xui.ui.HChart  
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    基于highcharts的js图
 *           (最早源自pl-charts.js by cxl(chenxinle@baidu.com))
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, highcharts
 */

(function () {

    var ieVersion = xutil.dom.ieVersion;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var inheritsObject = xutil.object.inheritsObject;
    var formatNumber = xutil.number.formatNumber;
    var getQuarterBegin = xutil.date.getQuarterBegin;
    var dateToString = xutil.date.dateToString;
    var stringToDate = xutil.date.stringToDate;
    var getQuarter = xutil.date.getQuarter;
    var getWeekend = xutil.date.getWeekend;
    var getWorkday = xutil.date.getWorkday;
    var getQuarterBegin = xutil.date.getQuarterBegin;
    var encodeHTML = xutil.string.encodeHTML;
    var extend = xutil.object.extend;
    var bind = xutil.fn.bind;
    var XOBJECT = xui.XObject;

    /**
     * 基于highcharts的JS图
     *
     * @class
     * @extends {xui.ui.Control}
     */
    var UI_H_CHART = xui.ui.HChart = 
        inheritsObject(
            XOBJECT,
            function (options) {
                var el = options.el;
                this._sType = 'xui-h-chart';
                addClass(el, this._sType);

                options.resizable = false;
                Highcharts.setOptions(this.CHART_OPTIONS);

                var type = this._sType;
                el.innerHTML = [
                    '<div class="' + type + '-header">',
                        '<div class="' + type + '-legend"></div>',
                    '</div>',
                    '<div class="' + type + '-content"></div>'
                ].join('');

                this._eLegend = el.childNodes[0].firstChild;
                this._eContent = el.childNodes[1];
            }
        );
    var UI_H_CHART_CLASS = UI_H_CHART.prototype;

    /** 
     * highcharts的默认配置
     *
     * @type {Object}
     * @protected
     */
    UI_H_CHART_CLASS.CHART_OPTIONS = {
        colors: [
            '#50bfc6', 
            '#e9693c', 
            '#0ca961', 
            '#f6ab1a', 
            '#88d915', 
            '#0380ea', 
            '#3c2dc9', 
            '#8e45e9', 
            '#f44dce', 
            '#e21d3d'
        ],
        global: { useUTC: false }
    };

    /** 
     * 周显示
     *
     * @type {Array}
     * @private
     */
    var STR_WEEKDAY = [
        '周日', '周一', '周二', '周三', '周四', '周五', '周六'
    ];

    /**
     * 一天的毫秒数
     */
    var DAY_MILL = 1000 * 60 * 60 * 24;

    /**
     * 全局margin
     */
    var CHART_MARGIN_RIGHT = 35;

    /**
     * 扩展的rangeSelector类型（及其转换方法）
     * 其中新定义了by属性，
     * 如果值为'max'则意为窗口右界会设为最大值
     * 如果值为'current'则意为窗口右界不动（默认）
     *
     * @type {Object}
     * @protected
     */
    UI_H_CHART_CLASS.EXT_RANGE_SELECTOR_TYPE = {
        thisMonth: function (btn) {
            btn.type = function (options) {
                var now = new Date(options.newMax);
                return {
                    newMin: new Date(
                            now.getFullYear(), 
                            now.getMonth(), 
                            1
                        ).getTime()
                }
            };
        },
        thisQuarter: function (btn) {
            btn.type = function (options) {
                return {
                    newMin: getQuarterBegin(
                            new Date(options.newMax)
                        ).getTime()
                }
            };
        },
        thisYear: function (btn) {
            btn.type = function (options) {
                var now = new Date(options.newMax);
                return {
                    newMin: new Date(now.getFullYear(), 0, 1).getTime()
                }
            };
        },
        // highcharts提供的month算不准，所以新做xMonth。
        // xMonth中，当btn.count == 1时，和thisMonth等价
        xMonth: function (btn) {
            btn.type = function (options) {
                var now = new Date(options.newMax);
                return {
                    newMin: new Date(
                            now.getFullYear(), 
                            now.getMonth() - btn.count + 1,
                            1
                        ).getTime()
                }
            };
        },
        // xQuarter中，当btn.count == 1时，和thisQuarter等价
        xQuarter: function (btn) {
            btn.type = function (options) {
                var quarterBegin = getQuarterBegin(new Date(options.newMax));
                quarterBegin.setMonth(
                    quarterBegin.getMonth() - (btn.count - 1) * 3
                );
                return {
                    newMin: quarterBegin.getTime()
                }
            };
        }
    };

    /** 
     * 轴格式解析
     *
     * @type {Object}
     * @protected
     */
    var efmt = UI_H_CHART_CLASS.EXT_AXIS_FORMAT = {};

    /**
     * date 轴格式
     */
    efmt.date = {
        parse: function (dateStr) {
            return dateStr != null
                ? stringToDate(dateStr, 'yyyy-MM-dd').getTime()
                : void 0;
        },
        format: function (timestamp) {
            return dateToString(new Date(timestamp), 'yyyy-MM-dd');
        },
        formatTooltip: function (timestamp) {
            var date = new Date(timestamp);
            return dateToString(date, 'yyyy-MM-dd') 
                + ' (' + STR_WEEKDAY[date.getDay()] + ')';
        },
        inputFormat: '%Y-%m-%d',
        minRange: 2 * 24 * 60 * 60 * 1000
    };

    /**
     * week 轴格式
     */
    efmt.week = {
        parse: efmt.date.parse,
        format: function (timestamp, options) {
            var date = new Date(timestamp);
            var range = (options || {}).range;

            return dateToString(
                    fixByDateRange(getWorkday(date), range), 
                    'yyyy-MM-dd'
                ) 
                + '<br>' 
                + dateToString(
                    fixByDateRange(getWeekend(date), range), 
                    'yyyy-MM-dd'
                );
        },
        formatTooltip: function (timestamp, options) {
            var date = new Date(timestamp);
            var range = (options || {}).range;
            var workday = fixByDateRange(getWorkday(date), range);
            var weekend = fixByDateRange(getWeekend(date), range);
            return dateToString(workday, 'yyyy-MM-dd') 
                + ' (' + STR_WEEKDAY[workday.getDay()] + ')'
                + ' ~ ' 
                + dateToString(weekend, 'yyyy-MM-dd')
                + ' (' + STR_WEEKDAY[weekend.getDay()] + ')';
        },
        formatNavigator: function (timestamp, options) {
            var range = (options || {}).range;
            return dateToString(
                fixByDateRange(getWorkday(new Date(timestamp)), range), 
                'yyyy-MM-dd'
            );
        },
        inputFormat: '%Y-%m-%d',
        minRange: 2 * 7 * 24 * 60 * 60 * 1000
    };

    /**
     * month 轴格式
     */
    efmt.month = {
        parse: function (dateStr) {
            return dateStr != null 
                ? stringToDate(dateStr, 'yyyy-MM').getTime()
                : void 0;
        },
        format: function (timestamp) {
            return dateToString(new Date(timestamp), 'yyyy-MM');
        },
        inputFormat: '%Y-%m',
        minRange: 2 * 31 * 24 * 60 * 60 * 1000
    };

    /**
     * quarter 轴格式
     */
    efmt.quarter = {
        parse: parseQuarter,
        format: function (timestamp) {
            var date = new Date(timestamp);
            return String(
                date.getFullYear() + '-Q' + getQuarter(date)
            );
        },
        inputFormat: '%Y-%q',
        minRange: 2 * 3 * 31 * 24 * 60 * 60 * 1000
    };

    /**
     * year 轴格式
     */
    efmt.year = {
        parse: function (dateStr) {
            return dateStr != null 
                ? new Date(
                    parseInt(dateStr, 10), 0, 1
                ).getTime()
                : void 0;
        },
        format: function (timestamp) {
            return new Date(timestamp).getFullYear();
        },
        inputFormat: '%Y',
        minRange: 2 * 366 * 24 * 60 * 60 * 1000
    };

    /**
     * 解析季度
     */
    function parseQuarter(dateStr) {
        if (dateStr == null) {
            return null;
        }
        var par = [0, 0, 3, 6, 9];
        dateStr = dateStr.split('-Q');
        return new Date(
            parseInt(dateStr[0], 10), 
            par[parseInt(dateStr[1], 10)], 
            1
        ).getTime();
    }

    /**
     * 初始化
     */
    UI_H_CHART_CLASS.init = function () {
    };

    /**
     * 设置数据
     *
     * @public
     * @param {Object} dataWrap 数据
     * @param {boolean=} isSilent 是否静默（不渲染），缺省则为false
     */
    UI_H_CHART_CLASS.setData = function (dataWrap, isSilent) {
        dataWrap = dataWrap || {};

        this._sChartType = fixChartType(dataWrap.chartType, 'line');
        this._bSeriesHasValue = null;
        this._nWidth = dataWrap.width;
        this._nHeight = dataWrap.height;
        /**
         * x轴定义
         * 例如：
         *  xAxis: [
         *      {
         *          type: 'quarter', // 或'category', 'date', 'month'等，参见EXT_AXIS_FORMAT
         *          data: ['2012-Q1', '2012-Q2']
         *      }
         *  ];
         */
        this._aXAxis = dataWrap.xAxis || [];
        /**
         * y轴定义
         * 例如：
         *  xAxis: [
         *      {
         *          format: 'I,III.DD%', // 显示格式
         *          title: '我是y轴上的描述文字'
         *      }
         *  ];
         */
        this._aYAxis = dataWrap.yAxis || [];   
        /**
         * 系列数据
         * 例如：
         *  series: [
         *      {
         *          name: '我是系列1',
         *          data: [1234.1234, 12344.333, 57655]
         *      },
         *      {
         *          name: '我是系列2',
         *          data: [566.1234, 565, 9987]
         *      }
         *  ];
         */
        this._aSeries = dataWrap.series || [];
        /**
         * 用户自定义rangeselector的按钮
         * 例如：
         *  rangeSelector: {
         *      byAxisType: {
         *          date: {
         *              buttons: [
         *                  { type: 'thisMonth', text: '本月', by: 'max' },
         *                  { type: 'all', text: '全部' }
         *              ],
         *              selected: 0
         *          }
         *      }
         *  }
         */
        this._oRangeSelector = dataWrap.rangeSelector || {};
        /**
         * 用户自定义legend的模式（外观+行为）
         * 例如：
         *  legend: { 
         *      xMode: 'pl' // PL模式的legend。缺省则使用默认模式。
         *  }
         */
        this._oLegend = dataWrap.legend || {};
        /**
         * 数据为空时的html
         */
        this._sEmptyHTML = dataWrap.emptyHTML || '数据为空';
             
        !isSilent && this.render();
    };

    /**
     * 设置数据
     *
     * @protected
     */
    UI_H_CHART_CLASS.$setupSeries = function (options) {
        var series = [];
        var xAxis = this._aXAxis[0];

        for (var i = 0, ser, serDef; serDef = this._aSeries[i]; i ++) {
            ser = { data: [] };
            ser.name = serDef.name || '';
            ser.yAxis = serDef.yAxisIndex || 0;
            ser.color = serDef.color || void 0;
            ser.format = serDef.format || void 0;
            ser.type = fixChartType(serDef.type);
            serDef.id !== null && (ser.id = serDef.id);

            if (xAxis.type in this.EXT_AXIS_FORMAT) {
                // 依据扩展时间类型，对series进行调整，使用[x, y]格式
                ser.data = [];
                for (var j = 0; j < serDef.data.length; j ++) {
                    ser.data.push(
                        [
                            this.EXT_AXIS_FORMAT[xAxis.type].parse(xAxis.data[j]),
                            serDef.data[j]
                        ]
                    );
                }
            }
            else {
                ser.data = serDef.data;
            }

            series.push(ser);
        }
        options.series = series;
    }
    
    /**
     * 设置提示浮层
     *
     * @protected
     */
    UI_H_CHART_CLASS.$setupTooptip = function (options) {
        // x轴类型
        var xAxis = this._aXAxis[0];
        var type = xAxis.type; 
        var callback = xAxis.tipCallback;
        var aSeries = this._aSeries;

        var fmt = this.EXT_AXIS_FORMAT[xAxis.type];
        fmt = fmt 
            && (fmt.formatTooltip || fmt.format) 
            || function (o) { return o };

        // 条形图
        if (this._sChartType == 'bar') {
            options.tooltip = {
                useHTML: false,
                shared: true,
                borderColor: '#11A4F2',

                formatter: callback || function () {
                    var htmlArr = [];
                    htmlArr.push(
                        '<span style="color:#4770A7;font-size:13px;font-weight:bold;font-family:\"微软雅黑\",Arial">', 
                            fmt(this.x, { range: xAxis.range }),
                        '</span><br>'
                    );

                    for (var i = 0, o; o = this.points[i]; i ++) {
                        if (o.series.name != null) {
                            htmlArr.push('<span style="color:' + o.series.color + ';font-size:12px;font-weight:bold">' + o.series.name + ': </span>');
                        }
                        htmlArr.push('<span style="color:#000;font-size:12px;font-family:Arial">' + o.point.config[2] + '</span>');
                        if (o.point.config[3] != null) {
                            htmlArr.push(' <span style="color:#000;font-size:12px;font-family:Arial">( ' + o.point.config[3] + ' )</span>');
                        }
                        if (i < this.points.length - 1) {
                            htmlArr.push('<br>');
                        }
                    }
                    return htmlArr.join('');
                }
            }

        } 

        // 其他图
        else {
            options.tooltip = {
                useHTML: false,
                shared: true,
                borderColor: '#11A4F2',

                formatter: callback || function () {
                    var htmlArr = [];
                    htmlArr.push(
                        '<span style="color:#4770A7;line-height:20px;font-size:13px;font-weight:bold;font-family:\"微软雅黑\",Arial">',
                            fmt(this.x, { range: xAxis.range }),
                        '</span><br />'
                    );

                    for (var i = 0, o; o = this.points[i]; i ++) {
                        sFormat = aSeries[i].format;
                        if (o.series.name != null) {
                            htmlArr.push(
                                '<span style="color:' + o.series.color + ';font-size:12px;font-weight:bold">',
                                o.series.name + ': ',
                                '</span>',
                                '<span style="text-align:right;color:#000;font-size:12px;font-family:Arial">',
                                sFormat != null ? formatNumber(o.y, sFormat, null, null, true) : o.y,
                                '</span>'
                            );
                        }
                        if (i < this.points.length - 1) {
                            htmlArr.push('<br>');
                        }
                    }
                    return htmlArr.join('');
                }
            }
        }
    }

    /**
     * 设置x轴
     *
     * @private
     */
    UI_H_CHART_CLASS.$setupXAxis = function (options) {
        var me = this;
        var axisList = [];

        for (
            var axisIndex = 0, xAxisDef, fmt, data; 
            xAxisDef = this._aXAxis[axisIndex]; 
            axisIndex ++
        ) {
            data = xAxisDef.data;

            // range
            if ((fmt = this.EXT_AXIS_FORMAT[xAxisDef.type]) 
                && data 
                && data.length > 0
                && xAxisDef.range
            ) {
                xAxisDef.range = [
                    xAxisDef.range[0] ? fmt.parse(xAxisDef.range[0]) : null,
                    xAxisDef.range[1] ? fmt.parse(xAxisDef.range[1]) : null
                ];
            }

            var xAxis = {
                gridLineWidth: 0,
                gridLineColor: '#DBDBDB',
                tickPosition: 'inside',
                tickLength: 5,
                // startOnTick不要设为true，
                // 因为highstock-1.1.5的bug，true则navigator会
                // 算不准起始点，且拖动后范围越来越大。
                // 暂没空跟这个bug了
                startOnTick: false,
                lineColor: xAxisDef.color || '#8CA5C9',
                lineWidth: 2,
                endOnTick: false,
                maxPadding: 0.002,
                minRange: (this.EXT_AXIS_FORMAT[xAxisDef.type] || {}).minRange,
                tickPositioner: (function (
                            me, axisType, isExtAxisType, useYearMonthAdjust
                        ) {
                        return function (min, max) {
                            return tickPositioner.call(
                                this, me, axisType, isExtAxisType, 
                                useYearMonthAdjust, min, max
                            );
                        }
                    })(
                        me, 
                        xAxisDef.type, 
                        xAxisDef.type in this.EXT_AXIS_FORMAT, 
                        xAxisDef.useYearMonthAdjust
                    ),                
                tickPixelInterval: xAxisDef.tickPixelInterval != null 
                    ? xAxisDef.tickPixelInterval
                    : void 0,
                title: this._aXAxis[axisIndex].title != null
                    ? {
                        enabled: true,
                        text: this._aXAxis[axisIndex].title,
                        align: 'high',
                        rotation: 0,
                        tickInterval: 1,
                        offset: 0,
                        y: -12,
                        x: 10
                    }
                    : void 0,
                labels: { 
                    overflow: void 0,
                    formatter: (function (extFormat, xAxisDef) {
                            return function () {
                                var fun = extFormat[xAxisDef.type];
                                return fun 
                                    ? fun.format.call(
                                        null, 
                                        this.value, 
                                        { range: xAxisDef.range }
                                    )
                                    : this.value;
                            }
                        })(this.EXT_AXIS_FORMAT, xAxisDef),
                    style: {
                        fontFamily: 'Arial,Serif,Times', 
                        fontSize: '12px', 
                        color: '#6B6B6B'
                    }
                }
            };

            if (data 
                && !(this._aXAxis[axisIndex].type in this.EXT_AXIS_FORMAT)
            ) {
                xAxis.categories = data;
            }

            if (this._aXAxis[axisIndex].plotLines != null) {
                xAxis.plotLines = [];

                for (
                    var i = 0, o, before, after; 
                    o = this._aXAxis[axisIndex].plotLines[i]; 
                    i ++
                ) {
                    if (o.value != null) {
                        o.value = this.EXT_AXIS_FORMAT[
                            this._aXAxis[axisIndex].type
                        ].parse(o.value);
                        xAxis.plotLines.push(o);
                    } 

                    else if (
                        o.valueBefore != null || o.valueAfter != null
                    ) {

                        before = o.valueBefore != null 
                            ? o.valueBefore : o.valueAfter;
                        after = o.valueAfter != null 
                            ? o.valueAfter : o.valueBefore;

                        o.value = Math.round(
                            (
                                this.EXT_AXIS_FORMAT[
                                    this._aXAxis[axisIndex].type
                                ].parse(before)
                                + this.EXT_AXIS_FORMAT[
                                    this._aXAxis[axisIndex].type
                                ].parse(after)
                            ) / 2
                        );
                        xAxis.plotLines.push(o);
                    }
                }
            }

            axisList.push(xAxis);
        }

        options.xAxis = !axisList.length 
            ? void 0 
            : (axisList.length > 1 ? axisList : axisList[0]);
    }

    /**
     * 设置y轴
     * 支持多轴
     *
     * @private
     */
    UI_H_CHART_CLASS.$setupYAxis = function (options) {
        var yas = []
        var align = ['right', 'left'];
        var opposite = [false, true];
        var labelOffset = [-7, 5];

        for (var i = 0, yAxisDef, o; yAxisDef = this._aYAxis[i]; i++) {
            o = {
                gridLineWidth: 1,
                gridLineColor: '#DBDBDB',                
                lineColor: yAxisDef.color || '#8CA5C9',
                lineWidth: 2,                
                tickPosition: 'inside',
                tickmarkPlacement: 'on',
                labels: {
                    align: align[i % 2],
                    x: this._sChartType == 'bar' ? 20 : labelOffset[i % 2],
                    style: {
                        fontFamily: 'Arial,Serif,Times', 
                        fontSize: '11px', 
                        color: '#6B6B6B'
                    },
                    formatter: yAxisDef.format
                        ? (typeof yAxisDef.format == 'string'
                            ? (function (formatStr) {
                                return function () { 
                                    return formatNumber(this.value, formatStr, null, null, true) 
                                }
                            })(yAxisDef.format)
                            : yAxisDef.format
                        )
                        : void 0
                },
                opposite: opposite[i % 2],
                title: (yAxisDef.title != null && this.$seriesHasValue())
                    ? extend(
                        {
                            enabled: true,
                            align: 'high',
                            rotation: 0,
                            x: 30,
                            y: -10
                        },
                        yAxisDef.title
                    )
                    : void 0
            };

            if (this._sChartType == 'bar') {
                o.tickPixelInterval = 210;        
                o.min = yAxisDef.min; // 暂不允许负值
            }

            yas.push(o);
        }

        options.yAxis = !yas.length 
            ? {} 
            : (yas.length > 1 ? yas : yas[0]);
    };

    /**
     * 序列上有值
     *
     * @private
     */
    UI_H_CHART_CLASS.$seriesHasValue = function () {
        if (this._bSeriesHasValue != null) {
            //取缓存
            return this._bSeriesHasValue;
        }

        for (var i = 0, ser; i < this._aSeries.length; i ++) {
            if ((ser = this._aSeries[i]) && ser.data && ser.data.length) {
                var lineHasValue = false;
                for (var j = 0; j < ser.data.length; j ++) {
                    if (ser.data[j] != null) {
                        lineHasValue = true;
                    }
                }
                if (lineHasValue) {
                    return this._bSeriesHasValue = true;
                }
            }
        }
        return this._bSeriesHasValue = false;
    }

    /**
     * 设置点
     *
     * @protected
     */
    UI_H_CHART_CLASS.$setupPlotOptions = function (options) {
        // if (this._sChartType == 'bar') {
        //     options.plotOptions = {
        //         bar: {
        //             minPointLength: 2,
        //             borderWidth: 0,
        //             dataLabels: {
        //                 enabled: true,
        //                 color: '#4770A7',
        //                 style: {
        //                     fontWeight: 'bold', 
        //                     fontFamily: 'Arial', 
        //                     fontSize: '14px'
        //                 },
        //                 formatter: function () {
        //                     if (this.point.config[3] != null) {
        //                         return this.point.config[3]; 
        //                     } 
        //                     else {
        //                         return '';
        //                     }
        //                 }
        //             }
        //         }
        //     };
        // }
        var plotOptions = options.plotOptions = options.plotOptions || {};
        var seriesOpt = plotOptions.series = plotOptions.series || {};
        var columnOpt = plotOptions.column = plotOptions.column || {};

        if (!ieVersion) {
            columnOpt.shadow = true;
            columnOpt.borderWidth = 1;
        }

        var useStack = false;
        for (var i = 0, serDef; serDef = this._aSeries[i]; i ++) {
            serDef.stack && (useStack = true);
        }
        useStack && (seriesOpt.stacking = 'normal');
    }

    /**
     * 设置图例
     *
     * @protected
     */
    UI_H_CHART_CLASS.$setupLegend = function (options) {
        // pl模式的legend
        if (this._oLegend.xMode == 'pl') {
            var type = this._sType;

            this._eLegend.style.marginRight = CHART_MARGIN_RIGHT + 'px';

            // 初始化自定义legend
            for (var i = 0, o, ser, color; ser = this._aSeries[i]; i ++) {
                o = document.createElement('span');
                addClass(o, type + '-legend-item');
                color = ser.color || this.CHART_OPTIONS.colors[i];
                o.style.backgroundColor = color;
                o.setAttribute('rel', color);
                o.innerHTML = encodeHTML(ser.name)
                    + '<span class="' + type + '-legend-item-icon"></span>';
                this._eLegend.appendChild(o);

                // 点击事件
                o.onclick = bind(this.$handleLegendClick, this, i, o);
            }

            // 不使用默认legend
            options.legend = { enabled: false };
        }

        // 默认的legend模式
        else {
            options.legend = {
                enabled: true,
                align: 'center',
                borderColor: '#FFF',
                verticalAlign: 'top',
                margin: 15
            };
        }
    }

    /**
     * 图列点击事件处理
     *
     * @protected
     */
    UI_H_CHART_CLASS.$handleLegendClick = function (index, el) {
        var visibleCount = 0;
        var type = this._sType;
        
        this.$foreachSeries(function (ser, index) {
            if (ser && ser.visible) { visibleCount ++; }
        });
        
        // 在highcharts中顺序是一致的，所以可以用index取
        var serie = this._oChart.series[index];
        if (!serie) { return; }
        
        if (serie.visible) {
            if (visibleCount <= 1) {
                return;
            }
            else {
                serie.hide();
                addClass(el, type + '-legend-item-hidden');
                el.style.background = '#B9B9B9';
            }
        }
        else {
            serie.show();
            removeClass(el, type + '-legend-item-hidden');
            el.style.background = el.getAttribute('rel');
        }
    };

    /**
     * 设置区域选择
     * @protected
     */
    UI_H_CHART_CLASS.$setupZoom = function (options) {
        var xAxis = this._aXAxis[0];
        var axisType = xAxis.type;

        options.chart = options.chart || {};
        options.navigator = options.navigator || {};

        // 是否使用zoom和navigator
        if (axisType in this.EXT_AXIS_FORMAT) {
            options.navigator.enabled = true;
            options.scrollbar = { enabled: true };
            options.chart.zoomType = 'x';
            setupRangeSelector.call(this, options, true);
        } 
        else {
            options.navigator.enabled = false;
            options.chart.zoomType = '';
            options.scrollbar = { enabled: false };
            setupRangeSelector.call(this, options, false);
        } 
        
        // navigator初始化
        if (options.navigator.enabled) {
            options.navigator.height = 30;
            options.navigator.series = { 
                dataGrouping: { smoothed: false } 
            };
            var fmt = this.EXT_AXIS_FORMAT[xAxis.type];
            fmt = fmt && fmt.formatNavigator || fmt.format;
            options.navigator.xAxis = { 
                labels: {
                    formatter: function () {
                        return fmt
                            ? fmt.call(null, this.value, { range: xAxis.range })
                            : this.value;
                    },
                    style: { fontFamily: 'Arial', fontSize: '11px' }
                }
            };
        }
    }

    /**
     * 设置区域选择按钮
     *
     * @private
     */
    function setupRangeSelector(options, enabled) {
        var buttons;
        var selected;
        var axisType = this._aXAxis[0].type;
        
        // 禁用rangeselector的情况
        if (!enabled) {
            options.rangeSelector = { enabled: false };
            return;
        }

        var rSele = this._oRangeSelector;
        var rSeleDef = rSele.byAxisType
            // 取axisType对应的buttons定义
            ? rSele.byAxisType[axisType]
            // 如果没有，则取通用的buttons定义
            : rSele;
            
        // 有自定义rangeSelector按钮，则取自定义
        if (rSeleDef) {
            buttons = [];
            for (var i = 0, btn, extFn; i < rSeleDef.buttons.length; i ++) {
                buttons.push(btn = extend({}, rSeleDef.buttons[i]));
                // 扩展类型的处理
                if (extFn = this.EXT_RANGE_SELECTOR_TYPE[btn.type]) {
                    extFn(btn);
                }
            }
            selected = rSeleDef.selected;
        }
        // 未自定义rangeSelector按钮，则取默认配置
        else {
            if (axisType == 'date') {
                buttons = [
                    { type: 'month', count: 1, text: '1月' }, 
                    { type: 'month', count: 3, text: '3月' }, 
                    { type: 'month', count: 6, text: '6月' }, 
                    { type: 'year', count: 1, text: '1年' },
                    { type: 'all', text: '全部' }
                ];
                selected = 4;
            } 
            else if (axisType == 'month') {
                buttons = [
                    { type: 'month', count: 6, text: '6月' }, 
                    { type: 'year', count: 1, text: '1年' },
                    { type: 'all', text: '全部' }
                ];
                selected = 2;
            }
            else {
                buttons = [{ type: 'all', text: '全部' }];
                selected = 0;
            }
        }

        options.rangeSelector = {
            enabled: true,
            buttons: buttons,
            selected: selected,
            buttonTheme: {
                fill: 'none',
                stroke: 'none',
                style: { 
                    color: '#282828', 
                    fontFamily: '微软雅黑, Arial' 
                },
                states: {
                    hover: { 
                        fill: 'white', 
                        stroke: '#50bfc6'
                    },
                    select: { 
                        fill: '#d7ebf6', 
                        stroke: '#50bfc6'
                    }
                }
            },
            inputEnabled: true,
            inputDateFormat: this.EXT_AXIS_FORMAT[axisType].inputFormat,
            inputEditDateFormat: this.EXT_AXIS_FORMAT[axisType].inputFormat,
            inputStyle: {
                color: '#3784b7',
                fontWeight: 'bold'
            },
            labelStyle: {
                color: '#b0b0b0',
                fontWeight: 'bold'
            }
        };
    }

    /**
     * 自定义的x轴刻度排布。
     *  尤其对时间类型的窗口进行适配。
     * 默认的刻度排布处理间隔不能准确。
     *
     * @private
     */
    function tickPositioner(
        control, axisType, isExtAxisType, useYearMonthAdjust, min, max
    ) {
        var axis = this;
        var tickPositions = [];

        // 取第一个series进行刻度
        var firstSeries = axis.series[0];
        if( !firstSeries) {
            return [min, max];
        }

        var ordinalPositions = firstSeries.processedXData;

        // 取得当前窗口
        var tmin;
        var tmax;
        var winIndexStart;
        var winIndexEnd;
        var winIndexLength;
        for (
            var i = 0, item, len = ordinalPositions.length;
            i < len; 
            i ++
        ) {
            item = ordinalPositions[i];
            if(item == null) { continue; }

            if (item >= min 
                && (item - min < tmin || typeof tmin == 'undefined')
            ) { 
                winIndexStart = i; 
                tmin = item - min; 
            }
            if (item <= max 
                && (max - item < tmax || typeof tmax == 'undefined')
            ) { 
                winIndexEnd = i; 
                tmax = max - item; 
            }
        }
        if (typeof winIndexEnd == 'undefined' 
            || typeof winIndexStart == 'undefined'
        ) { 
            return [min, max]; 
        }
        winIndexLength = winIndexEnd - winIndexStart + 1;

        // 计算tick的数量和间隔（各种特例处理）
        if (useYearMonthAdjust 
            && axisType == 'date' 
            && (winIndexLength == 365 || winIndexLength == 366)
        ) {
            // 一年全部日数据的特殊处理
            // 这段代码，如果要tick和datasource对上，
            // 必须是精度到天级别的数据源
            // 月从0开始
            var month30 = { '4': 1, '6': 1, '9': 1, '11': 1 }; 
            var d = new Date(ordinalPositions[winIndexEnd]);
            
            var date = d.getDate();
            var month = d.getMonth();
            var year = d.getFullYear();

            while (true) {
                if (month + 1 == 2 && date >= 29) {
                    d = new Date(year, month, 29);
                    if(d.getMonth() + 1 != 2) {
                        d = new Date(year, month, 28);
                    }
                } 
                else if (month + 1 in month30 && date >= 31) {
                    d = new Date(year, month, 30);
                } 
                else {
                    d = new Date(year, month, date);
                }
                if (d.getTime() < ordinalPositions[winIndexStart]) {
                    break;
                }
                tickPositions.splice(0, 0, d.getTime()); 
                (month <= 0) ? (( month = 11) && (year --)) : (month --);
            }
        } 
        else {
            // 默认情况
            var splitNumber = control._aXAxis[0].splitNumber == null 
                    ? (isExtAxisType ? 5 : winIndexLength)
                    : control._aXAxis[0].splitNumber;
            var indexInterval = Math.ceil(winIndexLength / splitNumber);

            for (i = winIndexEnd; i >= winIndexStart; i -= indexInterval) {
                tickPositions.splice(0, 0, ordinalPositions[i]);
            }
        }

        return tickPositions;
    };

    function fixByDateRange(date, range) {
        if (!range || !date) { return date; }
        var timestamp = date.getTime();
        if (timestamp < range[0]) {
            return new Date(range[0]);
        }
        else if (range[1] < timestamp) {
            return new Date(range[1]);
        }
        return date;
    }

    function fixChartType(rawType, defaultType) {
        if (rawType == 'bar') {
            // 与ecom标准一致化
            return 'column';
        }
        return rawType || defaultType || 'line';
    }

    /**
     * 排序Tooltip
     *
     * @private
     * @param {Array} points 待排序的点列表
     * @returns {Array} 排序后的点列表
     */
    UI_H_CHART_CLASS.sortPoints = function (points) {
        if (!points) { return null; }

        var newPoints = [];
        
        for (var i = 0, l = points.length; i < l; i++) {
            newPoints.push(points[i]);
        }
        
        return newPoints.sort(
            function (pa, pb) {
                if (!pa) { return -1; }
                if (!pb) { return 1; }
                
                if (pa.y > pb.y) { return -1; }
                else if (pa.y < pb.y) { return 1; }
                else { return 0; }
            }
        );
    };

    /**
     * 遍历数据series
     * 因为_oChart.series中也包含有flag和navigator的series，
     * 所以用_aSeries来定位具体的数据series，
     * 同时使用_aSeries.length和_oChart.series[i]，因为后者真包含前者，并且顺序对应
     *
     * @protected
     */
    UI_H_CHART_CLASS.$foreachSeries = function (callback) {
        for(var i = 0, len = this._aSeries.length; i < len; i ++) {
            callback(this._oChart.series[i], i);
        }
    };

    /**
     * 重新渲染图表
     *
     * @public
     */
    UI_H_CHART_CLASS.render = function () {
        this.$disposeChart();

        if (!this._aSeries || this._aSeries.length == 0) {
            this._eContent.innerHTML = '' 
                + '<div class="' + this._sType + '-empty">' 
                    + this._sEmptyHTML 
                + '</div>';
            return;
        }

        this.$createChart(this.$initOptions()) ;
    };

    /**
     * 创建图表
     *
     * @public
     */
    UI_H_CHART_CLASS.$createChart = function (options) {
        if (this._aXAxis[0].type in this.EXT_AXIS_FORMAT) {
            // 扩展时间类型，使用stockchart完成
            this._oChart = new Highcharts.StockChart(options);
        }
        else {
            this._oChart = new Highcharts.Chart(options);
        }
    };

    /**
     * 构建图表参数
     *
     * @private
     */
    UI_H_CHART_CLASS.$initOptions = function () {
        var options = {
            chart: {
                type: this._sChartType,
                renderTo: this._eContent,
                zoomType: 'x',
                width: this._nWidth,
                height: this._nHeight
            },
            credits: { enabled: false },
            title: { text: '' }
        };
        if (this._aYAxis.length > 0) {
            options.chart.marginRight = CHART_MARGIN_RIGHT;
        }
        
        this.$setupSeries(options);
        this.$setupPlotOptions(options);
        this.$setupXAxis(options);
        this.$setupYAxis(options);
        this.$setupTooptip(options);
        this.$setupLegend(options);
        this.$setupZoom(options);
        
        return options;
    };

    /**
     * 销毁图表
     *
     * @private
     */
    UI_H_CHART_CLASS.$disposeChart = function () {
        if (this._oChart) {
            this._oChart.destroy();
            this._oChart = null;
        }
        this._eContent && (this._eContent.innerHTML = '');
        this._eLegend && (this._eLegend.innerHTML = '');
    };

    /**
     * @override
     */
    UI_H_CHART_CLASS.dispose = function () {
        this.$disposeChart();
        UI_H_CHART_CLASS.superClass.dispose.call(this);
    };

})();

/**
 * di.shared.adapter.HChartVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    HChart的适配器
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var formatTime = UTIL.formatTime;
    var dateToString = xutil.date.dateToString;
    var GLOBAL_MODEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * IstCalendar的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().HChartVUIAdapter = function(def, options) {
        return {
            setData: setData
        };
    };

    /**
     * 设置数据
     *
     * @public
     */
    function setData(data) {
        var now = GLOBAL_MODEL().getDateModel().now();

        if (data.weekViewRange) {
            var range = parseTimeUnitDef(data.weekViewRange, [now, now]);

            if (range) {
                var fmt = 'yyyy-MM-dd';
                range[0] = range.start ? dateToString(range.start, fmt) : null;
                range[1] = range.end ? dateToString(range.end, fmt) : null;

                for (
                    var i = 0, xAxisDef; 
                    xAxisDef = (data.xAxis || [])[i]; 
                    i ++
                ) {
                    xAxisDef.range = range;
                }
            }
        }

        this.setData(data);
    }

})();


/*
Button - 定义按钮的基本操作。
按钮控件，继承自基础控件，屏蔽了激活状态的向上冒泡，并且在激活(active)状态下鼠标移出控件区域会失去激活样式，移入控件区域再次获得激活样式，按钮控件中的文字不可以被选中。

按钮控件直接HTML初始化的例子:
<div ecui="type:button">
  <!-- 这里放按钮的文字 -->
  ...
</div>
或
<button ecui="type:button">
  <!-- 这里放按钮的文字 -->
  ...
</button>
或
<input ecui="type:button" value="按钮文字" type="button">

属性
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        setText = dom.setText,
        setDefault = util.setDefault,

        inheritsControl = core.inherits,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_BUTTON
    ///__gzip_original__UI_BUTTON_CLASS
    /**
     * 初始化基础控件。
     * options 对象支持的属性如下：
     * text 按钮的文字
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_BUTTON = ui.Button =
        inheritsControl(
            UI_CONTROL,
            'ui-button',
            function (el, options) {
                setDefault(options, 'userSelect', false);
                if (options.text) {
                    setText(el, options.text);
                }
            }
        ),
        UI_BUTTON_CLASS = UI_BUTTON.prototype;
//{else}//
    /**
     * 按钮控件获得激活时需要阻止事件的冒泡。
     * @override
     */
    UI_BUTTON_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        event.stopPropagation();
    };

    /**
     * 如果控件处于激活状态，移除状态样式 -active，移除状态样式不失去激活状态。
     * @override
     */
    UI_BUTTON_CLASS.$mouseout = function (event) {
        UI_CONTROL_CLASS.$mouseout.call(this, event);
        if (this.isActived()) {
            this.alterClass('-active');
        }
    };

    /**
     * 如果控件处于激活状态，添加状态样式 -active。
     * @override
     */
    UI_BUTTON_CLASS.$mouseover = function (event) {
        UI_CONTROL_CLASS.$mouseover.call(this, event);
        if (this.isActived()) {
            this.alterClass('+active');
        }
    };

    /**
     * 设置控件的文字。
     * @public
     *
     * @param {string} text 控件的文字
     */
    UI_BUTTON_CLASS.setText = function (text) {
        setText(this.getBody(), text);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Scrollbar - 定义在区间轴内移动的基本操作。
滚动条控件，继承自基础控件，是滚动行为的虚拟实现，不允许直接初始化，它的子类通常情况下也不会被直接初始化，而是作为控件的一部分用于控制父控件的行为。

属性
_nTotal         - 滚动条区域允许设置的最大值
_nStep          - 滚动条移动一次时的基本步长
_nValue         - 滚动条当前设置的值
_oStop          - 定时器的句柄，用于连续滚动处理
_uPrev          - 向前滚动按钮
_uNext          - 向后滚动按钮
_uThumb         - 滑动按钮

滑动按钮属性
_oRange         - 滑动按钮的合法滑动区间
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        FLOOR = MATH.floor,
        MAX = MATH.max,
        MIN = MATH.min,

        children = dom.children,
        blank = util.blank,
        setDefault = util.setDefault,
        timer = util.timer,

        $fastCreate = core.$fastCreate,
        drag = core.drag,
        getActived = core.getActived,
        getMouseX = core.getMouseX,
        getMouseY = core.getMouseY,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SCROLLBAR
    ///__gzip_original__UI_SCROLLBAR_CLASS
    ///__gzip_original__UI_VSCROLLBAR
    ///__gzip_original__UI_VSCROLLBAR_CLASS
    ///__gzip_original__UI_HSCROLLBAR
    ///__gzip_original__UI_HSCROLLBAR_CLASS
    /**
     * 初始化滚动条控件。
     * @protected
     *
     * @param {Object} options 初始化选项
     */
    var UI_SCROLLBAR = ui.Scrollbar =
        inheritsControl(
            UI_CONTROL,
            'ui-scrollbar',
            function (el, options) {
                setDefault(options, 'userSelect', false);
                setDefault(options, 'focusable', false);

                var type = this.getType();

                el.innerHTML =
                    '<div class="' +
                        type + '-prev' + this.Button.TYPES +
                        '" style="position:absolute;top:0px;left:0px"></div><div class="' +
                        type + '-next' + this.Button.TYPES +
                        '" style="position:absolute;top:0px;left:0px"></div><div class="' +
                        this.Thumb.TYPES + '" style="position:absolute"></div>';
            },
            function (el, options) {
                // 使用 el 代替 children
                el = children(el);

                // 初始化滚动条控件
                this._nValue = this._nTotal = 0;
                this._nStep = 1;

                // 创建向前/向后滚动按钮与滑动按钮
                this._uPrev = $fastCreate(this.Button, el[0], this, {focusable: false});
                this._uNext = $fastCreate(this.Button, el[1], this, {focusable: false});
                this._uThumb = $fastCreate(this.Thumb, el[2], this, {focusable: false});

                this._oStop = blank;
            }
        ),
        UI_SCROLLBAR_CLASS = UI_SCROLLBAR.prototype,

        /**
         * 初始化滚动条控件的滑动按钮部件。
         * @protected
         *
         * @param {Object} options 初始化选项
         */
        UI_SCROLLBAR_THUMB_CLASS =
            (UI_SCROLLBAR_CLASS.Thumb = inheritsControl(UI_BUTTON, 'ui-scrollbar-thumb')).prototype,

        /**
         * 初始化滚动条控件的按钮部件。
         * @protected
         *
         * @param {Object} options 初始化选项
         */
        UI_SCROLLBAR_BUTTON_CLASS =
            (UI_SCROLLBAR_CLASS.Button = inheritsControl(UI_BUTTON, 'ui-scrollbar-button')).prototype;
//{else}//
    /**
     * 控扭控件自动滚动。
     * @private
     *
     * @param {ecui.ui.Scrollbar} scrollbar 滚动条控件
     * @param {number} step 单次滚动步长，为负数表示向前滚动，否则是向后滚动
     * @param {number} interval 触发时间间隔，默认40ms
     */
    function UI_SCROLLBAR_AUTO_SCROLL(scrollbar, step, interval) {
        var value = scrollbar._nValue,
            direction = scrollbar.getMouseDirection();

        // 如果有没有结束的自动滚动，需要先结束，这种情况出现在快速的多次点击时
        scrollbar._oStop();

        if (direction == -1 && step < 0 || direction == 1 && step > 0) {
            scrollbar.setValue(value + step);
        }
        else {
            // 如果因为鼠标位置的原因无法自动滚动，需要强制设置值变化属性
            value = -1;
        }

        // 如果滚动条的值发生变化，将进行下一次的自动滚动，否则滚动条已经到达两端停止自动滚动
        scrollbar._oStop = scrollbar._nValue != value ?
            timer(UI_SCROLLBAR_AUTO_SCROLL, interval || 200, null, scrollbar, step, 40) : blank;
    }

    /**
     * 滚动条值发生改变后的处理。
     * 滚动条的值发生改变后，将触发父控件的 onscroll 事件，如果事件返回值不为 false，则调用父控件的 $scroll 方法。
     * @private
     *
     * @param {ecui.ui.Scrollbar} scrollbar 滚动条控件
     */
    function UI_SCROLLBAR_CHANGE(scrollbar) {
        var parent = scrollbar.getParent(),
            uid;

        if (parent) {
            parent.$scroll();
            if (!UI_SCROLLBAR[uid = parent.getUID()]) {
                // 根据浏览器的行为，无论改变滚动条的值多少次，在一个脚本运行周期只会触发一次onscroll事件
                timer(function () {
                    delete UI_SCROLLBAR[uid];
                    triggerEvent(parent, 'scroll', false);
                });
                UI_SCROLLBAR[uid] = true;
            }
        }
    }

    /**
     * 滑动按钮获得激活时，触发滑动按钮进入拖拽状态。
     * @override
     */
    UI_SCROLLBAR_THUMB_CLASS.$activate = function (event) {
        UI_BUTTON_CLASS.$activate.call(this, event);

        drag(this, event, this._oRange);
    };

    /**
     * @override
     */
    UI_SCROLLBAR_THUMB_CLASS.$dragmove = function (event, x, y) {
        UI_BUTTON_CLASS.$dragmove.call(this, event, x, y);

        var parent = this.getParent(),
            value = parent.$calculateValue(x, y);

        // 应该滚动step的整倍数
        parent.$setValue(value == parent._nTotal ? value : value - value % parent._nStep);
        UI_SCROLLBAR_CHANGE(parent);
    };

    /**
     * 设置滑动按钮的合法拖拽区间。
     * @public
     *
     * @param {number} top 允许拖拽的最上部区域
     * @param {number} right 允许拖拽的最右部区域
     * @param {number} bottom 允许拖拽的最下部区域
     * @param {number} left 允许拖拽的最左部区域
     */
    UI_SCROLLBAR_THUMB_CLASS.setRange = function (top, right, bottom, left) {
        this._oRange = {
            top: top,
            right: right,
            bottom: bottom,
            left: left
        };
    };

    /**
     * 滚动条按钮获得激活时，将开始自动滚动。
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$activate = function (event) {
        UI_BUTTON_CLASS.$activate.call(this, event);

        var parent = this.getParent();
        UI_SCROLLBAR_AUTO_SCROLL(parent, parent.getMouseDirection() * MAX(parent._nStep, 5));
    };

    /**
     * 滚动条按钮失去激活时，将停止自动滚动。
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$deactivate = function (event) {
        UI_BUTTON_CLASS.$deactivate.call(this, event);
        this.getParent()._oStop();
    };

    /**
     * 滚动条按钮鼠标移出时，如果控件处于直接激活状态，将暂停自动滚动。
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$mouseout = function (event) {
        UI_BUTTON_CLASS.$mouseout.call(this, event);
        if (getActived() == this) {
            this.getParent()._oStop(true);
        }
    };

    /**
     * 滚动条按钮鼠标移入时，如果控件处于直接激活状态，将恢复自动滚动。
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$mouseover = function (event) {
        UI_BUTTON_CLASS.$mouseover.call(this, event);
        if (getActived() == this) {
            this.getParent()._oStop(true);
        }
    };

    /**
     * 滚动条获得激活时，将开始自动滚动。
     * @override
     */
    UI_SCROLLBAR_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        UI_SCROLLBAR_AUTO_SCROLL(this, this.getMouseDirection() * this.$getPageStep());
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        this._uPrev.cache(true, true);
        this._uNext.cache(true, true);
        this._uThumb.cache(true, true);
    };

    /**
     * 滚动条失去激活时，将停止自动滚动。
     * @override
     */
    UI_SCROLLBAR_CLASS.$deactivate = function (event) {
        UI_CONTROL_CLASS.$deactivate.call(this, event);
        this._oStop();
    };

    /**
     * 隐藏滚动条控件时，滚动条控件的当前值需要复位为0，参见 setValue 方法。
     * @override
     */
    UI_SCROLLBAR_CLASS.$hide = function () {
        UI_CONTROL_CLASS.$hide.call(this);
        UI_SCROLLBAR_CLASS.setValue.call(this, 0);
    };

    /**
     * 滚动条鼠标移出时，如果控件处于直接激活状态，将暂停自动滚动。
     * @override
     */
    UI_SCROLLBAR_CLASS.$mouseout = function (event) {
        UI_CONTROL_CLASS.$mouseout.call(this, event);
        if (getActived() == this) {
            this._oStop(true);
        }
    };

    /**
     * 滚动条鼠标移入时，如果控件处于直接激活状态，将恢复自动滚动。
     * @override
     */
    UI_SCROLLBAR_CLASS.$mouseover = function (event) {
        UI_CONTROL_CLASS.$mouseover.call(this, event);
        if (getActived() == this) {
            this._oStop(true);
        }
    };

    /**
     * 设置滚动条控件的单页步长。
     * 滚动条控件的单页步长决定在点击滚动条空白区域(即非按钮区域)时滚动一页移动的距离，如果不设置单页步长，默认使用最接近滚动条长度的合理步长(即单项步长最接近总长度的整数倍)。
     * @protected
     *
     * @param {number} step 单页步长
     */
    UI_SCROLLBAR_CLASS.$setPageStep = function (step) {
        this._nPageStep = step;
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
    };

    /**
     * 直接设置控件的当前值。
     * $setValue 仅仅设置控件的参数值，不进行合法性验证，也不改变滑动按钮的位置信息，用于滑动按钮拖拽时同步设置当前值。
     * @protected
     *
     * @param {number} value 控件的当前值
     */
    UI_SCROLLBAR_CLASS.$setValue = function (value) {
        this._nValue = value;
    };

    /**
     * 获取滚动条控件的单次滚动步长。
     * getStep 方法返回滚动条控件发生滚动时，移动的最小步长值，通过 setStep 设置。
     * @public
     *
     * @return {number} 单次滚动步长
     */
    UI_SCROLLBAR_CLASS.getStep = function () {
        return this._nStep;
    };

    /**
     * 获取滚动条控件的最大值。
     * getTotal 方法返回滚动条控件允许滚动的最大值，最大值、当前值与滑动按钮控件的实际位置互相影响，通过 setTotal 设置。
     * @public
     *
     * @return {number} 控件的最大值
     */
    UI_SCROLLBAR_CLASS.getTotal = function () {
        return this._nTotal;
    };

    /**
     * 获取滚动条控件的当前值。
     * getValue 方法返回滚动条控件的当前值，最大值、当前值与滑动按钮控件的实际位置互相影响，但是当前值不允许超过最大值，通过 setValue 方法设置。
     * @public
     *
     * @return {number} 滚动条控件的当前值
     */
    UI_SCROLLBAR_CLASS.getValue = function () {
        return this._nValue;
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uPrev.init();
        this._uNext.init();
        this._uThumb.init();
    };

    /**
     * 设置滚动条控件的单次滚动步长。
     * setStep 方法设置的值必须大于0，否则不会进行操作。
     * @public
     *
     * @param {number} value 单次滚动步长
     */
    UI_SCROLLBAR_CLASS.setStep = function (value) {
        if (value > 0) {
            this._nStep = value;
        }
    };

    /**
     * 设置滚动条控件的最大值。
     * setTotal 方法设置的值不能为负数，当前值如果大于最大值，设置当前值为新的最大值，最大值发生改变将导致滑动按钮刷新。
     * @public
     *
     * @param {number} value 控件的最大值
     */
    UI_SCROLLBAR_CLASS.setTotal = function (value) {
        if (value >= 0 && this._nTotal != value) {
            this._nTotal = value;
            // 检查滚动条控件的当前值是否已经越界
            if (this._nValue > value) {
                // 值发生改变时触发相应的事件
                this._nValue = value;
                UI_SCROLLBAR_CHANGE(this);
            }
            this.$flushThumb();
        }
    };

    /**
     * 设置滚动条控件的当前值。
     * setValue 方法设置的值不能为负数，也不允许超过使用 setTotal 方法设置的控件的最大值，如果当前值不合法，将自动设置为最接近合法值的数值，当前值发生改变将导致滑动按钮控件刷新。
     * @public
     *
     * @param {number} value 控件的当前值
     */
    UI_SCROLLBAR_CLASS.setValue = function (value) {
        value = MIN(MAX(0, value), this._nTotal);
        if (this._nValue != value) {
            // 值发生改变时触发相应的事件
            this._nValue = value;
            UI_SCROLLBAR_CHANGE(this);
            this.$flushThumb();
        }
    };

    /**
     * 滚动条控件当前值移动指定的步长次数。
     * 参数 value 必须是整数, 正数则向最大值方向移动，负数则向0方向移动，允许移动的区间在0-最大值之间，参见 setStep、setTotal 与 setValue 方法。
     * @public
     *
     * @param {number} n 移动的步长次数
     */
    UI_SCROLLBAR_CLASS.skip = function (n) {
        this.setValue(this._nValue + n * this._nStep);
    };
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化垂直滚动条控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_VSCROLLBAR = ui.VScrollbar = inheritsControl(UI_SCROLLBAR, 'ui-vscrollbar'),
        UI_VSCROLLBAR_CLASS = UI_VSCROLLBAR.prototype;
//{else}//
    /**
     * 计算滑动按钮拖拽时的当前值。
     * 滑动按钮拖拽时，根据位置计算对应的当前值，然后通过 $setValue 方法直接设置。
     * @protected
     *
     * @param {number} x 滑动按钮实际到达的X轴坐标
     * @param {number} y 滑动按钮实际到达的Y轴坐标
     */
    UI_VSCROLLBAR_CLASS.$calculateValue = function (x, y) {
        //__gzip_original__range
        var thumb = this._uThumb,
            range = thumb._oRange;
        return (y - range.top) / (range.bottom - this._uPrev.getHeight() - thumb.getHeight()) * this._nTotal;
    };

    /**
     * 滑动按钮刷新。
     * 当滚动条控件的大小或最大值/当前值发生变化时，滑动按钮的大小与位置需要同步改变，参见 setSize、setValue 与 setTotal 方法。
     * @protected
     */
    UI_VSCROLLBAR_CLASS.$flushThumb = function () {
        // 计算滑动按钮高度与位置
        var thumb = this._uThumb,
            total = this._nTotal,
            height = this.getHeight(),
            prevHeight = this._uPrev.getHeight(),
            bodyHeight = this.getBodyHeight(),
            thumbHeight = MAX(FLOOR(bodyHeight * height / (height + total)), thumb.getMinimumHeight() + 5);

        if (total) {
            thumb.$setSize(0, thumbHeight);
            thumb.setPosition(0, prevHeight + FLOOR((this._nValue / total) * (bodyHeight - thumbHeight)));
            thumb.setRange(prevHeight, 0, bodyHeight + prevHeight, 0);
        }
    };

    /**
     * 获取单页的步长。
     * 如果使用 $setPageStep 方法设置了单页的步长，$getPageStep 方法直接返回设置的步长，否则 $getPageStep 返回最接近滚动条控件长度的步长的整数倍。
     * @protected
     *
     * @return {number} 单页的步长
     */
    UI_VSCROLLBAR_CLASS.$getPageStep = function () {
        var height = this.getHeight();
        return this._nPageStep || height - height % this._nStep;
    };

    /**
     * @override
     */
    UI_VSCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_SCROLLBAR_CLASS.$setSize.call(this, width, height);

        //__gzip_original__next
        var bodyWidth = this.getBodyWidth(),
            prevHeight = this.$$paddingTop,
            next = this._uNext;

        // 设置滚动按钮与滑动按钮的信息
        this._uPrev.$setSize(bodyWidth, prevHeight);
        next.$setSize(bodyWidth, this.$$paddingBottom);
        this._uThumb.$setSize(bodyWidth);
        next.setPosition(0, this.getBodyHeight() + prevHeight);

        this.$flushThumb();
    };

    /**
     * 获取鼠标相对于滑动按钮的方向。
     * 鼠标如果在滑动按钮之前，返回 -1，鼠标如果在滑动按钮之后，返回 1，否则返回 0。
     * @protected
     *
     * @return {number} 鼠标相对于滑动按钮的方向数值
     */
    UI_VSCROLLBAR_CLASS.getMouseDirection = function () {
        return getMouseY(this) < this._uThumb.getY() ?
            -1 : getMouseY(this) > this._uThumb.getY() + this._uThumb.getHeight() ? 1 : 0;
    };
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化水平滚动条控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_HSCROLLBAR = ui.HScrollbar = inheritsControl(UI_SCROLLBAR, 'ui-hscrollbar'),
        UI_HSCROLLBAR_CLASS = UI_HSCROLLBAR.prototype;
//{else}//
    /**
     * 计算滑动按钮拖拽时的当前值。
     * 滑动按钮拖拽时，根据位置计算对应的当前值，然后通过 $setValue 方法直接设置。
     * @protected
     *
     * @param {number} x 滑动按钮实际到达的X轴坐标
     * @param {number} y 滑动按钮实际到达的Y轴坐标
     */
    UI_HSCROLLBAR_CLASS.$calculateValue = function (x, y) {
        //__gzip_original__range
        var thumb = this._uThumb,
            range = thumb._oRange;
        return (x - range.left) / (range.right - this._uPrev.getWidth() - thumb.getWidth()) * this._nTotal;
    };

    /**
     * 滑动按钮刷新。
     * 当滚动条控件的大小或最大值/当前值发生变化时，滑动按钮的大小与位置需要同步改变，参见 setSize、setValue 与 setTotal 方法。
     * @protected
     */
    UI_HSCROLLBAR_CLASS.$flushThumb = function () {
        // 计算滑动按钮高度与位置
        var thumb = this._uThumb,
            total = this._nTotal,
            width = this.getWidth(),
            prevWidth = this._uPrev.getWidth(),
            bodyWidth = this.getBodyWidth(),
            thumbWidth = MAX(FLOOR(bodyWidth * width / (width + total)), thumb.getMinimumWidth() + 5);

        if (total) {
            thumb.$setSize(thumbWidth);
            thumb.setPosition(prevWidth + FLOOR((this._nValue / total) * (bodyWidth - thumbWidth)), 0);
            thumb.setRange(0, bodyWidth + prevWidth, 0, prevWidth);
        }
    };

    /**
     * 获取单页的步长。
     * 如果使用 $setPageStep 方法设置了单页的步长，$getPageStep 方法直接返回设置的步长，否则 $getPageStep 返回最接近滚动条控件长度的步长的整数倍。
     * @protected
     *
     * @return {number} 单页的步长
     */
    UI_HSCROLLBAR_CLASS.$getPageStep = function () {
        var width = this.getWidth();
        return width - width % this._nStep;
    };

    /**
     * @override
     */
    UI_HSCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_SCROLLBAR_CLASS.$setSize.call(this, width, height);

        //__gzip_original__next
        var bodyHeight = this.getBodyHeight(),
            prevWidth = this.$$paddingLeft,
            next = this._uNext;

        // 设置滚动按钮与滑动按钮的信息
        this._uPrev.$setSize(prevWidth, bodyHeight);
        next.$setSize(this.$$paddingRight, bodyHeight);
        this._uThumb.$setSize(0, bodyHeight);
        next.setPosition(this.getBodyWidth() + prevWidth, 0);

        this.$flushThumb();
    };

    /**
     * 获取鼠标相对于滑动按钮的方向。
     * 鼠标如果在滑动按钮之前，返回 -1，鼠标如果在滑动按钮之后，返回 1，否则返回 0。
     * @protected
     *
     * @return {number} 鼠标相对于滑动按钮的方向数值
     */
    UI_HSCROLLBAR_CLASS.getMouseDirection = function () {
        return getMouseX(this) < this._uThumb.getX() ?
            -1 : getMouseX(this) > this._uThumb.getX() + this._uThumb.getWidth() ? 1 : 0;
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Panel - 定义在一个小区域内截取显示大区域内容的基本操作。
截面控件，继承自基础控件，用于显示实际的内容区域超过控件显示区域的信息，通过拖拽滚动条显示完整的内容，截面控件可以设置参数决定是否自动显示水平/垂直滚动条，如果设置不显示水平/垂直滚动条，水平/垂直内容超出的部分将直接被截断，当设置两个滚动条都不显示时，截面控件从显示效果上等同于基础控件。在截面控件上滚动鼠标滑轮，将控制截面控件往垂直方向(如果没有垂直滚动条则在水平方向)前移或者后移滚动条，在获得焦点后，通过键盘的方向键也可以操作截面控件的滚动条。

截面控件直接HTML初始化的例子:
<div ecui="type:panel">
  <!-- 这里放内容 -->
  ...
</div>

属性
_bAbsolute           - 是否包含绝对定位的Element
_nWheelDelta         - 鼠标滚轮滚动一次的差值
_eBrowser            - 用于浏览器原生的滚动条实现的Element
_uVScrollbar         - 垂直滚动条控件
_uHScrollbar         - 水平滚动条控件
_uCorner             - 夹角控件
$$mainWidth          - layout区域的实际宽度
$$mainHeight         - layout区域的实际高度
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,
        FLOOR = MATH.floor,

        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getStyle = dom.getStyle,
        moveElements = dom.moveElements,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        calcHeightRevise = core.calcHeightRevise,
        calcWidthRevise = core.calcWidthRevise,
        findControl = core.findControl,
        getKey = core.getKey,
        getScrollNarrow = core.getScrollNarrow,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        wrapEvent = core.wrapEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_VSCROLLBAR = ui.VScrollbar,
        UI_HSCROLLBAR = ui.HScrollbar;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化浏览器原生滚动条控件。
     * @protected
     *
     * @param {Object} options 初始化选项
     */
    ///__gzip_original__UI_BROWSER_SCROLLBAR
    ///__gzip_original__UI_BROWSER_SCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_VSCROLLBAR
    ///__gzip_original__UI_BROWSER_VSCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_HSCROLLBAR
    ///__gzip_original__UI_BROWSER_HSCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_CORNER
    ///__gzip_original__UI_BROWSER_CORNER_CLASS
    ///__gzip_original__UI_PANEL
    ///__gzip_original__UI_PANEL_CLASS
    var UI_BROWSER_SCROLLBAR =
        inheritsControl(
            UI_CONTROL,
            null,
            null,
            function (el, options) {
                detachEvent(el, 'scroll', UI_BROWSER_SCROLLBAR_SCROLL);
                attachEvent(el, 'scroll', UI_BROWSER_SCROLLBAR_SCROLL);
            }
        ),
        UI_BROWSER_SCROLLBAR_CLASS = UI_BROWSER_SCROLLBAR.prototype;
//{else}//
    /**
     * 原生滚动条滚动处理。
     * 滚动条滚动后，将触发父控件的 onscroll 事件，如果事件返回值不为 false，则调用父控件的 $scroll 方法。
     * @private
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    function UI_BROWSER_SCROLLBAR_SCROLL(event) {
        triggerEvent(findControl(getParent(wrapEvent(event).target)), 'scroll');
    }

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.$hide = UI_BROWSER_SCROLLBAR_CLASS.hide = function () {
        this.getMain().style[this._aProperty[0]] = 'hidden';
        UI_BROWSER_SCROLLBAR_CLASS.setValue.call(this, 0);
    };

    /**
     * 直接设置控件的当前值。
     * @protected
     *
     * @param {number} value 控件的当前值
     */
    UI_BROWSER_SCROLLBAR_CLASS.$setValue = function (value) {
        this.getMain()[this._aProperty[1]] = MIN(MAX(0, value), this.getTotal());
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.$show = UI_BROWSER_SCROLLBAR_CLASS.show = function () {
        this.getMain().style[this._aProperty[0]] = 'scroll';
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.getHeight = function () {
        return this._aProperty[4] ? this.getMain()[this._aProperty[4]] : getScrollNarrow();
    };

    /**
     * 获取滚动条控件的最大值。
     * getTotal 方法返回滚动条控件允许滚动的最大值，最大值、当前值与滑动块控件的实际位置互相影响，通过 setTotal 设置。
     * @public
     *
     * @return {number} 控件的最大值
     */
    UI_BROWSER_SCROLLBAR_CLASS.getTotal = function () {
        return toNumber(this.getMain().lastChild.style[this._aProperty[2]]);
    };

    /**
     * 获取滚动条控件的当前值。
     * getValue 方法返回滚动条控件的当前值，最大值、当前值与滑动按钮控件的实际位置互相影响，但是当前值不允许超过最大值，通过 setValue 方法设置。
     * @public
     *
     * @return {number} 滚动条控件的当前值
     */
    UI_BROWSER_SCROLLBAR_CLASS.getValue = function () {
        return this.getMain()[this._aProperty[1]];
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.getWidth = function () {
        return this._aProperty[3] ? this.getMain()[this._aProperty[3]] : getScrollNarrow();
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.isShow = function () {
        return this.getMain().style[this._aProperty[0]] != 'hidden';
    };

    /**
     * 设置滚动条控件的最大值。
     * setTotal 方法设置的值不能为负数，当前值如果大于最大值，设置当前值为新的最大值，最大值发生改变将导致滑动按钮刷新。
     * @public
     *
     * @param {number} value 控件的最大值
     */
    UI_BROWSER_SCROLLBAR_CLASS.setTotal = function (value) {
        this.getMain().lastChild.style[this._aProperty[2]] = value + 'px';
    };

    /**
     * 设置滚动条控件的当前值。
     * @public
     *
     * @param {number} value 控件的当前值
     */
    UI_BROWSER_SCROLLBAR_CLASS.setValue = function (value) {
        this.$setValue(value);
        triggerEvent(this.getParent(), 'scroll');
    };

    UI_BROWSER_SCROLLBAR_CLASS.$cache =
        UI_BROWSER_SCROLLBAR_CLASS.$getPageStep = UI_BROWSER_SCROLLBAR_CLASS.$setPageStep =
        UI_BROWSER_SCROLLBAR_CLASS.$setSize = UI_BROWSER_SCROLLBAR_CLASS.alterClass =
        UI_BROWSER_SCROLLBAR_CLASS.cache = UI_BROWSER_SCROLLBAR_CLASS.getStep =
        UI_BROWSER_SCROLLBAR_CLASS.init = UI_BROWSER_SCROLLBAR_CLASS.setPosition =
        UI_BROWSER_SCROLLBAR_CLASS.setStep = UI_BROWSER_SCROLLBAR_CLASS.skip = blank;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化浏览器原生垂直滚动条控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_BROWSER_VSCROLLBAR =
        inheritsControl(
            UI_BROWSER_SCROLLBAR,
            null,
            null,
            function (el, options) {
                this._aProperty = ['overflowY', 'scrollTop', 'height', null, 'offsetHeight'];
            }
        );
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化浏览器原生水平滚动条控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_BROWSER_HSCROLLBAR =
        inheritsControl(
            UI_BROWSER_SCROLLBAR,
            null,
            null,
            function (el, options) {
                this._aProperty = ['overflowX', 'scrollLeft', 'width', 'offsetWidth', null];
            }
        );
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化夹角控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_BROWSER_CORNER = inheritsControl(UI_CONTROL),
        UI_BROWSER_CORNER_CLASS = UI_BROWSER_CORNER.prototype;
//{else}//
    (function () {
        for (var name in UI_CONTROL_CLASS) {
            UI_BROWSER_CORNER_CLASS[name] = blank;
        }
    })();
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化截面控件，截面控件支持自动展现滚动条控件，允许指定需要自动展现的垂直或水平滚动条。
     * options 对象支持的属性如下：
     * vScroll    是否自动展现垂直滚动条，默认展现
     * hScroll    是否自动展现水平滚动条，默认展现
     * browser    是否使用浏览器原生的滚动条，默认使用模拟的滚动条
     * absolute   是否包含绝对定位的Element，默认不包含
     * wheelDelta 鼠标滚轮的步长，即滚动一次移动的最小步长单位，默认总步长(差值*步长)为不大于20像素的最大值
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_PANEL = ui.Panel =
        inheritsControl(
            UI_CONTROL,
            'ui-panel',
            function (el, options) {
                var vscroll = options.vScroll !== false,
                    hscroll = options.hScroll !== false,
                    type = this.getType(),
                    o = createDom(
                        type + '-body',
                        'position:absolute;top:0px;left:0px' + (hscroll ? ';white-space:nowrap' : '')
                    );

                el.style.overflow = 'hidden';
                moveElements(el, o, true);

                el.innerHTML =
                    (options.browser ?
                        '<div style="position:absolute;top:0px;left:0px;overflow:auto;padding:0px;border:0px">' +
                            '<div style="width:1px;height:1px;padding:0px;border:0px"></div></div>'
                        : (vscroll ?
                            '<div class="' + type + '-vscrollbar' + this.VScrollbar.TYPES +
                                '" style="position:absolute"></div>' : '') +
                                (hscroll ?
                                    '<div class="' + type + '-hscrollbar' + this.HScrollbar.TYPES +
                                        '" style="position:absolute"></div>' : '') +
                                (vscroll && hscroll ?
                                    '<div class="' + type + '-corner' + UI_CONTROL.TYPES +
                                        '" style="position:absolute"></div>' : '')
                    ) + '<div class="' + type +
                            '-layout" style="position:relative;overflow:hidden;padding:0px"></div>';

                el.lastChild.appendChild(o);
            },
            function (el, options) {
                var i = 0,
                    browser = options.browser,
                    vscroll = options.vScroll !== false,
                    hscroll = options.hScroll !== false,
                    list = [
                        [vscroll, '_uVScrollbar', browser ? UI_BROWSER_VSCROLLBAR : this.VScrollbar],
                        [hscroll, '_uHScrollbar', browser ? UI_BROWSER_HSCROLLBAR : this.HScrollbar],
                        [vscroll && hscroll, '_uCorner', browser ? UI_BROWSER_CORNER : UI_CONTROL]
                    ],
                    o;

                this.$setBody(el.lastChild.lastChild);

                this._bAbsolute = options.absolute;
                this._nWheelDelta = options.wheelDelta;

                el = el.firstChild;
                if (browser) {
                    this._eBrowser = el;
                }

                // 生成中心区域的Element层容器，滚动是通过改变容器的left与top属性实现
                for (; o = list[i++]; ) {
                    if (o[0]) {
                        this[o[1]] = $fastCreate(o[2], el, this);
                        if (!browser) {
                            el = el.nextSibling;
                        }
                    }
                }
            }
        ),
        UI_PANEL_CLASS = UI_PANEL.prototype;
//{else}//

    UI_PANEL_CLASS.VScrollbar = UI_VSCROLLBAR;
    UI_PANEL_CLASS.HScrollbar = UI_HSCROLLBAR;

    /**
     * @override
     */
    UI_PANEL_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        var body = this.getBody(),
            mainWidth = body.offsetWidth,
            mainHeight = body.offsetHeight;

        style = getStyle(getParent(body));
        this.$$bodyWidthRevise = calcWidthRevise(style);
        this.$$bodyHeightRevise = calcHeightRevise(style);

        // 考虑到内部Element绝对定位的问题，中心区域的宽度与高度修正
        if (this._bAbsolute) {
            for (
                var i = 0,
                    list = body.all || body.getElementsByTagName('*'),
                    pos = getPosition(body);
                // 以下使用 body 代替临时的 DOM 节点对象
                body = list[i++];
            ) {
                if (body.offsetWidth && getStyle(body, 'position') == 'absolute') {
                    style = getPosition(body);
                    mainWidth = MAX(mainWidth, style.left - pos.left + body.offsetWidth);
                    mainHeight = MAX(mainHeight, style.top - pos.top + body.offsetHeight);
                }
            }
        }

        this.$$mainWidth = mainWidth;
        this.$$mainHeight = mainHeight;

        if (this._uVScrollbar) {
             this._uVScrollbar.cache(true, true);
        }
        if (this._uHScrollbar) {
             this._uHScrollbar.cache(true, true);
        }
        if (this._uCorner) {
            this._uCorner.cache(true, true);
        }
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.$dispose = function () {
        this._eBrowser = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 接管对方向键的处理。
     * @override
     */
    UI_PANEL_CLASS.$keydown = UI_PANEL_CLASS.$keypress = function (event) {
        var which = getKey(),
            o = which % 2 ? this._uHScrollbar : this._uVScrollbar;

        if (which >= 37 && which <= 40 && !event.target.value) {
            if (o) {
                o.skip(which + which % 2 - 39);
            }
            return false;
        }
    };

    /**
     * 如果有垂直滚动条，则垂直滚动条随滚轮滚动。
     * @override
     */
    UI_PANEL_CLASS.$mousewheel = function (event) {
        if (this.isHovered()) {
            o = this._uVScrollbar;

            if (o && o.isShow()) {
                // 计算滚动的次数，至少要滚动一次
                var value = o.getValue(),
                    delta = this._nWheelDelta || FLOOR(20 / o.getStep()) || 1,
                    o;

                o.skip(event.detail > 0 ? delta : -delta);
                event.stopPropagation();
                // 如果截面已经移动到最后，不屏弊缺省事件
                return value == o.getValue();
            }
        }
    };

    /**
     * 控件的滚动条发生滚动的默认处理。
     * 如果控件包含滚动条，滚动条滚动时触发 onscroll 事件，如果事件返回值不为 false，则调用 $scroll 方法。
     * @protected
     */
    UI_PANEL_CLASS.$scroll = function () {
        var style = this.getBody().style;
        style.left = -MAX(this.getScrollLeft(), 0) + 'px';
        style.top = -MAX(this.getScrollTop(), 0) + 'px';
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();

        var basicWidth = this.$getBasicWidth(),
            basicHeight = this.$getBasicHeight(),
            paddingWidth = this.$$paddingLeft + this.$$paddingRight,
            paddingHeight = this.$$paddingTop + this.$$paddingBottom,
            bodyWidth = this.getWidth() - basicWidth,
            bodyHeight = this.getHeight() - basicHeight,
            mainWidth = this.$$mainWidth,
            mainHeight = this.$$mainHeight,
            browser = this._eBrowser,
            vscroll = this._uVScrollbar,
            hscroll = this._uHScrollbar,
            corner = this._uCorner,
            vsWidth = vscroll ? vscroll.getWidth() : 0,
            hsHeight = hscroll ? hscroll.getHeight() : 0, 
            innerWidth = bodyWidth - vsWidth,
            innerHeight = bodyHeight - hsHeight,
            hsWidth = innerWidth + paddingWidth,
            vsHeight = innerHeight + paddingHeight;

        // 设置垂直与水平滚动条与夹角控件的位置
        if (vscroll) {
            vscroll.setPosition(hsWidth, 0);
        }
        if (hscroll) {
            hscroll.setPosition(0, vsHeight);
        }
        if (corner) {
            corner.setPosition(hsWidth, vsHeight);
        }

        if (mainWidth <= bodyWidth && mainHeight <= bodyHeight) {
            // 宽度与高度都没有超过截面控件的宽度与高度，不需要显示滚动条
            if (vscroll) {
                vscroll.$hide();
            }
            if (hscroll) {
                hscroll.$hide();
            }
            if (corner) {
                corner.$hide();
            }
            innerWidth = bodyWidth;
            innerHeight = bodyHeight;
        }
        else {
            while (true) {
                if (corner) {
                    // 宽度与高度都超出了显示滚动条后余下的宽度与高度，垂直与水平滚动条同时显示
                    if (mainWidth > innerWidth && mainHeight > innerHeight) {
                        hscroll.$setSize(hsWidth);
                        hscroll.setTotal(browser ? mainWidth + basicWidth : mainWidth - innerWidth);
                        hscroll.$show();
                        vscroll.$setSize(0, vsHeight);
                        vscroll.setTotal(browser ? mainHeight + basicHeight : mainHeight - innerHeight);
                        vscroll.$show();
                        corner.$setSize(vsWidth, hsHeight);
                        corner.$show();
                        break;
                    }
                    corner.$hide();
                }
                if (hscroll) {
                    if (mainWidth > bodyWidth) {
                        // 宽度超出控件的宽度，高度没有超出显示水平滚动条后余下的高度，只显示水平滚动条
                        hscroll.$setSize(bodyWidth + paddingWidth);
                        hscroll.setTotal(browser ? mainWidth + basicWidth : mainWidth - bodyWidth);
                        hscroll.$show();
                        if (vscroll) {
                            vscroll.$hide();
                        }
                        innerWidth = bodyWidth;
                    }
                    else {
                        hscroll.$hide();
                    }
                }
                if (vscroll) {
                    if (mainHeight > bodyHeight) {
                        // 高度超出控件的高度，宽度没有超出显示水平滚动条后余下的宽度，只显示水平滚动条
                        vscroll.$setSize(0, bodyHeight + paddingHeight);
                        vscroll.setTotal(browser ? mainHeight + basicHeight : mainHeight - bodyHeight);
                        vscroll.$show();
                        if (hscroll) {
                            hscroll.$hide();
                        }
                        innerHeight = bodyHeight;
                    }
                    else {
                        vscroll.$hide();
                    }
                }
                break;
            }
        }

        innerWidth -= this.$$bodyWidthRevise;
        innerHeight -= this.$$bodyHeightRevise;
        (innerWidth < 0) && (innerWidth = 0);
        (innerHeight < 0) && (innerHeight = 0);

        if (vscroll) {
            vscroll.$setPageStep(innerHeight);
        }
        if (hscroll) {
            hscroll.$setPageStep(innerWidth);
        }
    
        // 设置内部定位器的大小，以下使用 corner 表示 style
        if (browser) {
            corner = browser.style;
            corner.width = bodyWidth + paddingWidth + 'px';
            corner.height = bodyHeight + paddingHeight + 'px';
        }

        corner = getParent(this.getBody()).style;
        corner.width = innerWidth + 'px';
        corner.height = innerHeight + 'px';
    };

    /**
     * 获取水平滚动条的当前值。
     * getScrollLeft 方法提供了对水平滚动条当前值的快捷访问方式，参见 getValue。
     * @public
     *
     * @return {number} 水平滚动条的当前值，如果没有水平滚动条返回 -1
     */
    UI_PANEL_CLASS.getScrollLeft = function () {
        var o = this._uHScrollbar;
        return o ? o.getValue() : -1;
    };

    /**
     * 获取垂直滚动条的当前值。
     * getScrollTop 方法提供了对水平滚动条当前值的快捷访问方式，参见 getValue。
     * @public
     *
     * @return {number} 垂直滚动条的当前值，如果没有垂直滚动条返回 -1
     */
    UI_PANEL_CLASS.getScrollTop = function () {
        var o = this._uVScrollbar;
        return o ? o.getValue() : -1;
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        if (this._uVScrollbar) {
            this._uVScrollbar.init();
        }
        if (this._uHScrollbar) {
            this._uHScrollbar.init();
        }
        if (this._uCorner) {
            this._uCorner.init();
        }
    };

    /**
     * 控件显示区域复位。
     * reset 方法设置水平滚动条或者垂直滚动条的当前值为 0。
     * @public
     */
    UI_PANEL_CLASS.reset = function () {
        if (this._uVScrollbar) {
            this._uVScrollbar.setValue(0);
        }
        if (this._uHScrollbar) {
            this._uHScrollbar.setValue(0);
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Table - 定义由行列构成的表格的基本操作。
表格控件，继承自截面控件，对基本的 TableElement 功能进行了扩展，表头固定，不会随表格的垂直滚动条滚动而滚动，在行列滚动时，支持整行整列移动，允许直接对表格的数据进行增加/删除/修改操作。

表格控件直接HTML初始化的例子:
<div ecui="type:table">
  <table>
    <!-- 表头区域 -->
    <thead>
      <tr>
        <th style="width:200px;">公司名</th>
        <th style="width:200px;">url</th>
        <th style="width:250px;">地址</th>
        <th style="width:100px;">创办时间</th>
      </tr>
    </thead>
    <!-- 内容行区域 -->
    <tbody>
      <tr>
        <td>百度</td>
        <td>www.baidu.com</td>
        <td>中国北京中关村</td>
        <td>1999</td>
      </tr>
    </tbody>
  </table>
</div>

属性
_aHCells     - 表格头单元格控件对象
_aRows       - 表格数据行对象
_uHead       - 表头区域

表头列属性
$$pos        - 列的坐标

行属性
$$pos        - 行的坐标
_aElements   - 行的列Element对象，如果当前列需要向左合并为null，需要向上合并为false
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        REGEXP = RegExp,
        MAX = MATH.max,
        MIN = MATH.min,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getPosition = dom.getPosition,
        getAttribute = dom.getAttribute,
        getParent = dom.getParent,
        insertBefore = dom.insertBefore,
        insertHTML = dom.insertHTML,
        next = dom.next,
        removeDom = dom.remove,
        trim = string.trim,
        extend = util.extend,
        toNumber = util.toNumber,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        disposeControl = core.dispose,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ],

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_SCROLLBAR_CLASS = ui.Scrollbar.prototype,
        UI_VSCROLLBAR = ui.VScrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_TABLE
    ///__gzip_original__UI_TABLE_CLASS
    /**
     * 初始化表格控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_TABLE = ui.Table =
        inheritsControl(
            UI_PANEL,
            'ui-table',
            function (el, options) {
                var list, o,
                    type = this.getType();

                options.wheelDelta = 1;
                if (el.tagName == 'TABLE') {
                    var table = el;
                    insertBefore(el = createDom(table.className), table).appendChild(table);
                    if (options.width) {
                        el.style.width = options.width;
                    }
                    if (options.height) {
                        el.style.height = options.height;
                    }
                    table.className = '';
                }

                o = el.getElementsByTagName('TABLE')[0];
                list = children(o);

                o.setAttribute('cellSpacing', '0');

                if (list[0].tagName != 'THEAD') {
                    insertBefore(createDom('', '', 'thead'), list[0])
                        .appendChild(children(list[0])[0]);
                }
                
                return el;
            },
            function (el, options) {
                var i = 0,
                    type = this.getType(),
                    rows = this._aRows = [],
                    cols = this._aHCells = [],
                    colspans = [],
                    o = el.getElementsByTagName('TABLE')[0],
                    list = children(o),
                    j = list[0],
                    headRowCount = 1;

                o = children(list[0]);
                headRowCount = o.length;
                list = o.concat(children(list[1]));

                // 设置滚动条操作
                if (o = this.$getSection('VScrollbar')) {
                    o.setValue = UI_TABLE_SCROLL_SETVALUE;
                }
                if (o = this.$getSection('HScrollbar')) {
                    o.setValue = UI_TABLE_SCROLL_SETVALUE;
                }

                // 初始化表格区域
                o = createDom(type + '-head' + UI_CONTROL.TYPES, 'position:absolute;top:0px;overflow:hidden');
                o.innerHTML =
                    '<div style="white-space:nowrap;position:absolute"><table cellspacing="0"><tbody>' +
                        '</tbody></table></div>';
                (this._uHead = $fastCreate(UI_CONTROL, this.getMain().appendChild(o), this)).$setBody(j);

                // 以下初始化所有的行控件
                for (; o = list[i]; i++) {
                    o.className = trim(o.className) + this.Row.TYPES;
                    // list[i] 保存每一行的当前需要处理的列元素
                    list[i] = first(o);
                    colspans[i] = 1;
                    (rows[i] = $fastCreate(this.Row, o, this))._aElements = [];
                }

                for (j = 0; ; j++) {
                    for (i = 0; o = rows[i]; i++) {
                        if (colspans[i]-- > 1) {
                            continue;
                        }
                        if (el = list[i]) {
                            if (o._aElements[j] === undefined) {
                                o._aElements[j] = el;
                                // 当前元素处理完成，将list[i]指向下一个列元素
                                list[i] = next(el);

                                var rowspan = +getAttribute(el, 'rowSpan') || 1,
                                    colspan = colspans[i] = +getAttribute(el, 'colSpan') || 1;

                                while (rowspan--) {
                                    if (!rowspan) {
                                        colspan--;
                                    }
                                    for (o = colspan; o--; ) {
                                        rows[i + rowspan]._aElements.push(rowspan ? false : null);
                                    }
                                }
                            }
                        }
                        //如果此单元格是被行合并的，则继续处理下一个单元格
                        else if (o._aElements[j] === false) {
                            continue;
                        }
                        else {
                            // 当前行处理完毕，list[i]不再保存行内需要处理的下一个元素
                            for (j = 0; ; j++) {
                                // 以下使用 type 临时表示列的初始化参数
                                type = {};
                                for (i = 0; o = rows[i]; i++) {
                                    el = o._aElements[j];
                                    if (el === undefined) {
                                        this._aHeadRows = this._aRows.splice(0, headRowCount);
                                        return;
                                    }
                                    else if (el) {
                                        if (i < headRowCount) {
                                            extend(type, getOptions(el));
                                            el.className = trim(el.className) + this.HCell.TYPES;
                                            cols[j] = $fastCreate(this.HCell, el, this);
                                            cols[j]._oOptions = extend({}, type); //防止子列options影响父列
                                        }
                                        else {
                                            el.className =
                                                (trim(el.className) || type.primary || '') + this.Cell.TYPES;
                                            el.getControl = UI_TABLE_GETCONTROL();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        ),
        UI_TABLE_CLASS = UI_TABLE.prototype,

        /**
         * 初始化表格控件的行部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_TABLE_ROW_CLASS = (UI_TABLE_CLASS.Row = inheritsControl(UI_CONTROL, 'ui-table-row')).prototype,

        /**
         * 初始化表格控件的列部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_TABLE_HCELL_CLASS = (UI_TABLE_CLASS.HCell = inheritsControl(UI_CONTROL, 'ui-table-hcell')).prototype,

        /**
         * 初始化表格控件的单元格部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_TABLE_CELL_CLASS = (UI_TABLE_CLASS.Cell = inheritsControl(
            UI_CONTROL,
            'ui-table-cell',
            function (el, options) {
                // 单元格控件不能改变大小
                options.resizable = false;
            }
        )).prototype,

        /**
         * 在需要时初始化单元格控件。
         * 表格控件的单元格控件不是在初始阶段生成，而是在单元格控件第一次被调用时生成，参见核心的 getControl 方法。
         * @private
         *
         * @return {Function} 初始化单元格函数
         */
        UI_TABLE_GETCONTROL = ieVersion == 8 ? function () {
            // 为了防止写入getControl属性而导致的reflow如此处理
            var control;
            return function () {
                return (control = control || UI_TABLE_CREATE_CELL(this));
            };
        } : function () {
            return UI_TABLE_INIT_CELL;
        };
//{else}//
    /**
     * 初始化单元格。
     * @private
     *
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    function UI_TABLE_INIT_CELL() {
        this.getControl = null;
        return UI_TABLE_CREATE_CELL(this);
    }

    /**
     * 建立单元格控件。
     * @private
     *
     * @param {HTMLElement} main 单元格控件主元素
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    function UI_TABLE_CREATE_CELL(main) {
        // 获取单元格所属的行控件
        var row = getParent(main).getControl(),
            table = row.getParent();

        return $fastCreate(
            table.Cell,
            main,
            row,
            extend({}, table._aHCells[indexOf(row._aElements, main)]._oOptions)
        );
    }

    /**
     * 表格控件初始化一行。
     * @private
     *
     * @param {ecui.ui.Table.Row} row 行控件
     */
    function UI_TABLE_INIT_ROW(row) {
        for (var i = 0, list = row.getParent()._aHCells, el, o; o = list[i]; ) {
            if ((el = row._aElements[i++]) && el != o.getMain()) {
                o = o.getWidth() - o.getMinimumWidth();
                while (row._aElements[i] === null) {
                    o += list[i++].getWidth();
                }
                el.style.width = o + 'px';
            }
        }
    }

    /**
     * 表格控件改变显示区域值。
     * 表格控件改变显示区域时，每次尽量移动一个完整的行或列的距离。
     * @private
     *
     * @param {number} value 控件的当前值
     */
    function UI_TABLE_SCROLL_SETVALUE(value) {
        //__gzip_original__length
        var i = 1,
            list = this.getParent()[this instanceof UI_VSCROLLBAR ? '_aRows' : '_aHCells'],
            length = list.length,
            oldValue = this.getValue();

        value = MIN(MAX(0, value), this.getTotal());

        if (value == oldValue) {
            return;
        }

        if (value > oldValue) {
            if (length == 1) {
                UI_SCROLLBAR_CLASS.setValue.call(this, this.getTotal());
                return;
            }
            for (; ; i++) {
                // 计算后移的新位置
                if (value <= list[i].$$pos) {
                    if (oldValue < list[i - 1].$$pos) {
                        i--;
                    }
                    break;
                }
            }
        }
        else {
            for (i = length; i--; ) {
                // 计算前移的新位置
                if (value >= list[i].$$pos) {
                    if (i < length - 1 && oldValue > list[i + 1].$$pos) {
                        i++;
                    }
                    break;
                }
            }
        }

        UI_SCROLLBAR_CLASS.setValue.call(this, list[i].$$pos);
    }

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$dispose = function () {
        this._aElements = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 获取一行内所有单元格的主元素。
     * $getElement 方法返回的主元素数组可能包含 false/null 值，分别表示当前单元格被向上或者向左合并。
     * @protected
     *
     * @return {Array} 主元素数组
     */
    UI_TABLE_ROW_CLASS.$getElements = function () {
        return this._aElements.slice();
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$hide = function () {
        var i = 0,
            table = this.getParent(),
            index = indexOf(table._aRows, this),
            nextRow = table._aRows[index + 1],
            j,
            cell,
            o;

        for (; table._aHCells[i]; i++) {
            o = this._aElements[i];
            if (o === false) {
                o = table.$getElement(index - 1, i);
                // 如果单元格向左被合并，cell == o
                if (cell != o) {
                    o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') - 1);
                    cell = o;
                }
            }
            else if (o && (j = +getAttribute(o, 'rowSpan')) > 1) {
                // 如果单元格包含rowSpan属性，需要将属性添加到其它行去
                o.setAttribute('rowSpan', j - 1);
                for (j = i + 1; ; ) {
                    cell = nextRow._aElements[j++];
                    if (cell || cell === undefined) {
                        break;
                    }
                }

                o.getControl().$setParent(nextRow);
                nextRow.getBody().insertBefore(o, cell || null);
            }
        }

        UI_CONTROL_CLASS.$hide.call(this);
        table.repaint();
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$show = function () {
        var i = 0,
            table = this.getParent(),
            index = indexOf(table._aRows, this),
            nextRow = table._aRows[index + 1],
            j,
            cell,
            o;

        for (; table._aHCells[i]; i++) {
            o = this._aElements[i];
            if (o === false) {
                o = table.$getElement(index - 1, i);
                // 如果单元格向左被合并，cell == o
                if (cell != o) {
                    o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') + 1);
                    cell = o;
                }
            }
            else if (o && nextRow && nextRow._aElements[i] === false) {
                // 如果单元格包含rowSpan属性，需要从其它行恢复
                o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') + 1);
                for (j = i + 1; ; ) {
                    cell = this._aElements[j++];
                    if (cell || cell === undefined) {
                        break;
                    }
                }

                o.getControl().$setParent(this);
                this.getBody().insertBefore(o, cell || null);
            }
        }

        UI_CONTROL_CLASS.$show.call(this);
        table.resize();
    };

    /**
     * 获取单元格控件。
     * @public
     *
     * @param {number} colIndex 列序号，从0开始
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    UI_TABLE_ROW_CLASS.getCell = function (colIndex) {
        return this._aElements[colIndex] ? this._aElements[colIndex].getControl() : null;
    };

    /**
     * 获取全部单元格控件。
     * @public
     *
     * @return {Array} 单元格控件数组
     */
    UI_TABLE_ROW_CLASS.getCells = function () {
        for (var i = this._aElements.length, result = []; i--; ) {
            result[i] = this.getCell(i);
        }
        return result;
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.setSize = function (width, height) {
        for (var i = this._aElements.length, oldHeight = this.getHeight(); i--; ) {
            if (this._aElements[i]) {
                this._aElements[i].getControl().$setSize(null, height);
            }
        }
        this.getParent()[height > oldHeight ? 'resize' : 'repaint']();
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.$hide = function () {
        this.$setStyles('display', 'none', -this.getWidth());
    };

    /**
     * 设置整列的样式。
     * $setStyles 方法批量设置一列所有单元格的样式。
     * @protected
     *
     * @param {string} name 样式的名称
     * @param {string} value 样式的值
     * @param {number} widthRevise 改变样式后表格宽度的变化，如果省略表示没有变化
     */
    UI_TABLE_HCELL_CLASS.$setStyles = function (name, value, widthRevise) {
        //__gzip_original__cols
        var i = 0,
            table = this.getParent(),
            rows = table._aHeadRows.concat(table._aRows),
            body = this.getBody(),
            cols = table._aHCells,
            index = indexOf(cols, this),
            o = getParent(getParent(getParent(body))).style,
            j;

        body.style[name] = value;
        if (widthRevise) {
            o.width = first(table.getBody()).style.width = toNumber(o.width) + widthRevise + 'px';
        }

        for (; o = rows[i++]; ) {
            // 以下使用 body 表示列元素列表
            body = o._aElements;
            o = body[index];
            if (o) {
                o.style[name] = value;
            }
            if (widthRevise && o !== false) {
                for (j = index; !(o = body[j]); j--) {}

                var width = -cols[j].getMinimumWidth(),
                    colspan = 0;

                do {
                    if (!cols[j].getOuter().style.display) {
                        width += cols[j].getWidth();
                        colspan++;
                    }
                }
                while (body[++j] === null);

                if (width > 0) {
                    o.style.display = '';
                    o.style.width = width + 'px';
                    o.setAttribute('colSpan', colspan);
                }
                else {
                    o.style.display = 'none';
                }
            }
        }
        if (widthRevise > 0) {
            table.resize();
        }
        else {
            table.repaint();
        }
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.$show = function () {
        this.$setStyles('display', '', this.getWidth());
    };

    /**
     * 获取单元格控件。
     * @public
     *
     * @param {number} rowIndex 行序号，从0开始
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    UI_TABLE_HCELL_CLASS.getCell = function (rowIndex) {
        return this.getParent().getCell(rowIndex, indexOf(this._aHCells, this));
    };

    /**
     * 获取全部单元格控件。
     * @public
     *
     * @return {Array} 单元格控件数组
     */
    UI_TABLE_HCELL_CLASS.getCells = function () {
        for (var i = 0, index = indexOf(this.getParent()._aHCells, this), o, result = []; o = this.getParent()._aRows[i]; ) {
            result[i++] = o.getCell(index);
        }
        return result;
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.setSize = function (width) {
        var oldWidth = this.getWidth();
        // 首先对列表头控件设置宽度，否则在计算合并单元格时宽度可能错误
        this.$setSize(width);
        this.$setStyles('width', width - this.$getBasicWidth() + 'px', width - oldWidth);
    };

    /**
     * @override
     */
    UI_TABLE_CELL_CLASS.getHeight = function () {
        return this.getOuter().offsetHeight;
    };

    /**
     * @override
     */
    UI_TABLE_CELL_CLASS.getWidth = function () {
        return this.getOuter().offsetWidth;
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$cache = function (style, cacheSize) {
        UI_PANEL_CLASS.$cache.call(this, style, cacheSize);

        this._uHead.cache(false, true);

        // 以下使用 style 表示临时对象 o
        this.$$paddingTop = this._uHead.getBody().offsetHeight;

        for (var i = 0, pos = 0; style = this._aRows[i++]; ) {
            style.$$pos = pos;
            style.cache(true, true);
            if (!style.getOuter().style.display) {
                pos += style.getHeight();
            }
        }
        for (i = 0, pos = 0; style = this._aHCells[i++]; ) {
            style.$$pos = pos;
            style.cache(true, true);
            if (!style.getOuter().style.display) {
                pos += style.getWidth();
            }
        }
        this.$$mainWidth = pos;
    };

    /**
     * 获取单元格主元素。
     * $getElement 方法在合法的行列序号内一定会返回一个 Element 对象，如果当前单元格被合并，将返回合并后的 Element 对象。
     * @protected
     *
     * @param {number} rowIndex 单元格的行数，从0开始
     * @param {number} colIndex 单元格的列数，从0开始
     * @return {HTMLElement} 单元格主元素对象
     */
    UI_TABLE_CLASS.$getElement = function (rowIndex, colIndex) {
        //__gzip_original__rows
        var rows = this._aRows,
            cols = rows[rowIndex] && rows[rowIndex]._aElements,
            col = cols && cols[colIndex];

        if (col === undefined) {
            col = null;
        }
        else if (!col) {
            for (; col === false; col = (cols = rows[--rowIndex]._aElements)[colIndex]) {}
            for (; !col; col = cols[--colIndex]) {}
        }
        return col;
    };

    /**
     * 页面滚动事件的默认处理。
     * @protected
     */
    UI_TABLE_CLASS.$pagescroll = function () {
        UI_PANEL_CLASS.$pagescroll.call(this);
        if (!this._uVScrollbar) {
            this._uHead.getOuter().style.top =
                MAX(getView().top - getPosition(this.getOuter()).top, 0) + 'px';
        }
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$scroll = function () {
        UI_PANEL_CLASS.$scroll.call(this);
        this._uHead.getMain().lastChild.style.left = this.getBody().style.left;
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$setSize = function (width, height) {
        var body = this.getBody(),
            vscroll = this.$getSection('VScrollbar'),
            hscroll = this.$getSection('HScrollbar'),
            mainWidth = this.$$mainWidth,
            mainHeight = this.$$mainHeight,
            vsWidth = vscroll && vscroll.getWidth(),
            hsHeight = hscroll && hscroll.getHeight(),
            basicWidth = this.$getBasicWidth(),
            basicHeight = this.$getBasicHeight(),
            mainWidthRevise = mainWidth + basicWidth,
            mainHeightRevise = mainHeight + basicHeight,
            bodyWidth = width - basicWidth,
            bodyHeight = height - basicHeight,
            o;

        this.getMain().style.paddingTop = this.$$paddingTop + 'px';
        first(body).style.width = this._uHead.getMain().lastChild.lastChild.style.width = mainWidth + 'px';

        // 计算控件的宽度与高度自动扩展
        if (mainWidth <= bodyWidth && mainHeight <= bodyHeight) {
            width = mainWidthRevise;
            height = mainHeightRevise;
        }
        else if (!(vscroll && hscroll &&
            mainWidth > bodyWidth - vsWidth && mainHeight > bodyHeight - hsHeight)
        ) {
            o = mainWidthRevise + (!vscroll || bodyHeight >= mainHeight ? 0 : vsWidth);
            width = hscroll ? MIN(width, o) : o;
            o = mainHeightRevise + (!hscroll || bodyWidth >= mainWidth ? 0 : hsHeight);
            height = vscroll ? MIN(height, o) : o;
        }

        UI_PANEL_CLASS.$setSize.call(this, width, height);

        this._uHead.$setSize(toNumber(getParent(body).style.width) + this._uHead.$getBasicWidth(), this.$$paddingTop);
    };

    /**
     * 增加一列。
     * options 对象对象支持的属性如下：
     * width   {number} 列的宽度
     * primary {string} 列的基本样式
     * title   {string} 列的标题
     * @public
     *
     * @param {Object} options 列的初始化选项
     * @param {number} index 被添加的列的位置序号，如果不合法将添加在末尾
     * @return {ecui.ui.Table.HCell} 表头单元格控件
     */
    UI_TABLE_CLASS.addColumn = function (options, index) {
        var i = 0,
            headRowCount = this._aHeadRows.length,
            rows = this._aHeadRows.concat(this._aRows),
            primary = options.primary || '',
            el = createDom(primary + this.HCell.TYPES, '', 'td'),
            col = $fastCreate(this.HCell, el, this),
            row,
            o;

        el.innerHTML = options.title || '';

        primary += this.Cell.TYPES;
        for (; row = rows[i]; i++) {
            o = row._aElements[index];
            if (o !== null) {
                // 没有出现跨列的插入列操作
                for (j = index; !o; ) {
                    o = row._aElements[++j];
                    if (o === undefined) {
                        break;
                    }
                }
                if (i < headRowCount) {
                    row._aElements.splice(index, 0, row.getBody().insertBefore(el, o));
                    el.setAttribute('rowSpan', headRowCount - i);
                    this._aHCells.splice(index, 0, col);
                    i = headRowCount - 1;
                }
                else {
                    row._aElements.splice(index, 0, o = row.getBody().insertBefore(createDom(primary, '', 'td'), o));
                    o.getControl = UI_TABLE_GETCONTROL();
                }
            }
            else {
                // 出现跨列的插入列操作，需要修正colspan的属性值
                var cell = this.$getElement(i - headRowCount, index),
                    j = +getAttribute(cell, 'rowspan') || 1;

                cell.setAttribute('colSpan', +getAttribute(cell, 'colSpan') + 1);
                row._aElements.splice(index, 0, o);
                for (; --j; ) {
                    rows[++i]._aElements.splice(index, 0, false);
                }
            }
        }

        col.cache();
        col.$setSize(options.width);
        col.$setStyles('width', el.style.width, options.width);
        col._oOptions = extend({}, options);

        return col;
    };

    /**
     * 增加一行。
     * @public
     *
     * @param {Array} data 数据源(一维数组)
     * @param {number} index 被添加的行的位置序号，如果不合法将添加在最后
     * @return {ecui.ui.Table.Row} 行控件
     */
    UI_TABLE_CLASS.addRow = function (data, index) {
        var i = 0,
            j = 1,
            body = this.getBody().lastChild.lastChild,
            el = createDom(),
            html = ['<table><tbody><tr class="' + this.Row.TYPES + '">'],
            rowCols = [],
            row = this._aRows[index],
            col;

        if (!row) {
            index = this._aRows.length;
        }

        for (; col = this._aHCells[i]; ) {
            if (row && row._aElements[i] === false || data[i] === false) {
                rowCols[i++] = false;
            }
            else {
                // 如果部分列被隐藏，colspan/width 需要动态计算
                rowCols[i] = true;
                html[j++] = '<td class="' + this.Cell.TYPES + '" style="';
                for (
                    var o = i,
                        colspan = col.isShow() ? 1 : 0,
                        width = col.getWidth() - col.getMinimumWidth();
                    (col = this._aHCells[++i]) && data[i] === null;
                ) {
                    rowCols[i] = null;
                    if (col.isShow()) {
                        colspan++;
                        width += col.getWidth();
                    }
                }
                rowCols[o] = true;
                html[j++] = (colspan ? 'width:' + width + 'px" colSpan="' + colspan : 'display:none') + '">' +
                    (data[o] || '') + '</td>';
            }
        }

        html[j] = '</tr></tbody></table>';
        el.innerHTML = html.join('');
        el = el.lastChild.lastChild.lastChild;

        body.insertBefore(el, row ? row.getOuter() : null);
        row = $fastCreate(this.Row, el, this);
        this._aRows.splice(index--, 0, row);

        // 以下使用 col 表示上一次执行了rowspan++操作的单元格，同一个单元格只需要增加一次
        for (i = 0, el = el.firstChild, col = null; this._aHCells[i]; i++) {
            if (o = rowCols[i]) {
                rowCols[i] = el;
                el.getControl = UI_TABLE_GETCONTROL();
                el = el.nextSibling;
            }
            else if (o === false) {
                o = this.$getElement(index, i);
                if (o != col) {
                    o.setAttribute('rowSpan', (+getAttribute(o, 'rowSpan') || 1) + 1);
                    col = o;
                }
            }
        }

        row._aElements = rowCols;
        this.resize();
        return row;
    };

    /**
     * 获取单元格控件。
     * @public
     *
     * @param {number} rowIndex 行序号，从0开始
     * @param {number} colIndex 列序号，从0开始
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    UI_TABLE_CLASS.getCell = function (rowIndex, colIndex) {
        rowIndex = this._aRows[rowIndex];
        return rowIndex && rowIndex.getCell(colIndex) || null;
    };

    /**
     * 获取表格列的数量。
     * @public
     *
     * @return {number} 表格列的数量
     */
    UI_TABLE_CLASS.getColumnCount = function () {
        return this._aHCells.length;
    };

    /**
     * 获取表头单元格控件。
     * 表头单元格控件提供了一些针对整列进行操作的方法，包括 hide、setSize(仅能设置宽度) 与 show 方法等。
     * @public
     *
     * @param {number} index 列序号，从0开始
     * @return {ecui.ui.Table.HCell} 表头单元格控件
     */
    UI_TABLE_CLASS.getHCell = function (index) {
        return this._aHCells[index] || null;
    };

    /**
     * 获取全部的表头单元格控件。
     * @public
     *
     * @return {Array} 表头单元格控件数组
     */
    UI_TABLE_CLASS.getHCells = function () {
        return this._aHCells.slice();
    };

    /**
     * 获取行控件。
     * @public
     *
     * @param {number} index 行数，从0开始
     * @return {ecui.ui.Table.Row} 行控件
     */
    UI_TABLE_CLASS.getRow = function (index) {
        return this._aRows[index] || null;
    };

    /**
     * 获取表格行的数量。
     * @public
     *
     * @return {number} 表格行的数量
     */
    UI_TABLE_CLASS.getRowCount = function () {
        return this._aRows.length;
    };

    /**
     * 获取全部的行控件。
     * @public
     *
     * @return {Array} 行控件列表
     */
    UI_TABLE_CLASS.getRows = function () {
        return this._aRows.slice();
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.init = function () {
        insertBefore(this._uHead.getBody(), this._uHead.getMain().lastChild.lastChild.firstChild);
        this.$$mainHeight -= this.$$paddingTop;

        UI_PANEL_CLASS.init.call(this);

        for (var i = 0, o; o = this._aHCells[i++]; ) {
            o.$setSize(o.getWidth());
        }
        for (i = 0; o = this._aHeadRows[i++]; ) {
            UI_TABLE_INIT_ROW(o);
        }
        for (i = 0; o = this._aRows[i++]; ) {
            UI_TABLE_INIT_ROW(o);
        }
    };

    /**
     * 移除一列并释放占用的空间。
     * @public
     *
     * @param {number} index 列序号，从0开始计数
     */
    UI_TABLE_CLASS.removeColumn = function (index) {
        var i = 0,
            cols = this._aHCells,
            o = cols[index];

        if (o) {
            o.hide();

            removeDom(o.getOuter());
            disposeControl(o);
            cols.splice(index, 1);

            for (; o = this._aRows[i++]; ) {
                cols = o._aElements;
                if (o = cols[index]) {
                    if (cols[index + 1] === null) {
                        // 如果是被合并的列，需要保留
                        cols.splice(index + 1, 1);
                        continue;
                    }
                    removeDom(o);
                    if (o.getControl != UI_TABLE_GETCONTROL()) {
                        disposeControl(o.getControl());
                    }
                }
                cols.splice(index, 1);
            }
        }
    };

    /**
     * 移除一行并释放占用的空间。
     * @public
     *
     * @param {number} index 行序号，从0开始计数
     */
    UI_TABLE_CLASS.removeRow = function (index) {
        var i = 0,
            row = this._aRows[index],
            rowNext = this._aRows[index + 1],
            body = row.getBody(),
            o;

        if (row) {
            row.hide();
            for (; this._aHCells[i]; i++) {
                if (o = row._aElements[i]) {
                    if (getParent(o) != body) {
                        rowNext._aElements[i] = o;
                        for (; row._aElements[++i] === null; ) {
                            rowNext._aElements[i] = null;
                        }
                        i--;
                    }
                }
            }

            removeDom(row.getOuter());
            disposeControl(row);
            this._aRows.splice(index, 1);

            this.repaint();
        }
    };

    // 初始化事件转发信息
    (function () {
        function build(name) {
            var type = name.replace('mouse', '');

            name = '$' + name;

            UI_TABLE_ROW_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                triggerEvent(this.getParent(), 'row' + type, event);
            };

            UI_TABLE_CELL_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                triggerEvent(this.getParent().getParent(), 'cell' + type, event);
            };
        }

        for (var i = 0; i < 7; ) {
            build(eventNames[i++]);
        }
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
修改版的LockedTable，为性能而优化。（为区别，改名为SlowLockedTable）

LockedTable - 定义允许左右锁定若干列显示的高级表格的基本操作。
允许锁定左右两列的高级表格控件，继承自表格控件，内部包含两个部件——锁定的表头区(基础控件)与锁定的行内容区(基础控件)。

锁定列高级表格控件直接HTML初始化的例子:
<div ecui="type:locked-table;left-lock:2;right-lock:1">
    <table>
        <!-- 当前节点的列定义，如果有特殊格式，需要使用width样式 -->
        <thead>
            <tr>
                <th>标题</th>
                ...
            </tr>
        </thead>
        <tbody>
            <!-- 这里放单元格序列 -->
            <tr>
                <td>单元格一</td>
                ...
            </tr>
            ...
        </tbody>
    </table>
</div>

属性
_nLeft       - 最左部未锁定列的序号
_nRight      - 最右部未锁定列的后续序号，即未锁定的列序号+1
_aLockedRow  - 用于显示锁定区域的行控件数组
_uLockedHead - 锁定的表头区
_uLockedMain - 锁定的行内容区

表格行与锁定行属性
_eFill       - 用于控制中部宽度的单元格
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        REGEXP = RegExp,
        USER_AGENT = navigator.userAgent,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getAttribute = dom.getAttribute,
        insertBefore = dom.insertBefore,
        removeDom = dom.remove,
        blank = util.blank,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        disposeControl = core.dispose,
        $bind = core.$bind,
        inheritsControl = core.inherits,

        firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ],

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_TABLE = ui.Table,
        UI_TABLE_CLASS = UI_TABLE.prototype,
        UI_TABLE_ROW = UI_TABLE_CLASS.Row,
        UI_TABLE_ROW_CLASS = UI_TABLE_ROW.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化高级表格控件。
     * options 对象支持的属性如下：
     * left-lock  左边需要锁定的列数
     * right-lock 右边需要锁定的列数
     * @public
     *
     * @param {Object} options 初始化选项
     */
    //__gzip_original__UI_LOCKED_TABLE
    //__gzip_original__UI_LOCKED_TABLE_ROW
    var UI_LOCKED_TABLE = ui.SlowLockedTable =
        inheritsControl(
            UI_TABLE,
            '*locked-table',
            null,
            function (el, options) {

                // ==========================
                // var ddd = new Date();                
                
                var i = 0,
                    type = this.getType(),
                    headRows = this._aHeadRows,
                    rows = headRows.concat(this._aRows),
                    lockedEl = createDom('', 'position:absolute;top:0px;left:0px;overflow:hidden'),
                    list = [],
                    lockedRows = this._aLockedRow = [],
                    lockedHeadRows = this._aLockedHeadRow = [],
                    o;

                this._nLeft = options.leftLock || 0;
                this._nRight = this.getColumnCount() - (options.rightLock || 0);

                // 以下使用 options 代替 rows
                for (; el = rows[i]; ) {
                    el = el.getMain();
                    list[i++] =
                        '<tr class="' + el.className + '" style="' + el.style.cssText +
                            '"><td style="padding:0px;border:0px"></td></tr>';
                }

                lockedEl.innerHTML =
                    '<div class="' + type + '-locked-head" style="position:absolute;top:0px;left:0px"><div style="white-space:nowrap;position:absolute"><table cellspacing="0"><thead>' + list.splice(0, headRows.length).join('') + '</thead></table></div></div><div class="' + type + '-locked-layout" style="position:absolute;left:0px;overflow:hidden"><div style="white-space:nowrap;position:absolute;top:0px;left:0px"><table cellspacing="0"><tbody>' + list.join('') + '</tbody></table></div></div>';
                // 初始化锁定的表头区域，以下使用 list 表示临时变量
                o = this._uLockedHead = $fastCreate(UI_CONTROL, lockedEl.firstChild, this);
                o.$setBody(el = o.getMain().lastChild.lastChild.firstChild);

                for (i = 0, list = children(el); o = list[i]; ) {
                    lockedHeadRows[i] = UI_LOCKED_TABLE_CREATE_LOCKEDROW(o, headRows[i++]);
                }

                o = this._uLockedMain = $fastCreate(UI_CONTROL, el = lockedEl.lastChild, this);
                o.$setBody(el = el.lastChild);

                for (i = 0, list = children(el.lastChild.lastChild); o = list[i]; ) {
                    lockedRows[i] = UI_LOCKED_TABLE_CREATE_LOCKEDROW(o, this._aRows[i++]);
                }
                insertBefore(lockedEl.firstChild, this._uHead.getOuter());
                insertBefore(lockedEl.firstChild, getParent(this.getBody()));

                // console.log('=================== locked-table constructor] ' + ((new Date()).getTime() - ddd));
                // ddd = new Date();                
            }
        );
        UI_LOCKED_TABLE_CLASS = UI_LOCKED_TABLE.prototype,

        /**
         * 初始化高级表格控件的行部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_LOCKED_TABLE_ROW_CLASS = (UI_LOCKED_TABLE_CLASS.Row = inheritsControl(UI_TABLE_CLASS.Row)).prototype;
//{else}//
    /**
     * 建立锁定行控件。
     * @private
     *
     * @param {HTMLElement} el 锁定行的 Element 元素
     * @param {ecui.ui.Table.Row} row 表格基本行控件
     */
    function UI_LOCKED_TABLE_CREATE_LOCKEDROW(el, row) {
        $bind(el, row);
        row._eFill = el.lastChild;

        return row;
    }
    
    /**
     * 拆分行内的单元格到锁定列或基本列中。
     * @private
     *
     * @param {ecui.ui.LockedTable.LockedHead|ecui.ui.LockedTable.LockedRow} locked 锁定表头控件或者锁定行控件
     */
    function UI_LOCKED_TABLE_ROW_SPLIT(locked) {
        var i = 0,
            table = locked.getParent(),
            cols = table.getHCells(),
            list = locked.$getElements(),
            baseBody = locked.getBody(),
            lockedBody = getParent(locked._eFill),
            el = lockedBody.firstChild,
            o;

        for (; cols[i]; ) {
            if (i == table._nLeft) {
                el = baseBody.firstChild;
            }
            if (o = list[i++]) {
                if (el != o) {
                    (i <= table._nLeft || i > table._nRight ? lockedBody : baseBody).insertBefore(o, el);
                }
                else {
                    el = el.nextSibling;
                }
            }
            if (i == table._nRight) {
                el = locked._eFill.nextSibling;
            }
        }
    }

    /**
     * 拆分所有行内的单元格到锁定列或基本列中。
     * @private
     *
     * @param {ecui.ui.LockedTable} table 锁定式表格控件
     */
    function UI_LOCKED_TABLE_ALL_SPLIT(table) {
        for (var i = 0, o; o = table._aLockedHeadRow[i++]; ) {
            UI_LOCKED_TABLE_ROW_SPLIT(o);
        }
        for (var i = 0, o; o = table._aLockedRow[i++]; ) {
            UI_LOCKED_TABLE_ROW_SPLIT(o);
        }
    }

    /**
     * @override
     */
    UI_LOCKED_TABLE_ROW_CLASS.$dispose = function () {
        this._eFill = null;
        UI_TABLE_ROW_CLASS.$dispose.call(this);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$cache = function (style, cacheSize) {

        // ==========================
        // var ttt = new Date();
        // var ddd = ttt;

        UI_TABLE_CLASS.$cache.call(this, style, cacheSize);

        // console.log('=================== locked-table $cache super class cache] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        var i = 0,
            rows = this.getRows(),
            cols = this.getHCells(),
            pos = cols[this._nLeft].$$pos;

        this.$$paddingTop = MAX(this.$$paddingTop, this._uLockedHead.getBody().offsetHeight);
        this.$$mainWidth -=
            (this.$$paddingLeft = pos) +
                (this.$$paddingRight =
                    this._nRight < cols.length ? this.$$mainWidth - cols[this._nRight].$$pos : 0);

        // console.log('=================== locked-table $cache 1] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        // 以下使用 style 代替临时变量 o
        for (; style = cols[i++]; ) {
            style.$$pos -= pos;
        }

        // console.log('=================== locked-table $cache 2 (col)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        for (i = 0, pos = 0; style = rows[i++]; ) {
            style.getCell(this._nLeft).cache(false, true);
            style.$$pos = pos;
            pos += MAX(style.getHeight(), style._eFill.offsetHeight);
        }

        // ======================== ch 35
        // console.log('=================== locked-table $cache 3 (row)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        if (pos) {
            this.$$mainHeight = pos;
            if (!this._bCreated) {
                this.$$mainHeight += this.$$paddingTop;
            }
        }

        this._uLockedHead.cache(false, true);
        this._uLockedMain.cache(false, true);

        // console.log('=================== locked-table $cache 4 (locked)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        // console.log('=================== locked-table $cache] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$pagescroll = function () {
        UI_TABLE_CLASS.$pagescroll.call(this);
        if (!this._uVScrollbar) {
            this._uLockedHead.getOuter().style.top = this._uHead.getOuter().style.top
        }
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$resize = function () {
        // ==========================
        // var ddd = new Date();

        var o = this.getMain().style;
        o.paddingLeft = o.paddingRight = '';
        this.$$paddingLeft = this.$$paddingRight = 0;

        // console.log('=================== locked-table $resize start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        UI_TABLE_CLASS.$resize.call(this);

        // console.log('=================== locked-table $resize superclass resize] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$scroll = function () {
        UI_TABLE_CLASS.$scroll.call(this);
        this._uLockedMain.getBody().style.top = this.getBody().style.top;
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$setSize = function (width, height) {
        // ====================================
        // var ddd = new Date();
        // var ttt = new Date();

        var o = this.getMain().style,
            i = 0,
            layout = getParent(this.getBody()),
            lockedHead = this._uLockedHead,
            lockedMain = this._uLockedMain,
            style = getParent(getParent(lockedHead.getBody())).style;

        // console.log('=================== locked-table $setSize start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        o.paddingLeft = this.$$paddingLeft + 'px';
        o.paddingRight = this.$$paddingRight + 'px';

        // console.log('=================== locked-table $setSize 1] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        UI_TABLE_CLASS.$setSize.call(this, width, height);

        // console.log('=================== locked-table $setSize 2] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        o = this._uHead.getWidth() + this.$$paddingLeft + this.$$paddingRight;
        (o < 0 || isNaN(o)) && (o = 0);

        // console.log('=================== locked-table $setSize 3] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        lockedHead.$setSize(o, this.$$paddingTop);

        // console.log('=================== locked-table $setSize 4] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        style.height = this.$$paddingTop + 'px';
        this._uLockedMain.$setSize(o, toNumber(layout.style.height));

        // console.log('=================== locked-table $setSize 5] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        style.width = this._uLockedMain.getBody().lastChild.style.width = o + 'px';
        this._uLockedMain.getOuter().style.top = this.$$paddingTop + 'px';
        
        // bugfix: 尽管有已经有padding来定位内容区，但是如果不设left，还是有可能初始定位到左上角。
        this._uHead.getOuter().style.left = this.$$paddingLeft + 'px';

        width = layout.style.width;

        // 统一行高
        // 分别设置表头与内容区域
        var rows = this._aLockedHeadRow,
            minHeight;

        // console.log('=================== locked-table $setSize 6] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();


        // 设置表头， 处理多行表头的问题
        height = this.$$paddingTop / rows.length; 
        for (i = 0; o = rows[i]; i++) {
            o._eFill.style.width = width;
            o._eFill.style.height = height + 'px';
            o = o.getCell(this._nLeft);
            if (o) {
                minHeight = firefoxVersion ? 0 : o.$getBasicHeight();
                isNaN(minHeight) && (minHeight = 0);
                o = o.getOuter();
                style = getAttribute(o, 'rowSpan') || 0;
                if (style) {
                    style = parseInt(style, 10);
                }
                o.style.height = MAX(style * height - minHeight, 0) + 'px';
            }
        }

        // console.log('=================== locked-table $setSize 7] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();


        // 设置表格内容行
        rows = this._aLockedRow;
        for (i = 0; o = rows[i]; i++) {
            // ==================================
            // ddd1 = new Date();

            // ================================== ch sometimes 1
            o._eFill.style.width = width;

            //================================== 下面一个循环 ch 1205 （从olap-table.resize来时这段共用了315）
            // 下面这些内容，就是检查为_eFill和getCell(this._nLeft)的高度是否一样，不一样则设置高度强制一样。
            // 通过css来保证这些，所以去掉这段代码。

            /*
            console.log('=================== locked-table $setSize hot_0] ' + ((new Date()).getTime() - ddd1));
            ddd1 = new Date();

            // ================================== ch 4 (着重优化)
            style = MAX(height = o.getCell(this._nLeft).getOuter().offsetHeight, o._eFill.offsetHeight);

            console.log('=================== locked-table $setSize hot_1] ' + ((new Date()).getTime() - ddd1));
            
            // ==================================
            ddd1 = new Date();

            // ================================== 一般不走此两条分支
            if (style > o._eFill.offsetHeight) {
                o._eFill.style.height = style + 'px';
            }
            else if (height < style) {
                minHeight = firefoxVersion ? 0 : o.getCell(this._nLeft).$getBasicHeight();
                o.getCell(this._nLeft).getOuter().style.height = MAX(style - minHeight, 0) + 'px';
            }

            console.log('=================== locked-table $setSize hot_2] ' + ((new Date()).getTime() - ddd1));
            */
        }

        // console.log('=================== locked-table $setSize end (hot!!) (into)] ' + ((new Date()).getTime() - ddd));
        // console.log('=================== locked-table $setSize total] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.addColumn = function (options, index) {
        if (index >= 0) {
            if (index < this._nLeft) {
                this._nLeft++;
            }
            if (index < this._nRight) {
                this._nRight++;
            }
        }
        return UI_TABLE_CLASS.addColumn.call(this, options, index);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.removeRow = function (index) {
        var i = 0,  row = this._aRows[index], o,
            lockedTR = row._eFill.parentNode;

        if (row) {
            row.hide();
            o = row.getOuter();
            disposeControl(row);
            removeDom(o, true);
            removeDom(lockedTR, true);
            this._aRows.splice(index, 1);
            this._aLockedRow.splice(index, 1);
            this.repaint();
        }
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.addRow = function (data, index) {

        //__gzip_original__lockedRow
        var row = UI_TABLE_CLASS.addRow.call(this, data, index),
            index = indexOf(this.getRows(), row),
            lockedRow = this._aLockedRow[index],
            el = row.getMain(),
            o = createDom();

        o.innerHTML = '<table cellspacing="0"><tbody><tr class="' + el.className + '" style="' + el.style.cssText +
            '"><td style="padding:0px;border:0px"></td></tr></tbody></table>';

        o = UI_LOCKED_TABLE_CREATE_LOCKEDROW(el = o.lastChild.lastChild.lastChild, row);
        lockedRow = lockedRow ? lockedRow._eFill.parentNode : null;
        this._uLockedMain.getBody().lastChild.lastChild.insertBefore(el, lockedRow);
        this._aLockedRow.splice(index, 0, o);
        UI_LOCKED_TABLE_ROW_SPLIT(o);

        this.repaint();

        return row;
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.init = function () {
        // ==========================
        // var ddd = new Date();

        // ========================== ch 25
        UI_LOCKED_TABLE_ALL_SPLIT(this);

        // console.log('=================== locked-table init (locked-table split)] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        UI_TABLE_CLASS.init.call(this);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.removeColumn = function (index) {
        UI_TABLE_CLASS.removeColumn.call(this, index);
        if (index >= 0) {
            if (index < this._nLeft) {
                this._nLeft--;
            }
            if (index < this._nRight) {
                this._nRight--;
            }
        }
    };

    /**
     * 初始化需要执行关联控制的行控件鼠标事件的默认处理。
     * 行控件鼠标事件发生时，需要通知关联的行控件也同步产生默认的处理。
     * @protected
     */
    (function () {
        function build(name) {
            UI_LOCKED_TABLE_ROW_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                getParent(this._eFill).className = this.getMain().className;
            };
        }

        for (var i = 0; i < 11; ) {
            build('$' + eventNames[i++]);
        }
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * ecui.ui.OlapTable
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   多维分析表格
 *         （行列锁定，跨多行，垮多列，树状表头等）
 * @author: sushuang(sushuang@baidu.com)
 */

 (function() {
    
    var core = ecui;
    var dom = core.dom;
    var array = core.array;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var disposeControl = core.dispose;
    var createDom = dom.create;
    var addClass = dom.addClass;
    var setStyle = dom.setStyle;
    var removeClass = dom.removeClass;
    var getMouseX = core.getMouseX;
    var toNumber = util.toNumber;
    var getParent = dom.getParent;
    var getStyle = dom.getStyle;
    var sliceByte = string.sliceByte;
    var moveElements = dom.moveElements;
    var getAttribute = dom.getAttribute;
    var getPosition = dom.getPosition;
    var encodeHTML = string.encodeHTML;
    var remove = array.remove;
    var getView = util.getView;
    var extend = util.extend;
    var repaint = core.repaint;
    var attachEvent = util.attachEvent;
    var detachEvent = util.detachEvent;
    var pushArray = Array.prototype.push;
    // 引用了外部库
    var formatNumber = xutil.number.formatNumber;

    var MATH = Math;
    var MIN = MATH.min;
    var WINDOW = window;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_LOCKED_TABLE = ui.SlowLockedTable;
    var UI_LOCKED_TABLE_CLASS = UI_LOCKED_TABLE.prototype;

    /**
     * OLAP 表主类
     *
     * @class
     * @extends {ecui.ui.LockedTable}
     */
    var UI_OLAP_TABLE = ui.OlapTable =
        inheritsControl(
            UI_LOCKED_TABLE,
            'ui-table',
            function(el, options) {
                this.$setOptions(options);
                this.$renderHTML(el);
            }
        );
    var UI_OLAP_TABLE_CLASS = UI_OLAP_TABLE.prototype;

    var UI_OLAP_TABLE_CELL_CLASS = (
            UI_OLAP_TABLE_CLASS.Cell = inheritsControl(
                UI_LOCKED_TABLE_CLASS.Cell
            )
        ).prototype;

    var UI_TABLE_HCELL_CLASS = UI_OLAP_TABLE_CLASS.HCell.prototype;

    /**
     * 表格输入非法时的信息
     *
     * @type {string}
     * @private
     */
    var INVALID_TEXT = '数据错误';
    /**
     * 树节点缩进单位宽度
     *
     * @type {number}
     * @private
     */
    var TREE_INDENT = 15;

    //--------------------------------------------------
    // 条件格式
    //--------------------------------------------------

    /**
     * 得到条件格式样式
     *
     * @private
     * @param {Object} condFmtDef 条件格式定义
     * @param {string} ctrlCssBase 控件的css base
     * @return {Object} css和style
     */
    function getCondFmt(condFmtDef, ctrlCssBase) {
        var ret = { 
            text: { css: [], style: [] },
            outer: { css: [], style: [] },
            left: { css: [], style: [] },
            right: { css: [], style: [] }
        };

        if (!condFmtDef) { return null; }

        // 箭头
        if (condFmtDef.arr) {
            ret.right.css.push(
                ctrlCssBase + '-condfmt-arr',
                ctrlCssBase + '-condfmt-arr-' + condFmtDef.arr
            );
        }
        
        // 背景色
        if (condFmtDef.bg) {
            if (condFmtDef.bg.indexOf('#') >= 0) {
                ret.outer.style.push('background-color:' + condFmtDef.bg + ';');
            }
            else {
                ret.outer.css.push(ctrlCssBase + '-condfmt-bg-' + condFmtDef.bg);
            }
        }

        // 文字颜色
        if (condFmtDef.tx) {
            if (condFmtDef.tx.indexOf('#') >= 0) {
                ret.text.style.push('color:' + condFmtDef.tx + ';');
            }
            else {
                ret.text.css.push(ctrlCssBase + '-condfmt-tx-' + condFmtDef.tx);
            }
        }

        // 文字加粗
        if (condFmtDef.wt) {
            ret.text.style.push('font-weight:bold;');
        }

        return ret;
    }

    //--------------------------------------------------
    // UI_OLAP_TABLE 方法
    //--------------------------------------------------

    /**
     * @override
     */
    UI_OLAP_TABLE_CLASS.init = function() {
        UI_OLAP_TABLE.superClass.init.call(this);
        this.$initRowChecked();
    };

    /**
     * 设置参数
     * 
     * @protected
     * @param {Object} options 参数
     * @param {Array.<Object>} options.datasource 主体数据
     *      条件格式：每个节点中有：{Object} style字段。参见getCondFmt。
     * @param {Array.<Object>} options.colFields 上表头（不仅是内容区域，包括了左表头）
     * @param {Array.<Object>} options.colDefine 列定义（不仅是内容区域，包括了左表头）
     *      排序：每个节点中有：{string} orderby字段，值可为：'asc', 'desc', 'none'（默认为空，不排序）
     *      宽度：每个节点中有：{number} width字段。可不指定
     * @param {Array.<Object>} options.rowHeadFields 左表头
     *      缩进：每个节点有{number} indent字段，值为0, 1, 2, 3 （默认为空，不缩进）
     *      链接下钻：每个节点有{boolean} drillByLink字段
     *      expand/collapse（加减号）：每个节点有{boolean} expand字段，
     *          true表示可以expand（显示加号）
     *          false表示可以collapse（显示减号）
     * @param {Array.<Object>} options.rowDefine 行定义
     * @param {string} options.emptyHTML 数据为空时的显示字符
     * @param {number=} options.rowHCellCut 行头指定长度，文字过长截断成“...”，用title提示
     * @param {number=} options.cCellCut 内容区指定长度，文字过长截断成“...”，用title提示
     * @param {number=} options.hCellCut 表头区指定长度，文字过长截断成“...”，用title提示
     * @param {boolean=} options.rowCheckMode 是否启用行选中模式，
     *      'SELECT'（单选）, 'CHECK'（多选）, 空（默认）
     * @param {Array=} options.rowChecked 初始化行选中
     * @param {Array=} options.rowCheckMax 选择条数的上限
     * @param {Array=} options.rowCheckMin 选择条数的下限
     * @param {string=} options.defaultCCellAlign 默认的内容区的align，
     *      默认为left，可为right, left, center
     * @param {boolean} options.vScroll 是否使用纵向滚动条（默认false）
     * @param {boolean} options.hScroll 是否使用横向滚动条（默认true）
     */
    UI_OLAP_TABLE_CLASS.$setOptions = function(options) {
        this._sEmptyHTML = options.emptyHTML;

        this._aData = options.datasource || [];
        this._aColFields = options.colFields || [];
        this._aColDefine = options.colDefine || [];
        this._aRowHeadFields = options.rowHeadFields || [];
        this._aRowDefine = options.rowDefine || [];

        // 行选择记录
        this._oRowCheck = {
            rowCheckMode: options.rowCheckMode,
            rowChecked: options.rowChecked || [],
            rowCheckMax: options.rowCheckMax || Number.MAX_VALUE,
            rowCheckMin: options.rowCheckMin || Number.MIN_VALUE,
            rowCheckCount: 0
        };
        // 如果行内有selected标志，优先
        for (var i = 0, o; o = this._aRowDefine[i]; i ++) {
            o.selected && this._oRowCheck.rowChecked.push(i);
        }

        // 文字过长截断
        this._oCut = {
            ROWHCELL: options.rowHCellCut,
            CCELL: options.cCellCut,
            HCELL: options.hCellCut
        };

        // 样式
        this._oStyle = {
            defaultCCellAlign: options.defaultCCellAlign
        };

        // this.$validate();

        this._nLeftLock = options.leftLock = 
            this._bInvalid 
                ? 0 
                : (
                    this._aRowHeadFields.length
                        ? this._aRowHeadFields[0].length : 0
                );

        this._nRightLock = options.rightLock = 0;

        options.vScroll == null && (options.vScroll = false);
        options.hScroll == null && (options.hScroll = true);
    };

    /**
     * 校验输入数据
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$validate = function() {
        this._bInvalid = false;
        
        var colCount = validateLength.call(this, this._aColFields);
        var rowHeadColCount = validateLength.call(this, this._aRowHeadFields);
        var dataCount = validateLength.call(this, this._aData);

        if (this._aColDefine.length != colCount) {
            this._bInvalid = true;
        }
        if (rowHeadColCount + dataCount != colCount) {
            this._bInvalid = true;
        } 
        if (this._aRowHeadFields.length != this._aData.length) {
            this._bInvalid = true;
        }
    };

    /**
     * 校验二维数组宽高是否合法（含盖计算colspan和rowspan）
     * 
     * @private
     * @this {ui.OlapTable} 控件本身
     * @return {number} length
     */
    function validateLength(matrix) {
        // // TODO 
        // // 同时colspan和rowspan
        // var baseCount = 0; // 每行的应该长度
        // var rowMaxArr = []; // 每列因rowspan而到达的高度
        // var colCount;

        // for (var i = 0, line; i < matrix.length; i ++) {
        //     line = matrix[i];

        //     if (!line) {
        //         this._bInvalid = true;
        //         return baseCount;
        //     } 

        //     colCount = 0;
        //     itemJ = 0;
        //     for (var j = 0, item; ; j ++) {
        //         item = line[itemJ ++];
        //         rowMaxArr[colCount] == null && (rowMaxArr[colCount] = -1);

        //         if (rowMaxArr[colCount] >= i) {
        //             colCount ++;
        //             continue;
        //         }
        //         else {
        //             if (item === Object(item)) {
        //                 if (item.rowspan > 1) {
        //                     rowMaxArr[colCount] = i + item.rowspan - 1;
        //                 }
        //                 else if (item.colspan > 1) {
        //                     colCount += item.colspan;
        //                     rowMaxArr[colCount] = i;
        //                 }
        //             }
        //             else {
        //                 colCount ++;
        //                 rowMaxArr[colCount] = i;
        //             }
        //         }
        //     }

        //     if (!baseCount) {
        //         baseCount = colCount;
        //     }
        //     else if (baseCount != colCount) {
        //         this._bInvalid = true;
        //         return baseCount;
        //     }
        // }
        // return baseCount;
    };

    /**
     * 设置数据并渲染表格
     *
     * @public
     * @param {string} options 参数，参见setOptions
     */
    UI_OLAP_TABLE_CLASS.setData = function(options) {

        // ===========================
        // var ttt = new Date();

        // ===========================
        // var ddd = new Date();

        detachEvent(WINDOW, 'resize', repaint);

        
        // ===================== ch 1200
        this.$disposeInner();

        // console.log('=================== olap-table setData start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        var el = this.getOuter();
        el.innerHTML = '';
        this.$setBody(el);

        // console.log('=================== olap-table setData 1] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        this.$resize();

        // console.log('=================== olap-table setData 2] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        // ==================== ch 518
        UI_OLAP_TABLE.client.call(
            this, 
            el, 
            extend(
                { uid: this._sUID, primary: this._sPrimary }, 
                options
            )
        );
        this._bCreated = false;

        // console.log('=================== olap-table setData 3 (into)] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        // =================== ch 370
        this.cache(true, true);

        // console.log('=================== olap-table setData 4] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        // =================== ch 1102
        this.init();

        // console.log('=================== olap-table setData 51] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        // this.$resize();

        this.$bindCellLink();

        attachEvent(WINDOW, 'resize', repaint);

        // console.log('=================== olap-table setData 6] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        // 为优化而去掉
        // this.resize();

        // =================== ch resize：318 （里面会进入在locked-table.$setSize, 用了315）
        // console.log('=================== olap-table setData last] ' + ((new Date()).getTime() - ddd));

        // console.log('=================== olap-table setData total] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * 析构内部
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$disposeInner = function() {
        var disposeFunc = this.$dispose;
        this.$dispose = new Function();
        disposeControl(this);
        this.$dispose = disposeFunc;
    }    

    /**
     * 渲染HTML
     * 
     * @protected
     * @param {HTMLElement} el 控件容器
     */
    UI_OLAP_TABLE_CLASS.$renderHTML = function(el) {

        // =================================
        // var ttt = new Date();
        // var ddd = new Date();

        var type = this.getTypes()[0];
        var datasource = this._aData || [];
        var colFields = this._aColFields || [];
        var colDefine = this._aColDefine || [];
        var rowHeadFields = this._aRowHeadFields || [];
        var rowDefine = this._aRowDefine || [];
        var leftLock = this._nLeftLock;
        var html = [];
        var i;
        var j;
        var line;
        var wrap;

        setStyle(el, 'width', 'auto');
        setStyle(el, 'display', 'block');
        html.push('<table>');

        // 非法情况
        if (this._bInvalid) {
            html.push('<thead><tr><th class="' + type +'-hcell-empty">&nbsp;</th></tr></thead>');
            html.push('<tbody><tr><td>' + INVALID_TEXT + '</td></tr></tbody>');
        }

        // 正常情况
        else {
            // 上表头
            html.push('<thead>');
            if (!colFields.length) {
                html.push('<tr><th class="' + type + '-hcell-empty">&nbsp;</th></tr>');
            }
            else {
                for (i = 0; line = colFields[i]; i ++) {
                    html.push('<tr>');
                    for (j = 0; j < line.length; j ++) {
                        if (isPlaceholder(wrap = line[j])) {
                            continue;
                        }
                        this.$renderHCell(
                            html,
                            // 目前只有最底层才传colField
                            i == colFields.length - 1 ? colDefine[j] : null,
                            wrap,
                            j < this._nLeftLock ? j : (j - this._nLeftLock),
                            i
                        );
                    }
                    html.push('</tr>');
                }
            }
            html.push('</thead>');

            // 表内容
            html.push('<tbody>');
            if (this._bInvalid || !datasource.length) {
                html.push(
                    '<tr>',
                        '<td class="', type, '-cell-empty" align="middle" colspan="',
                            colFields.length, '">',
                            this._sEmptyHTML,
                        '</td>',
                    '</tr>'
                );
            }
            else {
                for (i = 0; line = datasource[i]; i ++) {
                    html.push('<tr class="'+ type +'-row">')
                    // 左表头
                    if (leftLock) {
                        for (j = 0; j < rowHeadFields[i].length; j ++) {
                            if (isPlaceholder(wrap = rowHeadFields[i][j])) {
                                continue;
                            }
                            this.$renderRowHCell(
                                html,
                                colDefine[j], 
                                wrap,
                                j,
                                i
                            );
                        }
                    }
                    // 内容
                    for (j = 0; j < line.length; j ++) {
                        wrap = line[j];
                        this.$renderCell(
                            html, 
                            colDefine[leftLock + j], 
                            rowDefine[i],
                            wrap,
                            j, 
                            i
                        );
                    }
                    html.push('</tr>')
                }
            }
        }

        html.push('</tbody></table>');

        // ==========================以上所有循环push ch 144
        // console.log('=================== olap-table html.push] ' + html.length + ' ' + ((new Date()).getTime() - ddd));

        // ====================================
        // ddd = new Date();

        html = html.join('');

        // console.log('=================== olap-table html.join("")] ' + html.length + ' ' + ((new Date()).getTime() - ddd));

        // ====================================
        // ddd = new Date();
        
        // ============================= ch 293 （分批加载来优化）
        el.innerHTML = html;

        // console.log('=================== olap-table renderHTML el.innerHTLM=...] ' + ((new Date()).getTime() - ddd));

        // console.log('=================== olap-table renderHTML total] ' + ((new Date()).getTime() - ttt));
        // ddd = new Date();

        return el;
    };

    /**
     * 渲染上方表头节点
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderHCell = function(
        // 只有最底层有colField
        html, colDefItem, wrap, x, y
    ) {
        var type = this.getType();
        var classStr = [type + '-hcell'];
        var styleStr = [];
        var attrStr = [];
        var span = [];
        var innerStr;

        wrap = objWrap(wrap);

        span.push(wrap.colspan ? ' colspan="' + wrap.colspan + '" ' : '');
        span.push(wrap.rowspan ? ' rowspan="' + wrap.rowspan + '" ' : '');

        if (colDefItem && colDefItem.width) {
            styleStr.push('width:' + colDefItem.width + 'px;');
        }
        if (colDefItem && colDefItem.orderby) {
            classStr.push(type + '-hcell-sort-' + colDefItem.orderby);
            attrStr.push('data-orderby="' + colDefItem.orderby + '"');
        }
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');
        innerStr = this.$renderCellInner('HCELL', null, wrap, attrStr, classStr, styleStr);
        html.push(
            '<th ', 
                span.join(' '), ' ',
                attrStr.join(' '), ' ',
                ' class="', classStr.join(' '), 
                '" style="', styleStr.join(' '), 
            '">', 
                innerStr, 
            '</th>'
        );
    }; 

    /**
     * 渲染左侧表头节点
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderRowHCell = function(html, colDefItem, wrap, x, y) {
        var type = this.getType();
        var classStr = [type + '-rowhcell'];
        var styleStr = [];
        var attrStr = [];
        var span = [];
        var innerStr;

        wrap = objWrap(wrap);

        span.push(wrap.colspan ? ' colspan="' + wrap.colspan + '" ' : '');
        span.push(wrap.rowspan ? ' rowspan="' + wrap.rowspan + '" ' : '');

        if (colDefItem.width) {
            styleStr.push('width:' + colDefItem.width + 'px;');
            // styleStr.push('min-width:' + colDefItem.width + 'px;');
            // styleStr.push('max-width:' + colDefItem.width + 'px;');
        }
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');
        attrStr.push('data-row-h="1"'); // 左表头的标志
        innerStr = this.$renderCellInner('ROWHCELL', null, wrap, attrStr, classStr, styleStr);

        html.push(
            '<td ', 
                span.join(' '), ' ', 
                attrStr.join(' '), ' ',
                ' style="', styleStr.join(' '), 
                '" class="', classStr.join(' '), 
            '">',
                innerStr, 
            '</td>'
        );
    };

    /**
     * 渲染内容节点
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderCell = function(html, colDefItem, rowDefItem, wrap, x, y) {
        var type = this.getType();
        var classStr = [type + '-ccell'];
        var styleStr = [];
        var attrStr = [];
        var innerStr;

        wrap = objWrap(wrap);

        var align = colDefItem.align || this._oStyle.defaultCCellAlign;
        if (align) {
            classStr.push(type + '-cell-align-' + align);
        }
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');
        attrStr.push('data-content="1"'); // 内容节点的标志

        innerStr = this.$renderCellInner(
            'CCELL',
            colDefItem,
            wrap, 
            attrStr,
            classStr, 
            styleStr
        );

        html.push(
            '<td ', 
                attrStr.join(' '), ' ',
                ' style="', styleStr.join(' '), 
                '" class="', classStr.join(' '), 
            '">',
                innerStr, 
            '</td>'
        );
    };

    /**
     * 节点内部结构
     *
     * @private
     * @param {string} cellType 为'ROWHCELL', 'HCELL', 'CCELL'
     * @param {Object=} defItem 列定义
     * @param {Object} wrap 节点数据
     * @param {Array} attrStr 父节点属性集合
     * @param {Array} classStr 父节点css class集合
     * @param {Array} styleStr 父节点css style集合
     * @return {string} 节点内部html
     */
    UI_OLAP_TABLE_CLASS.$renderCellInner = function(
        cellType, defItem, wrap, attrStr, classStr, styleStr
    ) {
        var indentStyle = '';
        var clz = '';
        var type = this.getType();
        var value = getWrapValue.call(this, cellType, wrap, defItem && defItem.format);
        var prompt = value.prompt;
        value = value.value;

        if (prompt) {
            attrStr.push('title="' + prompt + '"');
        }

        if (wrap.indent) {
            // margin-left会用来判断indent的点击事件，所以结构不能变
            attrStr.push('data-indent="' + wrap.indent + '"');
            indentStyle = 'margin-left:' + TREE_INDENT * wrap.indent + 'px;';
        }

        if (wrap.drillByLink) {
            attrStr.push('data-cell-link="true"');
            value = '<a href="#" class="' + type + '-cell-link" data-cell-link-drill-a="1">' + value + '</a>';
        } 
        else if (defItem && defItem.linkBridge) {
            attrStr.push('data-cell-link="true"');
            value = '<a href="#" class="' + type + '-cell-link" data-cell-link-bridge-a="1">' + value + '</a>';
        }

        // 条件格式
        var condFmt = getCondFmt(wrap.style, type);
        if (condFmt) {
            value = (
                    condFmt.left.css.length > 0 || condFmt.left.style.length > 0
                        ? '<span class="' + condFmt.left.css.join(' ') 
                            + '" style="' + condFmt.left.style.join(' ') + '">' + '</span>'
                        : ''
                )
                + (
                    condFmt.text.css.length > 0 || condFmt.text.style.length > 0
                        ? '<span class="' + condFmt.text.css.join(' ')
                            + '" style="' + condFmt.text.style.join(' ') + '">' + value + '</span>'
                        : value
                )
                + (
                    condFmt.right.css.length > 0 || condFmt.right.style.length > 0
                        ? '<span class="' + condFmt.right.css.join(' ') 
                            + '" style="' + condFmt.right.style.join(' ') + '">' + '</span>'
                        : ''
                );

            if (condFmt.outer.css.length > 0 || condFmt.outer.style.length > 0) {
                classStr.push.apply(classStr, condFmt.outer.css);
                styleStr.push.apply(styleStr, condFmt.outer.style);
            }
        }

        if (wrap.expand != null) {
            attrStr.push(
                'data-e-c="' + (!wrap.expand ? 'expanded' : 'collapsed') + '"'
            );
            clz = type + '-e-c-icon ' + type
                + (!wrap.expand ? '-expanded-icon ' : '-collapsed-icon ');
            value = [
                '<div style="' + indentStyle + ' text-align:left;" class="'
                    + type + '-tree-item">',
                    '<div class="' + clz + '"></div>',
                    value,
                '</div>',
            ].join('');
        }
        else if (indentStyle) {
            value = '<div style="' + indentStyle 
                + 'text-align:left;">' + value + '</div>';
        }

        return value;
    };

    /**
     * table生产完毕以后执行，触发sizechange事件
     *
     */
    UI_OLAP_TABLE_CLASS.$ready = function() {
        triggerEvent(this, 'sizechange');
    };

    /**
     * 浏览器resize时调整横滚的位置
     *
     * @override
     */
    UI_OLAP_TABLE_CLASS.$resize = function() {
        var me = this;
        UI_LOCKED_TABLE_CLASS.$resize.call(this);
        if (!this._bResizeTimeout) {
            this._bResizeTimeout = true;
            setTimeout(
                function() {
                    me._bResizeTimeout = false;
                    triggerEvent(me, 'sizechange');
                    me.$pagescroll();
                },
                100
            );
        }
    };

    /**
     * 页面滚动时保持表头和横滚浮在视窗上
     *
     * @override
     */
    UI_OLAP_TABLE_CLASS.$pagescroll = function() {
        UI_LOCKED_TABLE_CLASS.$pagescroll.call(this);

        if (this._uHScrollbar) {
            // setFloatHScroll(this);
        }
    };

    /**
     * 绑定cell link
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$bindCellLink = function() {
        var me = this;
        var tds = this.getOuter().getElementsByTagName('td');
        for (
            var i = 0, tdEl, aEls, aEl, o, j; 
            tdEl = tds[i]; 
            i ++
        ) {
            if (tdEl.getAttribute('data-cell-link')) {
                aEls = tdEl.getElementsByTagName('a');

                o = getCellPosition(tdEl);
                for (j = 0; aEl = aEls[j]; j ++) {
                    if (aEl.getAttribute('data-cell-link-drill-a')) {
                        aEl.onclick = (function(wrap) {
                            return function() {
                                !me._bDisabled 
                                    && triggerEvent(
                                        me, 
                                        'celllinkdrill', 
                                        null, 
                                        [wrap]
                                    );
                                return false;
                            }
                        })(this._aRowHeadFields[o.y][o.x]);
                    }
                    else if (aEl.getAttribute('data-cell-link-bridge-a')) {
                        aEl.onclick = (function(colDefItem, rowDefItem) {
                            return function() {
                                !me._bDisabled 
                                    && triggerEvent(
                                        me, 
                                        'celllinkbridge', 
                                        null, 
                                        [colDefItem, rowDefItem]
                                    );
                                return false;
                            }
                        })(
                            this._aColDefine[this._nLeftLock + o.x], 
                            this._aRowDefine[o.y]
                        );
                    }
                }
            }
        }
    };

    /**
     * 点击某个cell的api
     *
     * @public
     * @param {number} rowIndex 内容行序号，从0开始
     * @param {number} colIndex 内容列序号，从0开始
     */    
    // UI_OLAP_TABLE_CLASS.clickContentCell = function(rowIndex, colIndex) {
    //     var cell = this.getContentCell(rowIndex, colIndex);
    //     cell && cell.$handleCellClick();
    // };

    /**
     * 获取内容区单元格控件。
     *
     * @public
     * @param {number} rowIndex 内容行序号，从0开始
     * @param {number} colIndex 内容列序号，从0开始
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    UI_OLAP_TABLE_CLASS.getContentCell = function(rowIndex, colIndex) {
        rowIndex = this._aRows[rowIndex];
        return rowIndex && rowIndex.getCell(
            (this._nLeftLock || 0) + colIndex
        ) || null;
    };

    /**
     * 得到当前状态数据
     *
     * @public
     * @return {Object} 当前状态数据
     */
    UI_OLAP_TABLE_CLASS.getValue = function() {
        var rowChecked = [];
        var rows = this._aRows || [];
        for (var i = 0, row, cell; i < rows.length; i ++) {
            if ((row = rows[i]) && row._bRowChecked) {
                rowChecked.push({ value: this._aRowDefine[i], index: i });
            }
        }
        return {
            rowChecked: rowChecked,
            rowDefine: (this._aRowDefine || []).slice(),
            colDefine: (this._aColDefine || []).slice()
            // 其他的value，后续随功能添加
        }
    };

    /**
     * 得到内容区域的row控件
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$getContentRow = function(rowIndex) {
        // LockedTable失去了对内容row的引用，所以用这种不太好看的方法找到
        var row;
        var cell;
        return (row = this._aRows[rowIndex])
            && (cell = row.getCell(this._nLeftLock || 0))
            && cell.getParent()
            || null;
    };

    /**
     * 设置内容行选中
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$initRowChecked = function() {
        var rowCheck = this._oRowCheck;
        for (
            var i = 0, rowCtrl; 
            i < (rowCheck.rowChecked || []).length; 
            i ++
        ) {
            // LockedTable失去了对内容row的引用，所以用这种不太好看的方法找到
            if (rowCtrl = this.$getContentRow(rowCheck.rowChecked[i])) {
                this.$setRowChecked(rowCtrl, true);
            }
        }
    };

    /**
     * 设置内容行选中
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$setRowChecked = function(rowCtrl, checked) {
        var type = this.getType();
        var rowCheck = this._oRowCheck;

        var rowCheckMode = this._oRowCheck.rowCheckMode;
        // 多选
        if (rowCheckMode == 'CHECK') {
            if (checked
                && !rowCtrl._bRowChecked
                && rowCheck.rowCheckCount < rowCheck.rowCheckMax
            ) {
                rowCtrl._bRowChecked = true;
                addClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount ++;
                return true;
            }

            if (!checked 
                && rowCtrl._bRowChecked
                && rowCheck.rowCheckCount > rowCheck.rowCheckMin
            ) {
                rowCtrl._bRowChecked = false;
                removeClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount --;
                return true;
            }
        }
        // 单选
        else if (rowCheckMode == 'SELECT') {
            var rows = this._aRows || [];
            for (var i = 0, row, cell; i < rows.length; i ++) {
                if ((row = rows[i]) && row._bRowChecked) {
                    row._bRowChecked = false;
                    removeClass(row.getMain(), type + '-row-selected');
                }
            }
            rowCtrl._bRowChecked = true;
            addClass(rowCtrl.getMain(), type + '-row-selected');
            rowCheck.rowCheckCount = 1;
        }

        return false;
    };

    /**
     * 内容行是否选中
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$isRowChecked = function(rowCtrl) {
        return !!rowCtrl._bRowChecked;
    };

    /**
     * 让表格的横滚始终悬浮在页面视窗低端
     * 
     * @param {ecui.ui.CustomTable} con
     */
    function setFloatHScroll(con) {
        var el;

        el = con._eBrowser ? con._eBrowser : con._uHScrollbar.getOuter();
        el.style.top = MIN(
            getView().bottom - getPosition(con.getOuter()).top 
                - el.offsetHeight,
            con.getHeight() - el.offsetHeight
        ) + 'px';

        setStyle(el, 'zIndex', 1);
    }

    /**
     * 得到格式化的值
     *
     * @private
     * @param {string} cellType 为'ROWHCELL', 'HCELL', 'CCELL'
     * @param {Object} wrap 数据元素
     * @param {Object=} format 格式
     * @return {Object} value和prompt
     */
    function getWrapValue(cellType, wrap, format) {
        var value = String(
                wrap.v == null 
                    ? ' - '
                    : format
                        ? formatNumber(wrap.v, format, void 0, void 0, true)
                        : wrap.v
            );
        var prompt;
        var cut = this._oCut[cellType];
        if (cut) {
            prompt = value;
            value = sliceByte(value, cut, 'gbk');
            if (value.length < prompt.length) {
                value += '...';
            }
            else {
                prompt = null;
            }
        }
        return { 
            value: encodeHTML(value), 
            prompt: prompt && encodeHTML(prompt) 
        };
    }

    /**
     * 如果wrap不是对象，包装成对象
     *
     * @private 
     * @param {*} wrap 数据元素
     */
    function objWrap(wrap) {
        if (wrap !== Object(wrap)) {
            wrap = { v: wrap };
        }
        return wrap;
    }    

    /**
     * 得到cell坐标
     * 
     * @protected
     * @return {Object} 形如：{x: 4, y: 5}
     */    
    function getCellPosition(el) {
        var pos = el.getAttribute('data-cell-pos');
        if (pos) {
            pos = pos.split('-');
            return { x: toNumber(pos[0]), y: toNumber(pos[1]) };
        }
        else {
            return null;
        }
    }

    /**
     * 判断是否placeholder（空对象为placeholder）
     */
    function isPlaceholder(o) {
        if (o !== Object(o)) {
            return false;
        }
        for (var i in o) {
            return false;
        }
        return true;
    }

    //--------------------------------------------------
    // UI_OLAP_TABLE_HCELL 方法
    //--------------------------------------------------

    UI_TABLE_HCELL_CLASS.$click = function () {
        var orderby;
        var tableCtrl = this.getParent();

        UI_CONTROL_CLASS.$click(this);

        if (orderby = this.getOuter().getAttribute('data-orderby')) {
            var pos = getCellPosition(this.getOuter());
            triggerEvent(
                tableCtrl, 
                'sort', 
                null, 
                [tableCtrl._aColDefine[(tableCtrl._nLeftLock || 0) + pos.x]]
            );
        }
    };

    //--------------------------------------------------
    // UI_OLAP_TABLE_CELL 方法
    //--------------------------------------------------

    /**
     * 点击事件
     * 
     * @event
     * @protected
     */
    UI_OLAP_TABLE_CELL_CLASS.$click = function(event) {
        UI_OLAP_TABLE_CLASS.Cell.superClass.$click.call(this, event);

        // 链接则不走handleCellClick
        if (!event.target 
            || !(
                event.target.getAttribute('data-cell-link-drill-a')
                || event.target.getAttribute('data-cell-link-bridge-a')
            )
        ) {
            this.$handleCellClick();
        }
    };

    /**
     * 处理cell点击事件
     * 
     * @protected
     */    
    UI_OLAP_TABLE_CELL_CLASS.$handleCellClick = function() {
        var el = this.getOuter();
        var tableCtrl = this.getParent().getParent();
        var ec;

        // 左表头节点
        if (el.getAttribute('data-row-h') && (ec = el.getAttribute('data-e-c'))) {
            if (getMouseX(this) <= 
                    toNumber(getStyle(el.firstChild, 'marginLeft')) 
                    + toNumber(getStyle(el.firstChild, 'paddingLeft'))
            ) {
                var pos;
                var cellWrap;
                var rowWrap;
                if (pos = getCellPosition(this.getOuter())) {
                    cellWrap = tableCtrl._aRowHeadFields[pos.y][pos.x];
                    rowWrap = tableCtrl._aRowDefine[pos.y];
                }
                triggerEvent(
                    tableCtrl,
                    (ec == 'expanded' ? 'collapse' : 'expand'), 
                    null,
                    [cellWrap, rowWrap]
                );
            }
        }

        // 如果是内容节点
        if (el.getAttribute('data-content')) {
            var rowDefItem;
            if (pos = getCellPosition(this.getOuter())) {
                rowDefItem = tableCtrl._aRowDefine[pos.y];
            }
            // 暂全部为line选中
            triggerEvent(tableCtrl, 'rowclick', null, [rowDefItem]);

            var rowCtrl = this.getParent();

            var rowCheckMode = tableCtrl._oRowCheck.rowCheckMode;
            if (rowCheckMode) {
                var rowChecked = tableCtrl.$isRowChecked(rowCtrl);
                var eventName;

                if (rowCheckMode == 'SELECT') {
                    tableCtrl.$setRowChecked(rowCtrl, true);
                    eventName = 'rowselect';
                }
                else if (rowCheckMode == 'CHECK') {
                    if (rowChecked && tableCtrl.$setRowChecked(rowCtrl, false)) {
                        eventName = 'rowuncheck';
                    }
                    else if (!rowChecked && tableCtrl.$setRowChecked(rowCtrl, true)) {
                        eventName = 'rowcheck';
                    }
                }

                var callback = function (checked) {
                    tableCtrl.$setRowChecked(rowCtrl, checked);
                }

                eventName && triggerEvent(
                    tableCtrl,
                    eventName,
                    null,
                    [rowDefItem, callback]
                );
            }
        }
    };
 }) ();
/**
 * di.shared.model.DIFormModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 表单模型组件
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI 表单模型组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_FORM_MODEL = 
            $namespace().DIFormModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_FORM_MODEL_CLASS = 
            DI_FORM_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter
    }

    /**
     * @override
     */
    DI_FORM_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('FORM_DATA'),
            ASYNC_DATA: URL.fn('FORM_ASYNC_DATA')
        }
    );    

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_FORM_MODEL_DATA_' + getUID(),
            ASYNC_DATA: 'DI_FORM_MODEL_ASYNC_DATA_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            ASYNC_DATA: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) {
                return this._fCommonParamGetter(options.args.param); 
            },
            ASYNC_DATA: function (options) {
                return this._fCommonParamGetter(options.args.param);
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: function (data, ejsonObj, options) {
                this._oInitData = (data || {}).params || {};
                return data;
            },
            ASYNC_DATA: function (data, ejsonObj, options) {
                return (data || {}).params || {};
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                // TODO
            },
            ASYNC_DATA: function (status, ejsonObj, options) {
                // TODO
            }
        }
    );

    /** 
     * 得到初始化数据
     *
     * @public
     * @return {Object} 初始化数据
     */
    DI_FORM_MODEL_CLASS.getInitData = function () {
        return this._oInitData;
    };    

})();


/**
 * di.shared.ui.DIForm
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 表单视图组件
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var isObject = xutil.lang.isObject;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var extend = xutil.object.extend;

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 表单视图组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {string} options.submitMode 提交方式，可选值为
     *      'IMMEDIATE'（输入后立即提交，默认）
     *      'CONFIRM'（按确定按钮后提交）
     * @param {(Object|boolean)=} options.confirmBtn 是否有确认按钮
     *      如果为Object则内容为，{ text: '按钮文字' }
     */
    var DI_FORM = $namespace().DIForm = 
        inheritsObject(INTERACT_ENTITY);
    var DI_FORM_CLASS = DI_FORM.prototype;

    /**
     * 定义
     */
    DI_FORM_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'di-form',
        // model配置
        model: {
            clzPath: 'di.shared.model.DIFormModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_FORM_CLASS.$createView = function (options) {
        this._oOptions = extend({}, options);
        options.submitMode = options.submitMode || 'IMMEDIATE';

        // 创建参数输入控件
        this._aInput = [];
        for (var i = 0, o; o = this.$di('vuiCreate', 'input.' + i); i ++) {
            this._aInput.push(o);
            // 使用json格式传输数据
            o.$di('setOpt', 'cfgOpt', 'paramMode', 'JSON');
        }

        // 创建“确认”控件
        this._uConfirmBtn = this.$di('vuiCreate', 'confirm');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_FORM_CLASS.init = function() {
        var me = this;
        var i;
        var input;
        var def;
        var cfgOpt;

        // 绑定组件事件
        this.getModel().attach(
            ['sync.preprocess.DATA', this.$syncDisable, this, 'DATA'],
            ['sync.result.DATA', this.$renderMain, this],
            ['sync.result.DATA', this.$handleDataLoaded, this],
            ['sync.error.DATA', this.$handleDataError, this],
            ['sync.complete.DATA', this.$syncEnable, this, 'DATA'],

            // ASYNC不加disable，否则suggest框会在disasble的时候动input框，与输入法冲突。            
            // ['sync.preprocess.ASYNC_DATA', this.disable, this, 'DI_FORM'],
            ['sync.result.ASYNC_DATA', this.$renderAsync, this],
            ['sync.error.ASYNC_DATA', this.$handleAsyncError, this]
            // ['sync.complete.ASYNC_DATA', this.enable, this, 'DI_FORM']
        );

        // 绑定控件事件
        for (i = 0; input = this._aInput[i]; i ++ ) {
            def = input.$di('getDef');
            cfgOpt = input.$di('getOpt', 'cfgOpt');

            // 改变事件
            if (!cfgOpt.changeSilent) {
                input.$di(
                    'addEventListener',
                    'change',
                    this.$handleChange,
                    this
                );
            }

            // 异步取值事件
            if (cfgOpt.async) {
                input.$di(
                    'addEventListener',
                    'async',
                    this.$handleAsync,
                    this,
                    { bindArgs: [input] }
                );
            }
        }

        if (this._uConfirmBtn) {
            this._uConfirmBtn.onclick = function() {
                me.$submit();
            }
        }

        for (i = 0; input = this._aInput[i]; i ++ ) {
            input.$di('init');
        }
    };

    /**
     * @override
     */
    DI_FORM_CLASS.dispose = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
            input.$di('dispose');
        }
        DI_FORM.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     */
    DI_FORM_CLASS.sync = function(options) {

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA',  vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

        // 初始化参数
        var paramList = [];
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
            paramList.push(input.$di('getDef').name);
        }

        this.$sync(
            this.getModel(),
            'DATA',
            { paramList: paramList },
            this.$di('getEvent')
        );
    };

    /**
     * 清空视图
     *
     * @public
     */
    DI_FORM_CLASS.clear = function(options) {
        // TODO
    };

    /**
     * 提交
     *
     * @protected
     */
    DI_FORM_CLASS.$submit = function() {
        /**
         * 提交
         *
         * @event
         */
        this.$di('dispatchEvent', 'submit', [this.$di('getValue')]);
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    DI_FORM_CLASS.$renderMain = function(data, ejsonObj, options) {

        var setDataOpt = { diEvent: this.$diEvent(options) };

        // 设置数据并渲染
        var initData = this.getModel().getInitData();
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
            input.$di(
                'setData',
                initData[input.$di('getDef').name],
                setDataOpt
            );
        }

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 渲染同步
     * 
     * @protected
     */
    DI_FORM_CLASS.$renderAsync = function(data, ejsonObj, options) {
        var args = options.args;
        args.callback(data[args.input.$di('getDef').name] || {});
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_FORM_CLASS.resize = function() {
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_FORM_CLASS.enable = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++) {
            input.$di('enable');
        }
        this._uConfirmBtn && this._uConfirmBtn.$di('enable');
        DI_FORM.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_FORM_CLASS.disable = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++) {
            input.$di('disable');
        }
        this._uConfirmBtn && this._uConfirmBtn.$di('disable');
        DI_FORM.superClass.disable.call(this);
    };    

    /**
     * 初始数据加载完成
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleDataLoaded = function(data, ejsonObj, options) {
        /**
         * 初始数据加载完成
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded', options), 
            [this.$di('getValue')]
        );
    };

    /**
     * 条件变化事件
     *
     * @event
     * @protected
     */
    DI_FORM_CLASS.$handleChange = function() {
        if (this._oOptions.submitMode == 'IMMEDIATE') {
            this.$submit();
        }
    };

    /**
     * 异步取数据事件
     *
     * @event
     * @protected
     */
    DI_FORM_CLASS.$handleAsync = function(input, value, callback) {
        var name = input.$di('getDef').name;
        var arg = {};

        this.$sync(
            this.getModel(),
            'ASYNC_DATA',
            {
                paramName: name,
                arg: value
            },
            null,
            {
                value: value,
                callback: callback,
                input: input
            }
        );
    };

    /**
     * 获取数据错误处理
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleDataError = function(status, ejsonObj, options) {
        // 清空视图
        this.clear();

        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 获取async数据错误处理
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleAsyncError = function() {
        // TODO
        this.$di('dispatchEvent', 'rendered');
    };

})();
/*
InputControl - 定义输入数据的基本操作。
输入控件，继承自基础控件，实现了对原生 InputElement 的功能扩展，包括光标的控制、输入事件的实时响应(每次改变均触发事件)，以及 IE 下不能动态改变输入框的表单项名称的模拟处理。
** 在IE6下原生Input会有上下3px的间距，只能通过设置父元素的overflow:hidden解决，本控件未对这种情况进行特殊设置，请注意 **

输入控件直接HTML初始化的例子:
<input ecui="type:input-control" type="password" name="passwd" value="1111">
或:
<div ecui="type:input-control;name:passwd;value:1111;inputType:password"></div>
或:
<div ecui="type:input-control">
  <input type="password" name="passwd" value="1111">
</div>

属性
_bHidden - 输入框是否隐藏
_eInput  - INPUT对象
_aValidateRules - 验证规则
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        REGEXP = RegExp,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        createDom = dom.create,
        insertBefore = dom.insertBefore,
        setInput = dom.setInput,
        setStyle = dom.setStyle,
        encodeHTML = string.encodeHTML,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        timer = util.timer,

        $bind = core.$bind,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        wrapEvent = core.wrapEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_INPUT_CONTROL
    ///__gzip_original__UI_INPUT_CONTROL_CLASS
    /**
     * 初始化输入控件。
     * options 对象支持的属性如下：
     * name         输入框的名称
     * value        输入框的默认值
     * checked      输入框是否默认选中(radio/checkbox有效)
     * inputType    输入框的类型，默认为 text
     * hidden       输入框是否隐藏，隐藏状态下将不会绑定键盘事件
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_INPUT_CONTROL = ui.InputControl =
        inheritsControl(
            UI_CONTROL,
            null,
            function (el, options) {
                if (el.tagName == 'INPUT' || el.tagName == 'TEXTAREA') {
                    // 根据表单项初始化
                    var input = el;

                    insertBefore(el = createDom(input.className, input.style.cssText, 'span'), input).appendChild(input);
                    input.className = '';
                }
                else {
                    input = el.getElementsByTagName('INPUT')[0] || el.getElementsByTagName('TEXTAREA')[0];

                    if (!input) {
                        input = setInput(null, options.name, options.inputType);
                        input.defaultValue = input.value =
                            options.value === undefined ? '' : options.value.toString();
                        el.appendChild(input);
                    }
                }

                setStyle(el, 'display', 'inline-block');

                input.style.border = '0px';
                if (options.hidden) {
                    input.style.display = 'none';
                }
                if (options.checked) {
                    input.defaultChecked = input.checked = true;
                }

                return el;
            },
            function (el, options) {
                this._bHidden = options.hidden;
                this._eInput = el.getElementsByTagName('INPUT')[0] || el.getElementsByTagName('TEXTAREA')[0];

                if (util.validator) {
                    this._aValidateRules = util.validator.collectRules(options);
                }

                UI_INPUT_CONTROL_BIND_EVENT(this);
            }
        ),
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_INPUT_CONTROL_INPUT = {};
//{else}//

    /**
     * 表单提交事件处理。
     * @private
     *
     * @param {Event} event 事件对象
     */
    function UI_INPUT_CONTROL_FORM_SUBMIT(event) {
        event = wrapEvent(event);

        //__transform__elements_list
        //__transform__el_o
        for (var i = 0, elements = event.target.elements, el; el = elements[i++]; ) {
            if (el.getControl) {
                triggerEvent(el.getControl(), 'submit', event);
            }
        }
    }

    /**
     * 为控件的 INPUT 节点绑定事件。
     * @private
     *
     * @param {ecui.ui.Edit} control 输入控件对象
     */
    function UI_INPUT_CONTROL_BIND_EVENT(control) {
        $bind(control._eInput, control);
        if (!control._bHidden) {
            // 对于IE或者textarea的变化，需要重新绑定相关的控件事件
            for (var name in UI_INPUT_CONTROL_INPUT) {
                attachEvent(control._eInput, name, UI_INPUT_CONTROL_INPUT[name]);
            }
        }
    }

    /**
     * 输入框失去/获得焦点事件处理函数。
     * @private
     *
     * @param {Event} event 事件对象
     */
    UI_INPUT_CONTROL_INPUT.blur = UI_INPUT_CONTROL_INPUT.focus = function (event) {
        //__gzip_original__type
        var type = event.type;

        event = wrapEvent(event).target.getControl();

        // 设置默认失去焦点事件，阻止在blur/focus事件中再次回调
        event['$' + type] = UI_CONTROL_CLASS['$' + type];
        event[type]();

        delete event['$' + type];
    };

    /**
     * 拖拽内容到输入框时处理函数。
     * 为了增加可控性，阻止该行为。[todo] firefox下无法阻止，后续升级
     * @private
     *
     * @param {Event} event 事件对象
     */
    UI_INPUT_CONTROL_INPUT.dragover = UI_INPUT_CONTROL_INPUT.drop = function (event) {
        wrapEvent(event).exit();
    };

    /**
     * 输入框输入内容事件处理函数。
     * @private
     *
     * @param {Event} event 事件对象
     */
    if (ieVersion) {
        UI_INPUT_CONTROL_INPUT.propertychange = function (event) {
            if (event.propertyName == 'value') {
                triggerEvent(wrapEvent(event).target.getControl(), 'change');
            }
        };
    }
    else {
        UI_INPUT_CONTROL_INPUT.input = function (event) {
            triggerEvent(this.getControl(), 'change');
        };
    }

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$dispose = function () {
        this._eInput.getControl = undefined;
        this._eInput = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 输入重置事件的默认处理。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_INPUT_CONTROL_CLASS.$reset = function () {
        this.$ready();
    };

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$setParent = function (parent) {
        UI_CONTROL_CLASS.$setParent.call(this, parent);
        if (parent = this._eInput.form) {
            if (parent.getControl) {
                parent.getControl().addItem(this.getName(), this);
            }
        }
    };

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this._eInput.style.width = this.getBodyWidth() + 'px';
        this._eInput.style.height = this.getBodyHeight() + 'px';
    };

    /**
     * 输入提交事件的默认处理。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_INPUT_CONTROL_CLASS.$submit = blank;

    /**
     * 输入控件获得失效需要设置输入框不提交。
     * @override
     */
    UI_INPUT_CONTROL_CLASS.disable = function () {
        if (UI_CONTROL_CLASS.disable.call(this)) {
            var body = this.getBody();

            if (this._bHidden) {
                this._eInput.disabled = true;
            }
            else {
                body.removeChild(this._eInput);
                if (this._eInput.type != 'password') {
                    // 如果输入框是密码框需要直接隐藏，不允许将密码显示在浏览器中
                    body.innerHTML = encodeHTML(this._eInput.value);
                }
            }

            return true;
        }
        return false;
    };

    /**
     * 输入控件解除失效需要设置输入框可提交。
     * @override
     */
    UI_INPUT_CONTROL_CLASS.enable = function () {
        if (UI_CONTROL_CLASS.enable.call(this)) {
            var body = this.getBody();

            if (this._bHidden) {
                this._eInput.disabled = false;
            }
            else {
                body.innerHTML = '';
                body.appendChild(this._eInput);
            }

            return true;
        }
        return false;
    };

    /**
     * 获取控件的输入元素。
     * @public
     *
     * @return {HTMLElement} InputElement 对象
     */
    UI_INPUT_CONTROL_CLASS.getInput = function () {
        return this._eInput;
    };

    /**
     * 获取控件的名称。
     * 输入控件可以在表单中被提交，getName 方法返回提交时用的表单项名称，表单项名称可以使用 setName 方法改变。
     * @public
     *
     * @return {string} INPUT 对象名称
     */
    UI_INPUT_CONTROL_CLASS.getName = function () {
        return this._eInput.name;
    };

    /**
     * 获取当前当前选区的结束位置。
     * @public
     *
     * @return {number} 输入框当前选区的结束位置
     */
    UI_INPUT_CONTROL_CLASS.getSelectionEnd = ieVersion ? function () {
        var range = DOCUMENT.selection.createRange().duplicate();

        range.moveStart('character', -this._eInput.value.length);
        return range.text.length;
    } : function () {
        return this._eInput.selectionEnd;
    };

    /**
     * 获取当前选区的起始位置。
     * @public
     *
     * @return {number} 输入框当前选区的起始位置，即输入框当前光标的位置
     */
    UI_INPUT_CONTROL_CLASS.getSelectionStart = ieVersion ? function () {
        //__gzip_original__length
        var range = DOCUMENT.selection.createRange().duplicate(),
            length = this._eInput.value.length;

        range.moveEnd('character', length);
        return length - range.text.length;
    } : function () {
        return this._eInput.selectionStart;
    };

    /**
     * 获取控件的值。
     * getValue 方法返回提交时表单项的值，使用 setValue 方法设置。
     * @public
     *
     * @return {string} 控件的值
     */
    UI_INPUT_CONTROL_CLASS.getValue = function () {
        return this._eInput.value;
    };

    /**
     * 设置输入框光标的位置。
     * @public
     *
     * @param {number} pos 位置索引
     */
    UI_INPUT_CONTROL_CLASS.setCaret = ieVersion ? function (pos) {
        var range = this._eInput.createTextRange();
        range.collapse();
        range.select();
        range.moveStart('character', pos);
        range.collapse();
        range.select();
    } : function (pos) {
        this._eInput.setSelectionRange(pos, pos);
    };

    /**
     * 设置控件的名称。
     * 输入控件可以在表单中被提交，setName 方法设置提交时用的表单项名称，表单项名称可以使用 getName 方法获取。
     * @public
     *
     * @param {string} name 表单项名称
     */
    UI_INPUT_CONTROL_CLASS.setName = function (name) {
        var el = setInput(this._eInput, name || '');
        if (this._eInput != el) {
            UI_INPUT_CONTROL_BIND_EVENT(this);
            this._eInput = el;
        }
    };

    /**
     * 设置控件的值。
     * setValue 方法设置提交时表单项的值，使用 getValue 方法获取设置的值。
     * @public
     *
     * @param {string} value 控件的值
     */
    UI_INPUT_CONTROL_CLASS.setValue = function (value) {
        //__gzip_original__input
        var input = this._eInput,
            func = UI_INPUT_CONTROL_INPUT.propertychange;

        // 停止事件，避免重入引发死循环
        if (func) {
            detachEvent(input, 'propertychange', func);
        }
        input.value = value;
        if (this._bDisabled 
            && !this._bHidden 
            && this._eInput.type != 'password'
        ) {
            this.getBody().innerHTML = encodeHTML(value);
        }
        if (func) {
            attachEvent(input, 'propertychange', func);
        }
    };

    /**
     * 验证控件
     *
     * @return {Boolean} 验证结果
     */
    UI_INPUT_CONTROL_CLASS.validate = function() {
       return true; 
    };

    /**
     * 根据当前的值设置默认值
     */
    UI_INPUT_CONTROL_CLASS.setDefaultValue = function () {
        var value = this.getValue();
        this._eInput.defaultValue = value;
    };

    (function () {
        function build(name) {
            UI_INPUT_CONTROL_CLASS['$' + name] = function () {
                UI_CONTROL_CLASS['$' + name].call(this);

                //__gzip_original__input
                var input = this._eInput;

                detachEvent(input, name, UI_INPUT_CONTROL_INPUT[name]);
                try {
                    input[name]();
                }
                catch (e) {
                }
                attachEvent(input, name, UI_INPUT_CONTROL_INPUT[name]);
            };
        }

        build('blur');
        build('focus');
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Item/Items - 定义选项操作相关的基本操作。
选项控件，继承自基础控件，用于弹出菜单、下拉框、交换框等控件的单个选项，通常不直接初始化。选项控件必须用在使用选项组接口(Items)的控件中。
选项组不是控件，是一组对选项进行操作的方法的集合，提供了基本的增/删操作，通过将 ecui.ui.Items 对象下的方法复制到类的 prototype 属性下继承接口，最终对象要正常使用还需要在类构造器中调用 $initItems 方法。
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,

        indexOf = array.indexOf,
        remove = array.remove,
        children = dom.children,
        createDom = dom.create,
        insertBefore = dom.insertBefore,
        trim = string.trim,
        blank = util.blank,
        callSuper = util.callSuper,

        $fastCreate = core.$fastCreate,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_ITEM
    ///__gzip_original__UI_ITEMS
    /**
     * 初始化选项控件。
     * @public
     *
     * @param {string|Object} options 对象
     */
    var UI_ITEM = ui.Item =
        inheritsControl(
            UI_CONTROL,
            'ui-item',
            function (el, options) {
                el.style.overflow = 'hidden';
            }
        ),
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items = {};
//{else}//
    /**
     * 选项控件的点击事件将触发选项组的 onitemclick 事件。
     * @override
     */
    UI_ITEM_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);

        var parent = this.getParent();
        if (parent) {
            triggerEvent(parent, 'itemclick', event, [indexOf(UI_ITEMS[parent.getUID()], this)]);
        }
    };

    /**
     * 选项组只允许添加选项控件，添加成功后会自动调用 $alterItems 方法。
     * @override
     */
    UI_ITEMS.$append = function (child) {
        // 检查待新增的控件是否为选项控件
        if (!(child instanceof (this.Item || UI_ITEM)) || callSuper(this, '$append') === false) {
            return false;
        }
        UI_ITEMS[this.getUID()].push(child);
        this.$alterItems();
    };

    /**
     * @override
     */
    UI_ITEMS.$cache = function (style, cacheSize) {
        callSuper(this, '$cache');

        for (var i = 0, list = UI_ITEMS[this.getUID()], o; o = list[i++]; ) {
            o.cache(true, true);
        }
    };

    /**
     * @override
     */
    UI_ITEMS.$dispose = function () {
        delete UI_ITEMS[this.getUID()];
        callSuper(this, '$dispose');
    };

    /**
     * 初始化选项组对应的内部元素对象。
     * 选项组假设选项的主元素在内部元素中，因此实现了 Items 接口的类在初始化时需要调用 $initItems 方法自动生成选项控件，$initItems 方法内部保证一个控件对象只允许被调用一次，多次的调用无效。
     * @protected
     */
    UI_ITEMS.$initItems = function () {
        // 防止因为选项变化引起重复刷新，以及防止控件进行多次初始化操作
        this.$alterItems = this.$initItems = blank;

        UI_ITEMS[this.getUID()] = [];

        // 初始化选项控件
        for (var i = 0, list = children(this.getBody()), o; o = list[i++]; ) {
            this.add(o);
        }

        delete this.$alterItems;
    };

    /**
     * 选项组移除子选项后会自动调用 $alterItems 方法。
     * @override
     */
    UI_ITEMS.$remove = function (child) {
        callSuper(this, '$remove');
        remove(UI_ITEMS[this.getUID()], child);
        this.$alterItems();
    };

    /**
     * 添加子选项控件。
     * add 方法中如果位置序号不合法，子选项控件将添加在末尾的位置。
     * @public
     *
     * @param {string|HTMLElement|ecui.ui.Item} item 控件的 html 内容/控件对应的主元素对象/选项控件
     * @param {number} index 子选项控件需要添加的位置序号
     * @param {Object} options 子控件初始化选项
     * @return {ecui.ui.Item} 子选项控件
     */
    UI_ITEMS.add = function (item, index, options) {
        var list = UI_ITEMS[this.getUID()],
            o;

        if (item instanceof UI_ITEM) {
            // 选项控件，直接添加
            item.setParent(this);
        }
        else {
            // 根据是字符串还是Element对象选择不同的初始化方式
            if ('string' == typeof item) {
                this.getBody().appendChild(o = createDom());
                o.innerHTML = item;
                item = o;
            }

            o = this.Item || UI_ITEM;
            item.className = trim(item.className) + ' ' + this.getType() + '-item' + o.TYPES;

            options = options || getOptions(item);
            options.parent = this;
            options.select = false;
            list.push(item = $fastCreate(o, item, this, options));
            this.$alterItems();
        }

        // 改变选项控件的位置
        if (item.getParent() && (o = list[index]) && o != item) {
            insertBefore(item.getOuter(), o.getOuter());
            list.splice(index, 0, list.pop());
        }

        return item;
    };

    /**
     * 向选项组最后添加子选项控件。
     * append 方法是 add 方法去掉第二个 index 参数的版本。
     * @public
     *
     * @param {string|Element|ecui.ui.Item} item 控件的 html 内容/控件对应的主元素对象/选项控件
     * @param {Object} 子控件初始化选项
     * @return {ecui.ui.Item} 子选项控件
     */
    UI_ITEMS.append = function (item, options) {
        this.add(item, undefined, options);
    };

    /**
     * 获取全部的子选项控件。
     * @public
     *
     * @return {Array} 子选项控件数组
     */
    UI_ITEMS.getItems = function () {
        return UI_ITEMS[this.getUID()].slice();
    };

    /**
     * @override
     */
    UI_ITEMS.init = function () {
        callSuper(this, 'init');
        this.$alterItems();
    };

    /**
     * 移除子选项控件。
     * @public
     *
     * @param {number|ecui.ui.Item} item 选项控件的位置序号/选项控件
     * @return {ecui.ui.Item} 被移除的子选项控件
     */
    UI_ITEMS.remove = function (item) {
        if ('number' == typeof item) {
            item = UI_ITEMS[this.getUID()][item];
        }
        if (item) {
            item.setParent();
        }
        return item || null;
    };

    /**
     * 设置控件内所有子选项控件的大小。
     * @public
     *
     * @param {number} itemWidth 子选项控件的宽度
     * @param {number} itemHeight 子选项控件的高度
     */
    UI_ITEMS.setItemSize = function (itemWidth, itemHeight) {
        for (var i = 0, list = UI_ITEMS[this.getUID()], o; o = list[i++]; ) {
            o.$setSize(itemWidth, itemHeight);
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Select - 定义模拟下拉框行为的基本操作。
下拉框控件，继承自输入控件，实现了选项组接口，扩展了原生 SelectElement 的功能，允许指定下拉选项框的最大选项数量，在屏幕显示不下的时候，会自动显示在下拉框的上方。在没有选项时，下拉选项框有一个选项的高度。下拉框控件允许使用键盘与滚轮操作，在下拉选项框打开时，可以通过回车键或鼠标点击选择，上下键选择选项的当前条目，在关闭下拉选项框后，只要拥有焦点，就可以通过滚轮上下选择选项。

下拉框控件直接HTML初始化的例子:
<select ecui="type:select" name="sex">
  <option value="male" selected="selected">男</option>
  <option value="female">女</option>
</select>
或
<div ecui="type:select;name:sex;value:male">
  <div ecui="value:male">男</div>
  <div ecui="value:female">女</div>
</div>

属性
_nOptionSize  - 下接选择框可以用于选择的条目数量
_cSelected    - 当前选中的选项
_uText        - 下拉框的文本框
_uButton      - 下拉框的按钮
_uOptions     - 下拉选择框
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getText = dom.getText,
        insertAfter = dom.insertAfter,
        insertBefore = dom.insertBefore,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        encodeHTML = string.encodeHTML,
        extend = util.extend,
        getView = util.getView,
        setDefault = util.setDefault,

        $fastCreate = core.$fastCreate,
        getAttributeName = core.getAttributeName,
        getFocused = core.getFocused,
        inheritsControl = core.inherits,
        intercept = core.intercept,
        mask = core.mask,
        restore = core.restore,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_SCROLLBAR = ui.Scrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SELECT
    ///__gzip_original__UI_SELECT_CLASS
    /**
     * 初始化下拉框控件。
     * options 对象支持的属性如下：
     * browser        是否使用浏览器原生的滚动条，默认使用模拟的滚动条
     * optionSize     下拉框最大允许显示的选项数量，默认为5
     * optionsElement 下拉选项主元素
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_SELECT = ui.Select =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-select',
            function (el, options) {
                var name = el.name || options.name || '',
                    type = this.getType(),

                    id = options.id || 'id_notset',
                    optionsEl = createDom(
                        type + '-options' + this.Options.TYPES,
                        'position:absolute;z-index:65535;display:none'
                    );

                optionsEl.setAttribute('ecui_id', id);
                   
                setDefault(options, 'hidden', true);

                if (el.tagName == 'SELECT') {
                    var i = 0,
                        list = [],
                        elements = el.options,
                        o = el;

                    options.value = el.value;

                    // 移除select标签
                    el = insertBefore(createDom(el.className, el.style.cssText, 'span'), el);
                    removeDom(o);

                    // 转化select标签
                    for (; o = elements[i]; ) {
                        // 这里的text不进行转义，特殊字符不保证安全
                        list[i++] =
                            '<div ' + getAttributeName() + '="value:' + encodeHTML(o.value) + '">' +
                                o.text + '</div>';
                    }
                    optionsEl.innerHTML = list.join('');
                }
                else {
                    moveElements(el, optionsEl);
                }

                el.innerHTML =
                    '<span class="' + type + '-text' + UI_ITEM.TYPES + '"></span><span class="' + type + '-button' +
                        UI_BUTTON.TYPES + '" style="position:absolute"></span><input name="' + name + '" value="' +
                        encodeHTML(options.value || '') + '">';

                el.appendChild(optionsEl);

                return el;
            },
            function (el, options) {
                el = children(el);

                this._uText = $fastCreate(UI_ITEM, el[0], this, {capturable: false});
                this._uButton = $fastCreate(UI_BUTTON, el[1], this, {capturable: false});

                this._uOptions = $fastCreate(
                    this.Options,
                    removeDom(el[3]),
                    this,
                    {hScroll: false, browser: options.browser}
                );

                this.$setBody(this._uOptions.getBody());
                // 初始化下拉区域最多显示的选项数量
                this._nOptionSize = options.optionSize || 5;

                this.$initItems();
            }
        ),
        UI_SELECT_CLASS = UI_SELECT.prototype,

        /**
         * 初始化下拉框控件的下拉选项框部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_SELECT_OPTIONS_CLASS = (UI_SELECT_CLASS.Options = inheritsControl(UI_PANEL)).prototype,

        /**
         * 初始化下拉框控件的选项部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_SELECT_ITEM_CLASS =
            (UI_SELECT_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    this._sValue = options.value === undefined ? getText(el) : '' + options.value;
                }
            )).prototype;
//{else}//
    /**
     * 下拉框刷新。
     * @private
     *
     * @param {ecui.ui.Select} control 下拉框控件
     */
    function UI_SELECT_FLUSH(control) {
        var options = control._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            el = options.getOuter(),
            pos = getPosition(control.getOuter()),
            selected = control._cSelected,
            optionTop = pos.top + control.getHeight();

        if (!getParent(el)) {
            // 第一次显示时需要进行下拉选项部分的初始化，将其挂载到 DOM 树中
            DOCUMENT.body.appendChild(el);
            control.cache(false, true);
            control.$alterItems();
        }

        if (options.isShow()) {
            if (selected) {
                setFocused(selected);
            }
            scrollbar.setValue(scrollbar.getStep() * indexOf(control.getItems(), selected));

            // 以下使用control代替optionHeight
            control = options.getHeight();

            // 如果浏览器下部高度不够，将显示在控件的上部
            options.setPosition(
                pos.left,
                optionTop + control <= getView().bottom ? optionTop : pos.top - control
            );
        }
    }

    /**
     * 改变下拉框当前选中的项。
     * @private
     *
     * @param {ecui.ui.Select} control 下拉框控件
     * @param {ecui.ui.Select.Item} item 新选中的项
     */
    function UI_SELECT_CHANGE_SELECTED(control, item) {
        if (item !== control._cSelected) {
            control._uText.setContent(item ? item.getBody().innerHTML : '');
            UI_INPUT_CONTROL_CLASS.setValue.call(control, item ? item._sValue : '');
            control._cSelected = item;
            if (control._uOptions.isShow()) {
                setFocused(item);
            }
        }
    }

    extend(UI_SELECT_CLASS, UI_ITEMS);

    /**
     * 销毁选项框部件时需要检查是否展开，如果展开需要先关闭。
     * @override
     */
    UI_SELECT_OPTIONS_CLASS.$dispose = function () {
        this.hide();
        UI_PANEL_CLASS.$dispose.call(this);
    };

    /**
     * 关闭选项框部件时，需要恢复强制拦截的环境。
     * @override
     */
    UI_SELECT_OPTIONS_CLASS.$hide = function () {
        UI_PANEL_CLASS.$hide.call(this);
        mask();
        restore();
    };

    /**
     * 对于下拉框选项，鼠标移入即自动获得焦点。
     * @override
     */
    UI_SELECT_ITEM_CLASS.$mouseover = function (event) {
        UI_ITEM_CLASS.$mouseover.call(this, event);
        setFocused(this);
    };

    /**
     * 获取选项的值。
     * getValue 方法返回选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @return {string} 选项的值
     */
    UI_SELECT_ITEM_CLASS.getValue = function () {
        return this._sValue;
    };

    /**
     * 设置选项的值。
     * setValue 方法设置选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @param {string} value 选项的值
     */
    UI_SELECT_ITEM_CLASS.setValue = function (value) {
        var parent = this.getParent();
        this._sValue = value;
        if (parent && this == parent._cSelected) {
            // 当前被选中项的值发生变更需要同步更新控件的值
            UI_INPUT_CONTROL_CLASS.setValue.call(parent, value);
        }
    };

    /**
     * 下拉框控件激活时，显示选项框，产生遮罩层阻止对页面内 DOM 节点的点击，并设置框架进入强制点击拦截状态。
     * @override
     */
    UI_SELECT_CLASS.$activate = function (event) {
        if (!(event.getControl() instanceof UI_SCROLLBAR)) {
            UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
            this._uOptions.show();
            // 拦截之后的点击，同时屏蔽所有的控件点击事件
            intercept(this);
            mask(0, 65534);
            UI_SELECT_FLUSH(this);
            event.stopPropagation();
        }
    };

    /**
     * 选项控件发生变化的处理。
     * 在 选项组接口 中，选项控件发生添加/移除操作时调用此方法。虚方法，子控件必须实现。
     * @protected
     */
    UI_SELECT_CLASS.$alterItems = function () {
        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            step = this.getBodyHeight(),
            width = this.getWidth(),
            itemLength = this.getItems().length;

        if (getParent(options.getOuter())) {
            // 设置选项框
            scrollbar.setStep(step);

            // 为了设置激活状态样式, 因此必须控制下拉框中的选项必须在滚动条以内
            this.setItemSize(
                width - options.getMinimumWidth() - (itemLength > optionSize ? scrollbar.getWidth() : 0),
                step
            );

            // 设置options框的大小，如果没有元素，至少有一个单位的高度
            options.$$mainHeight = itemLength * step + options.$$bodyHeightRevise;
            options.$setSize(width, (MIN(itemLength, optionSize) || 1) * step + options.getMinimumHeight());
        }
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$cache = function (style, cacheSize) {
        (getParent(this._uOptions.getOuter()) ? UI_ITEMS : UI_INPUT_CONTROL_CLASS)
            .$cache.call(this, style, cacheSize);
        this._uText.cache(false, true);
        this._uButton.cache(false, true);
        this._uOptions.cache(false, true);
    };

    /**
     * 控件在下拉框展开时，需要拦截浏览器的点击事件，如果点击在下拉选项区域，则选中当前项，否则直接隐藏下拉选项框。
     * @override
     */
    UI_SELECT_CLASS.$intercept = function (event) {
        //__transform__control_o
        this._uOptions.hide();
        for (var control = event.getControl(); control; control = control.getParent()) {
            if (control instanceof this.Item) {
                if (control != this._cSelected) {
                    // 检查点击是否在当前下拉框的选项上
                    UI_SELECT_CHANGE_SELECTED(this, control);
                    triggerEvent(this, 'change');
                }
                break;
            }
        }
        event.exit();
    };

    /**
     * 接管对上下键与回车/ESC键的处理。
     * @override
     */
    UI_SELECT_CLASS.$keydown = UI_SELECT_CLASS.$keypress = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type](event);

        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            which = event.which,
            list = this.getItems(),
            length = list.length,
            focus = getFocused();

        if (this.isFocused()) {
            // 当前不能存在鼠标操作，否则屏蔽按键
            if (which == 40 || which == 38) {
                if (length) {
                    if (options.isShow()) {
                        setFocused(list[which = MIN(MAX(0, indexOf(list, focus) + which - 39), length - 1)]);
                        which -= scrollbar.getValue() / scrollbar.getStep();
                        scrollbar.skip(which < 0 ? which : which >= optionSize ? which - optionSize + 1 : 0);
                    }
                    else {
                        this.setSelectedIndex(MIN(MAX(0, indexOf(list, this._cSelected) + which - 39), length - 1));
                    }
                }
                return false;
            }
            else if (which == 27 || which == 13 && options.isShow()) {
                // 回车键选中，ESC键取消
                options.hide();
                if (which == 13) {
                    UI_SELECT_CHANGE_SELECTED(this, focus);
                    //触发change事件
                    triggerEvent(this, 'change');
                }
                return false;
            }
        }
    };

    /**
     * 如果控件拥有焦点，则当前选中项随滚轮滚动而自动指向前一项或者后一项。
     * @override
     */
    UI_SELECT_CLASS.$mousewheel = function (event) {
        if (this.isFocused()) {
            var options = this._uOptions,
                list = this.getItems(),
                length = list.length;

            if (options.isShow()) {
                options.$mousewheel(event);
            }
            else {
                //options表示当前选项的index
                options = indexOf(list, this._cSelected) + (event.detail > 0 ? 1 : -1)
                this.setSelectedIndex(
                    length ?
                        MIN(MAX(0, options), length - 1) : null
                );
                if (options >= 0 && options < length) {
                    //鼠标滚动触发change事件
                    triggerEvent(this, 'change');
                }
            }

            event.exit();
        }
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$ready = function () {
        this.setValue(this.getValue());
    };

    /**
     * 下拉框移除子选项时，如果选项是否被选中，需要先取消选中。
     * @override
     */
    UI_SELECT_CLASS.remove = function (item) {
        if ('number' == typeof item) {
            item = this.getItems()[item];
        }
        if (item == this._cSelected) {
            UI_SELECT_CHANGE_SELECTED(this);
        }
        return UI_ITEMS.remove.call(this, item);
    };

    /**
     * 添加选项需要根据情况继续cache操作
     * @override
     */
    UI_SELECT_CLASS.add = function (item, index, options) {
        item = UI_ITEMS.add.call(this, item, index, options);
        if (getParent(this._uOptions.getOuter())) {
            item.cache(true, true);
        }
        return item;
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$setSize = function (width, height) {
        UI_INPUT_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
        height = this.getBodyHeight();

        // 设置文本区域
        this._uText.$setSize(width = this.getBodyWidth() - height, height);

        // 设置下拉按钮
        this._uButton.$setSize(height, height);
        this._uButton.setPosition(width, 0);
    };

    /**
     * 获取被选中的选项控件。
     * @public
     *
     * @return {ecui.ui.Item} 选项控件
     */
    UI_SELECT_CLASS.getSelected = function () {
        return this._cSelected || null;
    };

    /**
     * 设置下拉框允许显示的选项数量。
     * 如果实际选项数量小于这个数量，没有影响，否则将出现垂直滚动条，通过滚动条控制其它选项的显示。
     * @public
     *
     * @param {number} value 显示的选项数量，必须大于 1
     */
    UI_SELECT_CLASS.setOptionSize = function (value) {
        this._nOptionSize = value;
        this.$alterItems();
        UI_SELECT_FLUSH(this);
    };

    /**
     * 根据序号选中选项。
     * @public
     *
     * @param {number} index 选项的序号
     */
    UI_SELECT_CLASS.setSelectedIndex = function (index) {
        UI_SELECT_CHANGE_SELECTED(this, this.getItems()[index]);
    };

    /**
     * 设置控件的值。
     * setValue 方法设置控件的值，设置的值必须与一个子选项的值相等，否则将被设置为空，使用 getValue 方法获取设置的值。
     * @public
     *
     * @param {string} value 需要选中的值
     */
    UI_SELECT_CLASS.setValue = function (value) {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            if (o._sValue == value) {
                UI_SELECT_CHANGE_SELECTED(this, o);
                return;
            }
        }

        // 找不到满足条件的项，将选中的值清除
        UI_SELECT_CHANGE_SELECTED(this);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
MonthView - 定义日历显示的基本操作。
日历视图控件，继承自基础控件，不包含年/月/日的快速选择与切换，如果需要实现这些功能，请将下拉框(选择月份)、输入框(输入年份)等组合使用建立新的控件或直接在页面上布局并调用接口。

日历视图控件直接HTML初始化的例子:
<div ecui="type:month-view;year:2009;month:11"></div>

属性
_nYear      - 年份
_nMonth     - 月份(0-11)
_aCells     - 日历控件内的所有单元格，其中第0-6项是日历的头部星期名称
_oRange     - 默认的选择范围，只能通过初始化时的参数进行赋值
_oCurRange  - 当前的选择范围，通过setRange设置，如果没有设置_oCurRange 则使用 _oRange,
              当两者都存在时取交集，确定最小的范围

子控件属性
_nDay       - 从本月1号开始计算的天数，如果是上个月，是负数，如果是下个月，会大于当月最大的天数
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        DATE = Date,

        extend = util.extend,
        indexOf = array.indexOf,
        addClass = dom.addClass,
        getParent = dom.getParent,
        removeClass = dom.removeClass,
        setText = dom.setText,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_MONTH_VIEW
    ///__gzip_original__UI_MONTH_VIEW_CLASS
    /**
     * 初始化日历控件。
     * options 对象支持的属性如下：
     * year    日历控件的年份
     * month   日历控件的月份(1-12)
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_MONTH_VIEW = ui.MonthView =
        inheritsControl(
            UI_CONTROL,
            'ui-monthview',
            null,
            function (el, options) {
                var i = 0,
                    type = this.getType(),
                    list = [],
                    o;

                el.style.overflow = 'auto';

                for (; i < 7; ) {
                    list[i] =
                        '<td class="' + type + '-title' + this.Cell.TYPES + (i == 6 ? type + '-title-last' : '') + '">' +
                            UI_MONTH_VIEW.WEEKNAMES[i++] + '</td>';
                }
                list[i] = '</tr></thead><tbody><tr>';
                for (; ++i < 50; ) {
                    list[i] =
                        '<td class="' + type + '-item' + this.Cell.TYPES +  (i % 7 ? '' : type + '-item-last') + '"></td>' +
                            (i % 7 ? '' : '</tr><tr>');
                }

                el.innerHTML =
                    '<table cellspacing="0" cellpadding="0"><thead><tr>' + list.join('') + '</tr></tbody></table>';

                this._aCells = [];
                list = el.getElementsByTagName('TD');
                for (i = 0; o = list[i]; ) {
                    // 日历视图单元格禁止改变大小
                    this._aCells[i++] = $fastCreate(this.Cell, o, this, {resizable: false});
                }

                this._oRange = options.range || {};
                this._oCurRange = extend({}, this._oRange);

                this.setDate(options.year, options.month);
                this.setDay(options.day);
            }
        ),
        UI_MONTH_VIEW_CLASS = UI_MONTH_VIEW.prototype,

        /**
         * 初始化日历控件的单元格部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_MONTH_VIEW_CELL_CLASS = (UI_MONTH_VIEW_CLASS.Cell = inheritsControl(UI_CONTROL)).prototype;
//{else}//
    UI_MONTH_VIEW.WEEKNAMES = ['一', '二', '三', '四', '五', '六', '日'];

    function UI_MONTH_VIEW_COMPARE(a, b) {
        a = new Date(a.getFullYear(), a.getMonth(), a.getDate());
        b = new Date(b.getFullYear(), b.getMonth(), b.getDate());
        return a >= b;
    }
    
    UI_MONTH_VIEW_CLASS.$setSelected = function (cell) {
        if (this._uCellSel) {
            this._uCellSel.alterClass('-selected');
        }
        if (cell) {
            cell.alterClass('+selected');
            this._uCellSel = cell;
        }
    };

    /**
     * 点击时，根据单元格类型触发相应的事件。
     * @override
     */
    UI_MONTH_VIEW_CELL_CLASS.$click = function (event) {
        var parent = this.getParent(),
            index = indexOf(parent._aCells, this);

        if (triggerEvent(
            parent,
            index < 7 ? 'titleclick' : 'dateclick',
            event,
            index < 7 ? [index] : [new DATE(parent._nYear, parent._nMonth, this._nDay)]
        ) !== false) {
            parent.$setSelected(this);
        }
    };

    /**
     * 获取日历控件当前显示的月份。
     * @public
     *
     * @return {number} 月份(1-12)
     */
    UI_MONTH_VIEW_CLASS.getMonth = function () {
        return this._nMonth + 1;
    };

    /**
     * 获取日历控件当前显示的年份。
     * @public
     *
     * @return {number} 年份(19xx-20xx)
     */
    UI_MONTH_VIEW_CLASS.getYear = function () {
        return this._nYear;
    };

    /**
     * 日历显示移动指定的月份数。
     * 参数为正整数则表示向当前月份之后的月份移动，负数则表示向当前月份之前的月份移动，设置后日历控件会刷新以显示新的日期。
     * @public
     *
     * @param {number} offsetMonth 日历移动的月份数
     */
    UI_MONTH_VIEW_CLASS.move = function (offsetMonth) {
        var time = new DATE(this._nYear, this._nMonth + offsetMonth, 1);
        this.setDate(time.getFullYear(), time.getMonth() + 1);
    };

    UI_MONTH_VIEW_CLASS.setDay = function (day) {
        var list = this._aCells, i, o;
        if (!day) {
            this.$setSelected();
            return;
        }
        for (i = 0; o = list[i]; i++) {
            if (!o.isDisabled() && o._nDay == day) {
                this.$setSelected(o);
                break;
            }
        }
    };

    UI_MONTH_VIEW_CLASS.getDay = function () {
        var res;
        if (this._uCellSel) {
            res = this._uCellSel._nDay;
        }
        return res;
    };

    /**
     * 设置日历控件当前显示的日期。
     * @public
     *
     * @param {number} year 年份(19xx-20xx)，如果省略使用浏览器的当前年份
     * @param {number} month 月份(1-12)，如果省略使用浏览器的当前月份
     */
    UI_MONTH_VIEW_CLASS.setDate = function (year, month) {
        //__gzip_original__date
        var i = 7,
            today = new DATE(),
            year = year || today.getFullYear(),
            month = month ? month - 1 : today.getMonth(),
            // 得到上个月的最后几天的信息，用于补齐当前月日历的上月信息位置
            o = new DATE(year, month, 0),
            day = 1 - o.getDay(),
            lastDayOfLastMonth = o.getDate(),
            // 得到当前月的天数
            lastDayOfCurrMonth = new DATE(year, month + 1, 0).getDate(),
            rangeBegin = this._oCurRange.begin,
            rangeEnd = this._oCurRange.end, currDate, cellDay;

        if (this._nYear != year || this._nMonth != month) {
            this._nYear = year;
            this._nMonth = month;

            currDate = new DATE(year, month, 1);

            for (; o = this._aCells[i++]; ) {
                if (month = day > 0 && day <= lastDayOfCurrMonth) {
                    currDate.setDate(day);
                    if ((!rangeBegin || rangeBegin <= currDate) 
                        && (!rangeEnd || rangeEnd >= currDate)) {
                        o.enable();
                    }
                    else {
                        o.disable();
                    }
                }
                else {
                    o.disable();
                }

                if (i == 36 || i == 43) {
                    (o.isDisabled() ? addClass : removeClass)(getParent(o.getOuter()), this.getType() + '-extra');
                }
                
                cellDay = month ? day : day > lastDayOfCurrMonth ? day - lastDayOfCurrMonth : lastDayOfLastMonth + day;
                this.setCellHTML && (this.setCellHTML(o, cellDay, day) !== false) || setText(o.getBody(), cellDay);
                o._nDay = day++;
            }
        }
    };

    UI_MONTH_VIEW_CLASS.setRange = function(begin, end, overrideOrg) {
        var o, i, range, 
            currDate = new DATE(this._nYear, this._nMonth, 1), 
            lastDayOfCurrMonth = new DATE(this._nYear, this._nMonth + 1, 0).getDate();

        if(overrideOrg === true) {
            this._oRange.begin = begin;
            this._oRange.end = end;
        }

        if(begin) {
            if(this._oRange.begin) {
                begin = UI_MONTH_VIEW_COMPARE(begin, this._oRange.begin) ? begin : this._oRange.begin;
            }
        } 
        else {
            begin = this._oRange.begin;
        }
        if(end) {
            if(this._oRange.end) {
                end = UI_MONTH_VIEW_COMPARE(this._oRange.end, end) ? end : this._oRange.end;
            }
        } 
        else {
            end = this._oRange.end;
        }

        for( i = 0; o = this._aCells[i ++]; ) {
            if(o._nDay > 0 && o._nDay <= lastDayOfCurrMonth) {
                currDate.setDate(o._nDay);
                if(( !begin || UI_MONTH_VIEW_COMPARE(currDate, begin)) 
                && ( !end || UI_MONTH_VIEW_COMPARE(end, currDate))) {
                    o.enable();
                } else {
                    o.disable();
                }
            }
        }

        this._oCurRange.begin = begin;
        this._oCurRange.end = end;
    };


//{/if}//
//{if 0}//
})();
//{/if}//

(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        string = core.string,
        util = core.util,

        DATE = Date,
        REGEXP = RegExp,
        DOCUMENT = document,

        pushArray = array.push,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        moveElements = dom.moveElements,
        setText = dom.setText,
        formatDate = string.formatDate,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        setFocused = core.setFocused,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_SELECT = ui.Select,
        UI_MONTH_VIEW = ui.MonthView,
        UI_MONTH_VIEW_CELL = UI_MONTH_VIEW.Cell;

    /**
     * 初始化日历控件。
     * options 对象支持的属性如下：
     * year    日历控件的年份
     * month   日历控件的月份(1-12)
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_CALENDAR = ui.Calendar =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-calendar',
            function (el, options) {
                options.hidden = true;
            },
            function (el, options) {
                var o = createDom(), child,
                    date, range,
                    type = this.getTypes()[0];

                o.innerHTML = '<div class="'+ type +'-text"></div><div class="'+ type +'-cancel"></div><div class="'+ type +'-button"></div>'
                    + '<div class="'+ type +'-layer" style="position:absolute;display:none"></div>';

                child = children(o);

                this._bTip = options.tip !== false;

                if (options.date) {
                    date = options.date.split('-');
                    this._oDate = new Date(date[0], parseInt(date[1], 10) - 1, date[2]);
                }
                else if (options.date === false) {
                    this._oDate = null
                }
                else {
                    this._oDate = new Date();
                }
                range = UI_CALENDAR_PARSE_RANGE(options.start, options.end);

                this._eText = child[0];

                this._uCancel = $fastCreate(this.Cancel, child[1], this);
                this._uButton = $fastCreate(UI_CONTROL, child[2], this);
                DOCUMENT.body.appendChild(child[3]);
                this._uLayer = $fastCreate(this.Layer, child[3], this, {date: this._oDate, range: range});

                moveElements(o, el, true);
            }
        ),

        UI_CALENDAR_CLASS = UI_CALENDAR.prototype,
        UI_CALENDAR_CANCEL_CLASS = (UI_CALENDAR_CLASS.Cancel = inheritsControl(UI_CONTROL)).prototype,

        UI_CALENDAR_LAYER = UI_CALENDAR_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-calendar-layer',
            null,
            function (el, options) {
                var html = [], o, i,
                    type = this.getTypes()[0],
                    buttonClass = this.Button,
                    selectClass = this.Select,
                    monthViewClass = this.MonthView,
                    date = options.date,
                    year = (new Date()).getFullYear();

                html.push('<div class="'+ type +'-buttons"><div class="'+ type +'-btn-prv'+ UI_BUTTON.TYPES +'"></div><select class="'+ type +'-slt-year'+ UI_SELECT.TYPES +'">');
                for ( i = year - 5; i < year + 5; i ++) {
                    html.push('<option value="'+ i +'">'+ i +'</option>');
                }
                html.push('</select><select class="'+ type +'-slt-month'+ UI_SELECT.TYPES +'">');
                for (i = 1; i <= 12; i++) {
                    html.push('<option value="'+ i +'">'+ (i < 10 ? '0' : '') + i +'</option>');
                }
                html.push('</select><div class="'+ type +'-btn-nxt'+ UI_BUTTON.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-month-view'+ UI_MONTH_VIEW.TYPES +'"></div>');
                el.innerHTML = html.join('');
                
                el = children(el);
                o = children(el[0]);

                this._uPrvBtn = $fastCreate(buttonClass, o[0], this);
                this._uPrvBtn._nStep = -1;
                this._uYearSlt = $fastCreate(selectClass, o[1], this);
                this._uMonthSlt = $fastCreate(selectClass, o[2], this);
                this._uNxtBtn = $fastCreate(buttonClass, o[3], this);
                this._uNxtBtn._nStep = 1;

                el = el[1];
                this._sMode = options.mode;
                this._uMonthView = $fastCreate(
                    monthViewClass, 
                    el, 
                    this, 
                    {
                        range : options.range, 
                        mode: options.mode
                    }
                );
            }
        ),

        UI_CALENDAR_LAYER_CLASS = UI_CALENDAR_LAYER.prototype,
        UI_CALENDAR_LAYER_BUTTON_CLASS = (UI_CALENDAR_LAYER_CLASS.Button = inheritsControl(UI_BUTTON, null)).prototype,
        UI_CALENDAR_LAYER_SELECT_CLASS = (UI_CALENDAR_LAYER_CLASS.Select = inheritsControl(UI_SELECT, null)).prototype,
        UI_CALENDAR_LAYER_MONTHVIEW_CLASS = (UI_CALENDAR_LAYER_CLASS.MonthView = inheritsControl(UI_MONTH_VIEW, null)).prototype,

        UI_CALENDAR_STR_DEFAULT = '<span class="ui-calendar-default">请选择一个日期</span>',
        UI_CALENDAR_STR_PATTERN = 'yyyy-MM-dd';


    function UI_CALENDAR_PARSE_RANGE(begin, end) {
        var now = new Date(), res = null,
            o = [now.getFullYear(), now.getMonth(), now.getDate()], t,
            p = {y:0, M:1, d:2};
        if (/^(\d+)([yMd])$/.test(begin)) {
            res = res || {};
            t = o.slice();
            t[p[REGEXP.$2]] -= parseInt(REGEXP.$1, 10);
            res.begin = new Date(t[0], t[1], t[2]);
        }
        else if ('[object String]' == Object.prototype.toString.call(begin)) {
            res = res || {};
            res.begin = new Date(begin);
        }

        if (/^(\d+)([yMd])$/.test(end)) {
            res = res || {};
            t = o.slice();
            t[p[REGEXP.$2]] += parseInt(REGEXP.$1, 10);
            res.end = new Date(t[0], t[1], t[2]);
        }
        else if ('[object String]' == Object.prototype.toString.call(end)) {
            res = res || {};
            res.end = new Date(end);
        }

        return res;
    }

    function UI_CALENDAR_TEXT_FLUSH(con) {
        var el = con._eText;
        if (el.innerHTML == '') {
            con._uCancel.hide();
            if (con._bTip) {
                el.innerHTML = UI_CALENDAR_STR_DEFAULT;
            }
        }
        else {
            con._uCancel.show();
        }
    }

    function UI_CALENDAR_MONTHVIEW_FLUSH(con, day) {
        var cal = con._uMonthView,
            month = con._uMonthSlt.getValue(),
            year = con._uYearSlt.getValue();

        if (cal.getMonth() != month || cal.getYear() != year) {
            cal.setDate(year, month);
        }
        if (con._oDateSel && 
                cal.getMonth() == con._oDateSel.getMonth() + 1 && 
                cal.getYear() == con._oDateSel.getFullYear()) {
            day = con._oDateSel.getDate();
        }
        cal.setDay(day);
    }

    UI_CALENDAR_CLASS.getDate = function () {
        return this._oDate;
    };

    UI_CALENDAR_CLASS.setDate = function (date) {
        var layer = this._uLayer,
            ntxt = date != null ? formatDate(date, UI_CALENDAR_STR_PATTERN) : '';

        if (this._uLayer.isShow()) {
            this._uLayer.hide();
        }

        this._eText.innerHTML = ntxt;
        this.setValue(ntxt);
        this._oDate = date;
        UI_CALENDAR_TEXT_FLUSH(this);
    };

    UI_CALENDAR_CLASS.$activate = function (event) {
        var layer = this._uLayer, con,
            pos = getPosition(this.getOuter()),
            posTop = pos.top + this.getHeight();

        UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
        if (!layer.isShow()) {
            layer.setDate(this.getDate());
            layer.show();
            con = layer.getHeight();
            layer.setPosition(
                pos.left,
                posTop + con <= getView().bottom ? posTop : pos.top - con
            );
            setFocused(layer);
        }
    };

    UI_CALENDAR_CLASS.$cache = function (style, cacheSize) {
        UI_INPUT_CONTROL_CLASS.$cache.call(this, style, cacheSize);
        this._uButton.cache(false, true);
        this._uLayer.cache(true, true);
    };

    UI_CALENDAR_CLASS.init = function () {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this.setDate(this._oDate);
        this._uLayer.init();
    };

    UI_CALENDAR_CLASS.clear = function () {
        this.setDate(null);
    };

    UI_CALENDAR_CANCEL_CLASS.$click = function () {
        var par = this.getParent(),
            layer = par._uLayer;

        UI_CONTROL_CLASS.$click.call(this);
        par.setDate(null);
    };

    UI_CALENDAR_CANCEL_CLASS.$activate = UI_BUTTON_CLASS.$activate;

    UI_CALENDAR_LAYER_CLASS.$blur = function () {
        this.hide();
    };

    UI_CALENDAR_LAYER_CLASS.setDate = function (date, notDay) {
        var monthSlt = this._uMonthSlt,
            yearSlt = this._uYearSlt,
            year = date != null ? date.getFullYear() : (new Date()).getFullYear(),
            month = date != null ? date.getMonth() + 1 : (new Date()).getMonth() + 1;

        if (!notDay) {
            this._oDateSel = date;
        }   
        monthSlt.setValue(month);
        yearSlt.setValue(year);
        UI_CALENDAR_MONTHVIEW_FLUSH(this, notDay ? null : date ? date.getDate() : null);
    };

    UI_CALENDAR_LAYER_CLASS.getDate = function () {
        var cal = this._uMonthView;
        return new Date(cal.getYear(), cal.getMonth() - 1);
    };

    UI_CALENDAR_LAYER_CLASS.$cache = function (style, cacheSize) {
        this._uPrvBtn.cache(true, true);
        this._uNxtBtn.cache(true, true);
        this._uMonthSlt.cache(true, true);
        this._uYearSlt.cache(true, true);
        this._uMonthView.cache(true, true);
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);
    };

    UI_CALENDAR_LAYER_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uMonthSlt.init();
        this._uYearSlt.init();
        this._uMonthView.init();
    };

    UI_CALENDAR_LAYER_CLASS.ondateclick = function (event, date) {
        var par = this.getParent();
        if ((!par.getDate || par.getDate().getTime() != date.getTime()) 
            && triggerEvent(par, 'change', null, [date])
        ) {
            par.setDate(date);
        }
        this.hide();
    };

    UI_CALENDAR_LAYER_SELECT_CLASS.onchange = function () {
        var layer = this.getParent();
        UI_CALENDAR_MONTHVIEW_FLUSH(layer);
        triggerEvent(layer, 'viewchange', null, [layer.getDate().getFullYear(), layer.getDate().getMonth() + 1]);
    };

    UI_CALENDAR_LAYER_BUTTON_CLASS.$click = function () {
        var step = this._nStep,
            layer = this.getParent(),
            date = layer.getDate(),
            ndate;
        ndate = new Date(date.getFullYear(), date.getMonth() + step, 1);
        layer.setDate(ndate, true);
        triggerEvent(layer, 'viewchange', null, [ndate.getFullYear(), ndate.getMonth() + 1]);
    };

    UI_CALENDAR_LAYER_MONTHVIEW_CLASS.ondateclick = function (event, date) {
        triggerEvent(this.getParent(), 'dateclick', event, [date]);
    };


/**
 * 双日历
 */
    var UI_MULTI_CALENDAR = ui.MultiCalendar = 
        inheritsControl(
            UI_CALENDAR,
            'ui-multi-calendar',
            function (el, options) {
                options.hidden = true;
            },
            function (el, options) {
                var o = createDom(), els;

                o.innerHTML = '<input type="hidden" name="'+ (options.beginname ? options.beginname : 'beginDate') +'" />'
                    + '<input type="hidden" name="'+ (options.endname ? options.endname : 'endDate') +'" />';
                
                if (options.bdate) {
                    els = options.bdate.split('-');
                    this._oBegin = new Date (els[0], parseInt(els[1], 10) - 1, els[2]);
                }
                if (options.edate) {
                    els = options.edate.split('-');
                    this._oEnd = new Date (els[0], parseInt(els[1], 10) - 1, els[2]);
                }
                els = children(o);    
                this._eBeginInput = els[0];
                this._eEndInput = els[1];

                moveElements(o, el, true);
            }
        ),

        UI_MULTI_CALENDAR_CLASS = UI_MULTI_CALENDAR.prototype,

        UI_MULTI_CALENDAR_LAY = UI_MULTI_CALENDAR_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-multi-calendar-layer',
            null,
            function (el, options) {
                var type = this.getTypes()[0],
                    html = [], range = options.range || {};

                html.push('<div class="'+ type +'-cal-area"><div class="'+ type +'-text"><strong>起始时间：</strong><span></span></div><div class="'+ UI_CALENDAR_LAYER.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-cal-area"><div class="'+ type +'-text"><strong>结束时间：</strong><span></span></div><div class="'+ UI_CALENDAR_LAYER.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-buttons"><div class="ui-button-g'+ UI_BUTTON.TYPES +'">确定</div><div class="'+ UI_BUTTON.TYPES +'">取消</div></div>');

                el.innerHTML = html.join('');
                el = children(el);

                this._eBeginText = el[0].firstChild.lastChild;
                this._eEndText = el[1].firstChild.lastChild;
                this._uBeginCal = $fastCreate(this.Cal, el[0].lastChild, this, {range: range});
                this._uBeginCal._sType = 'begin';
                this._uEndCal = $fastCreate(this.Cal, el[1].lastChild, this, {range: range});
                this._uEndCal._sType = 'end';
                this._uSubmitBtn = $fastCreate(this.Button, el[2].firstChild, this);
                this._uSubmitBtn._sType = 'submit';
                this._uCancelBtn = $fastCreate(this.Button, el[2].lastChild, this);
                this._uCancelBtn._sType = 'cancel';
            }
        ),

        UI_MULTI_CALENDAR_LAY_CLASS = UI_MULTI_CALENDAR_LAY.prototype;

        UI_MULTI_CALENDAR_LAY_CAL_CLASS = (UI_MULTI_CALENDAR_LAY_CLASS.Cal = inheritsControl(UI_CALENDAR_LAYER)).prototype,

        UI_MULTI_CALENDAR_LAY_BUTTON_CLASS = (UI_MULTI_CALENDAR_LAY_CLASS.Button = inheritsControl(UI_BUTTON)).prototype,
        UI_MULTI_CALENDAR_STR_DEFAULT = '<span class="ui-multi-calendar-default">请选择时间范围</span>';
    
    function UI_MULTI_CALENDAR_TEXT_FLUSH(con) {
        var el = con._eText;
        if (el.innerHTML == '') {
            con._uCancel.hide();
            if (con._bTip) {
                el.innerHTML = UI_MULTI_CALENDAR_STR_DEFAULT;
            }
        }
        else {
            con._uCancel.show();
        }
    };

    UI_MULTI_CALENDAR_CLASS.init = function () {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this.setDate({begin: this._oBegin, end: this._oEnd});
        this._uLayer.init();
    };

    UI_MULTI_CALENDAR_CLASS.setDate = function (date) {
        var str = [], beginTxt, endTxt;

        if (date == null) {
            date = {begin: null, end: null};
        }

        beginTxt = date.begin ? formatDate(date.begin, UI_CALENDAR_STR_PATTERN) : '';
        endTxt = date.end ? formatDate(date.end, UI_CALENDAR_STR_PATTERN) : '';

        this._oBegin = date.begin;    
        this._oEnd = date.end;
        this._eBeginInput.value = beginTxt;
        this._eEndInput.value = endTxt;
        if (this._oBegin) {
            str.push(beginTxt);
        }
        if (this._oEnd) {
            str.push(endTxt);
        }
        if (str.length == 1) {
            str.push(this._oEnd ? '之前' : '之后');
            str = str.join('');
        }
        else if (str.length == 2) {
            str = str.join('至');
        }
        else {
            str = '';
        }
        this._eText.innerHTML = str;
        UI_MULTI_CALENDAR_TEXT_FLUSH(this);
    };

    UI_MULTI_CALENDAR_CLASS.getDate = function () {
        return {begin: this._oBegin, end: this._oEnd};
    };

    UI_MULTI_CALENDAR_LAY_CLASS.setDate = function (date) {
        this._oBeginDate = date.begin;
        this._oEndDate = date.end;

        if (date.begin) {
            this._eBeginText.innerHTML = formatDate(date.begin, UI_CALENDAR_STR_PATTERN);
        }
        else {
            this._eBeginText.innerHTML = '';
        }

        if (date.end) {
            this._eEndText.innerHTML = formatDate(date.end, UI_CALENDAR_STR_PATTERN);
        }
        else {
            this._eEndText.innerHTML = '';
        }

        this._uBeginCal.setDate(date.begin);
        this._uBeginCal.setRange(undefined, date.end);
        this._uEndCal.setDate(date.end);
        this._uEndCal.setRange(date.begin);
    };

    UI_MULTI_CALENDAR_LAY_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
        this.hide();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uBeginCal.init();
        this._uEndCal.init();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.ondateset = function () {
        var par = this.getParent(),
            beginDate = this._oBeginDate,
            endDate = this._oEndDate;

        if (triggerEvent(par, 'dateset', [beginDate, endDate])) {
            par.setDate({begin: beginDate, end: endDate});
        }
        this.hide();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.$setDate = function (date, type) {
        var key = type.charAt(0).toUpperCase() 
                + type.substring(1);

        this['_e' + key + 'Text'].innerHTML = formatDate(date, UI_CALENDAR_STR_PATTERN);
        this['_o' + key + 'Date'] = date;
        if (type == 'begin') {
            this._uEndCal.setRange(date);
        }
        else {
            this._uBeginCal.setRange(undefined, date);
        }
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.ondateclick = function (event, date) {
        var par = this.getParent();

        this._oDateSel = date;
        par.$setDate(date, this._sType);
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.setRange = function (begin, end) {
        this._uMonthView.setRange(begin, end);
    };

    UI_MULTI_CALENDAR_LAY_BUTTON_CLASS.$click = function () {
        var par = this.getParent();
        UI_BUTTON_CLASS.$click.call(this);
        if (this._sType == 'submit') {
            triggerEvent(par, 'dateset');
        }
        else {
            par.hide();
        }
    }

})();

/**
 * ecui.ui.IstCalendar
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    IST风格的日历
 *          （支持单日历时间段选择，周月季选择）
 * @author:  sushuang(sushuang@baidu.com) 
 *          (
 *              从Pulse版本的ecui中拷贝而来
 *              (pl-calendar.js by cxl(chenxinle@baidu.com))，
 *              并稍做修改
 *          )
 * @depend:  ecui
 */

(function() {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;

    var DATE = Date;
    var REGEXP = RegExp;
    var DOCUMENT = document;

    var children = dom.children;
    var createDom = dom.create;
    var getParent = dom.getParent;
    var getPosition = dom.getPosition;
    var moveElements = dom.moveElements;
    var setText = dom.setText;
    var addClass = dom.addClass;
    var formatDate = string.formatDate;
    var getByteLength = string.getByteLength;
    var encodeHTML = string.encodeHTML;
    var sliceByte = string.sliceByte;
    var indexOf = array.indexOf;
    var getView = util.getView;
    var blank = util.blank;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var setFocused = core.setFocused;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_INPUT_CONTROL = ui.InputControl;
    var UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
    var UI_PANEL = ui.Panel;
    var UI_PANEL_CLASS = UI_PANEL.prototype;
    var UI_CALENDAR_CLASS = ui.Calendar.prototype;
    var UI_CALENDAR_LAYER_CLASS = UI_CALENDAR_CLASS.Layer.prototype;
    var UI_CALENDAR_LAYER_SELECT_CLASS = UI_CALENDAR_LAYER_CLASS.Select.prototype;
    var UI_BUTTON = ui.Button;
    var UI_MONTH_VIEW_CLASS = ui.MonthView.prototype;

    //-------------------------------------------------
    // 类型声明
    //-------------------------------------------------

    /**
     * 日历控件类
     *
     * @class
     * @param {Object} options 初始化选项
     * @param {string} options.start 范围开始点
     * @param {end} options.end 范围结束点
     * @param {string} optoins.date 初始时间，格式：2012-12-12
     * @param {string} options.dateEnd 如果是RANGE模式，表示最后时间，格式：2012-12-12
     * @param {number} optoins.now 当前时间戳（用于传来系统时间）
     * @param {string} options.mode 模式，
     *      可选值为：'DAY'(默认), 'WEEK', 'RANGE'
     * @param {string} options.viewMode 显示模式，
     *      可选值为：'POP'(默认), 'FIX' 
     * @param {boolean} options.shiftBtnDisabled 是否禁用前后移动button，默认false
     */
    var UI_IST_CALENDAR = ui.IstCalendar =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-calendar',
            function(el, options) {
                options.hidden = true;
            },
            function(el, options) {
                var o = createDom();
                var child;
                var date;
                var type = this.getTypes()[0];

                this._sMode = options.mode || 'DAY';
                if (this._sMode == 'WEEK' || this._sMode == 'RANGE') {
                    addClass(el, type + '-range-mode');
                }

                this._sViewMode = options.viewMode || 'POP';
                if (this._sViewMode == 'FIX') {
                    addClass(el, type + '-fix-view');
                }

                o.innerHTML = [
                    '<span class="'+ type +'-btn-prv '+ type +'-btn"></span>',
                    '<span class="'+ type +'-text"></span>',
                    '<span class="'+ type +'-btn-nxt '+ type +'-btn"></span>',
                    '<span class="'+ type +'-btn-cal '+ type +'-btn"></span>',
                    '<div class="'+ type +'-layer" style="position:absolute;display:none"></div>'
                ].join('');

                child = children(o);

                this._oDate = PARSE_INPUT_DATE(options.date);
                if (this._sMode == 'RANGE') {
                    this._oDateEnd = PARSE_INPUT_DATE(options.dateEnd);
                }

                this._oRange = UI_CALENDAR_PARSE_RANGE(
                    options.start, 
                    options.end,
                    options.now
                );

                this._eText = child[1];
                
                // 后退一天按钮
                if (options.shiftBtnDisabled) {
                    child[0].style.display = 'none';
                }
                this._uBtnPrv = $fastCreate(
                    this.Button, 
                    child[0], 
                    this, 
                    { command: 'prv', icon: true }
                );

                // 前进一天按钮
                if (options.shiftBtnDisabled) {
                    child[2].style.display = 'none';
                }
                this._uBtnNxt = $fastCreate(
                    this.Button, 
                    child[2], 
                    this, 
                    { command: 'nxt', icon: true }
                );

                // 小日历按钮
                if (this._sViewMode == 'FIX') {
                    // FIX模式下不显示
                    child[3].style.display = 'none'; 
                }
                this._uBtnCal = $fastCreate(
                    this.Button, 
                    child[3], 
                    this, 
                    { command: 'cal', icon: true }
                );

                if (this._sViewMode == 'POP') {
                    DOCUMENT.body.appendChild(child[4]);
                }

                this._uLayer = $fastCreate(
                    this.Layer, 
                    child[4], 
                    this, 
                    {
                        date: this._oDate, 
                        range: this._oRange,
                        mode: this._sMode
                    }
                );

                moveElements(o, el, true);

                if (this._sViewMode == 'FIX') {
                    this.$showLayer();
                }
            }
        );

    var UI_IST_CALENDAR_CLASS = UI_IST_CALENDAR.prototype;

    var UI_IST_CALENDAR_BUTTON_CLASS = (
            UI_IST_CALENDAR_CLASS.Button = inheritsControl(
                UI_BUTTON, 
                null, 
                function(el, options){
                    var o = createDom();
                    var type = this.getType();
                
                    moveElements(el, o, true);
                    el.innerHTML = '<span class="'+ type +'-inner"></span>';
                    moveElements(o, el.firstChild, true);

                    if (options.icon) {
                        o = createDom(type + '-icon', '',  'span');
                        el.appendChild(o);
                    }

                    this._sCommand = options.command;
                }
            )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_CLASS = (
            UI_IST_CALENDAR_CLASS.Layer = 
                inheritsControl(UI_CALENDAR_CLASS.Layer)
        ).prototype;

    var UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS = (
            UI_IST_CALENDAR_LAYER_CLASS.MonthView = 
                inheritsControl(
                    UI_CALENDAR_CLASS.Layer.prototype.MonthView,
                    null,
                    function(el, options) {
                        this._sMode = options.mode;
                        this._oCellSelSet = {};
                        this._oCellHoverSet = {};
                    }
                )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS = (
            UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.Cell = inheritsControl(
                UI_CALENDAR_CLASS.Layer.prototype.MonthView.prototype.Cell
            )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_SELECT_OPTIONS_CLASS = (
            UI_CALENDAR_LAYER_SELECT_CLASS.Options = inheritsControl(
                UI_CALENDAR_LAYER_SELECT_CLASS.Options, 
                null, 
                null, 
                function(el, options) { 
                    addClass(el, 'ui-calendar-select-options'); 
                }
            )
        ).prototype;

    //-------------------------------------------------
    // 常量
    //-------------------------------------------------

    var UI_IST_CALENDAR_STR_PATTERN = 'yyyy-MM-dd';
    var UI_IST_CALENDAR_STR_PATTERN_SHOW = 'yyyy-MM-dd';

    var TIME_TYPE_WEEK = 1;
    var TIME_TYPE_MONTH = 2;
    var TIME_TYPE_QUARTER = 3;
    var DAY_MILLISECOND = 24*60*60*1000;
    var DATE_ZERO = new Date(0);

    //-------------------------------------------------
    // 工具方法
    //-------------------------------------------------
        
    function UI_CALENDAR_PARSE_RANGE(begin, end, now) {
        now = now != null ? new Date(now) : new Date();
        var res = {};
        var o = [now.getFullYear(), now.getMonth(), now.getDate()];
        var t;
        var p = {y:0, M:1, d:2};

        if (/^([-+]?)(\d+)([yMd])$/.test(begin)) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.begin = new Date(t[0], t[1], t[2]);
        }
        else if (
            Object.prototype.toString.call(begin) in {
                '[object String]': 1, '[object Date]': 1
            }
        ) {
            res.begin = new Date(begin);
        }

        if (/^([-+]?)(\d+)([yMd])$/.test(end)) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.end = new Date(t[0], t[1], t[2]);
        }
        else if (
            Object.prototype.toString.call(end) in {
                '[object String]': 1, '[object Date]': 1
            }
        ) {
            res.end = new Date(end);
        }

        return res ? res : {};
    }
    
    function UI_CALENDAR_WEEK_INFO(date) {
        var weekDay = date.getDay();
        var pre = -((weekDay + 6) % 7), next = (7 - weekDay) % 7;
        return {
            monday: new Date(date.getTime() + pre * DAY_MILLISECOND), 
            sunday: new Date(date.getTime() + next * DAY_MILLISECOND)
        };
    }

    function COMPARE_DATE(year1, month1, date1, year2, month2, date2) {
        if (year1 == year2) {
            if (month1 == month2) {
                if (date1 == date2) {
                    return 0;
                }
                else {
                    return date1 > date2 ? 1 : -1;
                }
            }
            else {
                return month1 > month2 ? 1 : -1;
            }
        }
        else {
            return year1 > year2 ? 1 : -1;
        }
    }

    function COMPARE_DATE_OBJ(date1, date2) {
        return COMPARE_DATE(
            date1.getFullYear(), date1.getMonth(), date1.getDate(),
            date2.getFullYear(), date2.getMonth(), date2.getDate()
        );        
    }

    function PARSE_INPUT_DATE(input) {
        var ret;
        if (input === false) {
            ret = null
        }
        else if (Object.prototype.toString.call(input) == '[object Date]') {
            ret = input;
        }
        else if (Object.prototype.toString.call(input) == '[object String]') {
            ret = input.split('-');
            ret = new Date(
                ret[0], 
                parseInt(ret[1], 10) - 1, 
                ret[2]
            );
        }
        return ret;
    }

    //----------------------------------------------
    // UI_IST_CALENDAR_BUTTON_CLASS 的方法
    //----------------------------------------------

    UI_IST_CALENDAR_BUTTON_CLASS.$click = function(event) {
        var par = this.getParent();
        switch(this._sCommand) {
            case 'prv':
                par.go(-1, -1);
                break;
            case 'nxt':
                par.go(1, 1);
                break;
            case 'cal':
                par.$showLayer();
                break;
        }
        event.exit();
    };

    //----------------------------------------------
    // UI_IST_CALENDAR_CLASS 的方法
    //----------------------------------------------

    UI_IST_CALENDAR_CLASS.$setSize = new Function();

    UI_IST_CALENDAR_CLASS.$showLayer = function() {
        var layer = this._uLayer;
        var pos = getPosition(this.getOuter());
        var posTop = pos.top + this.getHeight();

        if (!layer.isShow()) {

            layer.setDate(this.getDate());
            layer.show();
            setFocused(layer);

            if (this._sViewMode == 'POP') {
                var height = layer.getHeight();
                layer.setPosition(
                    pos.left,
                    posTop + height <= getView().bottom 
                        ? posTop : pos.top - height
                );
            }
        }
    }

    UI_IST_CALENDAR_CLASS.getMode = function() {
        return this._sMode;
    }    

    UI_IST_CALENDAR_CLASS.$flush = function() {
        var curDate = this._oDate;
        var range = this._oRange;

        if (range.begin && range.begin.getTime() == curDate.getTime()) {
            this._uBtnPrv.disable();
        }
        else {
            this._uBtnPrv.enable();
        }
        
        if (range.end && range.end.getTime() == curDate.getTime()) {
            this._uBtnNxt.disable();
        }
        else {
            this._uBtnNxt.enable();
        }
    }

    UI_IST_CALENDAR_CLASS.$click = function(event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this);
        if (event.target == this._eText) {
            this.$showLayer();
        }
    };

    UI_IST_CALENDAR_CLASS.$activate = function (event) {
        var layer = this._uLayer;
        var con;
        var pos = getPosition(this.getOuter());
        var posTop = pos.top + this.getHeight();

        UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
        if (!layer.isShow()) {
            layer.setDate(this.getDate(), this.getDateEnd(), null, true);
            layer.show();
            con = layer.getHeight();
            layer.setPosition(
                pos.left,
                posTop + con <= getView().bottom ? posTop : pos.top - con
            );
            setFocused(layer);
        }
    };

    UI_IST_CALENDAR_CLASS.go = function(offset, offsetEnd) {
        var newDate = new Date(
                this._oDate.getFullYear(), 
                this._oDate.getMonth(), 
                this._oDate.getDate() + offset
            );

        var newDateEnd;
        if (this._sMode == 'RANGE') {
            newDateEnd = new Date(
                this._oDateEnd.getFullYear(), 
                this._oDateEnd.getMonth(), 
                this._oDateEnd.getDate() + offsetEnd
            );
        }

        this.setDate(newDate, newDateEnd, null, true);
        triggerEvent(this, 'change', null, [newDate, newDateEnd]);
    };

    UI_IST_CALENDAR_CLASS.getDate = function() {
        return this._oDate;
    };
    
    UI_IST_CALENDAR_CLASS.getDateEnd = function() {
        return this._oDateEnd;
    };
    
    UI_IST_CALENDAR_CLASS.getWeekInfo = function() {
        return UI_CALENDAR_WEEK_INFO(this._oDate);
    };

    UI_IST_CALENDAR_CLASS.setDate = function(
        date, dateEnd, remainLayer, remainRangeSelStatus
    ) {
        var layer = this._uLayer;
        var range = this._oRange;
        var ntxt; 
        var weekInfo;

        if ((range.begin && range.begin.getTime() > date.getTime()) 
            || (range.end && range.end.getTime() < date.getTime())
        ) {
            return;
        }

        if (this._sViewMode == 'POP' && this._uLayer.isShow() && !remainLayer) {
            this._uLayer.hide();
        }
        
        if (date != null) {
            // 周模式
            if (this._sMode == 'WEEK') {
                weekInfo = UI_CALENDAR_WEEK_INFO(date);
                ntxt = formatDate(
                        maxDate(weekInfo.monday, range.begin), 
                        UI_IST_CALENDAR_STR_PATTERN_SHOW
                    )
                    + ' 至 ' 
                    + formatDate(
                        minDate(weekInfo.sunday, range.end), 
                        UI_IST_CALENDAR_STR_PATTERN_SHOW
                    );
            } 
            // 范围模式
            else if (this._sMode == 'RANGE') {
                if (!remainRangeSelStatus || !this._sRangeSelStatus) {
                    this._sRangeSelStatus = 'END';
                }
                ntxt = formatDate(date, UI_IST_CALENDAR_STR_PATTERN_SHOW);
                if (dateEnd) {
                    ntxt += ' 至 ' + formatDate(dateEnd, UI_IST_CALENDAR_STR_PATTERN_SHOW);
                }
                else {
                    if (this._sViewMode == 'POP') {
                        // 为了小日历按钮对齐而做的fake
                        ntxt += [
                            '<span class="', this.getType(), '-fake-text">',
                            ' 至 ' + formatDate(DATE_ZERO, UI_IST_CALENDAR_STR_PATTERN_SHOW),
                            '</span>',
                        ].join('');
                    }
                }
            }
            // 天模式
            else {
                ntxt = formatDate(date, UI_IST_CALENDAR_STR_PATTERN_SHOW);
            }
        } else {
            ntxt = '';
        }

        this._eText.innerHTML = ntxt;
        this.setValue(ntxt.replace(/\//g, '-'));

        this._oDate = date;
        if (this._sMode == 'RANGE') {
            this._oDateEnd = dateEnd;
        }

        if (this._sViewMode == 'FIX') {
            this._uLayer.setDate(date);
        }

        this.$flush();
    };

    UI_IST_CALENDAR_CLASS.init = function() {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this._uLayer.init();
        this.setDate(this.getDate(), this.getDateEnd());
    };

    UI_IST_CALENDAR_CLASS.$cache = function(style, cacheSize) {
        UI_INPUT_CONTROL_CLASS.$cache.call(this, style, cacheSize);
        this._uLayer.cache(true, true);
    };

    UI_IST_CALENDAR_CLASS.setRange = function(begin, end) {
        var cal = this._uLayer._uMonthView;
        cal.setRange(begin, end, true);
    };

    function minDate(date1, date2) {
        if (!date2) { return date1; }
        if (!date1) { return date2; }
        return date1.getTime() > date2.getTime() ? date2 : date1;
    }

    function maxDate(date1, date2) {
        if (!date2) { return date1; }
        if (!date1) { return date2; }
        return date1.getTime() > date2.getTime() ? date1 : date2;        
    }
    
    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_CLASS 的方法
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_CLASS.ondateclick = function(event, date) {
        var par = this.getParent();

        // 非RANGE模式
        if (this._sMode != 'RANGE' 
            && (!par.getDate() 
                || par.getDate().getTime() != date.getTime()
            )
        ) {
            par.setDate(date, null, null, true);
            /**
             * @event
             * @param {Date} selected date
             */
            triggerEvent(par, 'change', null, [date])
        }

        // RANGE模式
        else if (this._sMode == 'RANGE') {
            this._oDateSel = null;
            if (par._sRangeSelStatus == 'BEGIN') {
                par._sRangeSelStatus = 'END';
                var start = par.getDate();
                var end = date;
                if (start && end && COMPARE_DATE_OBJ(start, end) > 0) {
                    var tmp = end;
                    end = start;
                    start = tmp;
                }
                par.setDate(start, end, false, true);
            }
            else {
                par._sRangeSelStatus = 'BEGIN';
                // 设值后不隐藏layer
                par.setDate(date, null, true, true);
            }

            /**
             * @event
             * @param {string} ragneSelStatus 取值为'BEGIN'或'END'
             * @param {Date} begin date
             * @param {Date} end date
             */
            triggerEvent(
                par,
                'change', 
                null, 
                par._sRangeSelStatus == 'BEGIN' 
                    ? ['BEGIN', par.getDate(), date] : ['END', date]
            )
        }

        // 其他
        else {
            this.hide();
        }
    };    

    UI_IST_CALENDAR_LAYER_CLASS.hide = function() {
        if (this.getParent()._sViewMode == 'FIX') {
            return;
        }

        if (this.isShow()) {
            var calCon = this.getParent();
            calCon && triggerEvent(calCon, 'layerhide');
        }
        UI_IST_CALENDAR_CLASS.Layer.superClass.hide.apply(this, arguments);
    };

    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS 的方法
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$setSelected = function(cell) {

        function removeStyle(c) { c.alterClass('-selected'); }
        function addStyle(c) { c.alterClass('+selected'); }
        var me = this;

        if (this._uCellSel) {
            // select一星期
            if (this._sMode == 'WEEK') {
                this.$travelWeek(this._uCellSel, removeStyle);
            }
            // select一天
            else if (this._sMode == 'DAY') {
                removeStyle(this._uCellSel);
            }
        }

        if (cell) {
            // select一星期
            if (this._sMode == 'WEEK') {
                this.$travelWeek(cell, addStyle);
            }
            // select一天
            else if (this._sMode == 'DAY') {
                addStyle(cell);
            }
            this._uCellSel = cell;
        }

        // select一个范围
        if (this._sMode == 'RANGE') {
            var calCon = this.getParent() 
                    ? this.getParent().getParent() : null;

            // 范围选完一半时
            if (calCon && calCon._sRangeSelStatus == 'BEGIN') {
                for (var i in this._oCellSelSet) {
                    removeStyle(this._oCellSelSet[i]);
                    delete this._oCellSelSet[i];
                }
                var cellWrap = this.$getCellByDate(calCon.getDate());
                if (cellWrap) {
                    this._oCellSelSet[cellWrap.index] = cellWrap.cell;
                    addStyle(cellWrap.cell);
                }
            }
            // 范围选完时
            else if (calCon && calCon._sRangeSelStatus == 'END') {
                this.$travelMonth(
                    function(c, i, isThisMonth) {

                        var isInRange;
                        if (isThisMonth) {
                            isInRange = me.$isCellInRange(
                                c, calCon.getDate(), calCon.getDateEnd()
                            );
                        }

                        if (isThisMonth 
                            && isInRange 
                            && !(i in me._oCellSelSet)
                        ) {
                            me._oCellSelSet[i] = c;
                            addStyle(c);
                        }
                        else if (
                            (!isInRange || !isThisMonth) 
                            && (i in me._oCellSelSet)
                        ) {
                            delete me._oCellSelSet[i];
                            removeStyle(c);
                        }
                    }
                );
            }
            // 其他情况
            else {
                for (var i in this._oCellSelSet) {
                    delete this._oCellSelSet[i];
                    removeStyle(this._oCellSelSet[i]);
                }
            }
        }
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$setHovered = function(
        cell, hovered
    ) {
        function addStyle(c) { c.alterClass('+hover'); }
        function removeStyle(c) { c.alterClass('-hover'); }
        var cellIndex = indexOf(this._aCells, cell);
        var me = this;

        if (cell) {
            // hover一星期
            if (this._sMode == 'WEEK') {
                this.$travelWeek(cell, (hovered ? addStyle : removeStyle));
            }

            // hover一天
            else if (this._sMode == 'DAY') {
                hovered ? addStyle(cell) : removeStyle(cell);
            }

            // hover一个范围
            else if (this._sMode == 'RANGE') {
                var calCon = this.getParent().getParent();
                var start = calCon.getDate();
                var end = new Date(this._nYear, this._nMonth, cell._nDay);
                if (start && end && COMPARE_DATE_OBJ(start, end) > 0) {
                    var tmp = end;
                    end = start;
                    start = tmp;
                }

                // 范围选完一半时
                if (calCon._sRangeSelStatus == 'BEGIN') {
                    this.$travelMonth(
                        function(c, i, isThisMonth) {
                            var isInRange;
                            if (isThisMonth) {
                                isInRange = me.$isCellInRange(c, start, end);
                            }
                            if (hovered
                                && isThisMonth 
                                && isInRange 
                                && !(i in me._oCellHoverSet)
                            ) {
                                me._oCellHoverSet[i] = c;
                                addStyle(c);
                            }
                            else if (
                                (!hovered || !isThisMonth || !isInRange)
                                && (i in me._oCellHoverSet)
                            ) {
                                delete me._oCellHoverSet[i];
                                removeStyle(c);
                            }
                        }
                    );
                }
                // 其他情况
                else {
                    this.$travelMonth(
                        function(c, i, isThisMonth) {
                            if ((!hovered || !isThisMonth)
                                && (i in me._oCellHoverSet)
                            ) {
                                delete me._oCellHoverSet[i];
                                removeStyle(c);
                            }
                        }
                    );
                    if (hovered) {
                        this._oCellHoverSet[cellIndex] = cell;
                        addStyle(cell);
                    }
                }
            }

        }
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$travelWeek = function(
        cell, callback
    ) {
        if (cell) {
            var currDate = new DATE(this._nYear, this._nMonth, cell._nDay);
            var index = indexOf(this._aCells, cell);
            index -= ((currDate.getDay() + 6) % 7);
            for (var i = 0; i < 7; i++) {
                callback.call(this, this._aCells[index + i]);    
            } 
        }  
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$travelMonth = function(callback) {
        var lastDateOfThisMonth = 
                new Date(this._nYear, this._nMonth + 1, 0).getDate();
        for (var i = 7, cell, isThisMonth; cell = this._aCells[i]; i ++) {
            isThisMonth = cell._nDay > 0 && cell._nDay <= lastDateOfThisMonth;
            callback(cell, i, isThisMonth);
        }
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$getCellByDate = function(date) {
        if (!date 
            || this._nYear != date.getFullYear() 
            || this._nMonth != date.getMonth()
        ) {
            return null;
        }
        var day = date.getDate();
        for (var i = 0, cell; cell = this._aCells[i]; i ++) {
            if (cell._nDay == day) { 
                return {cell: cell, index: i};
            }
        }
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$isCellInRange = function(
        cell, beginDate, endDate
    ) {
        if (!cell || !beginDate || !endDate) {
            return false;
        }

        var beginY = beginDate && beginDate.getFullYear();
        var beginM = beginDate && beginDate.getMonth();
        var beginD = beginDate && beginDate.getDate();
        var endY = endDate && endDate.getFullYear(); 
        var endM = endDate && endDate.getMonth();
        var endD = endDate && endDate.getDate();

        if ((   
                COMPARE_DATE(
                    beginY, beginM, beginD,
                    this._nYear, this._nMonth, cell._nDay
                ) <= 0
            )
            && (
                COMPARE_DATE(
                    this._nYear, this._nMonth, cell._nDay,
                    endY, endM, endD
                ) <= 0
            )
        ) {
            return true;
        }

        return false; 
    };
    
    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS 的方法
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS.$mouseover = function() {
        var parent = this.getParent();
        var index = indexOf(parent._aCells, this);
        // 非本月的cell已经被disabled，不会触发mouseover事件
        (index >= 7) && parent.$setHovered(this, true);  
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS.$mouseout = function() {
        var parent = this.getParent();
        var index = indexOf(parent._aCells, this);
        // 非本月的cell已经被disabled，不会触发mouseout事件
        (index >= 7) && parent.$setHovered(this, false);   
    };

    UI_CALENDAR_LAYER_SELECT_CLASS.$mousewheel = blank;

})();


/**
 * @author quyatong
 */

(function() {
    var core = ecui,
        ui = core.ui,
        dom = core.dom,
        string = core.string,
        util = core.util,
        disposeControl = core.dispose,
        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        findControl = core.findControl,
        first = dom.first,
        last = dom.last,
        children = dom.children,
        createDom = dom.create,
        removeDom = dom.remove,
        addClass = dom.addClass,
        removeClass = dom.removeClass,
        setText = dom.setText,
        moveElements = dom.moveElements,
        blank = util.blank,
        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_INPUT = ui.InputControl, //.Input,
        UI_INPUT_CLASS = UI_INPUT.prototype,
        UI_SELECT = ui.Select,

        attachEvent = util.attachEvent,
        detachEvent = util.detachEvent,
        repaint = core.repaint,
        WINDOW = window,
        UI_IST_CALENDAR = ui.IstCalendar;

    var UI_CALENDAR_PLUS = ui.CalendarPlus = inheritsControl(UI_CONTROL, "ui-calendar-plus", preProcess, process);

    var UI_CALENDAR_PLUS_CLASS = UI_CALENDAR_PLUS.prototype;

    UI_CALENDAR_PLUS_CLASS.Button = inheritsControl(
        UI_BUTTON, 
        null, 
        function(el, options) {
            var o = createDom();
            var type = this.getType();
        
            moveElements(el, o, true);
            el.innerHTML = '<span class="'+ type +'-inner"></span>';
            moveElements(o, el.firstChild, true);

            o = createDom(type + '-icon', '',  'span');
            el.appendChild(o);
        }
    );

    UI_CALENDAR_PLUS_CLASS.$setSize = new Function();
    
    UI_CALENDAR_PLUS_CLASS.setData = function (options) {
        var el = this.getOuter();
        this.$disposeInner();
        el.innerHTML = '';
        this.$setBody(el);

        preProcess.call(this, el, options);
        process.call(this, el, options);
    };

    UI_CALENDAR_PLUS_CLASS.$disposeInner = function (options) {
        // 耿朋啊，我还是很需要整体setDate功能的。
        // 写的较粗，不知会不会有问题。
        for (var key in this) {
            if (this.hasOwnProperty(key) 
                && key.indexOf('_u') >= 0
                && this[key] instanceof UI_CONTROL
            ) {
                disposeControl(this[key]);
                this[key] = null;
            }
        }
    };

    /**
     * 构造函数之前的预处理
     * @param {EcuiElement} ecui元素
     * @param {Ojbect} options 这个对象的东西比较多是传入的ecui的参数
     *
     */
     function preProcess(el, options) {
        var uiType = this.getType(); 
        setDefaultOptions(options);
        var types = options.types;
        var tagNames = options.tagNames;
        var list = [];
        var listBox = [];
        for (var i = 0, item; item = types[i]; i++) {
            if (item == 'D') {
               list.push('<option value="day">' + tagNames[i] + '</option>' );
            } 
            if (item == 'W') {
               list.push('<option value="week">'  + tagNames[i] +  '</option>' );
            } 
            if (item == 'M') {
               list.push('<option value="month">'   + tagNames[i] + '</option>' );
            }
            if (item == 'Q') {
               list.push('<option value="quarter">'  + tagNames[i] + '</option>' );
            }
        }

        listBox.push('<div style="display:none" class="time-box-day"><div data-id="day-calendar" class="ui-calendar"></div></div>');
        listBox.push('<div style="display:none" class="time-box-week"><div data-id="week-calendar" class="ui-calendar"></div></div>');
        listBox.push('<div style="display:none" class="time-box-month"><div class="ui-select"></div><div class="ui-select ml10"></div></div>');
        listBox.push('<div style="display:none" class="time-box-quarter"><div class="ui-select"></div><div class="ui-select ml10"></div></div>');
        var opts = list.join(''); 
        var boxs = listBox.join('');
        var htmls = [];
        //条件选择 默认是全部显示
        htmls.push('   <div class="' + uiType + '-box">' 
                    +     '<span class="' + uiType + '-label">时间粒度：</span>'
                    +     '<select class="' + UI_SELECT.TYPES + '">' 
                    +          opts 
                    +     '</select>'
                    + '</div>'
                  );

        var istCalType = UI_IST_CALENDAR.types[0];
        // htmls.push('<span class="' + uiType + '-btnpre" >&nbsp;&lt;&lt;</span>')
        htmls.push('<span class="'+ istCalType +'-btn-prv '+ istCalType +'-btn"></span>');

        htmls.push('  <div class="' + uiType + '-box">' 
                    +      boxs    
                    + '</div>'
                  );
      
        // htmls.push('<span class="' + uiType + '-btnnext">&nbsp;&gt;&gt;</span>')
        htmls.push('<span class="'+ istCalType +'-btn-nxt '+ istCalType +'-btn"></span>');

        el.innerHTML = htmls.join('');
        
    };

    /**
    * 这是ecui的构造函数
    * @param {EcuiElement} ecui元素
    * @param {Ojbect} options 这个对象的东西比较多是传入的ecui的参数
    */
    function process(el, options) {
        var parse = parseDate;
        var format = formatDate;
        setDefaultOptions(options);
        var me = this;
        me._oRange = options.range;
    
        me.typeList = {
            'day': null,
            'week': null,
            'month': null,
            'quarter': null 
        }
        //默认选中第一个 可以配置
        this._nSelectedType = this._getInnerType(options.types[0]);
        var childs = children(el);
        //条件查询
        var conBox = childs[0];
        var select = children(conBox)[1];

        //上一--按钮和 下一按钮
        // this._uBtnPre = childs[1];
        // this._uBtnNext = childs[3];
        this._uBtnPre = $fastCreate(this.Button, childs[1], this);        
        this._uBtnNext = $fastCreate(this.Button, childs[3], this);

        this._uConditionSelect = $fastCreate(UI_SELECT, select, this, {});
        this._uConditionSelect.$setSize(100, 20);

        //去掉滚轮的
        this._uConditionSelect.$mouseWheel = function() {};
        //注册change事件 可以调到后边
        this._uConditionSelect.$change = conditionChangeHandle(this); 
        
        //时间内容
        var timeWrap = childs[2];  
        var timeBoxs = children(timeWrap); 
        var dayBox = me.typeList['day'] = timeBoxs[0];
        var weekBox = me.typeList['week'] = timeBoxs[1]; 
        var monthBox = me.typeList['month'] = timeBoxs[2]; 
        var quarterBox = me.typeList['quarter'] = timeBoxs[3]; 
        //时间控件的创立，日粒度 
        if (hasType('D', options)) { 
            //创建日粒度的控件
            createDayControl(me, options, dayBox);
        }
        //周粒度的控件
        if (hasType('W', options)) {
            createWeekControl(me, options, weekBox);
        }
        //日粒度的相关的控件
        if (hasType('M', options)) {
            createMonthControl(me, options, monthBox);
        }
        //季度粒度的控件 
        if (hasType('Q', options)) {
            createQuarterControl(me, options, quarterBox);
        }
        this._uBtnPre.onclick = btnPreNextHandle('pre', this);
        this._uBtnNext.onclick = btnPreNextHandle('next', this);

        setTimeout(function() {
            var type = me._uConditionSelect.getValue();
            //显示默认类型
            me._showCalendarByType(type);
            //设置btn的状态
            //bug fix 初始化没有设置按钮状态
            me._setBtnStatus();
          //  core.triggerEvent(me._uConditionSelect, 'change', {}, null);
        }, 100); 
    };

    /**
    * 创建 月粒度的控件
    *
    * @param {EcuiElement} me 控件本身
    * @param {Object} options 构造函数的参数
    * @param {htmlElement} eleBox  包裹占位容器
    *
    */ 
    function createQuarterControl(me, options, eleBox) {

        var parse = parseDate; 
        //对于季度的处理
        var quarterControlYear = me._uQuarterSelectYear 
                               = $fastCreate(UI_SELECT, eleBox.firstChild, me, {});
        var quarterControlQuarter = me._uQuarterSelectQuarter  
                                  = $fastCreate(UI_SELECT, eleBox.lastChild, me, {});
        
        var quarterData = function() {
            var obj = {};
            var range = options.range.quarter;
            var start = parse(range.start, 'quarter');
            var end = parse(range.end, 'quarter');
            var startYear = start.getFullYear();
            var endYear = end.getFullYear();
            var startQ = range.start.split('-')[1];
            var endQ = range.end.split('-')[1];
            var result = [];

            //根据range生成年的数据
            for (var i = startYear; i <= endYear; i++) {
                result.push({ text: i + '', value: i });
            }
            var q = [
                { text: '第一季度', value: 'Q1' }, 
                { text: '第二季度', value: 'Q2' }, 
                { text: '第三季度', value: 'Q3' }, 
                { text: '第四季度', value: 'Q4' } 
            ];
            obj.year = result;
            obj.quarter = q;
            return obj;

        }();

        //季度条件
        quarterControlYear.$setSize(100, 20);
        quarterControlQuarter.$setSize(100, 20);
        setSelectData(quarterControlYear,quarterData.year);
        setSelectData(quarterControlQuarter, quarterData.quarter);
        var defaultDate = options.defaults.quarter;
        var  date =  parse(defaultDate, 'quarter');
        var _year = date.getFullYear();
        var _q = defaultDate.split('-')[1];  
        quarterControlYear.setValue(_year);
        quarterControlQuarter.setValue(_q);

        quarterControlYear.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
        quarterControlQuarter.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }

    };
    /**
    * 创建 月粒度的控件
    * @param {EcuiElement} me 控件本身
    * @param {Object} options 构造函数的参数
    * @param {htmlElement} eleBox  包裹占位容器
    */ 
    function createMonthControl(me, options, eleBox) {

        var parse = parseDate; 

        var monthControlYear = me._uMonthSelectYear 
        = $fastCreate(UI_SELECT, eleBox.firstChild, me, {});
        var monthControlMonth = me._uMonthSelectMonth 
        = $fastCreate(UI_SELECT, eleBox.lastChild, me, {});     

        //年数据的获取 和月的数据
        var monData = function(options) {
            var obj = {};
            var range = options.range.month;
            var start = parse(range.start, 'month');
            var end = parse(range.end, 'month');
            var startYear = start.getFullYear();
            var endYear = end.getFullYear();
            var startMonth = start.getMonth();
            var endMonth = end.getMonth();

            var result = [ ];
            var resultMon = [];
            var mon = [ '一', '二', '三', '四', '五', '六',
            '七', '八', '九', '十', '十一', '十二'
            ];

            //根据range生成年的数据
            for (var i = startYear; i <= endYear; i++) {
                result.push({ text: i + '', value: i });
            }

            //生成月的数据
            for (var i = 0, item; item = mon[i]; i ++) {
                resultMon.push({ text: item + '月' , value: i });
            }

            obj.year = result; 
            obj.month = resultMon; 
            return obj; 
        }(options);

        //月条件
        setSelectData(monthControlYear, monData.year);
        setSelectData(monthControlMonth, monData.month);
        var defaultDate = options.defaults.month;
        var  date =  parse(defaultDate, 'month');
        var _year = date.getFullYear();
        var _month = date.getMonth();
        //月控件控制大小
        monthControlYear.$setSize(100, 20);
        monthControlMonth.$setSize(100, 20);
        monthControlYear.setValue(_year);
        monthControlMonth.setValue(_month);

        monthControlYear.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
        monthControlMonth.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
    
    };
    /**
    * 创建 周粒度的控件
    * @param {EcuiElement} me 控件本身
    * @param {Object} options 构造函数的参数
    * @param {htmlElement} eleBox  包裹占位容器
    */
    function createWeekControl(me, options, eleBox) {
        var parse = parseDate; 
        //周控件
        var weekControl = me._uWeekCalendar
                        = $fastCreate(  UI_IST_CALENDAR, 
                                        eleBox.firstChild,
                                        me,
                                        { 
                                            mode:'WEEK', 
                                            viewMode:'POP',
                                            shiftBtnDisabled: true 
                                        }
                                    );
        var dft = parse( options.defaults.week, 'day' );
        var range = options.range.week;
        var start = parse( range.start, 'day');
        var end = parse( range.end, 'day');
        //开始时候哦周一
        //var startMonday = null;
        //结束时间的 周日
        var endMonday = getMonday(end);
        var endSunday =  new Date(endMonday.getFullYear(), endMonday.getMonth(), endMonday.getDate() + 6);
        var startMonday = getMonday(start);

        //bug fix: 修复设置week的range的时间
        weekControl.setRange(start, end);
        weekControl.setDate(dft);

        weekControl.$setSize(280, 20);
        weekControl.onchange = function() {

            core.triggerEvent(me, 'change', {}, null);
        }
    
    };
    /**
    * 创建日控件
    * @param {EcuiElement} me 控件本身
    * @param {Object} options 构造函数的参数
    * @param {htmlElement} eleBox  包裹占位容器
    */
    function createDayControl (me, options, eleBox) {
        var parse = parseDate; 
        var dayControl = me._uDayCalendar 
                       = $fastCreate(   UI_IST_CALENDAR, 
                                        eleBox.firstChild,
                                        me,
                                        {   
                                            mode:'DAY', 
                                            viewMode:'POP', 
                                            shiftBtnDisabled: true 
                                        }
                                    );
        var dft = parse( options.defaults.day , 'day');
        var range = options.range.day;
        var start = parse(range.start, 'day'); 
        var end = parse(range.end, 'day'); 

        dayControl.setRange(start, end);

        dayControl.setDate(dft);
        //日控件
        dayControl.$setSize(280, 20);
        dayControl.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        } 
    
    };

    /**
    * @param {EcuiElement} ele 控件元素
    * @return {Function} 返回onchange的处理函数
    */
    function conditionChangeHandle(ele) {
        var me = ele;
        return function() {
            var value = this.getValue();
            me._showCalendarByType(value);
            
            core.triggerEvent(me, 'change', {}, null);
        };
    } 
    
    /**
    * 设置select的数据
    * @inner
    * @param {ECUIElement} select ecui的选择控件
    * @param {Array[Object]} select ecui的选择控件
    */
    function setSelectData(select, data) {
        data = data || [];
        for (var i = 0, len = data.length; i < len; i++) {
            var item = data[i]; 
            select.add(item.text, i, { value: item.value });
        }
    };

    /**
    *  判断有没有 该类型的控件 目前 只有D M W Q四种
    * @param {string} type
    * @return {boolean} 是否存在
    */
    function hasType(type, options) {
        var types = options.types;
        var result = false;
        for (var i = 0; i < types.length; i ++) {
            if (types[i] === type) {
                result = true; 
                break;
            } 
        }
        return result;
    }; 
    /**
    * @param {string} op 操作的简称 pre next上一日 下一日
    * @param {HtmlElement} el 控件的元素引用 
    * @return {Function} 
    */
    function btnPreNextHandle(op, el) {
        var me = el;
        return function() {
            var type = me._getDateType();
            var today = new Date()
            var cName = this.className || '';

            //如果是灰色 就不做任何处理 其实上一步暂时没有做处理
            if (cName.match(/disable/)) {
                return ; 
            }
            if (type === 'day') {

                var cal = me._uDayCalendar;
                var d = cal.getDate();       
                if (op === 'pre') {
                    d.setDate(d.getDate() - 1); 
                }
                else {
                    d.setDate(d.getDate() + 1); 
                }
                cal.setDate(d);
                //XXX: 注意 控件的setDate是触发onchage事件的，
                //所以 手动对单个控件进行赋值 需要 手动触发onchange事件
                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'week') {
                var cal = me._uWeekCalendar;
                var d = cal.getDate();       
                //bugfix: 修复range的end不是周日，日期选择是周日，点击下一周失败的情况
                if (op === 'pre') {
                    d.setDate(d.getDate() - 7); 
                    //全部设置成周日
                    d = getMonday(d);
                    d.setDate(d.getDate() + 6);
                }
                else {
                    d.setDate(d.getDate() + 7); 
                    //全部设置成周一
                    d = getMonday(d);
                }
                cal.setDate(d);

                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'month') {
                //{type: 'M', date:''}
                var date = me.getDate().date; 
                date = parseDate(date, 'month');
                var cha = (op == 'pre' ? -1 : 1);
                var newDate = new Date(date.getFullYear(), date.getMonth() + cha); 
                newDate = formatDate(newDate, 'month');
                me.setDate({ type: 'M', date: newDate});

                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'quarter') {
                var date = me.getDate().date; 
                date = parseDate(date, 'quarter');
                var cha = (op == 'pre' ? -3 : 3);
                var newDate = new Date(date.getFullYear(), date.getMonth() + cha); 
                newDate = formatDate(newDate, 'quarter');
                me.setDate({ type: 'Q', date: newDate});

                core.triggerEvent(me, 'change', {}, null);
            }
        
        } 
    
    };
    // 设置默认options
    // @inner
    function  setDefaultOptions(options) {
        var parse = parseDate;
        var format = formatDate;
        var today = new Date();
        var tmp = '';
        //types 可能在dom节点设置
        if (Object.prototype.toString.call(options.types) == '[object String]') {
            options.types = options.types.split(',');  
        }
        if (!options.types) {
            options.types = ['D', 'W', 'M', 'Q']
        }
        if (!options.tagNames) {
            options.tagNames = ['日数据', '周数据', '月数据', '季度数据']; 
        }
        //防止没有设置range
        if (!options.range) {
            options.range = {}; 
        }
        var range = options.range;
        if (!range.day) {
            tmp = format(today, 'day');
            range.day = { start: '2008-01-01', end: tmp };

        }
        if (!range.week) {
            tmp = format(today, 'week');
            range.week = { start: '2008-01-01', end: tmp };
        }
        if (!range.month) {
            var end = new Date();
            var month = end.getFullYear();
            if (month > 2011) {
                end = format(end, 'month'); 
            }
            else {
                end = '2012-01'; 
            }
            range.month = { start: '2008-01', end: end }; 
        }
        if (!range.quarter) {

            var end = new Date();
            var q = end.getFullYear();
            if (q > 2011) {
                end = format(end, 'quarter'); 
            }
            else {
                end = '2012-Q1' 
            }
            range.quarter = { start: '2008-01', end: end };
        }
        //设置默认值
        if (!options.defaults) {
            options.defaults = {};
        }

        var date = new Date();
        var dft = options.defaults;
        dft.day = dft.day || format(date, 'day');
        dft.week = dft.week || format(date, 'week');
        dft.month = dft.month || format(date, 'month');
        dft.quarter = dft.quarter || format(date, 'quarter');

    };
    /**
    * @param {string}  strTime
    * @param {string_opt}  type : day or week, 
    * @return {Date}  返回的日期
    */
    function parseDate(strTime, type) {
        var date = null;
        var tmp = [];
        if (strTime == null || strTime == '') {
            return null; 
        }
        if (type === 'day' || type === 'week') {
            tmp = strTime.split('-');
            date = new Date(tmp[0], +tmp[1] - 1, tmp[2]); 
        } 
        else if (type === 'month') {
            tmp = strTime.split('-');
            date = new Date(tmp[0], +tmp[1] - 1, 1); 
        }
        else if (type === 'quarter') {
            tmp = strTime.split('-');
            q = strTime.slice(-1);
            date = new Date(tmp[0], q * 3 - 3, 1); 
        }
        return date;
    };

    /**
    * Date对象转为字符串的形式 2012-01-12
    * @param {Date} date
    * @param {Date} type 输入的日期类型 : day or week, month, quarter
    * @return {string}  返回字符串
    */
    function formatDate(date, type) {
        if (!date || '[object Date]' != Object.prototype.toString.call(date)) {
            return ''; 
        }
        type = type || 'day'; 
        var year = date.getFullYear();
        var month = date.getMonth() + 1;
        var day = date.getDate();
        var str = [];
        if (type === 'day' || type === 'week') {
            str.push(year);
            str.push(month < 10 ? '0' + month : month);
            str.push(day < 10 ? '0' + day : day);
        } 
        else if (type === 'month') {
            str.push(year);
            str.push(month < 10 ? '0' + month : month);
        }
        else if (type === 'quarter') {
            str.push(year);
            var q = Math.ceil(month / 3);
            str.push('Q' + q);
        }
        return str.join('-');
    };


    /**
    *  设置按钮的样式
    *  @inner
    */
    function setBtnStatus()  {
        var me = this;
        var gran = me._getDateType();
        var range = me._oRange;
        var today = range;
        var btnPre = me._uBtnPre;
        var btnNext = me._uBtnNext;
        //today = new Date(today.getFullYear(), today.getMonth(), today.getDate())
        var cName = this.getType() + '-btn-disable';
            //天粒度
        if (gran == 'day') {
            var d = me.getDate();       
            today = parseDate(range.day.end, 'day');
            var start = parseDate(range.day.start, 'day');

            d = parseDate(d.date, 'day');
            if (d.getTime() >= today.getTime()) {
                btnNext.disable();
                // addClass(btnNext, cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            //对于上一按钮的处理
            if (d.getTime() <= start.getTime()) {
                btnPre.disable();
                // addClass(btnPre, cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            } 
        }
        //周粒度
        else if (gran == 'week') {
            var d = me.getDate();       
            d = parseDate(d.date, 'day');
            today = parseDate(range.week.end, 'week');
            var monday = getMonday(today);
            var start = parseDate(range.week.start, 'week');
            if (d.getTime() >= monday.getTime()) {
                btnNext.disable();
                // addClass(btnNext , cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            monday = getMonday(start);
            if (d.getTime() <= monday.getTime()) {
                btnPre.disable();
                // addClass(btnPre , cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            }
        }
        //月粒度
        else if (gran == 'month') {
            var year = me._uMonthSelectYear.getValue();
            var month = me._uMonthSelectMonth.getValue();
            var d = parseDate(range.month.end, 'month');
            //开始时间
            var ds = parseDate(range.month.start, 'month');
            var ds_month =  ds.getMonth();
            var ds_year =  ds.getFullYear();

            var d_year = d.getFullYear();
            var d_month = d.getMonth();
            var big = false;
            if (   year > d_year 
                || ((year == d_year) && (month >= d_month)) 

                //bugfix: 开始范围的需要 超过之后+1
                || ((year == ds_year) && (month + 1 < ds_month))
            ) {
                big = true;
            }
            if (big) {
                btnNext.disable();
                // addClass(btnNext , cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            d = parseDate(range.month.start, 'month');

            var de = parseDate(range.month.end, 'month');
            de_month = de.getMonth();
            de_year = de.getFullYear();
            d_year = d.getFullYear();
            d_month = d.getMonth();
            var small = false;
            if (
                    year < d_year 
                || ((year == d_year) && (month <= d_month))

                //bugfix: 结束范围的需要 超过之后-1
                || ((year == de_year) && (month - 1 > de_month))
            ) {
                small = true;
            }
            if (small) {
                btnPre.disable();
                // addClass(btnPre , cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            }
        }
        //季度粒度
        else if (gran == 'quarter') {
            var year = me._uQuarterSelectYear.getValue();
            var month = me._uQuarterSelectQuarter.getValue();
            //结束range
            var d = parseDate(range.quarter.end, 'quarter');
            //开始range
            var ds = parseDate(range.quarter.start, 'quarter');
            var ds_year = ds.getFullYear();
            var ds_q = _getQ(ds.getMonth() + 1 );

            var d_year = d.getFullYear();
            var d_q = _getQ(d.getMonth() + 1 );
            var big = false;
            if (   year > d_year 
                || ((year == d_year) && month >= d_q)

                //bugfix: 开始范围的q需要 超过之后-1
                || ((year == ds_year) && +(month.slice(1)) + 1 < ds_q.slice(1)) 
            ) {
                big = true;
            }
            if (big) {
                btnNext.disable();
                // addClass(btnNext ,cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            d = parseDate(range.quarter.start, 'quarter');
            d_year = d.getFullYear();
            d_q = _getQ(d.getMonth() + 1 );

            var de = parseDate(range.quarter.end, 'quarter');
            de_year = de.getFullYear();
            de_q = _getQ(de.getMonth() + 1 );

            var small = false;
            if (   year < d_year 
                || ((year == d_year) && month <= d_q)
                //bugfix: 结束范围的q需要 超过之后-1
                || ((year == de_year) && +month.slice(1) - 1 > de_q.slice(1))
            
            ) {
                small = true;
            }
            if (small) {
                btnPre.disable();
                // addClass(btnPre, cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPe, cName); 
            }
        }
        /**
        * @param {number} month 月份 从1月开始
        * @return {String} 返回字符串类型 
        */
        function _getQ(month) {
            var q = '';
            if (month >= 1 && month <= 3) {
                q = 'Q1'; 
            }
            else if (month >= 4 && month <= 6) {
                q = 'Q2'; 
            }
            else if (month >= 7 && month <= 9) {
                q = 'Q3'; 
            }
            else if (month >= 10 && month <= 12) {
                q = 'Q4'; 
            }
            return q;
        }

    };

    /**
    * 获取星期一
    * @param {Date} date 需要转化的时间
    */
    function getMonday(date) {
        var day = date.getDay();
        var dd = date.getDate();
        var yyyy = date.getFullYear();
        var mm = date.getMonth();
        var monday = null;
        var distance = 0;
        if (day >= 1) {
            dd -= day - 1; 
        }
        else {
            dd -= 6; 
        }
        monday =  new Date(yyyy, mm, dd); 
        return monday;
    };

  

    /**
    * 获取选择时间
    * @return {Object} obj
    * @return {Object} obj.type 'M' 时间类型
    * @return {Object} obj.date '1900-01' 时间格式
    */
    function getDate() {
        // day week, month quarter
        var type = this._getDateType();
        var date = null;
        var result = {
            type: 'D',
            date: ''
        };
        if (type === 'day') {
            date = this._uDayCalendar.getDate(); 
            date = formatDate(date);
            result = {
                'type': 'D',
                'date': date
            } 
        }
        else if (type === 'week') {
            date = this._uWeekCalendar.getDate(); 
            date = getMonday(date);
            date = formatDate(date);
            result = {
                type: 'W',
                date: date 
            }
        }
        else if (type === 'month') {
            var year = this._uMonthSelectYear.getValue();
            var month = this._uMonthSelectMonth.getValue();
            date = new Date(year, month, 1); 
            date = formatDate(date, 'month');
            result = {
                type: 'M',
                date: date
            }
        }
        else if (type === 'quarter') {
            var year = this._uQuarterSelectYear.getValue();
            var quarter = this._uQuarterSelectQuarter.getValue();
            if (!year || !quarter) {
                date = '';
            }
            else {
                date = year + '-' + quarter;
                result = {
                    type: 'Q',
                    date: date
                } 
            }
        }
        return result;
    };

    /**
    * @param {string} type 控件 type： day week  month year
    * @  暴露给控件的prototype上
    */
    function showCalendarByType(type) {
        
        this._uConditionSelect.setValue(type);

        var typeList = this.typeList;
        var value = type;
        var preType = this._nSelectedType;
        typeList[preType].style.display = 'none';
        //value == day, week, month , quarter
        typeList[value].style.display = 'block';
        //设置当然选中的type
        this._nSelectedType = value;
       
    }
    /**
    *  设置控件的时间
    * @param {Object} obj
    * @param {string} obj.type 时间控件类型  'M', 'D', 'W', 'Q'
    * @param {string} obj.date 时间控件的具体值 1988-03
    */
    function setDate(obj) {
        var type = obj.type || 'M'; 
        var innerType = this._getInnerType(type);
        var date = obj.date;
        var currentType = this._nSelectedType;
        if (!date) {
            return ; 
        }
        //日期
        if (type === 'D') {
            var d = parseDate(date, 'day');
            this._uDayCalendar.setDate(d); 
            innerType = 'day';
        } 
        else if (type === 'W') {
            var d = parseDate(date, 'week');
            d = getMonday(d);
            this._uWeekCalendar.setDate(d); 
            innerType = 'week';
        }
        else if (type === 'M') {
            var d = parseDate(date, 'month');
            var year = d.getFullYear();
            var month = d.getMonth();
            this._uMonthSelectYear.setValue(year);
            this._uMonthSelectMonth.setValue(month);
            innerType = 'month';
        }
        else if (type === 'Q') {
            var d = parseDate(date, 'quarter');
            if (date.length == 7) {
                var year = date.slice(0, 4);
                var q = date.slice(-2);
            }
            this._uQuarterSelectYear.setValue(year);
            this._uQuarterSelectQuarter.setValue(q);
            innerType = 'quarter';
        }

        if (innerType != currentType) {
            this._showCalendarByType(innerType);
        }

        //core.triggerEvent(this, 'change', {}, null);
    };

    
    /**
    * @param {Object} options 构造函数里的options参数 很多东西的
    * @param {Array<String>} types   'D', 'M' ===
    * @param {Object} range 构造函数里的options参数 很多东西的
    * @param {String} range.type 构造函数里的options参数 很多东西的
    * @param {String} range.date  时间日期  1988-01-03
    */
    function render(options) {
        detachEvent(WINDOW, 'resize', repaint); 
        var el = this.getOuter();
        //卸载内部子控件
        for (key in this) {
            if (/_u\w+/.test(key)) {
                disposeControl(this[key]);
            }
        }
        el.innerHTML = '';
        UI_CALENDAR_PLUS.client.call(this, el, options);
        this.cache(true, true);
        this.init();

        this.$resize();
        //恢复
        attachEvent(WINDOW, 'resize', repaint);
    
    }


    /**
    * @private 私有方法
    * @param {String} type  获取 外部的D，M，W 等 对应的内部名称
    * @return {String}返回内部对应的名称
    */
    UI_CALENDAR_PLUS_CLASS._getInnerType = function(type) {

        //获取外部的简称 对应内部的类型
        var dic = {
            'D': 'day',
            'W': 'week',
            'M': 'month',
            'Q': 'quarter'
        } 
        return dic[type];
    }
    /**
    * @private 内部方法 检测设置 控件的可用样式
    * @param {Date=} 可以传入时间
    */
    UI_CALENDAR_PLUS_CLASS._setBtnStatus = setBtnStatus;

    /**
    * @private
    * @param {string} type 日期的类型 day week month year
    */
    UI_CALENDAR_PLUS_CLASS._showCalendarByType = showCalendarByType;

    /**
    * @private   内部调用 跟外部的接口可能不符合
    * 获取当前的时间类型
    * @return {string}  
    */
    UI_CALENDAR_PLUS_CLASS._getDateType = function() {
        return this._nSelectedType; 
    };

    /**
    * @inner 内部作用，设置时间的时候  处理按钮的可选
    */
    UI_CALENDAR_PLUS_CLASS.$change = function() {
        this._setBtnStatus(); 
    };

    /**
    * 重新渲染时间控件  
    * @param {Object} options 传入构造参数重新刷新
    *
    */
    UI_CALENDAR_PLUS_CLASS.render = render;

    /**
    *  设置控件的时间
    * @param {Object} obj
    * @param {string} obj.type 时间控件类型  'M', 'D', 'W', 'Q'
    * @param {string} obj.date 时间控件的具体值 1988-03
    */
    UI_CALENDAR_PLUS_CLASS.setDate = setDate;

    /**
    * 获取选择时间
    * @return {Object} obj
    * @return {Object} obj.type 'M' 时间类型
    * @return {Object} obj.date '1900-01-02' 时间格式
    */
    UI_CALENDAR_PLUS_CLASS.getDate = getDate;

   

    })();

/**
 * di.shared.adapter.CalendarPlusVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    CalendarPlus的适配器
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;
    var ecuiDispose = UTIL.ecuiDispose;
    var detachEvent = ecui.util.detachEvent;
    var attachEvent = ecui.util.attachEvent;
    var disposeControl = ecui.dispose;
    var repaint = ecui.repaint;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var formatTime = UTIL.formatTime;
    var CALENDAR_PLUS;
    var GLOBAL_MODEL;

    $link(function() {
        CALENDAR_PLUS = ecui.ui.CalendarPlus;
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * CalendarPlus的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().CalendarPlusVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @param {Object} options.granularities 粒度，
     *      'D', 'W', 'M', 'Q', 'Y'
     *          每项的配置，含有：
     *          options.start 开始时间，绝对值（如2012-12-12）或相对当前时间的值（如-5d）
     *          options.end 结束时间，格式同上
     * @return {Object} 创建的实例
     */
    function create(def, options) {
        return ecuiCreate(CALENDAR_PLUS, def.el, null, prepareData(options));
    }

    /**
     * 设置数据
     *
     * @public
     */
    function setData(data) {
        this.setData(prepareData(data));
        // detachEvent(window, 'resize', repaint);

        // var disposeFunc = this.$dispose;
        // this.$dispose = new Function();
        // disposeControl(this);
        // this.$dispose = disposeFunc;

        // var el = this.getOuter();
        // el.innerHTML = '';
        // this.$setBody(el);
        // this.$resize();
        // CALENDAR_PLUS.client.call(this, el, prepareData(data));
        // this._bCreated = false;
        // this.cache(true, true);
        // this.init();

        // attachEvent(window, 'resize', repaint);
    }

    /**
     * 准备数据
     *
     * @private
     */
    function prepareData(options) {
        var now = GLOBAL_MODEL().getDateModel().now();

        var defUnit = {
                defaultTime: ['0d'],
                range: ['-1Y', '0d']
            };
        var granularities = options.granularities
            // 缺省的granularity
            || { D: defUnit, W: defUnit, M: defUnit, Q: defUnit };

        var opt = {
            types: [],
            range: {},
            defaults: {}
        };

        var timeMap = {
            D: 'day', W: 'week', M: 'month', Q: 'quarter', Y: 'year'
        };

        var range;
        for (var gran in granularities) {
            opt.types.push(gran);

            range = granularities[gran];
            
            opt.defaults[timeMap[gran]] = formatObjTime(
                parseTimeUnitDef(range.defaultTime, [now, now]),
                gran
            ).start;
            opt.range[timeMap[gran]] = formatObjTime(
                parseTimeUnitDef(range.range, [now, now]) || {},
                gran
            );
        }

        return opt;
    }

    /**
     * 格式化时间
     * 
     * @private
     */    
    function formatObjTime(obj, granularity) {
        for (var key in obj) {
            obj[key] = formatTime(obj[key], granularity);
        }
        return obj;
    }

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    function getValue() {
        var wrap = this.getDate();
        return {
            start: wrap.date,
            end: wrap.date,
            granularity: wrap.type
        };
    }

})();


/**
 * di.shared.adapter.EcuiSelectVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    IstCalendar的适配器
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var DICT = di.config.Dict;

    /**
     * ecui Select的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiSelectVUIAdapter = function(def, options) {
        return {
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 设置初始化数据
     * 
     * @public
     * @param {Object} data 数据
     * @param {Array.<Object>} data.datasource 数据集
     *      每个节点：
     *          {string} text
     *          {string} value
     * @param {Array.<string>} data.value 初始选中
     */
    function setData(data) {
        data = data || {};
        var datasource = data.datasource || [];
        var value = (data.value && data.value[0])
            || (datasource[0] && datasource[0].value);
            
        // 清除
        this.setValue(null);
        while(this.remove(0)) {}

        // 添加
        for (var i = 0, o; o = datasource[i]; i++) {
            this.add(
                String(o.text != null ? o.text : ''), 
                null,
                { value: o.value }
            );
        }

        // 设置默认选中
        value != null && this.setValue(value);
    }

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    function getValue() {
        var v = this.getValue();
        return v == null ? [] : [v];
    }

})();


/**
 * di.shared.ui.FoldPanel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    折叠面板
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 折叠面板
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {boolean=} options.autoDeaf 使用deaf模式，
     *                  即隐藏时deaf内部实体，默认为true
     * @param {boolean=} options.autoComponentValueDisabled component自动在隐藏时valueDisabled模式，
     *                  即隐藏时value disable内部实体，默认为false
     * @param {boolean=} options.autoVUIValueDisabled vui自动在隐藏时使用valueDisabled模式，
     *                  即隐藏时value disable内部实体，默认为true
     */
    var FOLD_PANEL = $namespace().FoldPanel = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var FOLD_PANEL_CLASS = FOLD_PANEL.prototype;

    /**
     * 定义
     */
    FOLD_PANEL_CLASS.DEF = {
        // 主元素的css
        className: 'di-fold-panel',
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @constructor
     * @public
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this.$di('getEl');
        var o = document.createElement('div');
        el.appendChild(o);

        this._bFolded = true;
        this._bAutoDeaf = options.autoDeaf == null 
            ? true : options.autoDeaf;
        this._bAutoComponentValueDisabled = 
            options.autoComponentValueDisabled == null
                ? false : options.autoComponentValueDisabled;
        this._bAutoVUIValueDisabled = 
            options.autoVUIValueDisabled == null
                ? true : options.autoVUIValueDisabled;

        this._oBodyDef = this.$di('getRef', 'vpartRef', 'body', 'DEF');
        this._oCtrlBtnDef = this.$di('getRef', 'vpartRef', 'ctrlBtn', 'DEF');

        this.$createCtrlBtn();
        this.$resetCtrlBtnText();
        this.$ctrlBtnChange(true);
    };

    /**
     * 初始化
     *
     * @public
     */
    FOLD_PANEL_CLASS.init = function() {
        this.$resetDisabled();
    };

    /**
     * 创建ctrlBtn
     *
     * @protected
     */
    FOLD_PANEL_CLASS.$createCtrlBtn = function() {
        // 目前只支持文字式的ctrlBtn
        this._oCtrlBtnDef.el.innerHTML = [
            '<a href="#" class="di-fold-panel-ctrl-btn">',
                '<span class="di-fold-panel-ctrl-btn-text">&nbsp;</span>',
            '</a>',
            '<span class="di-fold-panel-ctrl-down"></span>'
        ].join('');

        var el = this._oCtrlBtnDef.el.firstChild;
        var me = this;
        el.onclick = function() {
            if (!me._bDisabled) { 
                me.$ctrlBtnChange();
                me.$resetDisabled();
            }
            return false;
        }
    };

    /**
     * @override
     */
    FOLD_PANEL_CLASS.dispose = function() {
        this._oCtrlBtnDef = null;
        this._oBodyDef = null;
        FOLD_PANEL.superClass.dispose.call(this);
    };

    /**
     * @protected
     */
    FOLD_PANEL_CLASS.$resetDisabled = function() {
        var inners;
        var key = this.$di('getId');

        inners = this._oBodyDef.$di(
            'getRef', 'componentRef', 'inner', 'INS'
        ) || [];

        for (var j = 0; j < inners.length; j ++) {
            if (inners[j]) {
                this._bAutoDeaf 
                    && inners[j].$di('setDeaf', this._bFolded, key);
                this._bAutoComponentValueDisabled
                    && inners[j].$di('setValueDisabled', this._bFolded, key);
            }
        }

        if (this._bAutoVUIValueDisabled) {
            inners = this._oBodyDef.$di(
                'getRef', 'vuiRef', 'inner', 'INS'
            ) || [];

            for (var j = 0; j < inners.length; j ++) {
                inners[j] && inners[j].$di('setValueDisabled', this._bFolded, key);
            }
        }
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    FOLD_PANEL_CLASS.resize = function() {
    };

    /**
     * 设置ctrlBtn文字
     *
     * @protected
     */    
    FOLD_PANEL_CLASS.$resetCtrlBtnText = function() {
        var btnDef = this._oCtrlBtnDef;
        var dataOpt = btnDef.$di('getOpt', 'dataOpt');

        // 暂只支持链接形式
        // TODO
        btnDef.el.firstChild.firstChild.innerHTML = this._bFolded
            ? dataOpt.expandText 
            : dataOpt.collapseText;
        btnDef.el.lastChild.className = this._bFolded
            ? 'di-fold-panel-ctrl-down'
            : 'di-fold-panel-ctrl-up';
    };

    /**
     * 展开折叠
     *
     * @protected
     * @param {boolean=} toFold 是否折叠，如不传，则将折叠与否置反
     */
    FOLD_PANEL_CLASS.$ctrlBtnChange = function(toFold) {
        var style = this._oBodyDef.el.style;

        this._bFolded = toFold == null ? !this._bFolded : toFold;

        this.$resetCtrlBtnText();

        style.display = this._bFolded ? 'none' : '';

        /**
         * 渲染完事件
         *
         * @event
         */
        this.$di('dispatchEvent', 'rendered');
    };

})();
/*
TreeView - 定义树形视图的基本操作。
树视图控件，继承自基础控件，不可以被改变大小，可以包含普通子控件或者子树视图控件，普通子控件显示在它的文本区域，如果是子树视图控件，将在专门的子树视图控件区域显示。子树视图控件区域可以被收缩隐藏或是展开显示，默认情况下点击树视图控件就改变子树视图控件区域的状态。

树视图控件直接HTML初始化的例子:
<div ecui="type:tree-view;">
  <!-- 显示的文本，如果没有label整个内容就是节点的文本 -->
  <label>公司</label>
  <!-- 子控件 -->
  <div>董事会</div>
  <div>监事会</div>
  <div>
    <label>总经理</label>
    <div>行政部</div>
    <div>人事部</div>
    <div>财务部</div>
    <div>市场部</div>
    <div>销售部</div>
    <div>技术部</div>
  </div>
</div>

属性
_bCollapsed    - 是否收缩子树
_eChildren     - 子控件区域Element对象
_aChildren     - 子控件集合
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        indexOf = array.indexOf,
        remove = array.remove,
        addClass = dom.addClass,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getStyle = dom.getStyle,
        insertAfter = dom.insertAfter,
        removeClass = dom.removeClass,
        trim = string.trim,
        extend = util.extend,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        getMouseX = core.getMouseX,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_TREE_VIEW
    ///__gzip_original__UI_TREE_VIEW_CLASS
    /**
     * 初始化树视图控件。
     * options 对象支持的属性如下：
     * collapsed      子树区域是否收缩，默认为展开
     * expandSelected 是否展开选中的节点，如果不自动展开，需要点击左部的小区域图标才有效，默认自动展开
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_TREE_VIEW = ui.TreeView =
        inheritsControl(
            UI_CONTROL,
            'ui-treeview',
            function (el, options) {
                options.resizable = false;

                var o = first(el);

                // 检查是否存在label标签，如果是需要自动初始化树的子结点
                if (o && o.tagName == 'LABEL') {
                    // 初始化子控件
                    for (
                        var i = 0,
                            list = children(el).slice(1),
                            childItems = UI_TREE_VIEW_SETITEMS(this, el.appendChild(createDom()));
                        o = list[i++];
                    ) {
                        childItems.appendChild(o);
                    }

                    addClass(
                        el,
                        options.current = options.primary + (options.collapsed ? '-collapsed' : '-expanded')
                    );

                    if (options.collapsed) {
                        childItems.style.display = 'none';
                    }
                }
            },
            function (el, options) {
                var childTrees = this._aChildren = [];

                this._bCollapsed = options.collapsed || false;
                this._bExpandSelected = options.expandSelected !== false;

                // 初始化子控件
                for (
                    var i = 0,
                        list = children(el.lastChild),
                        o;
                    o = list[i];
                ) {
                    delete options.current;
                    (childTrees[i++] = UI_TREE_VIEW_CREATE_CHILD(o, this, options)).$setParent(this);
                }
            }
        ),
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype;
//{else}//
    /**
     * 设置树视图控件的选项组 Element 对象。
     * @private
     *
     * @param {ecui.ui.TreeView} tree 树视图控件
     * @param {HTMLElement} items 子树选项组的 Element 对象
     * @return {HTMLElement} items 子树选项组的 Element 对象
     */
    function UI_TREE_VIEW_SETITEMS(tree, items) {
        tree._eChildren = items;
        items.className = tree.getType() + '-children';
        items.style.cssText = '';
        return items;
    }

    /**
     * 树视图控件刷新，根据子树视图控件的数量及显示的状态设置样式。
     * @private
     *
     * @param {ecui.ui.TreeView} control 树视图控件
     */
    function UI_TREE_VIEW_FLUSH(control) {
        control.setClass(
            control.getPrimary() + (control._aChildren.length ? control._bCollapsed ? '-collapsed' : '-expanded' : '')
        );
    }

    /**
     * 建立子树视图控件。
     * @private
     *
     * @param {HTMLElement} el 子树的 Element 对象
     * @param {ecui.ui.TreeView} parent 父树视图控件
     * @param {Object} options 初始化选项，参见 create 方法
     * @return {ecui.ui.TreeView} 子树视图控件
     */
    function UI_TREE_VIEW_CREATE_CHILD(el, parent, options) {
        el.className = (trim(el.className) || parent.getPrimary()) + parent.constructor.agent.TYPES;
        return $fastCreate(parent.constructor, el, null, extend(extend({}, options), getOptions(el)));
    }

    /**
     * 收缩/展开子树区域。
     * @private
     *
     * @param {ecui.ui.TreeView} control 树视图控件
     * @param {boolean} status 是否隐藏子树区域
     * @return {boolean} 状态是否改变
     */
    function UI_TREE_VIEW_SET_COLLAPSE(control, status) {
        if (control._eChildren && control._bCollapsed != status) {
            control._eChildren.style.display = (control._bCollapsed = status) ? 'none' : '';
            UI_TREE_VIEW_FLUSH(control);
        }
    }

    /**
     * 控件点击时改变子树视图控件的显示/隐藏状态。
     * @override
     */
    UI_TREE_VIEW_CLASS.$click = function (event) {
        if (event.getControl() == this) {
            UI_CONTROL_CLASS.$click.call(this, event);

            if (getMouseX(this) <= toNumber(getStyle(this.getBody(), 'paddingLeft'))) {
                // 以下使用 event 代替 name
                this[event = this.isCollapsed() ? 'expand' : 'collapse']();
                triggerEvent(this, event);
            }
            else {
                this.select();
            }
        }
    };

    /**
     * @override
     */
    UI_TREE_VIEW_CLASS.$dispose = function () {
        this._eChildren = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 隐藏树视图控件的同时需要将子树区域也隐藏。
     * @override
     */
    UI_TREE_VIEW_CLASS.$hide = function () {
        UI_CONTROL_CLASS.$hide.call(this);

        if (this._eChildren) {
            this._eChildren.style.display = 'none';
        }
    };

    /**
     * 树视图控件改变位置时，需要将自己的子树区域显示在主元素之后。
     * @override
     */
    UI_TREE_VIEW_CLASS.$setParent = function (parent) {
        var root = this.getRoot(),
            o = this.getParent();

        if (this == root._cSelected || this == root) {
            // 如果当前节点被选中，需要先释放选中
            // 如果当前节点是根节点，需要释放选中
            if (root._cSelected) {
                root._cSelected.alterClass('-selected');
            }
            root._cSelected = null;
        }
        else {
            remove(o._aChildren, this);
            UI_TREE_VIEW_FLUSH(o);
        }

        UI_CONTROL_CLASS.$setParent.call(this, parent);

        // 将子树区域显示在主元素之后
        if (this._eChildren) {
            insertAfter(this._eChildren, this.getOuter());
        }
    };

    /**
     * 显示树视图控件的同时需要将子树视图区域也显示。
     * @override
     */
    UI_TREE_VIEW_CLASS.$show = function () {
        UI_CONTROL_CLASS.$show.call(this);

        if (this._eChildren && !this._bCollapsed) {
            this._eChildren.style.display = '';
        }
    };

    /**
     * 添加子树视图控件。
     * @public
     *
     * @param {string|ecui.ui.TreeView} item 子树视图控件的 html 内容/树视图控件
     * @param {number} index 子树视图控件需要添加的位置序号，不指定将添加在最后
     * @param {Object} options 子树视图控件初始化选项
     * @return {ecui.ui.TreeView} 添加的树视图控件
     */
    UI_TREE_VIEW_CLASS.add = function (item, index, options) {
        var list = this._aChildren,
            o;

        if (!this._eChildren) {
            UI_TREE_VIEW_SETITEMS(this, createDom());
            insertAfter(this._eChildren, this.getOuter());
            this._eChildren.style.display = this._bCollapsed ? 'none' : '';
        }

        if (o = list[index]) {
            o = o.getOuter();
        }
        else {
            index = list.length;
            o = null;
        }

        if ('string' == typeof item) {
            o = this._eChildren.insertBefore(createDom(), o);
            o.innerHTML = item;
            item = UI_TREE_VIEW_CREATE_CHILD(o, this, options);
        }
        else {
            this._eChildren.insertBefore(item.getOuter(), o);
        }

        // 这里需要先 setParent，否则 getRoot 的值将不正确
        item.$setParent(this);
        list.splice(index, 0, item);

        UI_TREE_VIEW_FLUSH(this);

        return item;
    };

    /**
     * 收缩当前树视图控件的子树区域。
     * @public
     */
    UI_TREE_VIEW_CLASS.collapse = function () {
        UI_TREE_VIEW_SET_COLLAPSE(this, true);
    };

    /**
     * 展开当前树视图控件的子树区域。
     * @public
     */
    UI_TREE_VIEW_CLASS.expand = function () {
        UI_TREE_VIEW_SET_COLLAPSE(this, false);
    };

    /**
     * 获取当前树视图控件的所有子树视图控件。
     * @public
     *
     * @return {Array} 树视图控件列表
     */
    UI_TREE_VIEW_CLASS.getChildren = function () {
        return this._aChildren.slice();
    };

    /**
     * 获取当前树视图控件的第一个子树视图控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件，如果没有，返回 null
     */
    UI_TREE_VIEW_CLASS.getFirst = function () {
        return this._aChildren[0] || null;
    };

    /**
     * 获取当前树视图控件的最后一个子树视图控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件，如果没有，返回 null
     */
    UI_TREE_VIEW_CLASS.getLast = function () {
        return this._aChildren[this._aChildren.length - 1] || null;
    };

    /**
     * 获取当前树视图控件的后一个同级树视图控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件，如果没有，返回 null
     */
    UI_TREE_VIEW_CLASS.getNext = function () {
        var parent = this.getParent();
        return parent instanceof UI_TREE_VIEW && parent._aChildren[indexOf(parent._aChildren, this) + 1] || null;
    };

    /**
     * 获取当前树视图控件的前一个同级树视图控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件，如果没有，返回 null
     */
    UI_TREE_VIEW_CLASS.getPrev = function () {
        var parent = this.getParent();
        return parent instanceof UI_TREE_VIEW && parent._aChildren[indexOf(parent._aChildren, this) - 1] || null;
    };

    /**
     * 获取当前树视图控件的根控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件的根控件
     */
    UI_TREE_VIEW_CLASS.getRoot = function () {
        for (
            var o = this, parent;
            // 这里需要考虑Tree位于上一个Tree的节点内部
            (parent = o.getParent()) instanceof UI_TREE_VIEW && indexOf(parent._aChildren, o) >= 0;
            o = parent
        ) {}
        return o;
    };

    /**
     * 获取当前树视图控件选中的节点。
     * @public
     *
     * @return {ecui.ui.TreeView} 选中的节点
     */
    UI_TREE_VIEW_CLASS.getSelected = function () {
        return this.getRoot()._cSelected || null;
    };

    /**
     * @override
     */
    UI_TREE_VIEW_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        for (var i = 0, list = this._aChildren, o; o = list[i++]; ) {
            o.init();
        }
    };

    /**
     * 当前子树区域是否收缩。
     * @public
     *
     * @return {boolean} true 表示子树区域收缩，false 表示子树区域展开
     */
    UI_TREE_VIEW_CLASS.isCollapsed = function () {
        return !this._eChildren || this._bCollapsed;
    };

    /**
     * 将当前节点设置为选中。
     * @public
     */
    UI_TREE_VIEW_CLASS.select = function () {
        var root = this.getRoot();

        if (root._cSelected != this) {
            if (root._cSelected) {
                root._cSelected.alterClass('-selected');
            }
            this.alterClass('+selected');
            root._cSelected = this;
        }

        if (this._bExpandSelected) {
            this.expand();
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * data tree
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    data-tree.js
 * desc:    数据树
 *          在普通树控件的基础上进行扩展
 * author:  cxl(chenxinle@baidu.com)
 * date:    2012/03/12
 */
(function () {
    var core = ecui,
        array = core.array,
        ui = core.ui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        util = core.util,

        $fastCreate = core.$fastCreate,
        getMouseX = core.getMouseX,
        inheritsControl = core.inherits,
        getOptions = core.getOptions,
        disposeControl = core.dispose,
        triggerEvent = core.triggerEvent,
        extend = util.extend,
        indexOf = array.indexOf,
        extend = util.extend,
        toNumber = util.toNumber,
        getStyle = dom.getStyle,
        first = dom.first,
        insertAfter = dom.insertAfter,
        trim = string.trim,
        blank = util.blank,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_TREE_VIEW = ui.TreeView,
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype,

        UI_DATA_TREE = ui.DataTree = 
        inheritsControl(
            UI_TREE_VIEW,
            'ui-data-tree',
            function (el, options) {
                options.expandSelected = options.expandSelected === true;

                if (first(el) && 'divlabel'.indexOf(first(el).tagName.toLowerCase()) >= 0) {
                    extend(options, getOptions(first(el)));
                }

                if (options.value) {
                    options.value += '';
                }

                options.resizable = false;
            },
            function (el, options) {
                this._aSelected = [];
                this._sValue = options.value;
                this._bHideRoot = options.hideRoot === true; //是否隐藏根节点
                this._bSelectAble = options.selectable !== false;
                this._bMultiSelect = options.multi === true;
                this._bAsyn = options.asyn;
                this._bIsLeaf = options.isLeaf;
                if (options.asyn && !options.isLeaf && this._aChildren.length <= 0) {
                    this.add('Loadding', null);
                    this.collapse();
                    this._bNeedAsyn = true;                        
                }
            }
        ),
        
        UI_DATA_TREE_CLASS = UI_DATA_TREE.prototype;

    function UI_DATA_TREE_VIEW_FLUSH(control) {
        control.setClass(
            control.getPrimary() + (control._aChildren.length ? control._bCollapsed ? '-collapsed' : '-expanded' : '')
        );
    }

    UI_DATA_TREE_CLASS.init = function () {
        UI_TREE_VIEW_CLASS.init.call(this);

        if (this._bHideRoot && this == this.getRoot()) {
            this.hide();
            this.expand();
        }
    }

    UI_DATA_TREE_CLASS.$setParent = function (parent) {
        var root = this.getRoot(),
            selected = root._aSelected,
            o = this.getParent(), i;

        // 如果当前节点被选中，需要先释放选中
        if ((i = indexOf(selected, this)) >= 0) {
            root.$setSelected(this, false);
        }

        if (this !== root) {
            remove(o._aChildren, this);
            UI_DATA_TREE_VIEW_FLUSH(o);
        }

        UI_CONTROL_CLASS.$setParent.call(this, parent);

        // 将子树区域显示在主元素之后
        if (this._eChildren) {
            insertAfter(this._eChildren, this.getOuter());
        }
    }

    UI_DATA_TREE_CLASS.getValue = function () {
        return this._sValue;
    }

    UI_DATA_TREE_CLASS.getText = function () {
        return trim(this.getContent().replace(/<[^>]+>/g, ''));
    }

    UI_DATA_TREE_CLASS.getSelected = function () {
        if (this == this.getRoot()) {
            return this._aSelected.slice();
        }
    }

    UI_DATA_TREE_CLASS.getSelectedValues = function () {
        var res = [], i, item;
        if (this == this.getRoot()) {
            for (i = 0; item = this._aSelected[i]; i++) {
                res.push(item.getValue());
            }
            return this._bMultiSelect ? res : res[0];
        }
    }

    UI_DATA_TREE_CLASS.setValues = function (values) {
        var item;
        if (indexOf(values, this._sValue) >= 0) {
            this.getRoot().$setSelected(this, true);
            item = this;
            while((item = item.getParent()) && item instanceof UI_TREE_VIEW) {
                if (item.isCollapsed()) {
                    item.expand()
                }
            }
        }
        for (var i = 0, item; item = this._aChildren[i]; i++) {
            item.setValues(values);
        }
    }

    UI_DATA_TREE_CLASS.getItemByValue = function (value) {
        var res = null;

        if (this._sValue == value) {
            res = this;
        }
        for (var i = 0, item; (item = this._aChildren[i]) && res == null; i++) {
            res = item.getItemByValue(value);
        }
        return res;
    }

    UI_DATA_TREE_CLASS.load = function (datasource) {
        var i, item, text;

        for (i = 0; item = this._aChildren[i]; i++) {
            disposeControl(item);
        }
        this._aChildren = [];
        this._eChildren.innerHTML = '';

        for (i = 0; item = datasource[i]; i++) {
            text = item.text;
            item = extend({asyn: this._bAsyn}, item);
            delete item.text;
            this.add(text, null, item).init();
        }
    }

    UI_DATA_TREE_CLASS.$expand = function (item) {
        var superObj = item.getRoot();
        if (item._bNeedAsyn) {
            triggerEvent(superObj, 'load', null, [item.getValue(), function (data) {item.load(data)}]);
            item._bNeedAsyn = false;
        }
    }

    UI_DATA_TREE_CLASS.$click = function (event) {
        if (event.getControl() == this) {
            UI_CONTROL_CLASS.$click.call(this, event);

            if (getMouseX(this) <= toNumber(getStyle(this.getBody(), 'paddingLeft'))) {
                this.clickEC();
            }
            else {
                this.clickItem();
            }
        }
    }

    // 为QA自动化测试而暴露的api
    UI_DATA_TREE_CLASS.clickEC = function () {
        var e;
        this[e = this.isCollapsed() ? 'expand' : 'collapse']();
        triggerEvent(this.getRoot(), e, null, [this]);
    }

    // 为QA自动化测试而暴露的api
    UI_DATA_TREE_CLASS.clickItem = function () {
        var added = null;
        if (indexOf(this.getRoot()._aSelected, this) >= 0) {
            if (this._bMultiSelect) {
                added = false;    
            }
        }
        else {
            added = true;
        }
        this.getRoot().setSelected(this);
        triggerEvent(this.getRoot(), 'select', null, [this, added == true])
        if (added !== null) {
            triggerEvent(this.getRoot(), 'change', null, [this.getValue(), added]);
        }
    }

    UI_DATA_TREE_CLASS.getSelectedText = function () {
        var res = [], i, item;
        if (this == this.getRoot()) {
            for (i = 0; item = this._aSelected[i]; i++) {
                res.push(item.getText());
            }
            return res.join(',');
        }
    }

    UI_DATA_TREE_CLASS.setSelectAble = function (enable) {
        var root = this.getRoot(), i;

        if (!this.enable && (i = indexOf(root._aSelected, this)) >= 0) {
            root.$setSelected(this, false);
        }
        this._bSelectAble = enable;
    }

    UI_DATA_TREE_CLASS.$setSelected = function (node, flag) {
        var selected, i;
        if (this == this.getRoot()) {
            selected = this._aSelected;
            i = indexOf(selected, node);
            if (flag === true) {
                if (i < 0) {
                    selected.push(node);
                    node.alterClass('+selected');
                }
            }
            else if (flag === false) {
                if (i >= 0) {
                    selected.splice(i, 1);
                    node.alterClass('-selected');
                }
            }
        }
    }

    UI_DATA_TREE_CLASS.clearSelected = function () {
        var selected, i, item;
        
        if (this == this.getRoot()) {
            selected = this._aSelected;
            while(item = selected[0]) {
                this.$setSelected(item, false);
            }
        }
    }

    UI_DATA_TREE_CLASS.setSelected = function (node, force) {
        var selected, i;

        if (this == this.getRoot() && node._bSelectAble) {
            selected = this._aSelected;                    
            i = indexOf(selected, this);
            if ((i = indexOf(selected, node)) >= 0) {
                if (!force && this._bMultiSelect) {
                    this.$setSelected(node, false);
                }
            }
            else {
                if (!this._bMultiSelect && selected.length >= 1) {
                    this.$setSelected(selected[0], false);
                }
                this.$setSelected(node, true);
            }

            if (node && this._bExpandSelected) {
                node.expand();
            }
        }
    };

    UI_DATA_TREE_CLASS.$setSize = blank;
})();

/**
 * input tree
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    input-tree.js
 * desc:    树层级输入框
 * author:  cxl(chenxinle@baidu.com)
 * date:    2012/03/12
 */
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        setFocused = core.setFocused,
        disposeControl = core.dispose,
        createDom = dom.create,
        addClass = dom.addClass,
        children = dom.children,
        encodeHTML = string.encodeHTML,
        moveElements = dom.moveElements,
        getPosition  = dom.getPosition,
        inheritsControl = core.inherits,
        getView = util.getView,
        extend = util.extend,
        blank = util.blank,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;

        var UI_INPUT_TREE = ui.InputTree = 
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-input-tree',
            function (el, options) {
                var type = this.getTypes()[0],
                    o = createDom();
                
                o.innerHTML = '<div class="'+ type +'-layer" ' 
                    + ' style="position:absolute;display:none; z-index:65535; height:230px; width:250px">'
                    + '<div class="'
                    + UI_DATA_TREE.types[0] +'"></div></div>';

                o = o.firstChild;

                moveElements(el, o.lastChild, true);
                options._eLayer = document.body.appendChild(o);
                
                el.innerHTML = ''
                    + '<span class="'+ type +'-text"></span>'
                    + '<span class="'+ type +'-cancel"></span>' 
                    + '<span class="'+ type +'-button"></span>'
                    + '<input type="hidden name="'+ (options.name || '') +'" />';

                options.hidden = true;
                if (options.value) {
                    options.value += '';
                }
            },
            function (el, options) {
                var childs;
                
                if (options.value) {
                    UI_INPUT_CONTROL_CLASS.setValue.call(this, options.value);
                }

                childs = children(el);

                this._eText = childs[0];
                this._uCancel = $fastCreate(this.Cancel, childs[1], this);
                this._uLayer = $fastCreate(this.Layer, options._eLayer, this, {asyn : options.asyn});
                options._eLayer = null;
                delete options._eLayer;

                if (options.hideCancel === true) {
                    this._bHideCancel = true;
                    this._uCancel.$hide();
                }
            }
        ),

        UI_INPUT_TREE_CLASS = UI_INPUT_TREE.prototype,

        UI_INPUT_TREE_LAYER = UI_INPUT_TREE_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-input-tree-layer',
            null,
            function (el, options) {
                el.style.position = 'absolute';
                // 改为在setData中创建
                // this._uTree = $fastCreate(this.Tree, el.firstChild, this, {collapsed:true, asyn: options.asyn});
            }
        ),
        UI_INPUT_TREE_LAYER_CLASS = UI_INPUT_TREE_LAYER.prototype,
        
        UI_DATA_TREE = ui.DataTree,
        
        UI_INPUT_TREE_CANCEL_CLASS = (UI_INPUT_TREE_CLASS.Cancel = inheritsControl(UI_CONTROL)).prototype,
        UI_INPUT_TREE_LAYER_TREE_CLASS = (UI_INPUT_TREE_LAYER_CLASS.Tree = inheritsControl(UI_DATA_TREE)).prototype;

    function UI_INPUT_TREE_FLUSH(con) {
        if (con.getValue() == '') {
            con._uCancel.hide();
        }
        else if (!con._bHideCancel) {
            con._uCancel.show();
        }
    }

    //////////////////////////
    /**
     * 设置初始值
     *
     * @public
     * @param {Object} data 数据
     * @param {Object} data.root 初始树根
     *      每个节点内容为：
     *          {string} text
     *          {string} value
     *          {boolean} isLeaf
     * @param {string} data.selected 初始选中
     */
    UI_INPUT_TREE_CLASS.setData = function (data, options) {
        options = options || {};

        if (!data || !data.root) {
            return;
        }

        var html = [];

        function travelTree(node, isRoot) {
            var children = node.children || [];

            if (children.length == 0) {
                html.push(
                    '<div ecui="value:', encodeHTML(String(node.value)), ';isLeaf:', !!node.isLeaf, '">',
                         encodeHTML(node.text),
                    '</div>'
                );
            }
            else {
                html.push(
                    '<div>',
                        '<label ecui="value:', encodeHTML(String(node.value)), ';isLeaf:', !!node.isLeaf, '">',
                             encodeHTML(node.text),
                        '</label>'
                );
                for (var i = 0, child; child = children[i]; i ++) {
                    travelTree(child);
                }
                html.push('</div>');
            }
        }

        travelTree(data.root);

        var layer = this._uLayer;
        var o = layer.getBody();
        o.innerHTML = html.join('');
        addClass(o.firstChild, UI_DATA_TREE.types[0]);
        
        layer._uTree = $fastCreate(
            layer.Tree, 
            o.firstChild,
            layer, 
            extend(
                { 
                    collapsed: true, 
                    value: String(data.root.value),
                    isLeaf: data.root.isLeaf
                }, 
                options
            )
        );

        layer._uTree.init();
        
        if (data.selected != null ) {
            this.setValue(String(data.selected));
        }
    }

    UI_INPUT_TREE_CLASS.$activate = function () {
        this._uLayer.show();
    }
    UI_INPUT_TREE_CLASS.getValue = function () {
    
        var text = this._eText.innerHTML;
        var value = this._eInput.value;
        return {
            text: text,
            value: value
        }
    }

    UI_INPUT_TREE_CLASS.init = function () {
        var value = this.getValue();

        this.setValue(value);
        this._uLayer.init();
        UI_INPUT_CONTROL_CLASS.init.call(this);
    }

    UI_INPUT_TREE_CLASS.$setText = function (value) {
        if (value && value.length > 15) {
            value = value.substring(0, 15) + '...';
        }
        this._eText.innerHTML = value;
    }

    UI_INPUT_TREE_CLASS.setValue = function (value) {
        var tree = this._uLayer._uTree;
        if (!tree) { return; }

        if ('[object Object]' == Object.prototype.toString.call(value)) {
            UI_INPUT_CONTROL_CLASS.setValue.call(this, value.value);
            tree.clearSelected();
            tree.setValues([value.value]);
            this.$setText(tree.getSelectedText());
            UI_INPUT_TREE_FLUSH(this);
        }
        else {
            //转化为字符串
            value = value + '';
            UI_INPUT_CONTROL_CLASS.setValue.call(this, value);
            tree.clearSelected();
            tree.setValues([value]);
            this.$setText(tree.getSelectedText());
            UI_INPUT_TREE_FLUSH(this);
        }
    }

    UI_INPUT_TREE_CLASS.clear = function () {
        var tree = this._uLayer._uTree;

        tree.clearSelected();
        UI_INPUT_CONTROL_CLASS.setValue.call(this, '');
        this.$setText('');
        UI_INPUT_TREE_FLUSH(this);
    }

    /**
     * 重新收起input-tree,清理用户操作痕迹
     * @public
     */
    UI_INPUT_TREE_CLASS.clearState = function() {
        var tree = this._uLayer._uTree;
        collapseTree(tree);

        function collapseTree(tree) {
            tree.collapse();
            var children = tree.getChildren();
            if (children && children.length) {
                for (var i = 0; i < children.length; i++) {
                    collapseTree(children[i]);
                }
            }
        };
    };

    /**
     * 根据value获取树中的节点
     * @public
     * @param {string} value 
     */
    UI_INPUT_TREE_CLASS.getTreeNodeByValue = function(value) {
        return this._uLayer.getTreeNodeByValue(value);
    };

    /**
     * 设置输入文本框的值
     * @public
     * @param {string} text
     */
    UI_INPUT_TREE_CLASS.setText = function(text) {
        this.$setText(text);
    };

    UI_INPUT_TREE_CLASS.expand = function (value, callback) {
        var me = this;

        this._uLayer.expand(value, function () {
            callback.call(me);
        });
    }

    UI_INPUT_TREE_CLASS.selectParent = function (value) {
        var node = this._uLayer.getTreeNodeByValue(value);

        if (node != node.getRoot()) {
            node = node.getParent();
        }
        
        this.setValue(node.getValue());
    }

    UI_INPUT_TREE_LAYER_CLASS.init = function () {
        this._uTree && this._uTree.init();
        UI_CONTROL_CLASS.init.call(this);
    }

    UI_INPUT_TREE_LAYER_CLASS.$blur = function () {
        this.hide();
    }

    UI_INPUT_TREE_LAYER_CLASS.expand = function (value, callback) {
        var tree = this._uTree,
            node = tree.getItemByValue(value);
        if (node) {
            node.expand();
            tree.onexpand(node, callback);
        }
    }

    UI_INPUT_TREE_LAYER_CLASS.getTreeNodeByValue = function (value) {
        return this._uTree.getItemByValue(value);
    }

    UI_INPUT_TREE_LAYER_CLASS.show = function () {
        var par = this.getParent(), pos, o, view;

        UI_CONTROL_CLASS.show.call(this);

        if (par) {
            pos = getPosition(par.getOuter());
            view = getView();
            o = pos.top;
            /*
            if (o + par.getHeight() + this.getHeight() > view.bottom) {
                if (o - view.top > this.getHeight()) {
                    pos.top = o - this.getHeight();
                }
            }
            else {
                pos.top = o + par.getHeight();
            }
            */

            pos.top = o + par.getHeight();

            o = pos.left;
            if (o + this.getWidth() > view.right) {
                pos.left = o + par.getWidth() - this.getWidth();
            }
            else {
                pos.left = o;
            }
            this.setPosition(pos.left, pos.top);
            setFocused(this);
        }
    }

    UI_INPUT_TREE_CANCEL_CLASS.$click = function () {
        var par = this.getParent();
        UI_CONTROL_CLASS.$click.call(this);

        par.$setText('');
        UI_INPUT_CONTROL_CLASS.setValue.call(par, '');
        par._uLayer._uTree.clearSelected();
        UI_INPUT_TREE_FLUSH(par);
    }

    UI_INPUT_TREE_CANCEL_CLASS.$activate = UI_BUTTON_CLASS.$activate;

    UI_INPUT_TREE_LAYER_TREE_CLASS.onselect = function (con, added) {
        var superObj = this.getParent().getParent();
        UI_INPUT_CONTROL_CLASS.setValue.call(superObj, con.getValue());
        superObj.$setText(con.getText());
        UI_INPUT_TREE_FLUSH(superObj);
        this.getParent().hide();
    }

    UI_INPUT_TREE_LAYER_TREE_CLASS.onexpand = function (item, callback) {
        var superObj = this.getParent().getParent(),
            callback = callback || blank;
        
        var layer =  superObj._uLayer.getOuter(),
            scrollHeight = layer.scrollTop;
        var setScroll = function() {
           layer.scrollTop = scrollHeight ;
           layer = null;
        }
        if (item._bNeedAsyn) {
            triggerEvent(superObj, 'loadtree', null, [item.getValue(), function (data) {
                item.load(data); 
                callback.call(null);
                setScroll();
            }]);
            item._bNeedAsyn = false;
        }
        else {
            callback.call(null);
            setScroll();
        }
    }

    UI_INPUT_TREE_LAYER_TREE_CLASS.load = function (datasource) {
        var i, item, text;

        for (i = 0; item = this._aChildren[i]; i++) {
            disposeControl(item);
        }
        this._aChildren = [];
        this._eChildren.innerHTML = '';

        if (!datasource || datasource.length <= 0) {
            this.setClass(this.getPrimary());
            return;
        }

        for (i = 0; item = datasource[i]; i++) {
            text = item.text;
            item = extend({asyn: this._bAsyn}, item);
            delete item.text;
            this.add(text, null, item).init();
        }
        
    }
})();

/**
 * di.shared.adapter.EcuiInputTreeVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui input-tree的适配器
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {

    var ecuiCreate = di.helper.Util.ecuiCreate;
    var dateToString = xutil.date.dateToString;
    var isArray = xutil.lang.isArray;
    var DICT = di.config.Dict;

    /**
     * ecui input tree的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiInputTreeVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @return {Object} 创建的实例
     */
    function create(def, options) {
        // 控件初始化所须
        options.hideCancel = true;
        options.asyn = true;

        var ctrl = ecuiCreate(def.clz, def.el, null, options);

        ctrl.$di('registerEventAgent', 'async');

        // 挂接事件
        ctrl.onloadtree = function (value, func) {
            /**
             * 异步加载统一的事件
             *
             * @event
             */
            ctrl.$di(
                'dispatchEvent',
                'async',
                [
                    value,
                    function (data) {
                        func((data.datasource || {}).children || []);
                    }
                ]
            );
        }

        // 赋予全局浮层id，用于自动化测试的dom定位
        ctrl._uLayer.getOuter().setAttribute(DICT.TEST_ATTR, def.id);

        return ctrl;
    }

    /**
     * 设置初始化数据
     * 
     * @public
     * @param {Object} data 数据
     */
    function setData(data) {
        if (!data) {
            return;
        }

        this.setData(
            { 
                root: data.datasource,
                selected: isArray(data.value) 
                    ? data.value[0] 
                    : (data.value || (data.datasource || {}).value)
            }, 
            { 
                hideCancel: data.hideCancel == null 
                    ? true : data.hideCancel, 
                asyn: data.asyn == null 
                    ? true : data.asyn
            }
        );
    }

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    function getValue() {
        var v = this.getValue();
        return v ? [v.value] : [];
    }

})();


/*
Suggest - 定义模拟下拉框行为的基本操作。
下拉框控件，继承自输入控件，实现了选项组接口，扩展了原生 SelectElement 的功能，允许指定下拉选项框的最大选项数量，在屏幕显示不下的时候，会自动显示在下拉框的上方。在没有选项时，下拉选项框有一个选项的高度。下拉框控件允许使用键盘与滚轮操作，在下拉选项框打开时，可以通过回车键或鼠标点击选择，上下键选择选项的当前条目，在关闭下拉选项框后，只要拥有焦点，就可以通过滚轮上下选择选项。

下拉框控件直接HTML初始化的例子:

<div ecui="type:suggest;">

</div>

属性
_nOptionSize  - 下接选择框可以用于选择的条目数量
_cSelected    - 当前选中的选项
_uText        - suggest的文本框
_uOptions     - 下拉选择框
*/
//{if 0}//
;
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,
        trim = string.trim,
        undefined,
        DOCUMENT = document,
        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getText = dom.getText,
        insertAfter = dom.insertAfter,
        insertBefore = dom.insertBefore,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        encodeHTML = string.encodeHTML,
        extend = util.extend,
        getView = util.getView,
        setDefault = util.setDefault,

        $fastCreate = core.$fastCreate,
        getAttributeName = core.getAttributeName,
        getFocused = core.getFocused,
        inheritsControl = core.inherits,
        intercept = core.intercept,
        mask = core.mask,
        restore = core.restore,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_SCROLLBAR = ui.Scrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SELECT
    ///__gzip_original__UI_SUGGEST_CLASS
    /**
     * 初始化下拉框控件。
     * options 对象支持的属性如下：
     * browser        是否使用浏览器原生的滚动条，默认使用模拟的滚动条
     * optionSize     下拉框最大允许显示的选项数量，默认为10
     * optionsElement 下拉选项主元素
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_SUGGEST = ui.Suggest =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-suggest',
            function (el, options) {
                var me = this;
                var name = el.name || options.name || '',
                    type = this.getType(),

                    id = options.id || 'id_notset',
                    optionsEl = createDom(
                        type + '-options' + this.Options.TYPES,
                        'position:absolute;z-index:65535;display:none'
                    );

                optionsEl.setAttribute('ecui_id', id);
                   
                setDefault(options, 'hidden', true);

                
                moveElements(el, optionsEl);

                el.innerHTML =
                '<span class="ui-input"></span><input name="' + name + '" value="' +
                        encodeHTML(options.value || '') + '">';

                el.appendChild(optionsEl);
                //延迟400ms触发query事件
                this._nTimeout = 400;
                //延迟的句柄
                this._nTimeoutHandler = null;
                return el;
            },
            function (el, options) {
                if (options.timeout) {
                    this._nTimeout =  options.timeout;
                }
                if (options.hide) {
                    this.getOuter().style.display = 'none'; 
                }
                el = children(el);
                var me = this;
                //上次输入的值
                this._nLastText = '';
                this._uText = $fastCreate(UI_INPUT_CONTROL, el[0], this, {capturable: false});


                this._uOptions = $fastCreate(
                    this.Options,
                    removeDom(el[2]),
                    this,
                    {hScroll: false, browser: options.browser}
                );

                this.$setBody(this._uOptions.getBody());
                // 初始化下拉区域最多显示的选项数量
                this._nOptionSize = options.optionSize || 10;

                this.$initItems();

                //注册change事件
                this._uText.$change = EVENT_TEXT_CHANGE;
                //取消滚轮事件
                //this._uText.$mousewheel = function() {};
                
            }
        ),
        UI_SUGGEST_CLASS = UI_SUGGEST.prototype,

        /**
         * 初始化下拉框控件的下拉选项框部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_SUGGEST_OPTIONS_CLASS = (UI_SUGGEST_CLASS.Options = inheritsControl(UI_PANEL)).prototype,

        /**
         * 初始化下拉框控件的选项部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_SUGGEST_ITEM_CLASS =
            (UI_SUGGEST_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    this._sValue = options.value === undefined ? getText(el) : '' + options.value;
                }
            )).prototype;

    /**
    * 事件处理
    * @event 注册input文本框的onchange事件
    */
    function EVENT_TEXT_CHANGE() {
        var par = this.getParent(); 
        var value = par.getValue(); 
        
        //触发onchange事件
        triggerEvent(par, 'change', value); 
        var txt= par.getText();
        var lastTxt = par._nLastText;
        //trim后没有内容 所以不查找
        if (trim(txt) == '') {
            return; 
        }
        //如果输入不相符 就致空value
        if (trim(txt) != trim(lastTxt)) {

            par._eInput.value = '';
        } 
        //因为改变了文本，理论值不一样了
        //触发onquery事件
        if (par._nTimeoutHandler) {
            //清除之前的句柄
            clearTimeout(par._nTimeoutHandler); 
        }
        //延迟触发onquery事件
        par._nTimeoutHandler = setTimeout(function() {
            //清空事件句柄
            par._nTimeoutHandler = null;      
            triggerEvent(par, 'query', value);
            
        }, par._nTimeout);
            
    }
    /**
    * 填充输入的文字自动匹配value值
    * 用户输入文本以后 寻找相关的id,并填入sugguest框 
    * @param {ecui{Object}} suggest控件本身
    * @param {array[Object]} suggest控件本身
    * @param {string} suggest控件本身的text
    */
    function  AUTO_FILL_VALUE(ele, list, text) {
        list = list || [];
        var value = null;
        for (var i = 0, item; item = list[i++];) {
            if (item.text == text) {
                value = item.value; 
                break;
            }
        
        }
        //渲染
        if (value != null) {
            ele._eInput.value = value;
            //触发onslect
            triggerEvent(ele, 'select', {value: value, text:text}); 
        }
     
    }
//{else}//
    /**
     * 下拉框刷新。
     * @private
     *
     * @param {ecui.ui.Select} control 下拉框控件
     */
    function UI_SUGGEST_FLUSH(control) {
        var options = control._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            el = options.getOuter(),
            pos = getPosition(control.getOuter()),
            selected = control._cSelected,
            optionTop = pos.top + control.getHeight();

        if (!getParent(el)) {
            // 第一次显示时需要进行下拉选项部分的初始化，将其挂载到 DOM 树中
            DOCUMENT.body.appendChild(el);
            control.cache(false, true);
            control.$alterItems();
        }
        else {

            control.cache(false, true);
            control.$alterItems();
        }

        if (options.isShow()) {
            if (selected) {
                //setFocused(selected);
            }
            scrollbar.setValue(scrollbar.getStep() * indexOf(control.getItems(), selected));

            // 以下使用control代替optionHeight
            control = options.getHeight();

            // 如果浏览器下部高度不够，将显示在控件的上部
            options.setPosition(
                pos.left,
                optionTop + control <= getView().bottom ? optionTop : pos.top - control
            );
        }
    }

    /**
     * 改变下拉框当前选中的项。
     * @private
     * @param {ecui.ui.Select} control 下拉框控件
     * @param {ecui.ui.Select.Item} item 新选中的项
     */
    function UI_SUGGEST_CHANGE_SELECTED(control, item) {
        if (item !== control._cSelected) {

            UI_INPUT_CONTROL_CLASS.setValue.call(control, item ? item._sValue : '');
            var text = item ? item.getBody().innerHTML : '';
            control._uText.setValue(text);
            //FIX: setValue为一个对象
            control._cSelected = item;
            if (control._uOptions.isShow()) {
                setFocused(item);
            }
            //设置选中的值
            if (item && item._sValue) {


                //suggest选择事件
                //选择事件的触发
                //
                triggerEvent(control, 'select', {value: item._sValue, text:text}); 
                triggerEvent(control, item._sValue);
                //设置焦点到最后
                //bugfix ie可能会选择以后会有显示在前边问题
                setFocused(control);
                control.setFocusToEnd();
            }
        }
    }

    extend(UI_SUGGEST_CLASS, UI_ITEMS);

    /**
     * 销毁选项框部件时需要检查是否展开，如果展开需要先关闭。
     * @override
     */
    UI_SUGGEST_OPTIONS_CLASS.$dispose = function () {
        this.hide();
        UI_PANEL_CLASS.$dispose.call(this);
    };

    /**
     * 关闭选项框部件时，需要恢复强制拦截的环境。
     * @override
     */
    UI_SUGGEST_OPTIONS_CLASS.$hide = function () {
        UI_PANEL_CLASS.$hide.call(this);
        mask();
        restore();
    };

    /**
     * 对于下拉框选项，鼠标移入即自动获得焦点。
     * @override
     */
    UI_SUGGEST_ITEM_CLASS.$mouseover = function (event) {
        UI_ITEM_CLASS.$mouseover.call(this, event);
        setFocused(this);
    };

  
    /**
     * 获取选项的值。
     * getValue 方法返回选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @return {string} 选项的值
     */
    UI_SUGGEST_ITEM_CLASS.getValue = function () {
       
        return this._sValue;
    };
    /**
     * 获取选项的值。
     * getText 方法返回选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @return {string} 选项的值
     */
    UI_SUGGEST_ITEM_CLASS.getText = function () {
       
        return this._eBody.innerHTML;
    };
    /**
     * 设置选项的值。
     * setValue 方法设置选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @param {string} value 选项的值
     */
    UI_SUGGEST_ITEM_CLASS.setValue = function (value) {
        var parent = this.getParent();
        this._sValue = value;
        if (parent && this == parent._cSelected) {
            // 当前被选中项的值发生变更需要同步更新控件的值
            UI_INPUT_CONTROL_CLASS.setValue.call(parent, value);
        }
    };

    /**
     * 下拉框控件激活时，显示选项框，产生遮罩层阻止对页面内 DOM 节点的点击，并设置框架进入强制点击拦截状态。
     * @override
     */
    UI_SUGGEST_CLASS.$activate = function (event) {
        if (!(event.getControl() instanceof UI_SCROLLBAR)) {
            UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
            //这里不需要弹出层 ？？？
            return;
            this._uOptions.show();
            // 拦截之后的点击，同时屏蔽所有的控件点击事件
            intercept(this);
            mask(0, 65534);
            UI_SUGGEST_FLUSH(this);
            event.stopPropagation();
        }
    };

    /**
     * 选项控件发生变化的处理。
     * 在 选项组接口 中，选项控件发生添加/移除操作时调用此方法。虚方法，子控件必须实现。
     * @protected
     */
    UI_SUGGEST_CLASS.$alterItems = function () {
        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            step = this.getBodyHeight(),
            width = this.getWidth(),
            itemLength = this.getItems().length;

        if (getParent(options.getOuter())) {
            // 设置选项框
            scrollbar.setStep(step);

            // 为了设置激活状态样式, 因此必须控制下拉框中的选项必须在滚动条以内
            this.setItemSize(
                width - options.getMinimumWidth() - (itemLength > optionSize ? scrollbar.getWidth() : 0),
                step
            );

            // 设置options框的大小，如果没有元素，至少有一个单位的高度
            options.$$mainHeight = itemLength * step + options.$$bodyHeightRevise;
            options.$setSize(width, (MIN(itemLength, optionSize) || 1) * step + options.getMinimumHeight());
        }
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$cache = function (style, cacheSize) {
        (getParent(this._uOptions.getOuter()) ? UI_ITEMS : UI_INPUT_CONTROL_CLASS)
            .$cache.call(this, style, cacheSize);
        this._uText.cache(false, true);
        this._uOptions.cache(false, true);
    };
    /**
     * 控件在下拉框展开时，需要拦截浏览器的点击事件，如果点击在下拉选项区域，则选中当前项，否则直接隐藏下拉选项框。
     * @override
     */
    UI_SUGGEST_CLASS.$intercept = function (event) {
        //__transform__control_o
        this._uOptions.hide();
        for (var control = event.getControl(); control; control = control.getParent()) {
            if (control instanceof this.Item) {
                if (control != this._cSelected) {
                    // 检查点击是否在当前下拉框的选项上
                    UI_SUGGEST_CHANGE_SELECTED(this, control);
                    //onchange事件需要参数 在这里获取并发送
                    var obj = {
                        text: control.getText(),
                        value: control._sValue
                    };
                    triggerEvent(this, 'change', obj);
                    //设置焦点到最后
                    //bugfix ie可能会选择以后会有显示在前边问题
                    //不需要这里调用了 直接在选中的时候调用
                    //setFocused(this);
                    //this.setFocusToEnd();
                }
                break;
            }
        }
        event.exit();
    };

    /**
     * 接管对上下键与回车/ESC键的处理。
     * @override
     */
    UI_SUGGEST_CLASS.$keydown = UI_SUGGEST_CLASS.$keypress = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type](event);

        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            which = event.which,
            list = this.getItems(),
            length = list.length,
            focus = getFocused();

        if (this.isFocused()) {

            // 当前不能存在鼠标操作，否则屏蔽按键
            if (which == 40 || which == 38) {
                //bugfix
                //shift + 40 是（  ，shift + 38 是 &
                if (event && event._oNative.shiftKey) {
                    return true; 
                }
                if (length) {

                    if (options.isShow()) {
                        var uFocus = list[which = MIN(MAX(0, indexOf(list, focus) + which - 39), length - 1)];
                        setFocused(uFocus);
                        which -= scrollbar.getValue() / scrollbar.getStep();
                        scrollbar.skip(which < 0 ? which : which >= optionSize ? which - optionSize + 1 : 0);
                        event.cancelBubble = true;
                    }
                    else {
                        //不需要选择列表里的item
                        return false;
                        
                        //this.setSelectedIndex(MIN(MAX(0, indexOf(list, this._cSelected) + which - 39), length - 1));
                    }

                }
                return false;
            }
            else if (which == 27 || which == 13 && options.isShow()) {
                // 回车键选中，ESC键取消
                options.hide();
                if (which == 13) {
                    if (focus instanceof this.Item) {
                        UI_SUGGEST_CHANGE_SELECTED(this, focus);
                        //onchange事件需要参数 在这里获取并发送
                        var obj = {
                            text: focus.getText(),
                            value: focus._sValue
                        };
                        //触发change事件
                        triggerEvent(this, 'change', obj);
                    }
                }
                return false;
            }
            else {
                //可以支持用户继续输入
                //bugfix: 这里有一个bug，keypress和keydown，which可能是0 所以不用处理不然firefox会丢失 item的焦点
                if (which != 0) {
                        
                    setFocused(this._uText); 
                }

            }

        }
        
    };

    /**
     * 如果控件拥有焦点，则当前选中项随滚轮滚动而自动指向前一项或者后一项。
     * @override
     */
    UI_SUGGEST_CLASS.$mousewheel = function (event) {
        if (this.isFocused()) {
            var options = this._uOptions,
                list = this.getItems(),
                length = list.length;

            if (options.isShow()) {
                options.$mousewheel(event);
            }
            else {
                //options表示当前选项的index
                options = indexOf(list, this._cSelected) + (event.detail > 0 ? 1 : -1);
                this.setSelectedIndex(
                    length ?
                        MIN(MAX(0, options), length - 1) : null
                );
                if (options >= 0 && options < length) {
                    //鼠标滚动触发change事件
                    //triggerEvent(this, 'change');
                }
            }

            event.exit();
        }
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$ready = function () {
        this.setValue(this.getValue());
    };

    /**
     * 下拉框移除子选项时，如果选项是否被选中，需要先取消选中。
     * @override
     */
    UI_SUGGEST_CLASS.remove = function (item) {
        if ('number' == typeof item) {
            item = this.getItems()[item];
        }
        if (item == this._cSelected) {
            //UI_SUGGEST_CHANGE_SELECTED(this);
        }
        return UI_ITEMS.remove.call(this, item);
    };

    /**
     * 添加选项需要根据情况继续cache操作
     * @override
     */
    UI_SUGGEST_CLASS.add = function (item, index, options) {
        item = UI_ITEMS.add.call(this, item, index, options);
        if (getParent(this._uOptions.getOuter())) {
            item.cache(true, true);
        }
        return item;
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$setSize = function (width, height) {
        UI_INPUT_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
        height = this.getBodyHeight();

        // 设置文本区域  不需要减去height
        // bugfix:  并非select 所以不要右侧的下拉箭头
        this._uText.$setSize(width = this.getBodyWidth(), height);
        //this._uText.$setSize(width = this.getBodyWidth() - height, height);

        
    };

    /**
     * 获取被选中的选项控件。
     * @public
     *
     * @return {ecui.ui.Item} 选项控件
     */
    UI_SUGGEST_CLASS.getSelected = function () {
        return this._cSelected || null;
    };
    /**
    * 获取选项的文本
    * @return {string} 选择的文本
    */
    UI_SUGGEST_CLASS.getText = function () {
        var txt = this._uText.getValue(); 
        return txt;
    };

    /**
    * 获取选项的文本
    * @param {string} 设置文本
    * @return {string} 选择的文本
    */
    UI_SUGGEST_CLASS.setText = function (txt) {
        this._uText.setValue(txt); 
    };
    /**
    * 获取suggest的文本框里的值
    */
    UI_SUGGEST_CLASS.getValue = function () {
        var value = this._eInput.value;
        var text = this.getText();
        var obj = {
            value: value,
            text: text
        };
        return obj; 
    };
    /**
     * 设置下拉框允许显示的选项数量。
     * 如果实际选项数量小于这个数量，没有影响，否则将出现垂直滚动条，通过滚动条控制其它选项的显示。
     * @public
     *
     * @param {number} value 显示的选项数量，必须大于 1
     */
    UI_SUGGEST_CLASS.setOptionSize = function (value) {
        this._nOptionSize = value;
        this.$alterItems();
        UI_SUGGEST_FLUSH(this);
    };

    /**
     * 根据序号选中选项。
     * @public
     *
     * @param {number} index 选项的序号
     */
    UI_SUGGEST_CLASS.setSelectedIndex = function (index) {
        UI_SUGGEST_CHANGE_SELECTED(this, this.getItems()[index]);
    };

    /**
     * 设置控件的值。
     * setValue 方法设置控件的值，设置的值必须与一个子选项的值相等，否则将被设置为空，使用 getValue 方法获取设置的值。
     * @public
     *
     * @param {string} value 需要选中的值
     */
    UI_SUGGEST_CLASS.setValue = function (oValue) {

        //{text:XX,value:XX}
        var value = oValue;
        if ('[object Object]' == Object.prototype.toString.call(oValue)) {
            value = oValue.value; 
        }
        
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            if (o._sValue == value) {
                UI_SUGGEST_CHANGE_SELECTED(this, o);
                //text
                this._nLastText = Ovalue.text || o.getBody().innerHTML;
                return;
            }
        }

        // 找不到满足条件的项，将选中的值清除
        UI_SUGGEST_CHANGE_SELECTED(this);
    };
    /**
    * 清除suggest里的内容
    */
    UI_SUGGEST_CLASS.clear = function () {
        var items = this.getItems() || [],
            len = items.length;
        while ( len-- > 0 ) {
            this.remove(0);
        }

        this._uOptions.reset();
    };
     /**
    * 重新渲染suggest里的内容
    * @param {Array[Object]} 数据源
    */
    UI_SUGGEST_CLASS.update = function (list) {
        //清空    
        this.clear();
        var item = null;
        var el = null;
        var control = this;
        for (var i = 0, o; o = list[i++];) {
          
            item = this.add(o.text, null, {value: o.value});  
            //以后可以增加title的标识的变量
            if (true) {
                item.getOuter().title = o.text;
            }
        }
        if (!this._uOptions.isShow()) {
            this._uOptions.show();
            // 拦截之后的点击，同时屏蔽所有的控件点击事件
            intercept(this);
            mask(0, 65534);
            UI_SUGGEST_FLUSH(this);
        }
        else {
            
            control.$alterItems();
        }
        //自动填充相关id，用户
        var txt = this.getText(txt);
        AUTO_FILL_VALUE(this, list, txt); 
        //updae控件以后需要focus到文本框
        setFocused(control._uText);
        //event.stopPropagation();
    };
    //聚焦到最后
    UI_SUGGEST_CLASS.setFocusToEnd = function() {
        var input = this._uText;  
        core.setFocused(input);
        input = input._eInput;
        var len = input.value.length;
        if (document.selection) {
            var sel = input.createTextRange();
            sel.moveStart('character', len);
            sel.collapse();
            sel.select();
        } 
        else if (typeof input.selectionStart == 'number'
                && typeof input.selectionEnd == 'number') {
            input.selectionStart = input.selectionEnd = len;
        }
        
        
    };
    UI_SUGGEST_CLASS.$mousewheel = function() {};
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * di.shared.adapter.EcuiSuggestVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui suggest的适配器
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var extend = xutil.object.extend;
    var ecuiCreate = di.helper.Util.ecuiCreate;

    /**
     * ecui suggest的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @param {string} options.valueType 提交时值的类型，可为
     *      'TEXT'：则getValue取到的值是text（默认）
     *      'VALUE'：则getValue取到的是value
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiSuggestVUIAdapter = function(def, options) {
        return {
            create: create,
            getValue: getValueFunc[options.valueType || 'TEXT']
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @return {Object} 创建的实例
     */
    function create(def, options) {
        var ctrl = ecuiCreate(def.clz, def.el, null, options);

        ctrl.$di('registerEventAgent', 'async');
        
        // 挂接事件
        ctrl.onquery = function (value) {
            /**
             * 异步加载统一的事件
             *
             * @event
             */
            ctrl.$di(
                'dispatchEvent',
                'async',
                [
                    (value || {}).text,
                    function (data) {
                        ctrl.update(data.datasource || []);
                    }
                ]
            );
        }

        return ctrl;
    }    

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {string} 数据
     */
    var getValueFunc = {
        TEXT: function () {
            return (this.getValue() || {}).text || '';
        },
        VALUE: function () {
            return (this.getValue() || {}).value || '';
        }
    }

})();


/**
 * input
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    count-input.js
 * desc:    带计数的文本输入框(input与textarea)
 * author:  cxl(chenxinle@baidu.com)
 *          modified by sushuang(sushuang@baidu.com) 
 * date:    2012/03/12
 */
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        attachEvent = util.attachEvent,
        createDom = dom.create,
        addClass = dom.addClass,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        insertAfter = dom.insertAfter,
        trim = string.trim,
        setFocused = core.setFocused,
        blank = util.blank,
        triggerEvent = core.triggerEvent,
        inheritsControl = core.inherits,
        getByteLength = string.getByteLength,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,


        UI_INPUT = ui.Input = inheritsControl(
            UI_INPUT_CONTROL,
            'ui-input',
            function (el, options) {
                options.resizable = false;
                this._bPromptDisabled = options.promptDisabled == null 
                    ? true : options.promptDisabled;
            },
            function (el, options) {
                var o, type = this.getType();
                
                this.getInput().style.border = '';

                if(options.maxLength){
                    this._sMaxLength = options.maxLength;
                }

                if (options.tip) {
                    o = createDom(type + '-tip', 'display:none');
                    o.innerHTML = options.tip;
                    this.getBody().appendChild(o);
                    this._eTip = o;
                    attachEvent(this._eTip, 'keypressdown', UI_INPUT_TIP_HANDLER);
                }
            }
        ),
        UI_INPUT_CLASS = UI_INPUT.prototype,

        UI_TEXTAREA = ui.Textarea = inheritsControl(
            UI_INPUT,
            'ui-textarea',
            function (el, options) {
                options.inputType = 'textarea';
                this._bCountDisabled = options.countDisabled;
            }
        ),
        UI_TEXTAREA_CLASS = UI_TEXTAREA.prototype;

    var COUNT_NORMAL_TPL = '还可以输入$字',
        COUNT_OVERFLOW_TPL = '已经超过$字',
        CHAR_SET = 'gbk';

    function UI_INPUT_TIP_HANDLER(event) {
        var e = event || window.event,
            con;
        e = e.target || e.srcElement;
        con = e.parentNode.getControl();
        con.getInput().focus();
    }

    function UI_INPUT_TIP_DISPLAY(con, show) {
        if (con._eTip) {
            con._eTip.style.display = show ? '' : 'none';
        }
    }

    UI_INPUT_CLASS.$keydown = function () {
        UI_INPUT_TIP_DISPLAY(this, false);
    };

    UI_INPUT_CLASS.$keyup = function () {
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }        
    };

    UI_INPUT_CLASS.$change = function () {
        this.$updateCount();
    };

    UI_INPUT_CLASS.$updateCount = function () {
        var value = this.getValue(),
            type = this.getType(),
            byteLength,
            remain;
        
        if (this._sMaxLength && this._eCount){
            byteLength = getByteLength(value, CHAR_SET);

            if (byteLength > this._sMaxLength){
                remain = [
                    '<span class="', type, '-count-overflow">',
                        Math.ceil((byteLength - this._sMaxLength) / 2),
                    '</span>'
                ].join('');
                this._eCount.innerHTML = COUNT_OVERFLOW_TPL.replace('$', remain);
            }
            else {
                remain = [
                    '<span class="', type, '-count-normal">',
                        Math.floor((this._sMaxLength - byteLength) / 2),
                    '</span>'
                ].join('');
                this._eCount.innerHTML = COUNT_NORMAL_TPL.replace('$', remain);
            }
        }
    };

    UI_INPUT_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }
    };

    UI_INPUT_CLASS.$focus = function () {
        UI_CONTROL_CLASS.$focus.call(this);
        UI_INPUT_TIP_DISPLAY(this, false);
    };

    UI_INPUT_CLASS.$setSize = blank;

    UI_INPUT_CLASS.setValue = function (value) {
        UI_INPUT_CONTROL_CLASS.setValue.call(this, value);
        UI_INPUT_TIP_DISPLAY(this, value ? false : true);
        this.$updateCount();
    };

    UI_INPUT_CLASS.init = function () {
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }
        var type = this.getType();
        if (!this._bPromptDisabled) {
            if (!this._eBar) {
                this._eBar = createDom(type + '-bar');
                insertAfter(this._eBar, this.getOuter());
            }
            this._eBar.appendChild(
                this._ePrompt = createDom(type + '-prompt')
            );
        }
        UI_INPUT_CONTROL_CLASS.init.call(this);
    };

    /**
     * 显示错误
     *
     * @public
     * @param {boolean} error true则显示错误，false则还原
     * @prompt {string} 提示信息
     */
    UI_INPUT_CLASS.setErrorView = function (error, prompt) {
        if (error) {
            addClass(this.getOuter(), this.getType() + '-error');
        } 
        else {
            removeClass(this.getOuter(), this.getType() + '-error');
        }
        if (this._ePrompt) {
            this._ePrompt.innerHTML = prompt == null ? '' : prompt
        }
    };

    UI_TEXTAREA_CLASS.init = function () {
        var type = this.getType();
        if (this._sMaxLength && !this._bCountDisabled) {
            if (!this._eBar) {
                this._eBar = createDom(type + '-bar');
                insertAfter(this._eBar, this.getOuter());
            }            
            this._eBar.appendChild(
                this._eCount = createDom(type + '-count')
            );
            this.$updateCount();
        }
        UI_TEXTAREA.superClass.init.call(this);
    };

    UI_TEXTAREA_CLASS.$dispose = function () {
        removeDom(this._eBar);
        this._eBar = null;
        this._eCount = null;
        this._ePrompt = null;

        UI_TEXTAREA.superClass.$dispose.call(this);
    }

})();

/**
 * ecui.ui.HButton
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   可定制皮肤的左右结构的button
 * @author: sushuang(sushuang@baidu.com)
 */

 (function () {
    
    var inheritsControl = ecui.inherits;
    var UI_BUTTON = ecui.ui.Button;
    var moveElements = ecui.dom.moveElements;
    var createDom = ecui.dom.create;
    var addClass = ecui.dom.addClass;

    /**
     * 可定制皮肤的左右结构的button
     *
     * @class
     * @param {Object} options 选项
     * @param {string} options.skin 皮肤（的css类）
     * @param {string} options.text 按钮上的文字
     */
    var UI_H_BUTTON = ecui.ui.HButton =
        inheritsControl(
            UI_BUTTON,
            null,
            function (el, options) {
                if (options.skin) {
                    addClass(el, options.skin);
                    options.primary = options.skin;
                }
            },
            function (el, options) {
                var type = this.getType();

                var o = createDom(type + '-text', '', 'span');
                this.$setBody(o);
                moveElements(el, o, true);

                el.appendChild(createDom(type + '-inner', ''));
                el.firstChild.appendChild(createDom(type + '-left', '', 'span'));
                el.firstChild.appendChild(o);
                el.firstChild.appendChild(createDom(type + '-right', '', 'span'));
            }
        );

    var UI_H_BUTTON_CLASS = UI_H_BUTTON.prototype;

 }) ();
/*
Tab - 定义分页选项卡的操作。
选项卡控件，继承自基础控件，实现了选项组接口。每一个选项卡都包含一个头部区域与容器区域，选项卡控件存在互斥性，只有唯一的一个选项卡能被选中并显示容器区域。

直接初始化选项卡控件的例子
<div ecui="type:tab;selected:1">
    <!-- 包含容器的选项卡 -->
    <div>
        <label>标题1</label>
        <!-- 这里是容器 -->
        ...
    </div>
    <!-- 仅有标题的选项卡，以下selected定义与控件定义是一致的，可以忽略其中之一 -->
    <label ecui="selected:true">标题2</label>
</div>

属性
_bButton         - 向前向后滚动按钮是否显示
_oSelected       - 初始化时临时保存当前被选中的选项卡
_aPosition       - 选项卡位置缓存
_cSelected       - 当前选中的选项卡
_uPrev           - 向前滚动按钮
_uNext           - 向后滚动按钮
$$titleWidth     - 标签区域的宽度

Item属性
_sContainer      - 容器 DOM 元素的布局属性
_eContainer      - 容器 DOM 元素
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        createDom = dom.create,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        first = dom.first,
        setStyle = dom.setStyle,
        extend = util.extend,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化选项卡控件。
     * options 对象支持的特定属性如下：
     * selected 选中的选项序号，默认为0
     * @protected
     *
     * @param {Object} options 初始化选项
     */
    ///__gzip_original__UI_TAB
    ///__gzip_original__UI_TAB_BUTTON
    ///__gzip_original__UI_TAB_ITEM
    var UI_TAB = ui.Tab =
        inheritsControl(
            UI_CONTROL,
            'ui-tab',
            null,
            function (el, options) {
                //__gzip_original__buttonParams
                var type = this.getType(),
                    o = createDom(type + '-title', 'position:relative;overflow:hidden');

                this._oSelected = options.selected || 0;

                // 生成选项卡头的的DOM结构
                o.innerHTML = '<div class="' + type + '-prev' + this.Button.TYPES +
                    '" style="position:absolute;display:none;left:0px"></div><div class="' +
                    type + '-next' + this.Button.TYPES +
                    '" style="position:absolute;display:none"></div><div class="' +
                    type + '-items" style="position:absolute;white-space:nowrap"></div>';

                moveElements(el, options = o.lastChild);
                el.appendChild(o);
                this.$setBody(options);

                this.$initItems();

                // 滚动按钮
                this._uNext = $fastCreate(this.Button, options = options.previousSibling, this);
                this._uPrev = $fastCreate(this.Button, options.previousSibling, this);
            }
        ),
        UI_TAB_CLASS = UI_TAB.prototype,

        /**
         * 初始化选项卡控件的按钮部件。
         * @protected
         *
         * @param {Object} options 初始化选项
         */
        UI_TAB_BUTTON_CLASS = (UI_TAB_CLASS.Button = inheritsControl(UI_BUTTON, 'ui-tab-button')).prototype,

        /**
         * 初始化选项卡控件的选项部件。
         * options 对象支持的特定属性如下：
         * selected 当前项是否被选中
         * @protected
         *
         * @param {Object} options 初始化选项
         */
        UI_TAB_ITEM_CLASS =
            (UI_TAB_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    //__gzip_original__parent
                    var parent = options.parent;

                    if (el.tagName != 'LABEL') {
                        var o = first(el),
                            tmpEl;

                        moveElements(el, tmpEl = createDom(options.primary + '-container'), true);
                        el.appendChild(o);
                        this.setContainer(tmpEl);
                    }

                    setStyle(el, 'display', 'inline-block');

                    if (parent && options.selected) {
                        parent._oSelected = this;
                    }
                }
            )).prototype;
//{else}//
    /**
     * 刷新向前向右滚动按钮的可操作状态。
     * @private
     *
     * @param {ecui.ui.Tab} control Tab 控件对象
     */
    function UI_TAB_FLUSH_BUTTON(control) {
        var left = toNumber(control.getBody().style.left);

        control._uPrev[left < control._uPrev.getWidth() ? 'enable' : 'disable']();
        control._uNext[
            left > control.getBodyWidth() - control.$$titleWidth - control._uNext.getWidth() ? 'enable' : 'disable'
        ]();
    }

    extend(UI_TAB_CLASS, UI_ITEMS);

    /**
     * @override
     */
    UI_TAB_BUTTON_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);

        //__gzip_original__pos
        var parent = this.getParent(),
            style = parent.getBody().style,
            pos = parent._aPosition,
            index = parent.$getLeftMostIndex();

        index = MIN(
            MAX(0, index + (parent._uPrev == this ? toNumber(style.left) != pos[index] ? 0 : -1 : 1)),
            pos.length - 1
        );

        style.left = MAX(pos[index], parent.getBodyWidth() - parent.$$titleWidth - parent._uNext.getWidth()) + 'px';
        UI_TAB_FLUSH_BUTTON(parent);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$cache = function (style, cacheSize) {
        UI_ITEM_CLASS.$cache.call(this, style, cacheSize);

        this.$$marginLeft = toNumber(style.marginLeft);
        this.$$marginRight = toNumber(style.marginRight);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$click = function (event) {
        UI_ITEM_CLASS.$click.call(this, event);
        this.getParent().setSelected(this);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$dispose = function () {
        this._eContainer = null;
        UI_ITEM_CLASS.$dispose.call(this);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$setParent = function (parent) {
        //__gzip_original__el
        var el = this._eContainer;

        UI_ITEM_CLASS.$setParent.call(this, parent);
        if (el) {
            if (parent) {
                parent.getMain().appendChild(el);
            }
            else {
                removeDom(el);
            }
        }
    };

    /**
     * 获取选项卡对应的容器元素。
     * @public
     *
     * @return {HTMLElement} 选项卡对应的容器元素
     */
    UI_TAB_ITEM_CLASS.getContainer = function () {
        return this._eContainer;
    };

    /**
     * 设置选项卡对应的容器元素。
     * @public
     *
     * @param {HTMLElement} el 选项卡对应的容器元素
     */
    UI_TAB_ITEM_CLASS.setContainer = function (el) {
        var parent = this.getParent();

        if (this._eContainer) {
            removeDom(this._eContainer);
        }
        if (this._eContainer = el) {
            if ((this._sContainer = el.style.display) == 'none') {
                this._sContainer = '';
            }

            if (parent) {
                parent.getMain().appendChild(el);

                // 如果当前节点被选中需要显示容器元素，否则隐藏
                el.style.display = parent._cSelected == this ? this._sContainer : 'none';
            }
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$alterItems = function () {
        // 第一次进入时不需要调用$setSize函数，否则将初始化两次
        if (this._aPosition) {
            this.$setSize(this.getWidth());
        }

        for (
            var i = 0,
                list = this.getItems(),
                pos = this._aPosition = [this._uPrev.getWidth()],
                lastItem = {$$marginRight: 0},
                o;
            o = list[i++];
            lastItem = o
        ) {
            pos[i] = pos[i - 1] - MAX(lastItem.$$marginRight, o.$$marginLeft) - o.getWidth();
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$cache = function (style, cacheSize) {
        UI_ITEMS.$cache.call(this, style, cacheSize);

        this._uPrev.cache(true, true);
        this._uNext.cache(true, true);

        this.$$titleWidth = this.getBody().offsetWidth;
    };

    /**
     * 获得当前显示的选项卡中左边元素的索引，只在能左右滚动时有效。
     * @protected
     *
     * @return {number} 最左边元素的索引
     */
    UI_TAB_CLASS.$getLeftMostIndex = function () {
        for (var left = toNumber(this.getBody().style.left), pos = this._aPosition, i = pos.length; i--; ) {
            if (left <= pos[i]) {
                return i;
            }
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$remove = function (child) {
        if (this._cSelected == child) {
            var list = this.getItems(),
                index = indexOf(list, child);

            // 跳到被删除项的后一项
            this.setSelected(index == list.length - 1 ? index - 1 : index + 1);
        }

        UI_ITEMS.$remove.call(this, child);
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);

        //__gzip_original__prev
        //__gzip_original__next
        var prev = this._uPrev,
            next = this._uNext,
            style = this.getBody().style;

        width = this.getBodyWidth();
        if (this.$$titleWidth > width) {
            width -= next.getWidth();
            next.getOuter().style.left = width + 'px';

            if (this._bButton) {
                // 缩小后变大，右边的空白自动填补
                width -= this.$$titleWidth;
                if (toNumber(style.left) < width) {
                    style.left = width + 'px';
                }
            }
            else {
                prev.$show();
                next.$show();
                style.left = prev.getWidth() + 'px';
                this._bButton = true;
            }

            UI_TAB_FLUSH_BUTTON(this);
        }
        else if (this._bButton) {
            prev.$hide();
            next.$hide();
            style.left = '0px';
            this._bButton = false;
        }
    };

    /**
     * 获得当前选中的选项卡控件。
     *
     * @return {ecui.ui.Tab.Item} 选中的选项卡控件
     */
    UI_TAB_CLASS.getSelected = function () {
        return this._cSelected;
    };

    /**
     * @override
     */
    UI_TAB_CLASS.init = function () {
        this._uPrev.init();
        this._uNext.init();
        UI_ITEMS.init.call(this);
        for (var i = 0, list = this.getItems(), o; o = list[i++];) {
            o.$setSize(o.getWidth(), o.getHeight());
        }
        this.setSelected(this._oSelected);
    };

    /**
     * 设置被选中的选项卡。
     * @public
     *
     * @param {number|ecui.ui.Tab.Item} 选项卡子选项的索引/选项卡子选项控件
     */
    UI_TAB_CLASS.setSelected = function (item) {
        //__gzip_original__prev
        var i = 0,
            list = this.getItems(),
            prev = this._uPrev,
            style = this.getBody().style,
            left = toNumber(style.left),
            o;

        if ('number' == typeof item) {
            item = list[item];
        }
        if (this._cSelected != item) {
            for (; o = list[i++]; ) {
                if (o._eContainer) {
                    o._eContainer.style.display = o == item ? o._sContainer : 'none';
                }
            }

            if (this._cSelected) {
                this._cSelected.alterClass('-selected');
            }

            if (item) {
                item.alterClass('+selected');
                o = this._aPosition[indexOf(list, item)] - (prev.isShow() ? 0 : prev.getWidth());

                // 如果当前选中的项没有被完全显示(例如处于最左或最右时)，设置成完全显示
                if (left < o) {
                    style.left = o + 'px';
                }
                else {
                    o -= item.getWidth() 
                        + (prev.isShow() ? prev.getWidth() : 0) 
                        // + prev.getWidth()
                        + (this._uNext.isShow() ? this._uNext.getWidth() : 0)
                        // + this._uNext.getWidth()
                        - this.getBodyWidth();
                    if (left > o) {
                        style.left = o + 'px';
                    }
                }
                UI_TAB_FLUSH_BUTTON(this);
            }

            this._cSelected = item;
            triggerEvent(this, 'change');
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//
/**
 * ecui.ui.TabContainer
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    TAB页容器基类
 * author:  sushuang(sushuang@baidu.com)
 * depend:  ecui
 */

(function() {

    var array = ecui.array;
    var dom = ecui.dom;
    var ui = ecui.ui;
    var util = ecui.util;
    var string = ecui.string;
    var MAX = Math.max;

    var indexOf = array.indexOf;
    var $fastCreate = ecui.$fastCreate;
    var inheritsControl = ecui.inherits;
    var triggerEvent = ecui.triggerEvent;
    var disposeControl = ecui.dispose;
    var moveElements = dom.moveElements;
    var removeDom = dom.remove;
    var encodeHTML = string.encodeHTML;
    // 引了外部包
    var template = xutil.string.template;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var blank = util.blank;
    var q = xutil.dom.q;

    var createDom = dom.create;
    var getStyle = dom.getStyle;
    var extend = util.extend;

    var UI_CONTROL = ui.Control;
    var UI_TAB = ui.Tab;
    var UI_TAB_CLASS = UI_TAB.prototype;
    var UI_ITEMS = ui.Items;
    var UI_BUTTON = ui.Button;

    /**
     * tab控件
     * 
     * @class
     * @param {Object} options 初始化参数
     */
    var UI_TAB_CONTAINER = ui.TabContainer = inheritsControl(UI_TAB);
    var UI_TAB_CONTAINER_CLASS = UI_TAB_CONTAINER.prototype;
        
    var UI_TAB_ITEM_EXT_CLASS = (UI_TAB_CONTAINER_CLASS.Item = inheritsControl(
            UI_TAB_CLASS.Item, 
            null, 
            null,
            function(el, options) {
                var type = this.getType();

                el.innerHTML = template(TPL_ITEM, {   
                    currClass: this._sClass, 
                    content: el.innerHTML, 
                    close: options.canClose ? TPL_CLOSE_BTN : ''
                });
                    
                this._oMemo = options.memo;
                if (options.canClose) {
                    this._uCloseBtn = $fastCreate(
                        this.CloseBtn, 
                        q('q-close-btn', el)[0], 
                        this, 
                        { primary:'ui-tab-close-btn' }
                    );
                }
            }
        )).prototype;
        
    var UI_TAB_CLOSE_BTN_CLASS = (UI_TAB_ITEM_EXT_CLASS.CloseBtn = 
            inheritsControl(UI_BUTTON)).prototype;

    var UI_TAB_BUTTON_CLASS = (
            UI_TAB_CONTAINER_CLASS.Button = inheritsControl(
                UI_TAB_CLASS.Button,
                null,
                function(el, options) {
                    var type = this.getType();
                    el.appendChild(createDom(type + '-icon'));
                }
            )
        ).prototype;
    
    /*模板*/
    var TPL_ITEM = [
            '<div class="#{currClass}-ledge"></div>',
            '<div class="#{currClass}-lledge"></div>',
            '<div class="#{currClass}-inner">',
                '<span class="#{currClass}-text">#{content}</span>',
                '#{close}',
            '</div>',
            '<div class="#{currClass}-lledge"></div>',
            '<div class="#{currClass}-ledge"></div>'
        ].join('');
    var TPL_CLOSE_BTN = [
            '<span class="ui-tab-close-btn q-close-btn">',
                '<span class="ui-tab-close-btn-icon"></span>',
            '</span>'
        ].join('');
                    
    /**
     * @override
     */
    UI_TAB_CONTAINER_CLASS.$dispose = function() {
        UI_TAB_CONTAINER.superClass.$dispose.call(this);
    };        
        
    /**
     * @override
     */
    UI_TAB_CONTAINER_CLASS.$alterItems = function() {
        this.cache(true, true);
        UI_TAB_CONTAINER.superClass.$alterItems.call(this);
    };

    /**
     * 增加 tab
     * @public 
     * 
     * @param {ecui.ui.Control|Function} tabContent tab页内控件，
     *          或者用于创建页内控件的回调函数
     *          如果为回调函数，则函数参数为：
     *              {HTMLElement} tabEl item的container元素
     *              {ecui.ui.Tab} tabCtrl 父控件
     *              {ecui.ui.Item} tabItem项
     *          返回值为：
     *              {ecui.ui.Control} 页内对象
     * @param {Object} options 参数
     * @param {number} options.index 位置，可缺省
     * @param {string} options.title 页面标题，可缺省
     * @param {boolean} options.canClose 是否可以关闭，默认不可关闭
     * @param {HTMLElement=} options.tabEl 指定的tab el，可缺省
     * @param {HTMLElement=} options.contentEl 指定的content el，可缺省
     * @param {Any} options.memo 附加参数
     * @return {Object}
     *          {ecui.ui.Item} tabItem 子选项控件
     *          {(ecui.ui.Control|HTMLElement)} tabContent 子选项容器
     */    
    UI_TAB_CONTAINER_CLASS.addTab = function(tabContent, options) {
        options = options || {};
        options.canClose = options.canClose || false; 

        var el = options.tabEl;
        if (!el) {
            el = createDom();
            this.getBody().appendChild(el);
        }
        if (el.tagName != 'LABEL') {
            el.innerHTML = '<label>' + options.title + '</label>';
        }
        
        var tabItem = this.add(el, options.index, options);

        if (options.contentEl) {
            tabItem.setContainer(options.contentEl);
        }
        
        if (Object.prototype.toString.call(tabContent) 
                == '[object Function]'
        ) {
            tabContent = tabContent(
                tabItem.getContainer(),
                this,
                tabItem,
                options
            );
        }

        tabContent && tabContent.$setParent(this);

        return { tabItem: tabItem, tabContent: tabContent };
    };
        
    /**
     * 选择tab
     * @public
     * 
     * @param {ecui.ui.Item} tabItem 被选中的项的控件
     */
    UI_TAB_CONTAINER_CLASS.selectTab = function(tabItem) {
        this.setSelected(tabItem);
    };
    
    /**
     * 关闭tab
     * @public
     * 
     * @param {string} tabId tab的标志
     */
    UI_TAB_CONTAINER_CLASS.$closeTab = function(item) {
        this.remove(item);
    };
    
    //----------------------------------------
    // UI_TAB_ITEM_EXT
    //----------------------------------------
    
    /**
     * 得到附加信息
     * @public
     * 
     * @return {Any} 附加信息
     */
    UI_TAB_ITEM_EXT_CLASS.getMemo = function() {
        return this._oMemo;
    };

    /**
     * 更新标题，并支持过长截断
     * @public
     * 
     * @param {string} title 标题
     */
    UI_TAB_ITEM_EXT_CLASS.setTitle = function(title) {
        var titleEl = q(this._sClass + '-text', this.getOuter())[0];
        var parent = this.getParent();

        if (titleEl) {
            var fullTitle = encodeHTML(title);
            var shortTitle;
            if (textLength(title) > 36) {
                shortTitle = encodeHTML(textSubstr(title, 0, 36) + '...');
            } 
            else {
                shortTitle = fullTitle;
            }
            titleEl.innerHTML = '<label title="' + fullTitle + '">' 
                + shortTitle + '</label>';   

            parent.$alterItems();
            // 增加标题后调整位置
            // TODO
            // 这段逻辑晦涩复杂，效果差强人意，后续重构
            var style = parent.getBody().style;
            var left = parseInt(style.left);
            var itemIndex = indexOf(parent.getItems(), this);
            var itemLeft = parent._aPosition[itemIndex] 
                - (parent._uPrev.isShow() ? 0 : parent._uPrev.getWidth());

            if (left + parent.getBodyWidth() + itemLeft - this.getWidth() < 0) {
                style.left = 
                    MAX(
                        parent._aPosition[itemIndex], 
                        parent.getBodyWidth() - parent.$$titleWidth 
                            - parent._uNext.getWidth()
                    ) 
                    + 'px';
            }
        }
    };

    /**
     * 设置选项卡对应的容器元素。
     * （重载，不将容器元素添加到parent的eMain中。
     *
     * @public
     * @override
     * @param {HTMLElement} el 选项卡对应的容器元素
     */
    UI_TAB_ITEM_EXT_CLASS.setContainer = function (el) {
        var parent = this.getParent();

        if (this._eContainer) {
            removeDom(this._eContainer);
        }
        if (this._eContainer = el) {
            if ((this._sContainer = el.style.display) == 'none') {
                this._sContainer = '';
            }

            if (parent) {
                // 如果当前节点被选中需要显示容器元素，否则隐藏
                el.style.display = parent._cSelected == this 
                    ? this._sContainer : 'none';
            }
        }
    };
        
    /**
     * @override
     */
    UI_TAB_ITEM_EXT_CLASS.$click = function(event) {
        // 更改当前tab
        var par = this.getParent();
        var selected = par.getSelected();

        if (triggerEvent(par, 'beforechange', null, [this, selected]) !== false) {
            UI_TAB_CONTAINER_CLASS.Item.superClass.$click.apply(this, arguments);
            triggerEvent(par, 'afterchange', null, [this, selected]);
        }        
    };

    //----------------------------------------
    // UI_TAB_CLOSE_BTN
    //----------------------------------------
            
    /**
     * @override
     */
    UI_TAB_CLOSE_BTN_CLASS.$click = function(event) {
        // 关闭tab
        var item = this.getParent();
        var tabContainer = item.getParent();
        if (triggerEvent(tabContainer, 'tabclose', null, [item]) !== false) {
            tabContainer.$closeTab(item);
            tabContainer.$alterItems();
        }
        event.stopPropagation();
    };
    
})();


/**
 * di.shared.ui.DITab
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI tab容器
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var ecuiDispose = UTIL.ecuiDispose;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var ecuiCreate = UTIL.ecuiCreate;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var TAB_CONTAINER = ecui.ui.TabContainer;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI tab容器
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {boolean=} options.autoDeaf 使用deaf模式，
     *                  即隐藏时deaf内部实体，默认为true
     * @param {boolean=} options.autoComponentValueDisabled component自动在隐藏时valueDisabled模式，
     *                  即隐藏时value disable内部实体，默认为false
     * @param {boolean=} options.autoVUIValueDisabled vui自动在隐藏时使用valueDisabled模式，
     *                  即隐藏时value disable内部实体，默认为true
     */
    var DI_TAB = $namespace().DITab = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var DI_TAB_CLASS = DI_TAB.prototype;
    
    /**
     * 定义
     */
    DI_TAB_CLASS.DEF = {
        // 主元素的css
        className: 'di-tab',
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @constructor
     * @public
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this.$di('getEl');
        var o = document.createElement('div');
        el.appendChild(o);

        this._bAutoDeaf = options.autoDeaf == null ? true : options.autoDeaf;
        this._bAutoComponentValueDisabled = 
            options.autoComponentValueDisabled == null
                ? false : options.autoComponentValueDisabled;
        this._bAutoVUIValueDisabled = 
            options.autoVUIValueDisabled == null
                ? true : options.autoVUIValueDisabled;

        this._aTab = [];        
        // TODO
        // 后续要写成vui的形式，剥离ecui
        this._uTab = ecuiCreate(TAB_CONTAINER, o);
        this._aBodyPart = [];

        // 添加tab 创建vpart实例
        var tabs = this.$di('getRef', 'vpartRef', 'tab');
        var bodys = this.$di('getRef', 'vpartRef', 'body');
        for (var i = 0, tabDef, bodyDef; tabDef = tabs[i]; i ++) {
            bodyDef = bodys[i];
            this._aTab.push(
                this._uTab.addTab(
                    null, 
                    assign(
                        {
                            tabEl: tabDef.el,
                            contentEl: bodyDef.el
                        },
                        tabDef.$di('getOpt', 'dataOpt'),
                        ['title', 'canClose']
                    )
                )
            );

            this._aBodyPart.push(this.$di('vpartCreate', 'body.' + i));
        }
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_TAB_CLASS.init = function() {
        var me = this;

        // 事件绑定
        this._uTab.onafterchange = function(ctrlItem, lastCtrlItem) {

            // 设置耳聋
            me.$resetDisabled();

            for (
                var i = 0, item, bodyPart; 
                bodyPart = me._aBodyPart[i], item = me._aTab[i]; 
                i ++
            ) {
                /** 
                 * vpart显示事件
                 * 
                 * @event
                 */
                if (item.tabItem == ctrlItem) {
                    bodyPart.$di('dispatchEvent', 'active');
                }
                /** 
                 * vpart隐藏事件
                 * 
                 * @event
                 */
                if (item.tabItem == lastCtrlItem) {
                    bodyPart.$di('dispatchEvent', 'inactive');
                }
            }

            /**
             * 渲染完毕事件
             *
             * @event
             */
            me.$di('dispatchEvent', 'rendered');
            /**
             * tab更改事件
             *
             * @event
             */
            me.$di('dispatchEvent', 'change');
        }

        var opt = this.$di('getOpt', 'dataOpt');
        // 默认选中
        var selIndex = opt.selected - 1;
        var sel;
        if (sel = this._aTab[selIndex]) {
            this._uTab.selectTab(sel.tabItem);
            me.$di('dispatchEvent', 'rendered');
        }

        this.$resetDisabled();

        sel && this._aBodyPart[selIndex].$di('dispatchEvent', 'active');
    };

    /**
     * @protected
     */
    DI_TAB_CLASS.$resetDisabled = function() {
        var key = this.$di('getId');
        var bodys = this.$di('getRef', 'vpartRef', 'body', 'DEF');

        for (var i = 0, tab, inners, notCurr; tab = this._aTab[i]; i ++) {
            notCurr = this._uTab.getSelected() != tab.tabItem;

            inners = bodys[i].$di(
                'getRef', 'componentRef', 'inner', 'INS'
            ) || [];

            for (var j = 0; j < inners.length; j ++) {
                if (inners[j]) {
                    this._bAutoDeaf 
                        && inners[j].$di('setDeaf', notCurr, key);
                    this._bAutoComponentValueDisabled 
                        && inners[j].$di('setValueDisabled', notCurr, key);
                }
            }

            if (this._bAutoVUIValueDisabled) {
                inners = bodys[i].$di(
                    'getRef', 'vuiRef', 'inner', 'INS'
                ) || [];

                for (var j = 0; j < inners.length; j ++) {
                    inners[j] && inners[j].$di('setValueDisabled', notCurr, key);
                }
            }
        }    
    };

    /**
     * @override
     */
    DI_TAB_CLASS.dispose = function() {
        this._uTab && ecuiDispose(this._uTab);
        this._aTab = [];
        DI_TAB.superClass.dispose.call(this);
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_TAB_CLASS.resize = function() {
        this._uTab && this._uTab.resize();
    };

    /**
     * 解禁操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    DI_TAB_CLASS.enable = function(key) {
        this._uTab && this._uTab.enable();
        DI_TAB.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    DI_TAB_CLASS.disable = function(key) {
        this._uTab && this._uTab.disable();
        DI_TAB.superClass.disable.call(this);
    };

})();
/**
 * di.shared.model.OlapMetaConfigModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    元数据选择Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * 元数据选择Model
     *
     * @class
     * @extends xui.XDatasource
     * @param {Object} options
     * @param {Object} options.reportType
     * @param {Function=} options.commonParamGetter    
     */
    var OLAP_META_CONFIG_MODEL = 
            $namespace().OlapMetaConfigModel = 
            inheritsObject(XDATASOURCE, constructor);
    var OLAP_META_CONFIG_MODEL_CLASS = 
            OLAP_META_CONFIG_MODEL.prototype;
  
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 类型，TABLE 或者 CHART
         *
         * @type {string}
         * @private
         */
        this._sReportType = options.reportType || 'TABLE';
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
        /**
         * 指标列表
         *
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oIndList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * 维度列表
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oDimList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * selLine包装
         * key为selLine唯一名，value是selLine的list
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oSelLineWrap = new LINKED_HASH_MAP(null, 'k', 'l');
        /**
         * 元数据状态
         * dimMetas: {}
         * indMetas: {}
         *      {Array.<string>} validMetaNames
         *      {Array.<string>} selectedMetaNames
         *
         * @type {Object}
         * @private
         */
        this._oStatusWrap = {};
        /**
         * 图的属性
         *
         * @private
         */
        this._oSeriesCfg = null;
    }

    /**
     * @override
     */
    OLAP_META_CONFIG_MODEL_CLASS.init = function () {};

    var URL_MAP = {
        TABLE: {
            DATA: URL('META_CONDITION_IND_DIM_TABLE'),
            SELECT: URL('META_CONDITION_SELECT_TABLE')
        },
        CHART: {
            DATA: URL('META_CONDITION_IND_DIM_CHART'),
            SELECT: URL('META_CONDITION_SELECT_CHART'),
            LIST_SELECT: URL('META_CONDITION_LIST_SELECT_CHART')
        }
    };    

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.url = function (options) {
        return URL_MAP[this._sReportType][options.datasourceId];
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'OLAP_META_CONFIG_MODEL_DATA_' + getUID(),
            SELECT: 'OLAP_META_CONFIG_MODEL_SELECT_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            SELECT: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) { 
                return this._fCommonParamGetter(options.args.param);
            },
            SELECT: function (options) {
                var changeWrap = options.args.changeWrap;
                var paramArr = [];

                var param = {
                    from: changeWrap.from,
                    to: changeWrap.to,
                    toPosition: changeWrap.toPosition != null 
                        ? changeWrap.toPosition : -1,
                    needShowCalcInds: options.args.needShowCalcInds,
                    uniqNameList: []
                };

                param.uniqNameList.push.apply(
                    param.uniqNameList,
                    changeWrap.uniqNameList
                );

                return this._fCommonParamGetter(param);
            }, 
            LIST_SELECT: function (options) {
                var param = { indNames: [options.args.selected] };
                return this._fCommonParamGetter(param);
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: function (data, ejsonObj, options) {
                try {
                    var me = this;

                    this.$clean();
                    
                    // 指标维度元数据
                    var metaData = data['metaData'];
                    this._oIndList.appendAll(metaData['inds']);
                    this._oDimList.appendAll(metaData['dims']);

                    // 设置指标还是维度标记
                    setIndDimClazz.call(this, this._oIndList, 'IND');
                    setIndDimClazz.call(this, this._oDimList, 'DIM');

                    // 图的series属性（左右轴，图类型等）
                    // TODO
                    this._oSeriesCfg = data['seriesTypes']; 

                    // selLine处理
                    for (
                        var i = 0, key, list; 
                        key = data['index4Selected'][i]; 
                        i ++
                    ) {
                        this._oSelLineWrap.addLast(
                            {
                                k: key,
                                l: list = new LINKED_HASH_MAP(
                                    data['selected'][key], 
                                    'uniqName'
                                )
                            }
                        );
                        setIndDimClazz.call(this, list);
                    }

                    // 选中、禁用等状态
                    doMerge.call(this, data);
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            },

            SELECT: function (data, ejsonObj, options) {
                try {
                    // 选中、禁用等状态
                    doMerge.call(this, data);

                    // 提交成功才更新本地selected的Model数据
                    this.$updateSelected(options.args.changeWrap);
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            }
        }
    );

    /**
     * 对selected和meta进行融合
     * 
     * @private
     */
    function doMerge(data) {

        // 用selected中的status来覆盖进meta
        if (this._oStatusWrap = data['metaStatusData']) {
            // 处理、融合
            mergeStatus.call(
                this, 
                this._oStatusWrap.indMetas, 
                this._oIndList
            );
            mergeStatus.call(
                this, 
                this._oStatusWrap.dimMetas, 
                this._oDimList
            );
        }

        // 用meta中的其余信息（如fixed、align等）覆盖回selected
        var indList = this._oIndList;
        var dimList = this._oDimList;
        this._oSelLineWrap.foreach(
            function (selLineName, selLine, index) {
                selLine.foreach(function (key, item, idx) {
                    var o;
                    if ((o = indList.get(key))
                        || (o = dimList.get(key))
                    ) {
                        extend(item, o);
                    }
                });
            }
        );
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oIndList.clean();
                this._oDimList.clean();
                this._oSelLineWrap.clean();
                this._oStatusWrap = {};
            }
        }
    );

    OLAP_META_CONFIG_MODEL_CLASS.$clean = function() {
        this._oIndList.cleanWithoutDefaultAttr();
        this._oDimList.cleanWithoutDefaultAttr();
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        this._oStatusWrap = {};
        this._oSeriesCfg = null;
    }

    /**
     * 补充设置指标维度标志，根据字典
     *
     * @private
     */
    function setIndDimClazz(list, flag) {
        var me = this;
        list.foreach(
            function (key, o) {
                if (flag) {
                    o.clazz = flag;
                }
                else if (me._oIndList.containsKey(o.uniqName)) {
                    o.clazz = 'IND';
                }
                else if (me._oDimList.containsKey(o.uniqName)) {
                    o.clazz = 'DIM';
                }
            }
        );        
    }

    /**
     * 融合status
     *
     * @private
     */
    function mergeStatus(statusWrap, baseList) {
        // 先全设为disabled
        baseList.foreach(
            function (k, item, index) {
                item.status = DICT.META_STATUS.DISABLED;
            }
        );

        if (!statusWrap) { return; }

        var validMetaNames = statusWrap.validMetaNames;
        !validMetaNames 
            && (validMetaNames = statusWrap.validMetaNames = []);

        var selectedMetaNames = statusWrap.selectedMetaNames;
        !selectedMetaNames 
            && (selectedMetaNames = statusWrap.selectedMetaNames = []);

        // 用后台返回的normal和selected列表设置状态
        // 因为visible设定的影响，后台返回的项有可能含有baseList里不存在的（小明说灰常难改），
        // 所以在这里去除不存在的
        var i;
        var o;
        var item;
        for (i = 0; i < validMetaNames.length;) {
            if (item = baseList.get(validMetaNames[i])) {
                item.status = DICT.META_STATUS.NORMAL;
                i ++;
            }
            else {
                validMetaNames.splice(i, 1);
            }
        }
        for (i = 0; i < selectedMetaNames.length;) {
            if (item = baseList.get(selectedMetaNames[i])) {
                item.status = DICT.META_STATUS.SELECTED;
                i ++;
            }
            else {
                selectedMetaNames.splice(i, 1);
            }
        }

        // 接口定的有点乱，控件需要的其实是disabled列表
        var disabledMetaNames = statusWrap.disabledMetaNames = [];
        baseList.foreach(
            function (k, item, index) {
                if (item.status == DICT.META_STATUS.DISABLED) {
                    disabledMetaNames.push(k);
                }
            }
        );
    }

    /**
     * 得到selLine包装
     *
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    OLAP_META_CONFIG_MODEL_CLASS.getSelLineWrap = function () {
        return this._oSelLineWrap;
    };

    /**
     * 得到指标维度列表
     *
     * @public
     * @return {Object} 指标维度列表
     */
    OLAP_META_CONFIG_MODEL_CLASS.getIndDim = function () {
        return {
            indList: this._oIndList,
            dimList: this._oDimList
        };
    };

    /**
     * 得到指标维度最新状态
     *
     * @public
     * @return {Object} 指标维度最新状态
     */
    OLAP_META_CONFIG_MODEL_CLASS.getUpdateData = function () {
        return this._oStatusWrap;
    };

    /**
     * 根据uniqName得到项
     * 
     * @public
     * @param {string} uniqName
     * @return {Object} metaItem
     */
    OLAP_META_CONFIG_MODEL_CLASS.getMetaItem = function (uniqName) {  
        var item = this._oIndList.get(uniqName);
        if (!item) {
            item = this._oDimList.get(uniqName);
        }
        return item;
    };

    /**
     * 得到选择变化信息
     * 
     * @public
     * @param {Object} selLineWrap key为行列名，value为行列选中列表 
     * @return {Object} 返回值的key为from, to, toPosition
     */
    OLAP_META_CONFIG_MODEL_CLASS.diffSelected = function (selLineWrap) {
        var srcList;
        var removeList; 
        var addList;
        var changeWrap = { uniqNameList: [] };

        for (var name in selLineWrap) {
            srcList = this._oSelLineWrap.get(name);
            diffLineSelected.call(
                this, 
                name, 
                selLineWrap[name], 
                srcList, 
                changeWrap
            );
        }

        return changeWrap;
    };

    /**
     * 得到某行选择变化信息
     * 只支持三种可能：某项此行间换位值，拖离此行，拖进此行
     * （这些处理过于复杂，后端也重复实现了这些复杂逻辑，这
     *  源于定的from-to接口，合理的方式是重构，
     *  不使用from-to方式的接口，而是传当前状态）
     * 
     * @private
     * @param {string} lineName
     * @param {Array.<string>} currLine
     * @param {xutil.LinkedHashMap} srcList 
     * @param {Object} result
     */
    function diffLineSelected(lineName, currLine, srcList, result) {
        // 在此行间换位置的情况，检查出拖动的节点
        if (currLine.length == srcList.size()) {
            var diffKeySrc;
            var diffIndex;
            var tarIndexCurr;
            var tarIndexSrc;
            var tarKeySrc;
            srcList.foreach(
                function (key, value, index) {
                    if (diffIndex == null) {
                        if (key != currLine[index]) { 
                            // 出现了第一个不一样的值
                            diffKeySrc = key; 
                            diffIndex = index;
                        }
                    }
                    else {
                        if (diffKeySrc == currLine[index]) {
                            tarIndexCurr = index;
                        }
                        if (currLine[diffIndex] == key) {
                            tarIndexSrc = index;
                            tarKeySrc = key;
                        }
                    }
                }
            );
            if (diffIndex != null) {
                result.from = lineName;
                result.to = lineName;
                result.fromLineData = currLine;
                result.toLineData = currLine;
                if (tarIndexSrc > tarIndexCurr) {
                    result.uniqName = tarKeySrc;
                    result.toPosition = diffIndex;
                }
                else {
                    result.uniqName = diffKeySrc;
                    result.toPosition = tarIndexCurr;
                }
                result.uniqNameList.push(result.uniqName);
            }
        }
        // 拖进此行的情况
        else if (currLine.length > srcList.size()) {
            for (var i = 0, name; i < currLine.length; i ++) {
                name = currLine[i];
                if (!srcList.containsKey(name)) {
                    result.uniqName = name
                    result.uniqNameList.splice(0, 1, name);
                    result.to = lineName;
                    result.toLineData = currLine;
                    if (result.toPosition == null) {
                        result.toPosition = i;
                    }
                }
            }
        }
        // 拖离此行的情况（删除或者拖到别的行）
        else if (currLine.length < srcList.size()) {
            srcList.foreach(
                function (name, value, index) {
                    if (currLine[index] != name) {
                        result.uniqName = name
                        result.uniqNameList.push(name);
                        result.from = lineName;
                        result.fromLineData = currLine;
                        return false;
                    }
                }
            );
        }
        // FIXME
        // 临时处理，FIXME，后续改和后台的接口
        result.uniqNameList.splice(1, result.uniqNameList.length - 1);
    };

    /**
     * 设置条件选择变化
     * 
     * @protected
     * @param {Object} changeWrap
     * @param {Array.<string>} changeWrap.uniqNameList
     * @param {string} changeWrap.from
     * @param {string} changeWrap.to
     * @param {number} changeWrap.toPosition
     */
    OLAP_META_CONFIG_MODEL_CLASS.$updateSelected = function (changeWrap) {
        var fromList = changeWrap.from != changeWrap.to
                ? this._oSelLineWrap.get(changeWrap.from)
                : null;
        var toList = this._oSelLineWrap.get(changeWrap.to);

        var fromLineData = changeWrap.fromLineData;
        var toLineData = changeWrap.toLineData;
        var i = 0;
        var uniqName;

        if (fromList) {
            fromList.cleanWithoutDefaultAttr();
            for (i = 0; i < fromLineData.length; i ++) {
                uniqName = fromLineData[i];
                fromList.addLast(this.getMetaItem(uniqName));
            }
        }

        if (toList) {
            toList.cleanWithoutDefaultAttr();
            for (i = 0; i < toLineData.length; i ++) {
                uniqName = toLineData[i];
                toList.addLast(this.getMetaItem(uniqName));
            }
        }

        //----------------------------------
        // ONLY FOR TESTING. TO BE DELETED.
        // console.log(changeWrap);
        // console.log('      uniqNameList= ' + changeWrap.uniqNameList);
        // console.log('      from= ' + changeWrap.from);
        // console.log('      fromLineData= ' + changeWrap.fromLineData);
        // console.log('      to= ' + changeWrap.to);
        // console.log('      toLineData= ' + changeWrap.toLineData);
        // console.log('      toPosition= ' + changeWrap.toPosition);
        // this._oSelLineWrap.foreach(function (k, item, index) {
        //     console.log('LINE NAME::: ' + k);
        //     item.foreach(function (kk, oo, ii) {
        //         var arr = [];
        //         arr.push(kk);
        //         console.log('          ' + arr.join('  '));
        //     });
        // });
    };

    //------------------------------------------------
    // 拖拽规则
    //------------------------------------------------

    

})();


/**
 * di.shared.ui.OlapMetaConfig
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    多维分析报表原数据选择面板
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var ecuiDispose = UTIL.ecuiDispose;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var ecuiCreate = UTIL.ecuiCreate;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var getUID = xutil.uid.getIncreasedUID;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 元数据（指标维度）条件拖动选择
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {Object} options.reportType 类型，
     *          TABLE(默认)或者CHART
     * @param {string} options.submitMode 提交模式，可选值为
     *      'IMMEDIATE'（输入后立即提交，默认）
     *      'CONFIRM'（按确定按钮后提交）
     * @param {boolean} options.needShowCalcInds 计算列是否作为指标
     */
    var OLAP_META_CONFIG = $namespace().OlapMetaConfig = 
        inheritsObject(INTERACT_ENTITY);
    var OLAP_META_CONFIG_CLASS = OLAP_META_CONFIG.prototype;
    
    /**
     * 定义
     */
    OLAP_META_CONFIG_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'olap-meta-config',
        // model配置
        model: {
            clzPath: 'di.shared.model.OlapMetaConfigModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model初始化参数
     *
     * @private
     * @param {Object} options 参数
     */
    OLAP_META_CONFIG_CLASS.$createModelInitOpt = function (options) {
        return { reportType: options.reportType };
    };
    
    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    OLAP_META_CONFIG_CLASS.$createView = function (options) {
        /**
         * 是否计算列作为指标显示
         *
         * @type {boolean}
         * @private
         */
        this._bNeedShowCalcInds = options.needShowCalcInds || false;
        /**
         * 支持外部配置的datasourceId设置
         *
         * @type {Object}
         * @private
         */
        var did = this._oDatasourceId = options.datasourceId || {};
        did.DATA = did.DATA || 'DATA';
        did.SELECT = did.SELECT || 'SELECT';
        /**
         * 提交模式
         * 
         * @type {string}
         * @private 
         */
        this._sSubmitMode = options.submitMode;

        this._uOlapMetaSelector = this.$di('vuiCreate', 'main');
    };
    
    /**
     * 初始化
     *
     * @public
     */
    OLAP_META_CONFIG_CLASS.init = function () {
        // 事件绑定
        this.getModel().attach(
            ['sync.preprocess.DATA', this.$syncDisable, this, 'DATA'],
            ['sync.result.DATA', this.$renderMain, this],
            ['sync.error.DATA', this.$handleMetaError, this],
            ['sync.complete.DATA', this.$syncEnable, this, 'DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleSelected, this],
            ['sync.error.SELECT', this.$handleSelectError, this],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );
        this.getModel().attach(
            ['sync.preprocess.LIST_SELECT', this.$syncDisable, this, 'LIST_SELECT'],
            ['sync.result.LIST_SELECT', this.$handleSelected, this],
            ['sync.error.LIST_SELECT', this.$handleSelectError, this],
            ['sync.complete.LIST_SELECT', this.$syncEnable, this, 'LIST_SELECT']
        );
        this._uOlapMetaSelector.$di(
            'addEventListener',
            'change', 
            this.$handleChange, 
            this
        );

        this._uOlapMetaSelector.init();
        this.getModel().init();
    };

    /**
     * @override
     */
    OLAP_META_CONFIG_CLASS.dispose = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.dispose();
        this.getModel() && this.getModel().dispose();
        OLAP_META_CONFIG.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     */
    OLAP_META_CONFIG_CLASS.sync = function () {
        var datasourceId = this._oDatasourceId.DATA;

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 请求后台
        this.$sync(
            this.getModel(),
            datasourceId,
            { needShowCalcInds: this._bNeedShowCalcInds },
            this.$di('getEvent')
        );
    };

    /**
     * 清空视图
     * 
     * @public
     */
    OLAP_META_CONFIG_CLASS.clear = function () {  
        // TODO
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$renderMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                inddim: this.getModel().getIndDim(),
                selLineDataWrap: this.getModel().getSelLineWrap(),
                model: this.getModel(),
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
    };

    /**
     * 选择完成
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleSelected = function () {
        // 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this._mModel.getUpdateData()
        );

        if (this._sSubmitMode == 'IMMEDIATE') {
            /**
             * 提交事件
             *
             * @event
             */
            this.$di('dispatchEvent', 'submit');
        }
    };

    /**
     * 获取元数据选择处理
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleChange = function (wrap) {
        var didSel = this._oDatasourceId.SELECT;

        this.$sync(
            this._mModel,
            didSel,
            null,
            null,
            didSel == 'LIST_SELECT' 
                ? { selected: wrap }
                : {
                    uniqNameList: wrap[name],
                    changeWrap: this._mModel.diffSelected(wrap),
                    needShowCalcInds: this._bNeedShowCalcInds
                }
        );
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.enable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('enable');
        OLAP_META_CONFIG.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.disable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('disable');
        OLAP_META_CONFIG.superClass.disable.call(this);
    };    

    /**
     * 获取元数据初始化错误处理
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleMetaError = function () {
        this.clear();
        DIALOG.errorAlert();
    };

    /**
     * 元数据拖拽错误处理
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleSelectError = function () {
        DIALOG.errorAlert();
    };

})();
/**
 * di.shared.adapter.MetaConfigVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    元数据选择控件的适配器
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function () {

    var dateToString = xutil.date.dateToString;
    var isArray = xutil.lang.isArray;
    var ecuiCreate = di.helper.Util.ecuiCreate;
    var DICT = di.config.Dict;

    /**
     * 元数据选择控件的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().MetaConfigVUIAdapter = function (def, options) {
        var clzKey = def.clzKey;

        return {
            create: CREATE_METHOD[clzKey],
            setData: SET_DATA_METHOD[clzKey],
            updateData: UPDATE_DATA_METHOD[clzKey]
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @param {string} options.start 开始时间，
     *                      绝对值（如2012-12-12）
     *                      或相对于系统时间的偏移（如-5d）
     * @param {string} options.end 结束时间，格式同上。如果和range同时存在，则end优先
     * @param {string} options.range 区间，相对于start的偏移（如-4d）
     * @param {string} options.defaultTime 默认时间
     * @return {Object} 创建的实例
     */
    var CREATE_METHOD = {
        OLAP_META_DRAGGER: function create(def, options) {
            var ins = new def.clz(options)            

            ins.$di('registerEventAgent', 'change');

            ins.attach(
                'sellinechange', 
                function (wrap) {
                    ins.$di('dispatchEvent', 'change', [wrap]);
                }
            );

            return ins;
        },
        OLAP_META_IND_SELECT: function create(def, options) {
            var ins = ecuiCreate(def.clz, def.el, null, options);

            ins.$di('registerEventAgent', 'change');

            ins.onchange = function (wrap) {
                ins.$di('dispatchEvent', 'change', [ins.getValue()]);
            }

            // 禁用鼠标事件
            ins.$mousewheel = new Function();

            return ins;
        }
    };

    /**
     * 设置初始化数据
     * 
     * @public
     * @param {Object} data 数据
     */
    var SET_DATA_METHOD = {
        OLAP_META_DRAGGER: function (data) {
            this.setData(data);
        },
        OLAP_META_IND_SELECT: function (data) {
            var indList = data.inddim.indList;
            var datasource = [];
            var selected;
            if (indList) {
                indList.foreach(
                    function (k, item, index) {
                        if (item.status != DICT.META_STATUS.DISABLED) {
                            datasource.push(
                                { 
                                    text: item.caption, 
                                    value: item.uniqName 
                                }
                            );
                        }
                        if (item.status == DICT.META_STATUS.SELECTED) {
                            selected = item.uniqName;
                        }
                    }
                );
            }

            // 清除
            this.setValue(null);
            while(this.remove(0)) {}

            // 添加
            for (var i = 0, o; o = datasource[i]; i++) {
                this.add(
                    String(o.text != null ? o.text : ''), 
                    null,
                    { value: o.value }
                );
            }

            // 设置默认选中
            selected != null && this.setValue(selected);
        }
    };

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    var UPDATE_DATA_METHOD = {
        OLAP_META_DRAGGER: function (data) {
            this.refreshStatus(data);
        },
        OLAP_META_IND_SELECT: function (data) {
            // do nothing
        }
    };

})();


/**
 * ecui.ui.SwitchButton
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   可切换状态的button
 * @author: sushuang(sushuang@baidu.com)
 */

 (function () {
    
    var inheritsControl = ecui.inherits;
    var UI_H_BUTTON = ecui.ui.HButton;
    var moveElements = ecui.dom.moveElements;
    var createDom = ecui.dom.create;
    var triggerEvent = ecui.triggerEvent;
    var addClass = ecui.dom.addClass;
    var extend = ecui.util.extend;

    /**
     * 可切换状态的button
     *
     * @class
     * @extends {ecui.ui.Control}
     * @param {Array.<Object>} statusList
     *      内部元素为 text ... value ...
     * @param {number} status
     */
    var UI_SWITCH_BUTTON = ecui.ui.SwitchButton =
        inheritsControl(
            UI_H_BUTTON,
            null,
            null,
            function (el, options) {
                var type = this.getType();
                this._aStatusList = options.statusList || [];
                var index;
                for (var i = 0, o; o = this._aStatusList[i]; i ++) {
                    if (o.value == options.status) {
                        index = i;
                        break;
                    }
                }
                this.$switchStatus(index);
            }
        );

    var UI_SWITCH_BUTTON_CLASS = UI_SWITCH_BUTTON.prototype;

    UI_SWITCH_BUTTON_CLASS.$click = function () {
        UI_SWITCH_BUTTON.superClass.$click.apply(this, arguments);
        this.$switchStatus();
        triggerEvent(this, 'change');
    };

    UI_SWITCH_BUTTON_CLASS.$switchStatus = function (index) {
        var statusList = this._aStatusList;
        if (statusList.length == 0) {
            return;
        }

        var nextIndex = index != null 
            ? index
            : (
                this._nIndex == null
                ? 0
                : (this._nIndex + 1) % statusList.length
            );
        this._nIndex = nextIndex;

        this.setText(statusList[this._nIndex].text);
    };

    UI_SWITCH_BUTTON_CLASS.getValue = function () {
        return this._aStatusList[this._nIndex].value;
    };

 }) ();

/**
 * di.shared.model.DIChartModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 图模型组件
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI 图模型组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_CHART_MODEL = 
            $namespace().DIChartModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_CHART_MODEL_CLASS = 
            DI_CHART_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
        /**
         * 图后台返回的原始数据
         *
         * @type {Object}
         * @private
         */
        this._oRawChartData = {};
        /**
         * 图前台显示的数据
         *
         * @type {Object}
         * @private
         */
        this._oChartData = {};
    }

    /**
     * @override
     */
    DI_CHART_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('OLAP_CHART_DATA'),
            X_DATA: URL.fn('OLAP_CHART_X_DATA'),
            S_DATA: URL.fn('OLAP_CHART_S_DATA'),
            S_ADD_DATA: URL.fn('OLAP_CHART_S_ADD_DATA'),
            S_REMOVE_DATA: URL.fn('OLAP_CHART_S_REMOVE_DATA'),
            OFFLINE_DOWNLOAD: URL.fn('OLAP_CHART_OFFLINE_DOWNLOAD')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_CHART_MODEL_DATA_' + getUID(),
            X_DATA: 'DI_CHART_MODEL_X_DATA_' + getUID(),
            S_DATA: 'DI_CHART_MODEL_S_DATA_' + getUID(),
            S_ADD_DATA: 'DI_CHART_MODEL_S_ADD_DATA_' + getUID(),
            S_REMOVE_DATA: 'DI_CHART_MODEL_S_REMOVE_DATA_' + getUID(),
            OFFLINE_DOWNLOAD: 'DI_CHART_OFFLINE_DOWNLOAD_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: doParam,
            X_DATA: doParam,
            S_DATA: doParam,
            S_ADD_DATA: doParam,
            S_REMOVE_DATA: doParam,
            OFFLINE_DOWNLOAD: function (options) {
                return this._fCommonParamGetter(
                    { mainTo: options.args.param.email }
                );
            }
        }
    );
    function doParam(options) {
        var param = options.args.param;
        
        if (param.uniqueName) {
            // 合适么？
            param.dimTags = param.uniqueName;
            delete param.uniqueName;
        }

        if (param.uniqueNames) {
            param.dimTagsList = param.uniqueNames;
            delete param.uniqueNames;
        }

        return this._fCommonParamGetter(param);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            X_DATA: doComplete,
            S_DATA: doComplete,
            S_ADD_DATA: doComplete,
            S_REMOVE_DATA: doComplete,
            OFFLINE_DOWNLOAD: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: doParse,
            X_DATA: doParse,
            S_DATA: doParse,
            S_ADD_DATA: doParse,
            S_REMOVE_DATA: doParse
        }
    );

    /**
     * 图数据解析
     *
     * @private
     */
    function doParse(data, ejsonObj, options) {
        try {
            var rawData = this._oRawChartData = data['reportChart'];

            // 解析图后台返回数据
            var chartData = {};

            // FIXME
            // 暂时所有datetime类型了都作date类型
            if (rawData.xAxisType == 'datetime') {
                rawData.xAxisType = 'date';
            }

            chartData.chartType = 'line';
            chartData.series = rawData.seriesData;
            chartData.xAxis = [
                {
                    type: rawData.xAxisType,
                    data: rawData.xAxisCategories
                }
            ];

            // y轴
            chartData.yAxis = [];
            if (rawData.yAxises) {
                for (var i = 0, ya; ya = rawData.yAxises[i]; i ++) {
                    chartData.yAxis.push(
                        {
                            // 数值的格式化
                            format: ya.format,
                            // 轴上的文字
                            title: ya.unitName ? { text: ya.unitName } : null
                        }
                    );
                }
            }

            this._oChartData = chartData;                    
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: doError,
            X_DATA: doError,
            S_DATA: doError,
            S_ADD_DATA: doError,
            S_REMOVE_DATA: doError
        }
    );

    /**
     * 数据错误处理
     *
     * @private
     */
    function doError(status, ejsonObj, options) {    
        this._oRawChartData = {};
        this._oChartData = {};
    }

    /**
     * 得到图数据
     *
     * @public
     * @return {Object} 图数据
     */
    DI_CHART_MODEL_CLASS.getChartData = function() {
        return this._oChartData;
    };

})();


/**
 * di.shared.ui.DIChart
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 图视图组件
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var H_CHART;
        
    $link(function () {
        H_CHART = xutil.object.getByPath('xui.ui.HChart');
    });
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 图视图组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_CHART = $namespace().DIChart = 
        inheritsObject(INTERACT_ENTITY);
    var DI_CHART_CLASS = DI_CHART.prototype;
    
    //------------------------------------------
    // 常量 
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="q-di-chart"></div>',
    ].join('');

    /**
     * 暴露给interaction的api
     */
    DI_CHART_CLASS.EXPORT_HANDLER = {
        sync: { datasourceId: 'DATA' },
        syncX: { datasourceId: 'X_DATA' },
        syncS: { datasourceId: 'S_DATA' },
        syncSAdd: { datasourceId: 'S_ADD_DATA' },
        syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
        clear: {}
    };

    /**
     * 定义
     */
    DI_CHART_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncX: { datasourceId: 'X_DATA' },
            syncS: { datasourceId: 'S_DATA' },
            syncSAdd: { datasourceId: 'S_ADD_DATA' },
            syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'di-chart',
        // model配置
        model: {
            clzPath: 'di.shared.model.DIChartModel'
        }
    };


    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_CHART_CLASS.$createView = function (options) {
        var el = this.$di('getEl');

        // 模板
        var tplMode = this.$di('getTplMode');
        if (tplMode != 'FROM_SNIPPET') {
            el.innerHTML = TPL_MAIN;
        }

        this._uChart = tplMode == 'FROM_SNIPPET'
            ? this.$di('vuiCreate', 'mainChart')
            : new H_CHART({ el: q('q-di-chart', el)[0] });

        // 下载按钮
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 离线下载
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_CHART_CLASS.init = function () {
        var key;
        var exportHandler = this.DEF.exportHandler;
        
        // 事件绑定
        for (key in exportHandler) {
            var id = exportHandler[key].datasourceId;
            this.getModel().attach(
                ['sync.preprocess.' + id, this.$syncDisable, this, id],
                ['sync.result.' + id, this.$renderMain, this],
                ['sync.result.' + id, this.$handleDataLoaded, this],
                ['sync.error.' + id, this.$handleDataError, this],
                ['sync.complete.' + id, this.$syncEnable, this, id]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        this.getModel().attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        this._uDownloadBtn && (
            this._uDownloadBtn.onclick = bind(this.$handleDownload, this)
        );
        this._uOfflineDownloadBtn && (
            this._uOfflineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                this.getModel(),
                this._uChart, 
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ], 
            'init'
        );
    };

    /**
     * @override
     */
    DI_CHART_CLASS.dispose = function () {
        this._uChart && this._uChart.$di('dispose');
        DI_CHART.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     * @param {Object} options 参数
     */
    (function () {
        var exportHandler = DI_CHART_CLASS.DEF.exportHandler;
        for (var funcName in exportHandler) {
            DI_CHART_CLASS[funcName] = getSyncMethod(
                exportHandler[funcName].datasourceId
            );
        }
        function getSyncMethod(datasourceId) {
            return function (options) {
                // 视图禁用
                /*
                var diEvent = this.$di('getEvent');
                var vd = diEvent.viewDisable;
                vd && this.getModel().attachOnce(
                    ['sync.preprocess.' + datasourceId, vd.disable],
                    ['sync.complete.' + datasourceId, vd.enable]
                );*/

                // 请求后台
                this.$sync(
                    this.getModel(),
                    datasourceId,
                    (options || {}),
                    this.$di('getEvent')
                );
            };
        }
    })();

    /**
     * 清空视图
     * 
     * @public
     */
    DI_CHART_CLASS.clear = function () {  
        this._uChart && this._uChart.$di('setData');
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    DI_CHART_CLASS.$renderMain = function (data, ejsonObj, options) {
        this._uChart.$di(
            'setData', 
            this.getModel().getChartData(),
            { diEvent: this.$diEvent(options) }
        );
        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_CHART_CLASS.resize = function () {
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_CHART_CLASS.enable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'enable'
        );
        DI_CHART.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_CHART_CLASS.disable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'disable'
        );
        DI_CHART.superClass.disable.call(this);
    };    

    /**
     * 下载操作
     *
     * @protected
     */
    DI_CHART_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('OLAP_CHART_DOWNLOAD') 
            + '?' + commonParamGetter();
        download(url, null, true);

        // 对于下载，不进行reportTemplateId控制，直接打开
        commonParamGetter.update();
    };

    /**
     * 离线下载操作
     *
     * @protected
     */
    DI_CHART_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 数据加载成功
     * 
     * @protected
     */
    DI_CHART_CLASS.$handleDataLoaded = function  (data, ejsonObj, options) {
        /**
         * 数据成功加载事件（分datasourceId）
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded.' + options.datasourceId, options)
        );

        /**
         * 数据成功加载事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataloaded', options));
    };

    /**
     * 获取数据错误处理
     * 
     * @protected
     */
    DI_CHART_CLASS.$handleDataError = function (status, ejsonObj, options) {

        // 设置空视图
        this.clear();

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 数据加载失败事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
    };

    /**
     * 离线下载错误处理
     * 
     * @protected
     */
    DI_CHART_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * @file 可拖拽items
 * @author hades(denghongqi@gmail.com)
 */

(function() {
    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var util = core.util;

    var WINDOW = window;
    var DOCUMENT = document;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_ITEMS = ui.Items;
    var UI_ITEM = ui.Item;
    var UI_ITEM_CLASS = UI_ITEM.prototype;

    ui.DraggableList = core.inherits(
        ui.Control,
        'ui-draggable-list',
        function(el, options) {
        },
        function(el, options) {
            this._bDisableSelected = options.disableSelected === true;
            options.targets = options.targets || '';
            this._aTargetIds = options.targets.split(',') || [];
            this._sClazz = options.clazz;
            this.$setBody(el);
            this.$initItems();

            var list = this.getItems();
            for (var i = 0; i < list.length; i++) {
                var o = list[i];
                o.$setState(o._sState);
            }
        }
    );

    var UI_DRAGGABLE_LIST = ui.DraggableList;
    var UI_DRAGGABLE_LIST_CLASS = UI_DRAGGABLE_LIST.prototype;

    /**
     * 禁用$setSize
     */
    UI_DRAGGABLE_LIST_CLASS.$setSize = util.blank;

    /**
     * 增加target控件
     * @param {string} id
     */
    UI_DRAGGABLE_LIST_CLASS.addTarget = function(id) {
        this._aTargetIds.push(id);
    };

    UI_DRAGGABLE_LIST_CLASS.Item = core.inherits(
        UI_ITEM,
        null,
        function(el, options) {
            options.userSelect = false;
        },
        function(el, options) {
            this._sValue = options.value;
            this._sText = el.innerHTML;
            this._sState = options.state || 'normal';
            this._sClazz = options.clazz;
            this._bFixed = options.fixed;
            this._sAlign = options.align;
            this._sCalcColumnRefInd = options.calcColumnRefInd;
            if (this._sClazz == 'DIM') {
                dom.addClass(el, 'ui-draggable-list-item-dim');
            }
            else if (this._sClazz == 'IND') {
                dom.addClass(el, 'ui-draggable-list-item-ind');
            }
        }
    );
    var UI_DRAGGABLE_LIST_ITEM_CLASS = UI_DRAGGABLE_LIST_CLASS.Item.prototype;

    util.extend(UI_DRAGGABLE_LIST_CLASS, UI_ITEMS);

    /**
     * 要写dispose
     * @protected
     */
    UI_DRAGGABLE_LIST_CLASS.$dispose = function() {
        delete UI_ITEMS[this.getUID()];
        this.getOuter().innerHTML = '';
        util.callSuper(this, '$dispose');
    };
    

    UI_DRAGGABLE_LIST_CLASS.$alterItems = function() {
    };

    /**
     * 添加一个item
     * @public
     * @param {Object} data
     * @param {string} data.value
     * @param {string} data.text
     * @param {string} data.clazz
     * @param {boolean=} data.fixed
     * @param {boolean=} data.align
     * @param {number=} opt_index
     */
    UI_DRAGGABLE_LIST_CLASS.addItem = function(data, opt_index) {
        var el = dom.create();
        el.innerHTML = data.text;
        this.getOuter().appendChild(el);
        this.add(el, opt_index, data);
    };

    /**
     * 移除一个item
     * @public
     * @param {string} value
     */
    UI_DRAGGABLE_LIST_CLASS.removeItem = function(value) {
        this.remove(this.getItemByValue(value));
    };

    /**
     * 获取控件的clazz
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * 控件激活时触发拖动
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this, event);

        core.drag(this, event);
    };

    /**
     * 拖动开始时执行
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragstart = function() {
        var el = this.getOuter();
        el.style.zIndex = 32768;
        var par = this.getParent();
        var list = par.getItems();
        var index = 0;
        var i = 0;
        while(list[i] && list[i++] != this) {
            index = i;
        }

        if (!par._cPlacehold) {
            var el = dom.create('ui-draggable-list-placehold');
            par._cPlacehold = par.add(el, index, {});
            par._cPlacehold.setSize(this.getWidth(), this.getHeight());
        }
    };

    /**
     * 拖动中触发
     * @param {ecui.Event} event
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragmove = function(event) {
        var el = this.getOuter();
        var par = this.getParent();
        var targetEl;
        var targetCon;

        for (var i = 0; i < par._aTargetIds.length; i++) {
            if (
                core.get(par._aTargetIds[i])
                && intersect(el, core.get(par._aTargetIds[i]).getOuter())
            ) {
                targetCon = core.get(par._aTargetIds[i]);
                targetEl = targetCon.getOuter();
                break;
            }
        }

        if (par._cCurDrop && targetCon != par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'dragout', event, [this]);
        }
        par._cCurDrop = targetCon;

        if (!targetEl) {
            return ;
        }
        core.triggerEvent(targetCon, 'dragover', event, [this]);
    };

    /**
     * 拖动结束时触发
     * （此方法要保证能重复执行两遍，因为ecui拖拽到窗口外的问题未修）
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragend = function(event) {
        var el  = this.getOuter();
        el.style.position = 'relative';
        el.style.zIndex = 0;
        this.setPosition(0, 0);

        var par = this.getParent();

        if (par._cPlacehold == null) {
            return;
        }

        par.remove(par._cPlacehold);
        par._cPlacehold = null;

        if (par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'drop', event, [this]);
            // this.setSelected(true);
        }

        par._cCurDrop = null;
    };

    /**
     * 获取item子控件的值
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getValue = function() {
        return this._sValue;
    };

    /**
     * 获取控件显示的文字
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getText = function() {
        return this._sText;
    };

    /**
     * 获取控件的clazz
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * 获取控件的数据封装
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getWrap = function() {
        return {
            value : this._sValue,
            text : this._sText,
            clazz : this._sClazz,
            fixed: this._bFixed,
            align: this._sAlign,
            calcColumnRefInd: this._sCalcColumnRefInd
        };
    };

    /**
     * 设置item为选中或不选中状态
     * @public
     * @param {boolean} state true为选中，false为取消选中
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.setSelected = function(state) {
        var el = this.getOuter();
        dom.removeClass(el, 'ui-draggable-list-item-selected');
        if (state) {
            dom.addClass(el, 'ui-draggable-list-item-selected');
            this._sState = 'selected';
            var par = this.getParent();
            if (par._bDisableSelected) {
                this.disable();
                dom.removeClass(el, 'ui-draggable-list-item-disabled');
                dom.removeClass(el, 'ui-item-disabled');
            }
        }

        this._bSelected = state;
    };

    /**
     * 设置控件状态
     * @private
     * @param {string} state
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$setState = function(state) {
        if (state == 'disable') {
            this.disable();
            this._sState = 'disable';
        }
        else if (state == 'selected') {
            this.setSelected(true);
        }
        else {
            this.enable();
            this.setSelected(false);
            this._sState = 'normal';
        }
    };

    /**
     * 批量设置item子控件状态
     * @public
     * @param {Object} obj
     */
    UI_DRAGGABLE_LIST_CLASS.setState = function(obj) {
        for (var i = 0, len = this.getItems().length; i < len; i++) {
            this.getItems()[i].$setState('normal');
        }
        if (obj['disable'] && obj['disable'].length) {
            for (var i = 0; i < obj['disable'].length; i++) {
                this.getItemByValue(obj['disable'][i]).$setState('disable');
            }
        }
        if (obj['selected'] && obj['selected'].length) {
            for (var i = 0; i < obj['selected'].length; i++) {
                this.getItemByValue(obj['selected'][i]).$setState('selected');
            }
        }
    };

    /**
     * 根据value获取item控件
     * @public
     * @param {value}
     * @return {ecui.ui.Control}
     */
    UI_DRAGGABLE_LIST_CLASS.getItemByValue = function(value) {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            if (list[i].getValue() == value) {
                return list[i];
            }
        }

        return null;
    };

    /**
     * disable所有item子控件
     * @public
     */
    UI_DRAGGABLE_LIST_CLASS.disableAll = function() {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            list[i].disable();
        }
    };

    /**
     * 判断两个元素是否相交
     * @param {HTML element} element1 要检查的元素
     * @param {HTML element} element2 要检查的元素
     * @return {boolean} 检查两个元素是否相交的结果
     */
    function intersect(element1, element2) {
        var pos1 = ecui.dom.getPosition(element1);
        var pos2 = ecui.dom.getPosition(element2);

        var maxLeft = Math.max(pos1.left, pos2.left);
        var minRight = Math.min(
            pos1.left + element1.offsetWidth, 
            pos2.left + element2.offsetWidth
        );
        var maxTop = Math.max(pos1.top, pos2.top);
        var minBottom = Math.min(
            pos1.top + element1.offsetHeight,
            pos2.top + element2.offsetHeight
        );

        return maxLeft <= minRight && maxTop <= minBottom;
    };

}) ();
/**
 * @file 可拖放的items
 * @author hades(denghongqi@baidu.com)
 */

(function() {
    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var array = core.array;
    var util = core.util;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_ITEMS = ui.Items;
    var UI_ITEM = ui.Item;
    var UI_ITEM_CLASS = UI_ITEM.prototype;

    ui.DroppableList = core.inherits(
        UI_CONTROL,
        'ui-droppable-list',
        function(el, options) {
        },
        function(el, options) {
            this._sName = options.name;
            options.targets = options.targets ||'';
            this._aTargetIds = options.targets.split(',') || [];
            options.source = options.source || '';
            this._aSourceIds = options.source.split(',') || [];
            this._bConfigBtn = options.configBtn;
            this.$setBody(el);
            this.$initItems();
        }
    );

    var UI_DROPPABLE_LIST = ui.DroppableList;
    var UI_DROPPABLE_LIST_CLASS = UI_DROPPABLE_LIST.prototype;

    util.extend(UI_DROPPABLE_LIST_CLASS, UI_ITEMS);

    UI_DROPPABLE_LIST_CLASS.$alterItems = util.blank;

    /**
     * 禁用$setSize
     * @override
     */
    UI_DROPPABLE_LIST_CLASS.$setSize = util.blank;

    UI_DROPPABLE_LIST_CLASS.add = function (item, index, options) {
        options = options;
        options.configBtn = this._bConfigBtn;
        return UI_ITEMS.add.call(this, item, index, options);
    };

    /**
     * 要写dispose
     * @protected
     */
    UI_DROPPABLE_LIST_CLASS.$dispose = function() {
        delete UI_ITEMS[this.getUID()];
        this.getOuter().innerHTML = '';
        util.callSuper(this, '$dispose');
    };

    /**
     * @override
     */
    UI_DROPPABLE_LIST_CLASS.$mouseover = function() {
        UI_CONTROL_CLASS.$mouseover.call(this);
    };

    /**
     * 当有可drop元素经过时触发
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} 可drop的控件
     */
    UI_DROPPABLE_LIST_CLASS.$dragover = function(event, control) {
        if (this._cPlacehold) {
            this.remove(this._cPlacehold);
        }

        var index = getInsertIndex(this, event);

        // 校验是否可以drop
        if (core.triggerEvent(
                this,
                'checkdroppable',
                null, 
                [control.getWrap(), index, this._sName]
            ) === false
        ) {
            this._cPlacehold = null;
            return;
        }

        var o = dom.create('ui-droppable-list-placehold');
        this.getBody().appendChild(o);
        this._cPlacehold = this.add(o, index, {placehold : true});
        this._cPlacehold.setSize(control.getWidth(), control.getHeight());
    };

    /**
     * 可拖拽元素移出时触发
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} control 可drop的控件
     */
    UI_DROPPABLE_LIST_CLASS.$dragout = function(event, control) {
        if (!this._cPlacehold) {
            return ;
        }
        this.remove(this._cPlacehold);
        this._cPlacehold = null;
    };

    /**
     * 可拖拽控件drop时触发
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} kedrop的控件
     */
    UI_DROPPABLE_LIST_CLASS.$drop = function(event, control, listOfCon) {
        if (!this._cPlacehold) {
            return false; 
        }

        var index = getInsertIndex(this, event);
        if (this._cPlacehold) {
            this.remove(this._cPlacehold);
        }

        this._cNewAdd = this.addByItem(control, index);

        //this._cNewAdd.setSize(control.getWidth(), control.getHeight());

        if (this == listOfCon && control._nOriginIndex == index) {
            return;
        }

        for (var i = 0, con; i < this._aSourceIds.length; i++) {
            con = core.get(this._aSourceIds[i]);
            if (con && con.getClazz() == control.getClazz()) {
                core.triggerEvent(
                    con, 
                    'change', 
                    null, 
                    [
                        control.getWrap(), 
                        index, 
                        this._sName, 
                        control._nOriginIndex, 
                        control._sOriginParName
                    ]
                );
            }
        }        
    };

    /**
     * 可拖拽控件throw时触发
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} kedrop的控件
     */
    UI_DROPPABLE_LIST_CLASS.$throw = function(event, control, listOfCon) {
        for (var i = 0, con; i < this._aSourceIds.length; i++) {
            con = core.get(this._aSourceIds[i]);
            if (con && con.getClazz() == control.getClazz()) {
                core.triggerEvent(
                    con, 
                    'change', 
                    null,
                    [
                        control.getWrap(), 
                        null, 
                        this._sName,
                        control._nOriginIndex, 
                        control._sOriginParName
                    ]
                );
            }
        }        
    };

    /**
     * 得到item个数
     *
     * @public
     * @return {number} item个数
     */
    UI_DROPPABLE_LIST_CLASS.count = function() {
        return UI_ITEMS[this.getUID()].length;
    }

    /**
     * 是否包含此item
     *
     * @public
     * @param {Item} item
     * @return {boolean} 是否包含
     */
    UI_DROPPABLE_LIST_CLASS.contains = function(item) {
        return array.indexOf(UI_ITEMS[this.getUID()], item) >= 0;
    }

    /**
     * 添加一个item
     * @public
     * @param {Object} data
     * @param {string} data.value
     * @param {string} data.text
     * @param {string} data.clazz
     * @param {boolean=} data.fixed
     * @param {string=} data.align
     * @param {number=} opt_index
     */
    UI_DROPPABLE_LIST_CLASS.addItem = function(data, opt_index) {
        var el = dom.create();
        el.innerHTML = data.text;
        this.getOuter().appendChild(el);
        this.add(el, opt_index, data);
    };

    /**
     * 增加target控件
     * @param {string} id
     */
    UI_DROPPABLE_LIST_CLASS.addTarget = function(id) {
        this._aTargetIds.push(id);
    };

    /**
     * 移除一个item
     * @public
     * @param {string} value
     */
    UI_DROPPABLE_LIST_CLASS.removeItem = function(value) {
        this.remove(this.getItemByValue(value));
    };

    /**
     * 根绝value获取item控件
     * @public
     * @param {string} value
     * @return {ecui.ui.Control}
     */
    UI_DROPPABLE_LIST_CLASS.getItemByValue = function(value) {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            if (value == list[i].getValue()) {
                return list[i];
            }
        }

        return null;
    };

    /**
     * 获取drop控件容纳的子控件的值
     * @public
     * @return {Array}
     */
    UI_DROPPABLE_LIST_CLASS.getValue = function() {
        var list = this.getItems();
        var res = [];
        for (var i = 0; i < list.length; i++) {
            res.push(list[i].getValue());
        }

        return res;
    };    

    /**
     * 获取drop控件容纳的子控件的数据
     * @public
     * @return {Array}
     */
    UI_DROPPABLE_LIST_CLASS.getWrap = function() {
        var list = this.getItems();
        var res = [];
        for (var i = 0; i < list.length; i++) {
            res.push(list[i].getWrap());
        }

        return res;
    };

    /**
     * 根据一个节点的内容，复制，添加节点
     * 
     * @public
     * @param {Item} 原节点
     * @param {number} 目标位置
     * @return {Item} 添加得到的结果
     */
    UI_DROPPABLE_LIST_CLASS.addByItem = function(srcCtrl, index) {
        var o = dom.create();
        o.innerHTML = srcCtrl.getText();
        this.getBody().appendChild(o);

        return this.add(o, index, srcCtrl.getWrap());
    };


    UI_DROPPABLE_LIST_CLASS.Item = core.inherits(
        UI_ITEM,
        null,
        function(el, options) {
            options.userSelect = false;
            this._sText = el.innerHTML;
            if (!options.placehold && options.configBtn) {
                var o = dom.create('ui-droppable-list-item-icon');
                el.appendChild(o);
            }
        },
        function(el, options) {
            this._sValue = options.value;
            this._sClazz = options.clazz;
            this._bFixed = options.fixed;
            this._sAlign = options.align;
            this._sCalcColumnRefInd = options.calcColumnRefInd;
            if (this._sClazz == 'DIM') {
                dom.addClass(el, 'ui-droppable-list-item-dim');
            }
            else if (this._sClazz == 'IND') {
                dom.addClass(el, 'ui-droppable-list-item-ind');
            }
            if (!options.placehold && options.configBtn) {
                this._cIcon = core.$fastCreate(this.Icon, dom.last(el), this, {});
            }
        }
    );
    var UI_DROPPABLE_LIST_ITEM = UI_DROPPABLE_LIST_CLASS.Item;
    var UI_DROPPABLE_LIST_ITEM_CLASS = UI_DROPPABLE_LIST_ITEM.prototype;

    /**
     * 设置item子控件的值
     * @public
     * @param {string} value
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.setValue = function(value) {
        this._sValue = value;
    };

    /**
     * 获取item的值
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getValue = function() {
        return this._sValue;
    };

    /**
     * 获取item的文本
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getText = function() {
        return this._sText;
    };

    /**
     * 获取item子控件的clazz
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * 获取item子控件的数据封装
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getWrap = function() {
        return {
            value : this._sValue,
            text : this._sText,
            clazz : this._sClazz,
            fixed: this._bFixed,
            align: this._sAlign,
            calcColumnRefInd: this._sCalcColumnRefInd
        };
    };

    /**
     * 控件激活时触发拖动
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this, event);

        var par = this.getParent();
        var originIndex = array.indexOf(UI_ITEMS[par.getUID()], this);

        if (core.triggerEvent(
                par, 
                'checkdraggable', 
                null, 
                [
                    this.getWrap(), 
                    originIndex, 
                    par._sName
                ]
            ) !== false
        ) {
            this._sOriginParName = par._sName; // 拖拽之前的行名
            this._nOriginIndex = originIndex; // 拖拽之前的index
            core.drag(this, event);
        }
    };

    /**
     * 开始拖拽时触发
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragstart = function(event) {
    };

    /**
     * 拖拽中触发
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragmove = function(event) {
        this._bDragging = true;

        var par = this.getParent();
        var conArr = [];
        conArr.push(par);
        for (var i = 0; i < par._aTargetIds.length; i++) {
            if (core.get(par._aTargetIds[i])) {
                conArr.push(core.get(par._aTargetIds[i]));
            }
        }

        var el = this.getOuter();
        var targetCon;
        var targetEl;
        for (var i = 0; i < conArr.length; i++) {
            if (intersect(el, conArr[i].getOuter())) {
                targetCon = conArr[i];
                targetEl = targetCon.getOuter();
                break;
            }
        }

        if (par._cCurDrop && targetCon != par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'dragout', event, [this]);
        }
        par._cCurDrop = targetCon;

        if (!targetEl) {
            return ;
        }
        core.triggerEvent(targetCon, 'dragover', event, [this]);
    };

    /**
     * 拖拽结束时触发
     * （此方法要保证能重复执行两遍，因为ecui拖拽到窗口外的问题未修）
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragend = function(event) {
        var par = this.getParent();

        if (!par) { return; }

        if (!par._cCurDrop) {
            if (
                event.pageX >= dom.getPosition(par.getOuter()).left
                && event.pageX <= dom.getPosition(par.getOuter()).left + par.getWidth()
                && event.pageY >= dom.getPosition(par.getOuter()).top
                && event.pageY <= dom.getPosition(par.getOuter()).top + par.getHeight()
            ) {
                par._cCurDrop = par;
            }
        }
        par.remove(this);
        if (par._cCurDrop) {
            if (core.triggerEvent(par._cCurDrop, 'drop', event, [this, par]) == false) {
                // drop失败时（例如drop被禁止时），重新加入节点
                par.addByItem(this, this._nOriginIndex);           
            }
        }
        else {
            core.triggerEvent(par, 'throw', event, [this, par]);
        }
        par._cCurDrop = null;
        this._bDragging = false;
        this._nOriginIndex = null;

        core.triggerEvent(par, 'deactivate', event);
        core.triggerEvent(par, 'blur', event);
    };

    /**
     * item上的点击按钮
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.Icon = core.inherits(
        UI_CONTROL,
        'ui-droppable-list-item-icon',
        null,
        null
    );
    var UI_DROPPABLE_LIST_ITEM_ICON = UI_DROPPABLE_LIST_ITEM_CLASS.Icon;
    var UI_DROPPABLE_LIST_ITEM_ICON_CLASS = UI_DROPPABLE_LIST_ITEM_ICON.prototype;

    /**
     * 按钮的click事件
     */
    UI_DROPPABLE_LIST_ITEM_ICON_CLASS.$click = function(event) {
        UI_CONTROL_CLASS.$click.call(this);
        var item = this.getParent();
        var itemData = item.getWrap();
        core.triggerEvent(item.getParent(), 'itemclick', event, [itemData]);

        event.stopPropagation();
    };

    /**
     * 阻止按钮activate事件的冒泡
     */
    UI_DROPPABLE_LIST_ITEM_ICON_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this);

        event.stopPropagation();
    };

    /**
     * 判断两个元素是否相交
     * @param {HTML element} element1 要检查的元素
     * @param {HTML element} element2 要检查的元素
     * @return {boolean} 检查两个元素是否相交的结果
     */
    function intersect(element1, element2) {
        var pos1 = ecui.dom.getPosition(element1);
        var pos2 = ecui.dom.getPosition(element2);

        var maxLeft = Math.max(pos1.left, pos2.left);
        var minRight = Math.min(
            pos1.left + element1.offsetWidth, 
            pos2.left + element2.offsetWidth
        );
        var maxTop = Math.max(pos1.top, pos2.top);
        var minBottom = Math.min(
            pos1.top + element1.offsetHeight,
            pos2.top + element2.offsetHeight
        );

        return maxLeft <= minRight && maxTop <= minBottom;
    };

    /**
     * 计算拖拽子控件插入的index
     * @param {ecui.ui.Items} control
     * @param {ecui.Event} event
     */
    function getInsertIndex(control, event) {
        var list = control.getItems();
        var index;
        for (index = 0; index < list.length; index++) {
            var item = list[index];
            var el = item.getOuter();
            if (
                event.pageX <= dom.getPosition(el).left + item.getWidth()
                && event.pageY <= dom.getPosition(el).top + item.getHeight()
                && !item._bDragging
            ) {
                return index;
            }
        }
        return index;
    };
}) ();
/**
 * di.shared.model.DimSelectModel  
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    维度选择model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var extend = xutil.object.extend;
    var getByPath = xutil.object.getByPath;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var assign = xutil.object.assign;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var arrayProtoPush = Array.prototype.push;    
    var download = UTIL.download;
    var logError = UTIL.logError;
    var XDATASOURCE = xui.XDatasource;
        
    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * 维度选择Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var DIM_SELECT_MODEL = 
            $namespace().DimSelectModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DIM_SELECT_MODEL_CLASS = 
            DIM_SELECT_MODEL.prototype;
  
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * hierachy的根，子女节点是维度树
         *
         * @type {Array.<Object>}
         * @private
         */
        this._oHierarchyRoot;
        /**
         * 当前hierachy的维度树
         *
         * @type {Array.<Object>}
         * @private
         */
        this._oCurrDimTree;
        /**
         * 维度名
         *
         * @type {string} 
         * @private
         */
        this._sDimName;
        /**
         * schema名
         *
         * @type {string} 
         * @private
         */
        this._sSchemaName;
        /**
         * 维度类型, 目前可能为'TIME'或'NORMAL'
         *
         * @type {string} 
         * @private
         */
        this._sDimType;
        /**
         * 每个hierarchy的层级列表, key为hierarchy的name
         *
         * @type {Map} 
         * @private
         */
        this._oLevelMap;
    }

    var URL_MAP = {
        TREE: {
            TABLE: URL('DIM_TREE_TABLE'),
            CHART: URL('DIM_TREE_CHART')
        },
        SAVE: {
            TABLE: URL('DIM_SELECT_SAVE_TABLE'),
            CHART: URL('DIM_SELECT_SAVE_CHART')
        }
    };

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.url = function(options) {
        return URL_MAP[options.datasourceId][options.args.reportType];
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            // 请求维度树参数
            TREE: function(options) {
                var paramArr = this.$createBaseParam(options);
                if (options.args.dimMode == 'TIME') {
                    paramArr.push('isTimeDim=true');
                }
                return paramArr.join('&');
            },

            // 保存维度树当前选中参数
            SAVE: function(options) {
                var args = options.args;
                var paramArr = this.$createBaseParam(options);

                paramArr.push(
                    'hierarchyName=' + textParam(this._oCurrDimTree.name)
                );
                arrayProtoPush.apply(
                    paramArr,
                    wrapArrayParam(args.treeSelected, 'selectedNodes')
                );
                arrayProtoPush.apply(
                    paramArr,
                    wrapArrayParam(args.levelSelected, 'levelUniqueNames')
                );

                if (args.dimMode == 'TIME') {
                    // 暂时只支持范围选择
                    var start = args.timeSelect.start
                        ? dateToString(args.timeSelect.start) : '';
                    var end = args.timeSelect.end 
                        ? dateToString(args.timeSelect.end) : start;
                    paramArr.push('startDay=' + start);
                    paramArr.push('endDay=' + end);
                }
                
                return paramArr.join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            // 请求维度树后台返回解析
            TREE: function(data, ejsonObj, options) {
                try {
                    // timeType表示静态动态时间等，后面加. 0代表默认
                    var timeType = data['timeType'];
                    // 时间选择
                    this._oTimeSelect = data['timeSelects'] || {};

                    var dimTree = data['dimTree'];
                    var root = this._oHierarchyRoot = dimTree['dimTree'];
                    // 暂时都使用第一个hierarchy，后续再添加多hierarchy的支持
                    this._oCurrDimTree = root['children'][0];
                    this._oLevelMap = dimTree['hierarchyLevelUniqueNames'];
                    this._sDimName = dimTree['dimName'];
                    this._sSchemaName = dimTree['schemaName'];
                    this._sDimType = dimTree['isTimeDim'] ? 'TIME' : 'NORMAL';
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            }
        }
    );

    /**
     * 得到当前维度树
     * 
     * @public
     * @return {Object} 维度树
     */
    DIM_SELECT_MODEL_CLASS.getCurrDimTree = function() {
        return this._oCurrDimTree;
    };

    /**
     * 得到当前时间选择
     * 
     * @public
     * @return {Object} 时间选择
     */
    DIM_SELECT_MODEL_CLASS.getTimeSelect = function() {
        return this._oTimeSelect;
    };

    /**
     * 得到当前层级列表
     * 
     * @public
     * @return {Array.<Object>} 层级列表
     */
    DIM_SELECT_MODEL_CLASS.getCurrLevelList = function() {
        return (this._oLevelMap && this._oCurrDimTree)
            ? this._oLevelMap[this._oCurrDimTree.name]
            : null;
    };

    /**
     * 构造公用参数
     * 
     * @protected
     * @param {Object} options sync参数
     * @return {Array.<string>} 公用参数
     */
    DIM_SELECT_MODEL_CLASS.$createBaseParam = function(options) {
        var args = options.args;
        var paramArr = [];

        if (args.commonParamGetter) {
            paramArr.push(args.commonParamGetter());
        }
        paramArr.push(
            'dimSelectName=' + textParam(args.uniqName)
        );
        paramArr.push(
            'from=' + textParam(args.selLineName)
        );

        return paramArr;
    };

})();


/*
Form - 定义独立于文档布局的内容区域的基本操作。
窗体控件，继承自基础控件，仿真浏览器的多窗体效果，如果在其中包含 iframe 标签，可以在当前页面打开一个新的页面，避免了使用 window.open 在不同浏览器下的兼容性问题。多个窗体控件同时工作时，当前激活的窗体在最上层。窗体控件的标题栏默认可以拖拽，窗体可以设置置顶方式显示，在置顶模式下，只有当前窗体可以响应操作。窗体控件的 z-index 从4096开始，页面开发请不要使用大于或等于4096的 z-index 值。

窗体控件直接HTML初始化的例子:
<div ecui="type:form;hide:true">
  <label>窗体的标题</label>
  <!-- 这里放窗体的内容 -->
  ...
</div>

属性
_bFlag          - 初始是否自动隐藏/是否使用showModal激活
_bAutoTitle     - 标题栏是否自适应宽度
_bAutoHeight    - 高度是否自适应
_bAutoCenter    - 显示时位置是否自动居中
_uTitle         - 标题栏
_uClose         - 关闭按钮
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        string = core.string,
        util = core.util,

        undefined,
        MATH = Math,
        MAX = MATH.max,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getStyle = dom.getStyle,
        moveElements = dom.moveElements,
        encodeHTML = string.encodeHTML,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        calcHeightRevise = core.calcHeightRevise,
        calcWidthRevise = core.calcWidthRevise,
        drag = core.drag,
        inheritsControl = core.inherits,
        loseFocus = core.loseFocus,
        mask = core.mask,
        setFocused = core.setFocused,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = ui.Control.prototype,
        UI_BUTTON = ui.Button;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_FORM
    ///__gzip_original__UI_FORM_CLASS
    /**
     * 初始化窗体控件。
     * options 对象支持的属性如下：
     * hide         初始是否自动隐藏
     * autoTitle    title是否自适应宽度，默认自适应宽度
     * autoCenter   显示时位置是否自动居中，默认不处理
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_FORM = ui.Form =
        inheritsControl(
            UI_CONTROL,
            'ui-form',
            function (el, options) {
                // 生成标题控件与内容区域控件对应的Element对象
                var type = this.getType(),
                    o = createDom(type + '-body', 'position:relative;overflow:auto'),
                    titleEl = first(el);

                moveElements(el, o, true);

                if (titleEl && titleEl.tagName == 'LABEL') {
                    el.innerHTML =
                        '<div class="' + type + '-close' + this.Close.TYPES + '" style="position:absolute"></div>';
                    el.insertBefore(titleEl, el.firstChild);
                    titleEl.className = type + '-title' + this.Title.TYPES;
                    titleEl.style.position = 'absolute';
                }
                else {
                    el.innerHTML =
                        '<label class="' + type + '-title' + this.Title.TYPES +
                            '" style="position:absolute">'+ (options.title ? encodeHTML(options.title) : '') +'</label><div class="' + type + '-close' + this.Close.TYPES +
                            '" style="position:absolute"></div>';
                    titleEl = el.firstChild;
                }

                el.style.overflow = 'hidden';
                el.appendChild(o);
            },
            function (el, options) {
                this._bAutoHeight = !el.style.height;
                el = children(el);

                this._bFlag = options.hide;
                this._bAutoTitle = options.autoTitle !== false;
                this._bAutoCenter = options.autoCenter === true;

                // 初始化标题区域
                this._uTitle = $fastCreate(this.Title, el[0], this, {userSelect: false});

                // 初始化关闭按钮
                this._uClose = $fastCreate(this.Close, el[1], this);
                if (options.closeButton === false) {
                    this._uClose.$hide();
                }

                this.$setBody(el[2]);
            }
        ),
        UI_FORM_CLASS = UI_FORM.prototype,

        /**
         * 初始化窗体控件的标题栏部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_FORM_TITLE_CLASS = (UI_FORM_CLASS.Title = inheritsControl(UI_CONTROL)).prototype,

        /**
         * 初始化窗体控件的关闭按钮部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_FORM_CLOSE_CLASS = (UI_FORM_CLASS.Close = inheritsControl(UI_BUTTON)).prototype,

        UI_FORM_ALL = [],   // 当前显示的全部窗体
        UI_FORM_MODAL = 0;  // 当前showModal的窗体数
//{else}//
    /**
     * 刷新所有显示的窗体的zIndex属性。
     * @protected
     *
     * @param {ecui.ui.Form} form 置顶显示的窗体
     */
    function UI_FORM_FLUSH_ZINDEX(form) {
        UI_FORM_ALL.push(UI_FORM_ALL.splice(indexOf(UI_FORM_ALL, form), 1)[0]);

        // 改变当前窗体之后的全部窗体z轴位置，将当前窗体置顶
        for (var i = 0, j = UI_FORM_ALL.length - UI_FORM_MODAL, o; o = UI_FORM_ALL[i++]; ) {
            o.getOuter().style.zIndex = i > j ? 32767 + (i - j) * 2 : 4095 + i;
        }
    }

    /**
     * 标题栏激活时触发拖动，如果当前窗体未得到焦点则得到焦点。
     * @override
     */
    UI_FORM_TITLE_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        drag(this.getParent(), event);
    };

    /**
     * 窗体关闭按钮点击关闭窗体。
     * @override
     */
    UI_FORM_CLOSE_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);
        this.getParent().hide();
    };

    /**
     * @override
     */
    UI_FORM_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        style = getStyle(this.getMain().lastChild);
        this.$$bodyWidthRevise = calcWidthRevise(style);
        this.$$bodyHeightRevise = calcHeightRevise(style);
        this._uTitle.cache(true, true);
        this._uClose.cache(true, true);
    };

    /**
     * 销毁窗体时需要先关闭窗体，并不再保留窗体的索引。
     * @override
     */
    UI_FORM_CLASS.$dispose = function () {
        if (indexOf(UI_FORM_ALL, this) >= 0) {
            // 窗口处于显示状态，需要强制关闭
            // 避免在unload时子元素已经被dispose导致getOuter函数报错
            try {
                this.$hide();
            }
            catch(e) {}
        }
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 窗体控件获得焦点时需要将自己置于所有窗体控件的顶部。
     * @override
     */
    UI_FORM_CLASS.$focus = function () {
        UI_CONTROL_CLASS.$focus.call(this);
        UI_FORM_FLUSH_ZINDEX(this);
    };

    /**
     * 窗体隐藏时将失去焦点状态，如果窗体是以 showModal 方式打开的，隐藏窗体时，需要恢复页面的状态。
     * @override
     */
    UI_FORM_CLASS.$hide = function () {
        // showModal模式下隐藏窗体需要释放遮罩层
        var i = indexOf(UI_FORM_ALL, this);
        if (i >= 0) {
            UI_FORM_ALL.splice(i, 1);
        }

        if (i > UI_FORM_ALL.length - UI_FORM_MODAL) {
            if (this._bFlag) {
                if (i == UI_FORM_ALL.length) {
                    mask();
                }
                else {
                    // 如果不是最后一个，将遮罩层标记后移
                    UI_FORM_ALL[i]._bFlag = true;
                }
                this._bFlag = false;
            }
            UI_FORM_MODAL--;
        }

        UI_CONTROL_CLASS.$hide.call(this);
        loseFocus(this);
    };

    /**
     * @override
     */
    UI_FORM_CLASS.$setSize = function (width, height) {
        if (this._bAutoHeight) {
            height = null;
        }
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();

        var style = this.getMain().lastChild.style;

        style.width = this.getBodyWidth() + 'px';
        if (!this._bAutoHeight) {
            style.height = this.getBodyHeight() + 'px';
        }
        if (this._bAutoTitle) {
            this._uTitle.$setSize(this.getWidth() - this.$getBasicWidth());
        }
    };

    /**
     * 窗体显示时将获得焦点状态。
     * @override
     */
    UI_FORM_CLASS.$show = function () {
        UI_FORM_ALL.push(this);
        UI_CONTROL_CLASS.$show.call(this);
        setFocused(this);
    };

    /**
     * 窗体居中显示。
     * @public
     */
    UI_FORM_CLASS.center = function () {
        o = this.getOuter();
        o.style.position = this.$$position = 'absolute';
        o = o.offsetParent;

        if (!o || o.tagName == 'BODY' || o.tagName == 'HTML') {
            var o = getView(),
                x = o.right + o.left,
                y = o.bottom + o.top;
        }
        else {
            x = o.offsetWidth;
            y = o.offsetHeight;
        }

        this.setPosition(MAX((x - this.getWidth()) / 2, 0), MAX((y - this.getHeight()) / 2, 0));
    };

    /**
     * 如果窗体是以 showModal 方式打开的，只有位于最顶层的窗体才允许关闭。
     * @override
     */
    UI_FORM_CLASS.hide = function () {
        for (var i = indexOf(UI_FORM_ALL, this), o; o = UI_FORM_ALL[++i]; ) {
            if (o._bFlag) {
                return false;
            }
        }
        return UI_CONTROL_CLASS.hide.call(this);
    };

    /**
     * @override
     */
    UI_FORM_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uTitle.init();
        this._uClose.init();
        if (this._bFlag) {
            this._bFlag = false;
            this.$hide();
        }
        else {
            this.$show();
        }
    };

    /**
     * 设置窗体控件标题。
     * @public
     *
     * @param {string} text 窗体标题
     */
    UI_FORM_CLASS.setTitle = function (text) {
        this._uTitle.setContent(text || '');
    };

    /**
     * @override
     */
    UI_FORM_CLASS.show = function () {
        if (UI_FORM_MODAL && indexOf(UI_FORM_ALL, this) < UI_FORM_ALL.length - UI_FORM_MODAL) {
            // 如果已经使用showModal，对原来不是showModal的窗体进行处理
            UI_FORM_MODAL++;
        }

        var result = UI_CONTROL_CLASS.show.call(this);
        if (!result) {
            UI_FORM_FLUSH_ZINDEX(this);
        }
        else if (this._bAutoCenter) {
            this.center();
        }

        return result;
    };

    /*
     * @override
     */
    UI_FORM_CLASS.$resize = function () {
        var style = this.getMain().lastChild.style; 

        UI_CONTROL_CLASS.$resize.call(this);
        style.width = '';
        style.height = '';
    };

    /**
     * override
     * 自适应高度时getHeight需要实时计算
     */
    UI_FORM_CLASS.getHeight = function () {
        if (this._bAutoHeight) {
            this.cache(true, true);
        }
        return UI_CONTROL_CLASS.getHeight.call(this);
    }

    /**
     * 窗体以独占方式显示
     * showModal 方法将窗体控件以独占方式显示，此时鼠标点击窗体以外的内容无效，关闭窗体后自动恢复。
     * @public
     *
     * @param {number} opacity 遮罩层透明度，默认为0.05
     */
    UI_FORM_CLASS.showModal = function (opacity) {
        if (!this._bFlag) {
            if (indexOf(UI_FORM_ALL, this) < UI_FORM_ALL.length - UI_FORM_MODAL) {
                UI_FORM_MODAL++;
            }

            mask(opacity !== undefined ? opacity : 0.05, 32766 + UI_FORM_MODAL * 2);

            this._bFlag = true;
            if (!UI_CONTROL_CLASS.show.call(this)) {
                UI_FORM_FLUSH_ZINDEX(this);
            }
            else if (this._bAutoCenter) {
                this.center(); 
            }
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * ist.opanaly.fcanaly.ui.DimSelectPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    维度选择面板
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui
 */

$namespace('di.shared.ui');

(function() {
    
    //-----------------------------------
    // 引用
    //-----------------------------------
    
    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var ecuiCreate = UTIL.ecuiCreate;
    var template = xutil.string.template;
    var q = xutil.dom.q;
    var addClass = xutil.dom.addClass;
    var createSingleton = xutil.object.createSingleton;
    var hasValueNotBlank = xutil.lang.hasValueNotBlank;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var stringToDate = xutil.date.stringToDate;
    var trim = xutil.string.trim;
    var bind = xutil.fn.bind;
    var XVIEW = xui.XView;
    var UI_FORM = ecui.ui.Form;
    var UI_BUTTON = ecui.ui.Button;
    var UI_IND_TREE = ecui.ui.IndTree;
    var UI_CALENDAR = ecui.ui.IstCalendar;
    var DIM_SELECT_MODEL;

    $link(function() {
        DIM_SELECT_MODEL = di.shared.model.DimSelectModel;
    });

    //-----------------------------------
    // 类型声明
    //-----------------------------------

    /**
     * 维度树选择浮层
     * 单例，直接使用DIM_SELECT_PANEL()可得到实例
     * 
     * @class
     * @extends xui.XView
     */
    var DIM_SELECT_PANEL = 
        $namespace().DimSelectPanel = createSingleton(
            XVIEW,
            dimSelectPanelConstructor
        );
    var DIM_SELECT_PANEL_CLASS = DIM_SELECT_PANEL.prototype;

    /**
     * 构造函数
     *
     * @constructor
     * @param {Object} options 参数
     */
    function dimSelectPanelConstructor(options) {
        createModel.call(this, options);
        createView.call(this, options);
        this.init();
    }

    //-----------------------------------
    // 模板
    //-----------------------------------

    var TPL_MAIN = [
            '<div class="q-di-form">',
                '<label>维度选择</label>',
                '<div class="di-dim-select-tree">',
                    '<div class="q-di-tree"></div>',
                '</div>',
                '<div class="di-dim-select-cal">',
                    '<div class="q-calendar"></div>',
                '</div>',
                '<div>',
                    '<div class="di-dim-select-btn">',
                        '<div class="ui-button-g ui-button q-di-submit">确定</div>',
                        '<div class="ui-button q-di-cancel">取消</div>',
                    '</div>',
                '<div>',
            '</div>'
        ].join('');

    //-----------------------------------
    // 方法
    //-----------------------------------

    /**
     * 创建Model
     *
     * @private
     */
    function createModel() {
        this._mDimSelectModel = new DIM_SELECT_MODEL();
    };

    /**
     * 创建控件
     *
     * @private
     */
    function createView() {
        // 创建主dom
        var el = this._eMain = document.createElement('div');
        addClass(el, 'di-dim-select-panel');

        document.body.appendChild(el);
        el.innerHTML = TPL_MAIN;

        // 创建控件
        this._uForm = ecuiCreate(
            UI_FORM,
            q('q-di-form', el)[0],
            null,
            { hide: true }
        );

        this._uDimTree = ecuiCreate(
            UI_IND_TREE,
            q('q-di-tree', el)[0]
        );

        this._uCalendar = ecuiCreate(
            UI_CALENDAR,
            q('q-calendar', el)[0],
            null, 
            {
                mode: 'RANGE',
                viewMode: 'FIX',
                shiftBtnDisabled: true
            }
        );

        this._uSubmitBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-submit', el)[0]
        );
        this._uCancelBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-cancel', el)[0]
        );
    };

    /**
     * @override
     */
    DIM_SELECT_PANEL_CLASS.init = function() {
        var me = this;

        // 事件绑定
        this._mDimSelectModel.attach(
            ['sync.preprocess.TREE', this.disable, this],
            ['sync.result.TREE', this.$handleTreeSuccess, this],
            ['sync.error.TREE', this.$handleTreeError, this],
            ['sync.complete.TREE', this.enable, this]
        );
        this._mDimSelectModel.attach(
            ['sync.preprocess.SAVE', this.disable, this],
            ['sync.result.SAVE', this.$handleSubmitSuccess, this],
            ['sync.error.SAVE', this.$handleSubmitError, this],
            ['sync.complete.SAVE', this.enable, this]
        );
        this._uSubmitBtn.onclick = bind(this.$submitHandler, this);
        this._uCancelBtn.onclick = bind(this.$cancelHandler, this);

        // Init
        this._uForm.init();
        this._uDimTree.init();
        this._uSubmitBtn.init();
        this._uCancelBtn.init();
        this._uCalendar.init();

        this._uCalendar.hide();
        // this._uForm.$resize();

        this.$resetInput();
    };
    
    /**
     * @override
     */
    DIM_SELECT_PANEL_CLASS.dispose = function() {
        DIM_SELECT_PANEL.superClass.dispose.call(this);
    };

    /**
     * 打开面板
     *
     * @public
     * @param {string} mode 可取值：
     *                       'VIEW': 查看
     *                       'EDIT': 修改
     * @param {Object} options 参数
     * @param {string=} options.uniqName
     * @param {string} options.selLineName
     * @param {Function} options.commonParamGetter
     * @param {string} options.reportType 值为TABLE或者CHART
     * @param {string=} options.dimMode 模式，
     *      可选值为'NORMAL'（默认）, 'TIME'（时间维度面板）
     */
    DIM_SELECT_PANEL_CLASS.open = function(mode, options) {
        this._sMode = mode;
        this._oOptions = options;

        this.$resetInput();

        // 每次打开时从后台获取维度树和当前所选
        this._mDimSelectModel.sync(
            { 
                datasourceId: 'TREE', 
                args: this._oOptions
            }
        );
    };

    /**
     * 重置
     * 
     * @public
     */
    DIM_SELECT_PANEL_CLASS.$resetInput = function() {
        // 清空以及恢复状态
        // 如果后续只有此一行代码则移除此方法直接调用clear prompt
        this.$clearPrompt();
    };

    /**
     * 清除prompt
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$clearPrompt = function() {
        // TODO
    };

    /**
     * 解禁操作
     *
     * @override
     * @public
     */
    DIM_SELECT_PANEL_CLASS.enable = function(enable) {
        if (this._bDisabled && this._sMode == 'EDIT') {
            this._uSubmitBtn.enable();
            this._uCancelBtn.enable();
            this._uDimTree.enable(); // FIXME 验证
        }
        DIM_SELECT_PANEL.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @override
     * @public
     */
    DIM_SELECT_PANEL_CLASS.disable = function(enable) {
        if (!this._bDisabled) {
            this._uSubmitBtn.disable();
            this._uCancelBtn.disable();
            this._uDimTree.disable(); // FIXME 验证
        }
        DIM_SELECT_PANEL.superClass.disable.call(this);
    };    

    /**
     * 提交事件处理
     *
     * @protected
     * @event
     */
    DIM_SELECT_PANEL_CLASS.$submitHandler = function() {
        this._mDimSelectModel.sync(
            { 
                datasourceId: 'SAVE',
                args: extend(
                    {
                        treeSelected: this._uDimTree.getSelected(),
                        levelSelected: this._uDimTree.getLevelSelected(),
                        timeSelect: {
                            start: this._uCalendar.getDate(),
                            end: this._uCalendar.getDateEnd() 
                        }
                    },
                    this._oOptions
                )
            }
        );
    };

    /**
     * 取消事件处理
     *
     * @protected
     * @event
     */
    DIM_SELECT_PANEL_CLASS.$cancelHandler = function() {
        this._uForm.hide();
    };

    /**
     * 原因添加成功结果处理
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleTreeSuccess = function() {
        try {
            var model = this._mDimSelectModel;

            this._uForm.showModal(DICT.DEFAULT_MASK_OPACITY);

            // 渲染维度树
            this._uDimTree.render(
                {
                    tree: model.getCurrDimTree(),
                    level: model.getCurrLevelList()
                }
            );

            if (this._oOptions.dimMode == 'TIME') {
                this._uCalendar.show();
                var timeSelect = model.getTimeSelect();
                this._uCalendar.setDate(
                    stringToDate(timeSelect.start),
                    stringToDate(timeSelect.end)
                );
            }
            else {
                this._uCalendar.hide();
            }
            
            this._uForm.center();
        }
        catch (e) {
            // 需求变化性很大，数据源很杂，真不敢保证返回数据总是匹配，
            // 所以暂用try catch
            this.$handleTreeError();
        }
    };

    /**
     * 原因添加失败结果处理
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleTreeError = function() {
        var me = this;
        // 获取维度树出错，提示并关闭面板
        DIALOG.alert(
            LANG.GET_DIM_TREE_ERROR,
            function() {
                me._uForm.hide();
            }
        );
    };

    /**
     * 原因添加成功结果处理
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleSubmitSuccess = function() {
        this._uForm.hide();
        /**
         * @event di.shared.ui.DimSelectPanel#submit.close
         */
        this.notify('submit.close');
    };

    /**
     * 原因添加失败结果处理
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleSubmitError = function(status) {
        DIALOG.alert(LANG.SAVE_FAILURE);
    };

})();


/**
 * di.shared.ui.OlapMetaDragger
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    多维分析报表元数据拖拽
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var getByPath = xutil.object.getByPath;
    var getUID = xutil.uid.getIncreasedUID;
    var XOBJECT = xui.XObject;
    var UI_DROPPABLE_LIST;
    var UI_DRAGPABLE_LIST;
    var DIM_SELECT_PANEL;
    var ecuiCreate = UTIL.ecuiCreate;
    var ecuiDispose = UTIL.ecuiDispose;

    $link(function () {
        UI_DROPPABLE_LIST = getByPath('ecui.ui.DroppableList');
        UI_DRAGPABLE_LIST = getByPath('ecui.ui.DraggableList');
    });
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 元数据（指标维度）条件拖动选择
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     * @param {Object} options.reportType 类型，
     *          TABLE(默认)或者CHART
     * @param {Function=} options.commonParamGetter 公共参数获取     
     */
    var OLAP_META_DRAGGER = $namespace().OlapMetaDragger = 
            inheritsObject(XOBJECT, constructor);
    var OLAP_META_DRAGGER_CLASS = OLAP_META_DRAGGER.prototype;
    
    //------------------------------------------
    // 模板 
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="meta-condition-src">',
            '<div class="meta-condition-ind">',
                '<div class="meta-condition-head-text">选择指标：</div>',
                '<div class="meta-condition-ind-line q-di-meta-ind"></div>',
            '</div>',
            '<div class="meta-condition-dim">',
                '<div class="meta-condition-head-text">选择维度：</div>',
                '<div class="meta-condition-dim-line q-di-meta-dim"></div>',
            '</div>',
        '</div>',
        '<div class="meta-condition-tar q-di-meta-tar">',
        '</div>'
    ].join('');

    var TPL_SEL_LINE = [
        '<div class="meta-condition-sel">',
            '<div class="meta-condition-head-text">#{0}</div>',
            '<div class="meta-condition-sel-line q-di-meta-sel-line"></div>',
        '</div>'
    ].join('');

    var DEFAULT_SEL_LINE_TITLE = {
        ROW: '行：',
        FILTER: '过滤：',
        COLUMN: '列：'
    };


    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'meta-condition');

        // 模板
        el.innerHTML = TPL_MAIN;

        // 控件/DOM引用
        this._eSelLineArea = q('q-di-meta-tar', el)[0];

        // selLine控件集合，key为selLineName
        this._oSelLineWrap = new LINKED_HASH_MAP();
        // selLine控件id集合，key为selLineName
        this._oSelLineIdWrap = {};
    };
    
    /**
     * 初始化
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.init = function () {
    };

    /**
     * 设置数据
     *
     * @public
     * @param {Object} data 数据
     * @param {Object} data.inddim
     *      控件所需的item 的数据结构
     *      {string} uniqName （相当于控件的value）
     *      {string} caption （相当于控件的text）
     *      {string} clazz （标志是'IND'还是'DIM'）
     *      {boolean} fixed 是否固定
     *      {string} align item居左（'LEFT'）还是居右（'RIGHT'）
     * @param {Object} data.selLineDataWrap
     * @param {Object=} data.selLineTitleDef 标题定义，
     *      形如{ ROW: '行', COLUMN: '列, FITER: '过滤' }，
     *      为空则取默认。
     * @param {Object=} data.rule 拖拽规则
     *      FIXME
     *      这些规则配置没有实现，后续重构规则配置
     *      {Object=} data.rule.IND 指标规则
     *      {Object=} data.rule.DIM 维度规则
     *          规则项有：
     *              {Array.<string>} dropPos 可下落的位置（null则全可下落）
     *                  每项值可为'COL'\'ROW'\'FILTER'
     *      {Object=} data.rule.COL 列规则
     *      {Object=} data.rule.ROW 行规则
     *      {Object=} data.rule.FILTER 过滤器规则
     *          规则项有：
     *              {boolean} canEmpty 是否可为空（默认true）
     *              {boolean} draggable 是否可拖拽（默认true）
     *              {boolean} selectable 是否可选择（默认true）
     * @param {boolean} isSilent
     */
    OLAP_META_DRAGGER_CLASS.setData = function (data, isSilent) {
        this._oData = data || {};
        this._mModel = data.model;
        this._oRule = data.rule || {};
        !isSilent && this.render();
    };

    /**
     * 渲染
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.render = function () {
        var me = this;
        var el = this._eMain;
        var data = this._oData;

        // 清空
        this.$disposeInner();

        // 指标维度
        var sourceEcuiId = [
            '\x06_DI_META_COND_IND' + getUID('DI_META_COND'),
            '\x06_DI_META_COND_DIM' + getUID('DI_META_COND')
        ];
        var inddim = data.inddim;

        // 指标控件
        this._uIndSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-ind', el)[0],
            null,
            {
                id: sourceEcuiId[0],
                disableSelected: true, // 暂禁止重复拖动
                clazz: 'IND'
            }
        );
        inddim.indList.foreach(
            function (uniqName, item) {
                me._uIndSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align
                    }
                );
            }
        );

        // 维度控件
        this._uDimSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-dim', el)[0],
            null,
            {
                id: sourceEcuiId[1],
                disableSelected: true,
                clazz: 'DIM'
            }
        );
        inddim.dimList.foreach(
            function (uniqName, item) {
                me._uDimSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align
                    }
                );
            }
        );

        // 增加默认的selLine
        data.selLineDataWrap.foreach(
            function (name, selLineData, index) {
                me.$addSelLine(
                    name,
                    (data.selLineTitleDef || DEFAULT_SEL_LINE_TITLE)[
                        name.split('_')[0]
                    ],
                    sourceEcuiId.join(','),
                    selLineData
                );
            }
        );

        // 事件绑定
        this._uIndSrc.onchange = bind(this.$handleSelLineChange, this);
        this._uDimSrc.onchange = bind(this.$handleSelLineChange, this); 
        this._oSelLineWrap.foreach(
            function (selLineName, selLineCtrl) {
                selLineCtrl.onitemclick = bind(
                    me.$handleItemClick, 
                    me, 
                    selLineName
                );

                selLineCtrl.oncheckdroppable = bind(
                    me.$checkSelLineDroppable, me
                );
                selLineCtrl.oncheckdraggable = bind(
                    me.$checkSelLineDraggable, me
                );
            }
        );
    };

    /**
     * @override
     */
    OLAP_META_DRAGGER_CLASS.dispose = function () {
        this.$disposeInner();
        this._eSelLineArea = null;
        OLAP_META_DRAGGER.superClass.dispose.call(this);
    };

    /**
     * 内部清空
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$disposeInner = function () {
        if (this._uIndSrc) {
            ecuiDispose(this._uIndSrc);
            this._uIndSrc = null;
        }
        if (this._uDimSrc) {
            ecuiDispose(this._uDimSrc);
            this._uDimSrc = null;
        }
        this._oSelLineWrap.foreach(
            function (name, item, index) {
                ecuiDispose(item);
            }
        );
        this._eSelLineArea.innerHTML = '';
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        this._oSelLineIdWrap = {};
    };

    /**
     * 增加选择行
     * 
     * @protected
     * @param {string} selLineName selLine名
     * @param {string} selLineTitle selLine显示名
     * @param {string} source 来源ecui控件id
     * @param {xutil.LinkedHashMap=} selLineData selLine数据
     */
    OLAP_META_DRAGGER_CLASS.$addSelLine = function (
        selLineName, selLineTitle, source, selLineData
    ) {
        if (selLineName == null) {
            return;
        }
        var selLineWrap = this._oSelLineWrap;
        var selLineIdWrap = this._oSelLineIdWrap;

        // 增加selLine
        var o = document.createElement('div');
        o.innerHTML = template(TPL_SEL_LINE, selLineTitle);
        this._eSelLineArea.appendChild(o = o.firstChild);

        selLineWrap.addLast(
            ecuiCreate(
                UI_DROPPABLE_LIST, 
                q('q-di-meta-sel-line', o)[0],
                null,
                {
                    id: selLineIdWrap[selLineName] = 
                        '\x06_DI_META_COND_SEL' + getUID('DI_META_COND'),
                    source: source,
                    name: selLineName,
                    configBtn: false
                }
            ),
            selLineName
        );

        // 设置新增控件target，并对所有其他selLine设置target
        for (var name in selLineIdWrap) {
            if (name != selLineName) {
                selLineWrap.get(name).addTarget(selLineIdWrap[selLineName]);
            }
            selLineWrap.get(selLineName).addTarget(selLineIdWrap[name]);
        }
        this._uIndSrc.addTarget(selLineIdWrap[selLineName]);
        this._uDimSrc.addTarget(selLineIdWrap[selLineName]);

        // 初始数据
        if (selLineData) {
            selLineData.foreach( 
                function (uniqName, item, index) {
                    selLineWrap.get(selLineName).addItem(
                        {
                            value: item.uniqName, 
                            text: item.caption,
                            clazz: item.clazz,
                            fixed: item.fixed,
                            align: item.align
                        }
                    );
                }
            );
        }
    };

    /**
     * 更新控件的元数据状态
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.refreshStatus = function (statusWrap) {
        if (statusWrap) {
            this._uIndSrc.setState(
                { 
                    disable: statusWrap.indMetas.disabledMetaNames,
                    selected: statusWrap.indMetas.selectedMetaNames
                }
            );
            this._uDimSrc.setState(
                { 
                    disable: statusWrap.dimMetas.disabledMetaNames,
                    selected: statusWrap.dimMetas.selectedMetaNames
                }
            );
        }
    };

    /**
     * 解禁操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    OLAP_META_DRAGGER_CLASS.enable = function (key) {
        // TODO 检查
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            this._uIndSrc && this._uIndSrc.enable();
            this._uDimSrc && this._uDimSrc.enable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.enable();
                }
            );
        }
        OLAP_META_DRAGGER.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    OLAP_META_DRAGGER_CLASS.disable = function (key) {
        objKey.add(this, key);

        // TODO 检查
        if (!this._bDisabled) {
            this._uIndSrc && this._uIndSrc.disable();
            this._uDimSrc && this._uDimSrc.disable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.disable();
                }
            );
        }
        OLAP_META_DRAGGER.superClass.disable.call(this);
    };    

    /**
     * 获取元数据选择处理
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$handleSelLineChange = function (
        itemData, itemIndex, selLineName, oriItemIndex, oriSelLineName
    ) {
        var wrap = {};
        this._oSelLineWrap.foreach(
            function (k, o, index) {
                wrap[k] = o.getValue();
            }
        );

        var changeWrap = {
            from: oriSelLineName,
            to: selLineName,
            toPosition: itemIndex,
            uniqNameList: [itemData.value]
        };

        // 根据规则修正变化
        // this.$fixSelLineChange(itemData, itemIndex, selLineName, changeWrap);

        /**
         * 选择变化事件
         *
         * @event
         */
        this.notify('sellinechange', [wrap, changeWrap]);
    };

    /**
     * selLine上指标维度点击事件处理
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$handleItemClick = function (
        selLineName, event, itemData
    ) {
        var metaItem = 
            this._mModel.getMetaItem(itemData.value);

        // 维度--打开维度选择面板
        if (metaItem && metaItem.clazz == 'DIM') {
            DIM_SELECT_PANEL().open(
                'EDIT',
                {
                    uniqName: itemData.value,
                    reportType: this._sReportType,
                    selLineName: selLineName,
                    dimMode: metaItem.isTimeDim ? 'TIME' : 'NORMAL',
                    commonParamGetter: this._fCommonParamGetter
                }
            );
        }
        // 指标--打开指标设置面板
        else {
            // TODO
        }
    };

    /**
     * 从selline中寻找item
     *
     * @private
     * @param {string} clazz 'IND'或者'DIM'
     * @param {string=} selLineName 指定的selLineName，缺省则全局找
     * @param {Item=} exclude 排除
     * @return {Array.<Object>} 每项中含有：
     *          item：查找到的item
     *          selLineName：行名
     *          index：item的index
     */
    OLAP_META_DRAGGER_CLASS.$findItemFromSelLine = function(
        clazz, selLineName, exclude
    ) {
        var ret = [];

        function findInLine(selLineName, selLine) {
            var itemList = selLine.getItems();
            for (var i = 0, item; item = itemList[i]; i ++) {
                if (item != exclude && item.getClazz() == clazz) {
                    ret.push(
                        { 
                            item: item, 
                            selLineName: selLineName, 
                            index: i 
                        }
                    );
                }
            }
        }

        if (selLineName) {
            findInLine(selLineName, this._oSelLineWrap.get(selLineName));
        }
        else {
            this._oSelLineWrap.foreach(findInLine);
        }

        return ret;
    }


    //---------------------------------------------------
    // 拖拽规则(后续重构) FIXME
    //---------------------------------------------------

    /**
     * selLine上检查是否可以drop
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$checkSelLineDroppable = function (
        itemData, index, selLineName
    ) {
        var rule = this._oRule;
        // var ruleIND = rule.IND || {};
        // var ruleDIM = rule.DIM || {};

        // 规则 FORBID_1：指标只能拖到列上
        if (itemData.clazz == 'IND' && selLineName.indexOf('COL') < 0) {
            return false;
        }

        // 规则 FORBID_5：维度不能拖到列上
        if (itemData.clazz == 'DIM' && selLineName.indexOf('COL') >= 0) {
            return false;
        }

        // 规则 FORBID_7：filter不能drop
        if (selLineName.indexOf('FILTER') >= 0) {
            return false;
        }

        var selLine = this._oSelLineWrap.get(selLineName);

        // 规则 FORBID_4：有align标志的，只能在左或右
        // 这里假设后台来的数据都已经是align正确的，前台仅就拖拽行为进行限制
        var items = selLine.getItems();
        var item;
        if ((
                (item = items[index]) 
                && item.getWrap().align == 'LEFT'
            )
            || (
                (item = items[index - 1]) 
                && item.getWrap().align == 'RIGHT'
            )
        ) {
            return false;
        }

        return true;
    };
    
    /**
     * selLine上检查是否可以drag
     * 
     * @protected
     */    
    OLAP_META_DRAGGER_CLASS.$checkSelLineDraggable = function (
        itemData, index, selLineName
    ) {
        var rule = this._oRule;

        // 规则 FORBID_2：禁止指标维度全部拖空
        var selLine = this._oSelLineWrap.get(selLineName);
        if (selLine.count() <= 1) {
            if (rule.forbidColEmpty && selLineName.indexOf('COL') >= 0) {
                return false;
            }
            if (rule.forbidRowEmpty && selLineName.indexOf('ROW') >= 0) {
                return false;
            }
        }

        // 规则 FORBID_3：有fixed标志的，不能拖走
        if (itemData.fixed) {
            return false;
        }

        // 规则 FORBID_6：filter不能操作（禁止拖动、放大镜）
        if (selLineName.indexOf('FILTER') >= 0) {
            return false;
        }

        return true;
    }

    /**
     * 根据规则对拖拽结果进行修正
     * （这段逻辑没有启用，后面会移到后台）
     * 
     * @protected
     * @deprecated
     */
    OLAP_META_DRAGGER_CLASS.$fixSelLineChange = function (
        itemData, itemIndex, selLineName, changeWrap
    ) {
        if (itemIndex == null) {
            // 移除的情况，不作修正
            return;
        }
        
        // 规则 FIX_1：所有指标和计算列，总是连在一起。
        //          （指标和计算列的连带暂未实现）

        // 规则 FIX_2：指标区要么在头部，要么在尾部。

        // 被移动的项是否是计算列
        var isCal = (itemData.calcColumnRefInd || []).length > 0;
        var selLine = this._oSelLineWrap.get(selLineName);
        var selLineItems = selLine.getItems() || [];
        var dragItem = selLineItems[itemIndex];
        var prev = selLineItems[itemIndex - 1];
        var next = selLineItems[itemIndex + 1];
        var prevData = prev && prev.getWrap();
        var nextData = next && next.getWrap();
        var oList;
        var o;
        var des;
        var targetIndex;
        var i;

        // 判断dragItem的两边状况
        var side = { IND: [], DIM: [], WALL: [] };
        prevData 
            ? (side[prevData.clazz][0] = 1)
            : (side.WALL[0] = 1);
        nextData 
            ? (side[nextData.clazz][1] = 1)
            : (side.WALL[1] = 1);

        // IF 拖拽的dragItem是dim
        if (itemData.clazz == 'DIM') {
            // IF dragItem两边都是dim，THEN do nothing

            // IF dragItem一边是ind，另一边是dim，THEN do nothing

            // IF dragItem一边是ind，另一边是墙 
            if (side.IND.length > 0 && side.WALL.length > 0) {
                // THEN 同行所有dim都移入ind区和dragItem间
                oList = this.$findItemFromSelLine('DIM', selLineName, dragItem);                                
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, side.IND[0] ? (selLine.count() - 1) : 1);
                }
            }

            // IF dragItem两边都是ind
            else if (side.IND[0] && side.IND[1]) {
                // THEN 往两边找到dim区，item移入dim区和ind区之间
                // 用首尾判断即可
                des = selLineItems[0].getClazz() == 'DIM';
                for (
                    i = des ? 0 : (selLineItems.length - 1); 
                    o = selLineItems[i]; 
                    i += des ? 1 : -1
                ) {
                    if (o.getClazz() == 'IND') {
                        targetIndex = des ? i : (i + 1);
                        break;
                    }
                }
                selLine.remove(dragItem);
                selLine.add(
                    dragItem, 
                    targetIndex <= itemIndex ? targetIndex : targetIndex - 1
                );
            }
        }

        // IF 拖拽的dragItem是ind
        else if (itemData.clazz == 'IND') {
            // IF dragItem两边都是ind，THEN do nothing

            // IF dragItem一边是ind，另一边是dim，THEN do nothing

            // IF dragItem一边是dim，另一边是墙 
            if (side.DIM.length > 0 && side.WALL.length > 0) {
                // THEN 全局所有ind都移入dim区和dragItem间
                oList = this.$findItemFromSelLine('IND', null, dragItem);
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, side.DIM[0] ? (selLine.count() - 1) : 1);
                }
            }

            // IF dragItem两边都是dim
            else if (side.DIM[0] && side.DIM[1]) {
                // THEN 找到离墙近的那边，把dragItem移动到墙边，
                des = itemIndex > (selLineItems.length - 1) / 2;
                selLine.remove(dragItem);
                selLine.add(dragItem, des ? selLine.count() : 0);
                
                // 再把所有ind移动到dragItem和dragItem之间
                oList = this.$findItemFromSelLine('IND', null, dragItem);
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, des ? (selLine.count() - 1) : 1);
                }
            }
        }

        // 修正changeWrap的toPosition
        selLineItems = selLine.getItems() || [];
        for (i = 0; o = selLineItems[i]; i ++) {
            if (o.getClazz == 'IND') {

            }
        }
    };

})();
/**
 * di.shared.model.DITableModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 表模型组件
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI 表模型组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_TABLE_MODEL = 
            $namespace().DITableModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_TABLE_MODEL_CLASS = 
            DI_TABLE_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
    }

    /**
     * @override
     */
    DI_TABLE_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('OLAP_TABLE_DATA'),
            DRILL: URL.fn('OLAP_TABLE_DRILL'),
            LINK_DRILL: URL.fn('OLAP_TABLE_LINK_DRILL'),
            SORT: URL.fn('OLAP_TABLE_SORT'),
            CHECK: URL.fn('OLAP_TABLE_CHECK'),
            SELECT: URL.fn('OLAP_TABLE_SELECT'),
            OFFLINE_DOWNLOAD: URL.fn('OLAP_TABLE_OFFLINE_DOWNLOAD')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_TABLE_MODEL_DATA_' + getUID(),
            DRILL: 'DI_TABLE_MODEL_DRILL_' + getUID(),
            LINK_DRILL: 'DI_TABLE_MODEL_LINK_DRILL_' + getUID(),
            SORT: 'DI_TABLE_MODEL_SORT_' + getUID(),
            CHECK: 'DI_TABLE_MODEL_CHECK_' + getUID(),
            SELECT: 'DI_TABLE_MODEL_SELECT_' + getUID(),
            OFFLINE_DOWNLOAD: 'DI_TABLE_OFFLINE_DOWNLOAD_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) {
                return this._fCommonParamGetter(options.args.param);
            },
            DRILL: function (options) {
                return createLinkDrillParam.call(this, options);
            },
            LINK_DRILL: function (options) {
                return createLinkDrillParam.call(this, options);
            },
            SORT: function (options) {
                var param = options.args.param;
                return this._fCommonParamGetter(
                    {
                        uniqueName: param.uniqueName,
                        sortType: param.currentSort
                    }
                );
            },
            CHECK: function (options) {
                return this._fCommonParamGetter(
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            SELECT: function (options) {
                return this._fCommonParamGetter(
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            OFFLINE_DOWNLOAD: function (options) {
                return this._fCommonParamGetter(
                    { mailTo: options.args.param.email }
                );
            }
        }
    );

    /**
     * 创建链接式下钻参数
     *
     * @private
     */
    function createLinkDrillParam(options) {
        var param = options.args.param;
        var paramObj = {};
        
        paramObj['uniqueName'] = param.uniqueName;
        paramObj['lineUniqueName'] = param.lineUniqueName;

        paramObj['action'] = param.action;
        // FIXME
        // 现在先写死，不存在上表头下钻
        paramObj['drillAxisName'] = 'ROW';
        
        return this._fCommonParamGetter(paramObj);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            DRILL: doComplete,
            LINK_DRILL: doComplete,
            SORT: doComplete,
            CHECK: doComplete,
            OFFLINE_DOWNLOAD: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: doParse,
            DRILL: doParse,
            LINK_DRILL: doParse,
            SORT: doParse,
            CHECK: function (data) { return data; },
            SELECT: function (data) { return data; }
        }
    );

    /**
     * 解析后台数据
     * 
     * @private
     */
    function doParse(data, ejsonObj, options) {
        try {
            var retData = {};
            var tableData = retData.tableData = data['pivottable'];

            // 控件数据
            tableData.datasource = tableData.dataSourceRowBased;

            var i;
            var j;
            var o;
            var colspan;
            var headLength;

            // 控件列定义(colDefine)构造
            var firstLine = tableData['colFields'][0];
            var rawColDefine = tableData.colDefine;
            var colDefine = [];
            for (i = 0; i < firstLine.length; i ++) {
                o = firstLine[i];
                if (!o) { continue; }
                colspan = o.colspan || 1;
                for (j = 0; j < colspan; j ++) {
                    colDefine.push({ width:1 });
                }
            }
            headLength = colDefine.length - rawColDefine.length;
            for (i = 0; i < rawColDefine.length; i ++) {
                extend(colDefine[i + headLength], rawColDefine[i]);
            }
            tableData.colDefine = colDefine;

            // 由于之前不合适的接口制定：colspan和rowspan没有占位，导致坐标对不齐，
            // 这引来了很多处理上的麻烦（前后台都麻烦）。
            // 但是后台暂时没精力改了（因为有一定牵连）。
            // 所以这里对colFields和rowHeadFields强制加上占位，使其对其。
            fixColFields(tableData, headLength);
            fixRowHeadFields(tableData, headLength);

            // 排序
            var sortType; 
            var sortKeyMap = { // 前后台接口映射
                ASC: 'asc',
                DESC: 'desc',
                NONE: 'none'
            }
            for (i = 0; i < colDefine.length; i ++) {
                if (sortType = colDefine[i].currentSort) {
                    colDefine[i].orderby = sortKeyMap[sortType];
                }
            }

            // 行选中
            retData.tableData.rowCheckMax = data['rowCheckMax'];
            retData.tableData.rowCheckMin = data['rowCheckMin'];

            // 面包屑
            var breadcrumb = data['mainDimNodes'] || [];
            if (breadcrumb) {
                for (i = 0; o = breadcrumb[i]; i ++) {
                    o.text = o['showName'];
                    o.value = i;
                    o.url = null;
                    if (i == breadcrumb.length - 1) {
                        o.disabled = true;
                    }
                    if (i == 0) {
                        o.isFirst = true;
                    }
                }
            }
            retData.breadcrumbData = {
                datasource: breadcrumb,
                maxShow: 5,
                hidePosPercent: 0.5
            }

            retData.pageInfo = {
                totalRecordCount: data['totalSize'],
                currRecordCount: data['currentSize']
            }

            // retData.tableDataOverlap = getDataOverlap(
            //     tableData, 
            //     options.args.viewStateWrap
            // );
            
            return retData;
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    /**
     * 得到保存的状态，用于覆盖
     *
     * @protected
     */
    // function getDataOverlap(tableData, viewStateWrap) {
    //     if (!tableData || !viewStateWrap) { return; }

    //     var dataOverlap = {};

    //     // 行选择
    //     var rowCheckedMap = viewStateWrap.rowCheckedMap;
    //     if (rowCheckedMap) {
    //         var rowChecked = [];
    //         for (var i = 0, rhd; rhd = tableData.rowDefine[i]; i ++) {
    //             (rhd.uniqueName in rowCheckedMap) && rowChecked.push(i);
    //         }

    //         dataOverlap.rowChecked = rowChecked;
    //     }

    //     return dataOverlap;
    // };

    /**
     * 对colFields进行占位补齐，使用空对象{}进行标志。
     * 约定的法则：
     *      只有左上角第一行有rowspan（前面得到了headLength），
     *      其他地方不考虑rowspan，
     *      并且呈树状展开
     * 
     * @private
     */
    function fixColFields(tableData, headLength) {
        var i;
        var j;
        var k;
        var o;
        var line;
        var rawLine;
        var colspan;
        var colFields = [];

        for (i = 0; rawLine = tableData.colFields[i]; i ++) {
            colFields.push(line = []);
            if (i > 0) {
                // 左上角区域，后台只给第一行，后面的加占位
                for (k = 0; k < headLength; k ++) {
                    line.push({});
                }
            }
            for (j = 0; j < rawLine.length; j ++) {
                line.push(o = rawLine[j]);
                colspan = (o || {}).colspan || 1;
                for (k = 1; k < colspan; k ++) {
                    // 占位
                    line.push({});
                }
            }
        }
        tableData.colFields = colFields;
    }

    /**
     * 对rowHeadFields进行占位补齐，使用空对象{}进行标志。
     * 约定的法则：
     *      不存在colspan，
     *      只有rowspan，
     *      并且呈树状展开
     *
     * @private
     */
    function fixRowHeadFields(tableData, headLength) {
        var i;
        var j;
        var line;
        var rawLine;
        var rowHeadFields = [];

        for (i = 0; rawLine = tableData.rowHeadFields[i]; i ++) {
            rowHeadFields.push(line = []);
            // 前面补齐
            for (j = 0; j < headLength - rawLine.length; j ++) {
                line.push({});
            }
            for (j = 0; j < rawLine.length; j ++) {
                line.push(rawLine[j]);
            }
        }
        tableData.rowHeadFields = rowHeadFields;
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oTableData = {};
                this._oBreadcrumbData = {};
            }
            // TODO
        }
    );

})();


/**
 * di.shared.ui.DITable
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 表视图组件
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var ecuiDispose = UTIL.ecuiDispose;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var ecuiCreate = UTIL.ecuiCreate;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var OLAP_TABLE;
    var BREADCRUMB;
        
    $link(function () {
        OLAP_TABLE = getByPath('ecui.ui.OlapTable');
        BREADCRUMB = getByPath('ecui.ui.Breadcrumb');
    });
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 表视图组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_TABLE = $namespace().DITable = 
        inheritsObject(INTERACT_ENTITY);
    var DI_TABLE_CLASS = DI_TABLE.prototype;
    
    //------------------------------------------
    // 常量 
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="q-di-table-area di-table-area">',
            '<div class="q-di-breadcrumb"></div>',
            '<div class="q-di-table"></div>',
        '</div>'
    ].join('');

    /**
     * 定义
     */
    DI_TABLE_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'di-table',
        // model配置
        model: {
            clzPath: 'di.shared.model.DITableModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_TABLE_CLASS.$createView = function (options) {
        var el = this.$di('getEl');

        var tplMode = this.$di('getTplMode');
        // 模板
        if (tplMode != 'FROM_SNIPPET') {
            el.innerHTML = TPL_MAIN;
        }

        this._uTable = tplMode == 'FROM_SNIPPET'
            ? this.$di('vuiCreate', 'mainTable')
            : ecuiCreate(OLAP_TABLE, q('q-di-table', el)[0]);

        // 为ecui table控件在显示中渲染。后续检查是否有必要用这个方式
        // FIXME
        this._eArea = el;

        // 面包屑
        this._uBreadcrumb = tplMode == 'FROM_SNIPPET'
            ? this.$di(
                'vuiCreate', 
                'breadcrumb', 
                { maxShow: 5 } 
            )
            : ecuiCreate(
                BREADCRUMB,
                q('q-di-breadcrumb', el)[0],
                null,
                { maxShow: 5 }
            );

        // 下载按钮
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 离线下载
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');

        // 条目数值等信息
        // 模板配置接口：totalRecordCount, currRecordCount
        this._uCountInfo = this.$di('vuiCreate', 'countInfo');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_TABLE_CLASS.init = function () {
        var me = this;
        var key;

        // 事件绑定
        for (key in { 
                'DATA': 1, 
                'DRILL': 1, 
                'LINK_DRILL': 1,
                'SORT': 1
            }
        ) {
            this.getModel().attach(
                ['sync.preprocess.' + key, this.$syncDisable, this, key],
                ['sync.result.' + key, this.$renderMain, this],
                ['sync.result.' + key, this.$handleDataLoaded, this],
                ['sync.error.' + key, this.$handleDataError, this],
                ['sync.complete.' + key, this.$syncEnable, this, key]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        this.getModel().attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        this.getModel().attach(
            ['sync.preprocess.CHECK', this.$syncDisable, this, 'CHECK'],
            ['sync.result.CHECK', this.$handleRowAsync, this, false],
            ['sync.error.CHECK', this.$handleRowAsync, this, true],
            ['sync.complete.CHECK', this.$syncEnable, this, 'CHECK']
        );
        this.getModel().attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleRowAsync, this, false],
            ['sync.error.SELECT', this.$handleRowAsync, this, true],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );

        this.getModel().init();

        this._uTable.onexpand = bind(this.$handleExpand, this);
        this._uTable.oncollapse = bind(this.$handleCollapse, this);
        this._uTable.onsort = bind(this.$handleSort, this);
        this._uTable.onrowclick = bind(this.$handleRowClick, this);
        this._uTable.onrowselect = bind(this.$handleRowCheck, this, 'rowselect', 'SELECT');
        this._uTable.onrowcheck = bind(this.$handleRowCheck, this, 'rowcheck', 'CHECK');
        this._uTable.onrowuncheck = bind(this.$handleRowCheck, this, 'rowuncheck', 'CHECK');
        this._uTable.oncelllinkdrill = bind(this.$handleLinkDrill, this);
        this._uTable.oncelllinkbridge = bind(this.$handleLinkBridge, this);
        this._uBreadcrumb && (
            this._uBreadcrumb.onchange = bind(this.$handleBreadcrumbChange, this)
        );
        this._uDownloadBtn && (
            this._uDownloadBtn.onclick = bind(this.$handleDownload, this)
        );
        this._uOfflineDownloadBtn && (
            this._uOfflineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn                
            ],
            'init'
        )
        this._uBreadcrumb && this._uBreadcrumb.hide();

        this._eArea.style.display = 'none';
    };

    /**
     * @override
     */
    DI_TABLE_CLASS.dispose = function () {
        this._uTable && ecuiDispose(this._uTable);
        this._eArea = null;
        DI_TABLE.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     * @event
     * @param {Object} options 参数
     */
    DI_TABLE_CLASS.sync = function (options) {

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA', vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

        // 请求后台
        this.$sync(
            this.getModel(),
            'DATA',
            options || {},
            this.$di('getEvent')
        );
    };

    /**
     * 视图清空
     *
     * @public
     * @event
     */
    DI_TABLE_CLASS.clear = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo
            ],
            'setData'
        ); 
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    DI_TABLE_CLASS.$renderMain = function (data, ejsonObj, options) {
        this._eArea.style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn                
            ],
            'diShow'
        ); 

        var setDataOpt = { diEvent: this.$diEvent(options) };

        // 表格
        this._uTable.$di('setData', data.tableData, setDataOpt);

        // 面包屑
        if (this._uBreadcrumb) {
            if (data.breadcrumbData.datasource
                && data.breadcrumbData.datasource.length > 0
            ) {
                this._uBreadcrumb.show();
                this._uBreadcrumb.$di('setData', data.breadcrumbData, setDataOpt);
            }
            else {
                this._uBreadcrumb.hide();
            }
        }

        // 页信息
        this._uCountInfo && this._uCountInfo.$di(
            'setData', 
            {
                args: {
                    totalRecordCount: data.pageInfo.totalRecordCount,
                    currRecordCount: data.pageInfo.currRecordCount
                }
            },
            setDataOpt
        );

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_TABLE_CLASS.resize = function () {
        this._uTable && this._uTable.resize();
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_TABLE_CLASS.enable = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'enable'
        ); 
        DI_TABLE.superClass.enable.call(this);
    };

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_TABLE_CLASS.disable = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'disable'
        ); 
        DI_TABLE.superClass.disable.call(this);
    };

    /**
     * 下载操作
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('OLAP_TABLE_DOWNLOAD') 
            + '?' + commonParamGetter();
        download(url, null, true);

        // 对于下载，不进行reportTemplateId控制，直接打开
        commonParamGetter.update();
    };

    /**
     * 离线下载操作
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 面包屑点击
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleBreadcrumbChange = function (wrap) {
        this.$sync(
            this.getModel(),
            'LINK_DRILL',
            {
                action: 'EXPAND',
                // 这接口定的很乱，这里是简写的uniq
                uniqueName: wrap['uniqName']
            }
        );
    };  

    /**
     * link式下钻
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleLinkDrill = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'LINK_DRILL',
            {
                action: 'EXPAND',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']
            }
        );
    };        

    /**
     * 报表跳转
     *
     * @protected
     * @param {string} linkBridgeType 跳转类型，值可为'I'(internal)或者'E'(external)
     * @param {string} url 目标url
     * @param {Object} options 参数
     */
    DI_TABLE_CLASS.$handleLinkBridge = function (colDefItem, rowDefItem) {
        this.$di(
            'linkBridge', 
            colDefItem.linkBridge, 
            URL('OLAP_TABLE_LINK_BRIDGE'),
            this.$di('getCommonParamGetter')(
                {
                    colUniqName: colDefItem.uniqueName,
                    rowUniqName: rowDefItem.uniqueName,
                    colDefineId: colDefItem.colDefineId
                }
            )
        );
    };    

    /**
     * 展开（下钻）
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleExpand = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'DRILL',
            {
                action: 'EXPAND',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']
            }
        );
    };

    /**
     * 收起（上卷）
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleCollapse = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'DRILL',
            {
                action: 'COLLAPSE',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']
            }
        );
    };

    /**  
     * 行点击
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowClick = function (rowDefItem) {
        /**
         * 行点击事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            'rowclick',
            [{ uniqueName: rowDefItem.uniqueName }]
        );
    };

    /**  
     * 行选中
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowCheck = function (eventName, datasourceId, rowDefItem, callback) {
        this.$sync(
            this.getModel(),
            datasourceId, 
            { uniqueName: rowDefItem.uniqueName },
            null,
            {
                eventName: eventName,
                callback: callback
            }
        );
    };

    /**  
     * 排序
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleSort = function (colDefineItem) {
        this.$sync(
            this.getModel(),
            'SORT',
            colDefineItem
        );
    };

    /**  
     * 行选中
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowAsync = function (isFailed, data, ejsonObj, options) {

        // 根据后台结果，改变行选中与否
        options.args.callback(data.selected);

        /**
         * line check模式下行选中和取消选中事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            options.args.eventName,
            [{ uniqueName: options.args.param.uniqueName }]
        );
    };

    /**
     * 数据加载成功
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleDataLoaded = function (data, ejsonObj, options) {
        var datasourceId = options.datasourceId;     
        var value = this.$di('getValue');
        var args;
        var param = options.args.param;

        if (datasourceId == 'DATA') {
            args = [value];
        }
        else if (datasourceId == 'LINK_DRILL') {
            args = [assign({}, param, ['uniqueName'])];
        }
        else if (datasourceId == 'DRILL') {
            args = [assign({}, param, ['uniqueName', 'lineUniqueName'])];
        }
        else if (datasourceId == 'SORT') {
            args = [assign({}, param, ['uniqueName', 'currentSort'])];
        }

        /**
         * 数据成功加载事件（分datasourceId）
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            this.$diEvent('dataloaded.' + datasourceId, options),
            args
        );

        if (datasourceId in { DATA: 1, LINK_DRILL: 1, SORT: 1 }) {
            /**
             * 数据改变事件（DRILL在逻辑上是添加数据，不算在此事件中）
             *
             * @event
             */
            this.$di(
                'dispatchEvent', 
                this.$diEvent('datachange', options), 
                [value]
            );
        }

        /**
         * 数据成功加载事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded', options), 
            [value]
        );
    };

    /**
     * 获取表格数据错误处理
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleDataError = function (status, ejsonObj, options) {
        this._eArea.style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'diShow'
        ); 

        // 设置空视图
        this.clear();

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 数据加载失败事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
    };

    /**
     * 离线下载错误处理
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * ecui.ui.Breadcrumb
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   面包屑导航
 * @author: sushuang(sushuang@baidu.com)
 */

 (function() {
    
    var core = ecui;
    var ui = core.ui;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var disposeControl = core.dispose;
    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;

    /**
     * 面包屑导航
     *
     * @class
     * @extends {ecui.ui.Control}
     */
    var UI_BREADCRUMB = ui.Breadcrumb =
        inheritsControl(
            UI_CONTROL,
            'ui-breadcrumb',
            null,
            function(el, options) {
                this.$setOptions(options);
            }
        );
    var UI_BREADCRUMB_CLASS = UI_BREADCRUMB.prototype;

    //--------------------------------------------------
    // UI_BREADCRUMB 方法
    //--------------------------------------------------

    UI_BREADCRUMB_CLASS.$setSize = new Function();
    
    /**
     * 设置参数
     * 
     * @protected
     * @param {Object} options 参数
     * @parma {number=} options.maxShow 最大显示几项，
     *      如果超出，则中部会为'...'。如果不传此参数全显示。
     * @param {number=} options.hidePosPercent 如果设定了maxShow后，
     *      此参数决定了，如果超出后，那部分会使用“...”来隐藏。
     *      此参数是0到1之前的小数，默认为0.5，表示50%处隐藏。
     * @param {Array.<Object>} options.datasource 主体数据
     *      其中数组每项含有属性：
     *          {string} text 显示文字
     *          {number} value 值
     *          {boolean} disabled 是否可以点击
     *          {string=} url 值，可缺省，如果使用url，
     *              则不会触发change事件
     */
    UI_BREADCRUMB_CLASS.$setOptions = function(options) {
        this._oOptions = options || {};
        this._aDatasource = this._oOptions.datasource || [];
    };

    /**
     * 设置数据并渲染
     *
     * @public
     * @param {string} data 参数，参见setOptions
     */
    UI_BREADCRUMB_CLASS.setData = function(data) {
        this.$setOptions(data);

        this.$disposeInner();

        this.$renderHTML();

        this.$bindEvent();
    };

    /**
     * 渲染HTML
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$renderHTML = function() {
        var type = this.getType();
        var html = [];

        // 是否过长，中间需要隐藏
        var hidePos = this.$calculateHide();

        // 渲染
        var hidePushed = false;
        for (var i = 0, item, url; item = this._aDatasource[i]; i ++) {
            url = item.url || '#';
            if (i >= hidePos.start && i <= hidePos.end) {
                if (!hidePushed) {
                    html.push('<span class="' + type + '-hide-item">...<span>');
                    hidePushed = true;
                }
            }
            else if (item.disabled) {
                html.push('<span class="' + type + '-text-item">' + item.text + '<span>');
            }
            else {
                html.push(
                    '<a href="' + url + '" class="' + type + '-link-item" data-breadcrumb-index="' + i +'">' + item.text + '</a>'
                );
            }
        }
        var sepHTML = '<span class="' + type + '-sep">&gt;</span>';
        this.getBody().innerHTML = html.join(sepHTML);
    };

    /**
     * 计算隐藏的起止
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$calculateHide = function() {
        var hidePos = {};
        var maxShow = this._oOptions.maxShow;
        var dataLength = this._aDatasource.length;

        if (dataLength > maxShow) {
            if (maxShow == 1) {
                hidePos.start = 0;
                hidePos.end = dataLength - 2;
            }
            else if (maxShow > 1) {
                var per = this._oOptions.hidePosPercent;
                if (per == null || per < 0 || per > 1) {
                    per = 0.5;
                }
                var anchor = Math.floor((maxShow - 1) * per);
                hidePos.start = anchor;
                hidePos.end = dataLength - (maxShow - anchor) - 1;
            }
        }

        return hidePos;
    };

    /**
     * 事件绑定
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$bindEvent = function() {
        var me = this;
        var aEls = this.getBody().getElementsByTagName('a');
        for (var i = 0, aEl; aEl = aEls[i]; i ++) {
            if (aEl.getAttribute('data-breadcrumb-index') && aEl.href != '#') {
                aEl.onclick = function() {
                    if (!me._bDisabled) {
                        var ii = this.getAttribute('data-breadcrumb-index');
                        triggerEvent(me, 'change', null, [me._aDatasource[ii]]);
                    }
                    return false;
                }
            }
        }
    };

    /**
     * 析构内部
     * 
     * @protected
     */
    UI_BREADCRUMB_CLASS.$disposeInner = function() {
        this.getBody().innerHTML = '';
    };

 }) ();
/**
 * di.shared.vui.TextLabel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    文字区
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var isObject = xutil.lang.isObject;
    var isArray = xutil.lang.isArray;
    var template = xutil.string.template;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 文字区
     * 直接指定文字，或者html，
     * 或者模板（模板形式参见xutil.string.template）
     * 初始dom中的内容被认为是初始模板。
     * 也可以用参数传入模板。
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     */
    var TEXT_LABEL = $namespace().TextLabel = 
            inheritsObject(XOBJECT, constructor);
    var TEXT_LABEL_CLASS = TEXT_LABEL.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'vui-text-area');

        this._sInitTpl = el.innerHTML;
        el.innerHTML = '';

        this.setData(options);
    };
    
    /**
     * 设置数据
     *
     * @public
     * @param {Object} data 数据
     * @param {string} data.html html
     * @param {string} data.text 文本
     * @param {string} data.tpl 模板
     * @param {(Array|Object)} data.args 参数
     */
    TEXT_LABEL_CLASS.setData = function (data) {
        var el = this._eMain;
        data = data || {};

        if (data.html != null) {
            el.innerHTML = data.html;
        }
        else if (data.text != null) {
            el.innerHTML = encodeHTML(data.text);
        }
        else if (data.tpl != null) {
            renderTpl.call(this, data.tpl, data.args);
        }
        else if (this._sInitTpl != null) {
            renderTpl.call(this, this._sInitTpl, data.args);
        }
    };

    /**
     * 按照模板渲染
     * 
     * @private
     */
    function renderTpl(tpl, args) {
        var el = this._eMain;

        if (isObject(args)) {
            el.innerHTML = template(tpl, args);
        }
        else if (isArray(args)) {
            el.innerHTML = template.apply(null, tpl, args);
        }
        else {
            el.innerHTML = template.tpl || '';
        }
    }

})();
/**
 * di.shared.vui.OfflineDownload
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    离线下载按钮和对话框
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var ecuiCreate = di.helper.Util.ecuiCreate;
    var isObject = xutil.lang.isObject;
    var isArray = xutil.lang.isArray;
    var template = xutil.string.template;
    var domChildren = xutil.dom.children;
    var domRemove = xutil.dom.remove;
    var getByPath = xutil.object.getByPath;
    var DICT = di.config.Dict;
    var XOBJECT = xui.XObject;
    var UI_BUTTON;
    var UI_FORM;

    $link(function () {
        UI_BUTTON = getByPath('ecui.ui.HButton');
        UI_FORM = getByPath('ecui.ui.Form');
    });
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 离线下载按钮和对话框
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {string} options.skin 皮肤（的css类）
     * @param {string} options.text 按钮上的文字，默认为'离线下载'
     * @param {string} options.confirmText 确定按钮上的文字，默认为'确定'
     * @param {string} options.cancelText 取消按钮上的文字，默认为'取消'
     * @param {string} options.headText 提示文字，默认为'请输入邮箱'
     * @param {string} options.inputInfo 输入信息
     */
    var OFFLINE_DOWNLOAD = $namespace().OfflineDownload = 
            inheritsObject(XOBJECT, constructor);
    var OFFLINE_DOWNLOAD_CLASS = OFFLINE_DOWNLOAD.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'offline-download');

        var eel;
        var html;

        eel = document.createElement('div');
        el.appendChild(eel);
        this._uBtn = ecuiCreate(
            UI_BUTTON, 
            eel, 
            null,
            {
                text: options.text || '离线下载',
                skin: options.skin
            }
        );

        // 输入离线下载信息（如邮箱）的对话框
        if (!this._uDialog) {
            eel = document.createElement('div');
            html = [
                '<label>离线下载</label>',
                '<span class="offline-download-head">' + (options.headText || '请输入邮箱') + '</span>',
                '<input type="input" class="offline-download-input"/>',
                '<div></div>',
                '<div></div>'
            ];
            eel.innerHTML = html.join('');
            html = domChildren(eel);
            this._eInput = html[2];
            this._uDialog = ecuiCreate(UI_FORM, eel, null, { hide: true });
            this._uConfirmBtn = ecuiCreate(
                UI_BUTTON, 
                html[3],
                null,
                {
                    text: options.confirmText || '确定',
                    skin: options.skin
                }
            );
            this._uCancelBtn = ecuiCreate(
                UI_BUTTON, 
                html[4],
                null,
                {
                    text: options.cancelText || '取消',
                    skin: options.skin
                }
            );

            document.body.appendChild(eel);
        }
    };

    OFFLINE_DOWNLOAD_CLASS.init = function () {
        var me = this;

        this._uBtn.onclick = function () {
            me.$clear();
            me._uDialog.center();
            me._uDialog.showModal(DICT.DEFAULT_MASK_OPACITY);
        };

        this._uConfirmBtn.onclick = function () {
            me.notify('confirm', [me._eInput.value]);
            me._uDialog.hide();
        };

        this._uCancelBtn.onclick = function () {
            me._uDialog.hide();
        }

        this._uDialog.init();
        this._uBtn.init();
        this._uConfirmBtn.init();
        this._uCancelBtn.init();
    };   

    OFFLINE_DOWNLOAD_CLASS.$clear = function () {
        this._eInput.value = '';
    };

    OFFLINE_DOWNLOAD_CLASS.getValue = function () {
        return { email: this._eInput.value };
    };

    OFFLINE_DOWNLOAD_CLASS.dispose = function () {
        if (this._uDialog) {
            var el = this._uDialog.getOuter();
            this._uDialog.dispose();
            this._uBtn.dispose();
            this._uConfirmBtn.dispose();
            this._uCancelBtn.dispose();
            domRemove(el);
        }
    };       
    
})();
/**
 * project link
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    项目结尾文件
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui.XProject
 */

// 依赖连接
xui.XProject.doLink();
// 项目初始化最后执行的内容
xui.XProject.doEnd()