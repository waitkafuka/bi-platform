/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!memory;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( window.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.style.width = "2px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = marginDiv = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
		vb = "visibility:hidden;border:0;";
		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
		html = "<div " + style + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Figure out if the W3C box model works as expected
		div.innerHTML = "";
		div.style.width = div.style.paddingLeft = "1px";
		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
		}

		div.style.cssText = ptlm + vb;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		body.removeChild( container );
		div  = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, attr, name,
			data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var self = jQuery( this ),
					args = [ parts[0], value ];

				self.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;

					// See #9699 for explanation of this approach (setting first, then removal)
					jQuery.attr( elem, name, "" );
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( rboolean.test( name ) && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Determine handlers that should run if there are delegated events
		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
				selMatch = {};
				matches = [];
				jqcur[0] = cur;
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];
					sel = handleObj.selector;

					if ( selMatch[ sel ] === undefined ) {
						selMatch[ sel ] = (
							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
						);
					}
					if ( selMatch[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, matches: matches });
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						// If form was submitted by the user, bubble the event up the tree
						if ( this.parentNode && !event.isTrigger ) {
							jQuery.event.simulate( "submit", this.parentNode, event, true );
						}
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on.call( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					doneName = match[0];
					parent = elem.parentNode;
	
					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent[ expando ] = doneName;
					}
					
					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( 
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ? 
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret === null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight,
		i = 0,
		len = which.length;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i++ ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i++ ) {
			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
			}
		}
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			for ( p in prop ) {

				// property name normalization
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Adds width/height step functions
// Do not set anything below 0
jQuery.each([ "width", "height" ], function( i, prop ) {
	jQuery.fx.step[ prop ] = function( fx ) {
		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
	};
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if ( !elem ) {
				return null;
			}

			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

		// Set the scroll offset
		return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i ? val : jQuery( win ).scrollLeft(),
					 i ? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ],
				body = elem.document.body;
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNumeric( ret ) ? ret : orig;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

/*
HTML Clean for jQuery   
Anthony Johnston
http://www.antix.co.uk    
    
version 1.3.1

$Revision$

requires jQuery http://jquery.com   

Use and distibution http://www.opensource.org/licenses/bsd-license.php

2010-04-02 allowedTags/removeTags added (white/black list) thanks to David Wartian (Dwartian)
2010-06-30 replaceStyles added for replacement of bold, italic, super and sub styles on a tag
2012-04-30 allowedAttributes added, an array of attributed allowed on the elements
2013-02-25 now will push non-inline elements up the stack if nested in an inline element
2013-02-25 comment element support added, removed by default, see AllowComments in options
*/
(function ($) {
    $.fn.htmlClean = function (options) {
        // iterate and html clean each matched element
        return this.each(function () {
            var $this = $(this);
            if (this.value) {
                this.value = $.htmlClean(this.value, options);
            } else {
                this.innerHTML = $.htmlClean(this.innerHTML, options);
            }
        });
    };

    // clean the passed html
    $.htmlClean = function (html, options) {
        options = $.extend({}, $.htmlClean.defaults, options);

        var tagsRE = /(<(\/)?(\w+:)?([\w]+)([^>]*)>)|<!--(.*?--)>/gi;
        var attrsRE = /([\w\-]+)=(".*?"|'.*?'|[^\s>]*)/gi;

        var tagMatch;
        var root = new Element();
        var stack = [root];
        var container = root;
        var protect = false;

        if (options.bodyOnly) {
            // check for body tag
            if (tagMatch = /<body[^>]*>((\n|.)*)<\/body>/i.exec(html)) {
                html = tagMatch[1];
            }
        }
        html = html.concat("<xxx>"); // ensure last element/text is found
        var lastIndex;

        while (tagMatch = tagsRE.exec(html)) {
            var tag = tagMatch[6]
                ? new Tag("--", null, tagMatch[6], options)
                : new Tag(tagMatch[4], tagMatch[2], tagMatch[5], options);

            // add the text
            var text = html.substring(lastIndex, tagMatch.index);
            if (text.length > 0) {
                var child = container.children[container.children.length - 1];
                if (container.children.length > 0
                        && isText(child = container.children[container.children.length - 1])) {
                    // merge text
                    container.children[container.children.length - 1] = child.concat(text);
                } else {
                    container.children.push(text);
                }
            }
            lastIndex = tagsRE.lastIndex;

            if (tag.isClosing) {
                // find matching container
                if (popToTagName(stack, [tag.name])) {
                    stack.pop();
                    container = stack[stack.length - 1];
                }
            } else {
                // create a new element
                var element = new Element(tag);

                // add attributes
                var attrMatch;
                while (attrMatch = attrsRE.exec(tag.rawAttributes)) {

                    // check style attribute and do replacements
                    if (attrMatch[1].toLowerCase() == "style"
                        && options.replaceStyles) {

                        var renderParent = !tag.isInline;
                        for (var i = 0; i < options.replaceStyles.length; i++) {
                            if (options.replaceStyles[i][0].test(attrMatch[2])) {

                                if (!renderParent) {
                                    tag.render = false;
                                    renderParent = true;
                                }
                                container.children.push(element); // assumes not replaced
                                stack.push(element);
                                container = element; // assumes replacement is a container
                                // create new tag and element
                                tag = new Tag(options.replaceStyles[i][1], "", "", options);
                                element = new Element(tag);
                            }
                        }
                    }

                    if (tag.allowedAttributes != null
                            && (tag.allowedAttributes.length == 0
                            || $.inArray(attrMatch[1], tag.allowedAttributes) > -1)) {
                        element.attributes.push(new Attribute(attrMatch[1], attrMatch[2]));
                    }
                }
                // add required empty ones
                $.each(tag.requiredAttributes, function () {
                    var name = this.toString();
                    if (!element.hasAttribute(name)) element.attributes.push(new Attribute(name, ""));
                });

                // check for replacements
                for (var repIndex = 0; repIndex < options.replace.length; repIndex++) {
                    for (var tagIndex = 0; tagIndex < options.replace[repIndex][0].length; tagIndex++) {
                        var byName = typeof (options.replace[repIndex][0][tagIndex]) == "string";
                        if ((byName && options.replace[repIndex][0][tagIndex] == tag.name)
                                || (!byName && options.replace[repIndex][0][tagIndex].test(tagMatch))) {

                            // set the name to the replacement
                            tag.rename(options.replace[repIndex][1]);

                            repIndex = options.replace.length; // break out of both loops
                            break;
                        }
                    }
                }

                // check container rules
                var add = true;
                if (!container.isRoot) {
                    if (container.tag.isInline && !tag.isInline) {
                        if (add = popToContainer(stack)) {
                            container = stack[stack.length - 1];
                        }
                    } else if (container.tag.disallowNest && tag.disallowNest
                                && !tag.requiredParent) {
                        add = false;
                    } else if (tag.requiredParent) {
                        if (add = popToTagName(stack, tag.requiredParent)) {
                            container = stack[stack.length - 1];
                        }
                    }
                }

                if (add) {
                    container.children.push(element);

                    if (tag.toProtect) {
                        // skip to closing tag
                        while (tagMatch2 = tagsRE.exec(html)) {
                            var tag2 = new Tag(tagMatch2[3], tagMatch2[1], tagMatch2[4], options);
                            if (tag2.isClosing && tag2.name == tag.name) {
                                element.children.push(RegExp.leftContext.substring(lastIndex));
                                lastIndex = tagsRE.lastIndex;
                                break;
                            }
                        }
                    } else {
                        // set as current container element
                        if (!tag.isSelfClosing && !tag.isNonClosing) {
                            stack.push(element);
                            container = element;
                        }
                    }
                }
            }
        }

        // render doc
        return $.htmlClean.trim(render(root, options).join(""));
    };

    // defaults
    $.htmlClean.defaults = {
        // only clean the body tagbody
        bodyOnly: true,
        // only allow tags in this array, (white list), contents still rendered
        allowedTags: [],
        // remove tags in this array, (black list), contents still rendered
        removeTags: ["basefont", "center", "dir", "font", "frame", "frameset", "iframe", "isindex", "menu", "noframes", "s", "strike", "u"],
        // array of [attributeName], [optional array of allowed on elements] e.g. [["id"], ["style", ["p", "dl"]]] // allow all elements to have id and allow style on 'p' and 'dl'
        allowedAttributes: [],
        // array of attribute names to remove on all elements in addition to those not in tagAttributes e.g ["width", "height"]
        removeAttrs: [],
        // array of [className], [optional array of allowed on elements] e.g. [["aClass"], ["anotherClass", ["p", "dl"]]]
        allowedClasses: [],
        // format the result
        format: false,
        // format indent to start on
        formatIndent: 0,
        // tags to replace, and what to replace with, tag name or regex to match the tag and attributes 
        replace: [
            [["b", "big"], "strong"],
            [["i"], "em"]
        ],
        // styles to replace with tags, multiple style matches supported, inline tags are replaced by the first match blocks are retained
        replaceStyles: [
            [/font-weight:\s*bold/i, "strong"],
            [/font-style:\s*italic/i, "em"],
            [/vertical-align:\s*super/i, "sup"],
            [/vertical-align:\s*sub/i, "sub"]
        ],
        allowComments: false
    };

    function applyFormat(element, options, output, indent) {
        if (!element.tag.isInline && output.length > 0) {
            output.push("\n");
            for (i = 0; i < indent; i++) output.push("\t");
        }
    }

    function render(element, options) {
        var output = [], empty = element.attributes.length == 0, indent;

        if (element.tag.isComment) {
            if (options.allowComments) {
                output.push("<!--");
                output.push(element.tag.rawAttributes);
                output.push(">");

                if (options.format) applyFormat(element, options, output, indent - 1);
            }
        } else {

            var openingTag = this.name.concat(element.tag.rawAttributes == undefined ? "" : element.tag.rawAttributes);

            // don't render if not in allowedTags or in removeTags
            var renderTag
            = element.tag.render
                && (options.allowedTags.length == 0 || $.inArray(element.tag.name, options.allowedTags) > -1)
                && (options.removeTags.length == 0 || $.inArray(element.tag.name, options.removeTags) == -1);

            if (!element.isRoot && renderTag) {

                // render opening tag
                output.push("<");
                output.push(element.tag.name);
                $.each(element.attributes, function () {
                    if ($.inArray(this.name, options.removeAttrs) == -1) {
                        var m = RegExp(/^(['"]?)(.*?)['"]?$/).exec(this.value);
                        var value = m[2];
                        var valueQuote = m[1] || "'";

                        // check for classes allowed                    
                        if (this.name == "class" && options.allowedClasses.length > 0) {
                            value =
                            $.grep(value.split(" "), function (c) {
                                return $.grep(options.allowedClasses, function (a) {
                                    return a == c
                                        || (a[0] == c && (a.length == 1 || $.inArray(element.tag.name, a[1]) > -1));
                                }).length > 0;
                            })
                            .join(" ");
                        }

                        if (value != null && (value.length > 0 || $.inArray(this.name, element.tag.requiredAttributes) > -1)) {
                            output.push(" ");
                            output.push(this.name);
                            output.push("=");
                            output.push(valueQuote);
                            output.push(value);
                            output.push(valueQuote);
                        }
                    }
                });
            }

            if (element.tag.isSelfClosing) {
                // self closing 
                if (renderTag) output.push(" />");
                empty = false;
            } else if (element.tag.isNonClosing) {
                empty = false;
            } else {
                if (!element.isRoot && renderTag) {
                    // close
                    output.push(">");
                }

                var indent = options.formatIndent++;

                // render children
                if (element.tag.toProtect) {
                    var outputChildren = $.htmlClean.trim(element.children.join("")).replace(/<br>/ig, "\n");
                    output.push(outputChildren);
                    empty = outputChildren.length == 0;
                } else {
                    var outputChildren = [];
                    for (var i = 0; i < element.children.length; i++) {
                        var child = element.children[i];
                        var text = $.htmlClean.trim(textClean(isText(child) ? child : child.childrenToString()));
                        if (isInline(child)) {
                            if (i > 0 && text.length > 0
                        && (startsWithWhitespace(child) || endsWithWhitespace(element.children[i - 1]))) {
                                outputChildren.push(" ");
                            }
                        }
                        if (isText(child)) {
                            if (text.length > 0) {
                                outputChildren.push(text);
                            }
                        } else {
                            // don't allow a break to be the last child
                            if (i != element.children.length - 1 || child.tag.name != "br") {
                                if (options.format) applyFormat(child, options, outputChildren, indent);
                                outputChildren = outputChildren.concat(render(child, options));
                            }
                        }
                    }
                    options.formatIndent--;

                    if (outputChildren.length > 0) {
                        if (options.format && outputChildren[0] != "\n") applyFormat(element, options, output, indent);
                        output = output.concat(outputChildren);
                        empty = false;
                    }
                }

                if (!element.isRoot && renderTag) {
                    // render the closing tag
                    if (options.format) applyFormat(element, options, output, indent - 1);
                    output.push("</");
                    output.push(element.tag.name);
                    output.push(">");
                }
            }

            // check for empty tags
            if (!element.tag.allowEmpty && empty) { return []; }
        }

        return output;
    }

    // find a matching tag, and pop to it, if not do nothing
    function popToTagName(stack, tagNameArray) {
        return pop(
            stack,
            function (element) {
                return $.inArray(element.tag.nameOriginal, tagNameArray) > -1
            });
    }

    function popToContainer(stack) {
        return pop(
            stack,
            function (element) {
                return element.isRoot || !element.tag.isInline;
            });
    }

    function pop(stack, test, index) {
        index = index || 1;
        var element = stack[stack.length - index];
        if (test(element)) {
            return true;
        } else if (stack.length - index > 0
                && pop(stack, test, index + 1)) {
            stack.pop();
            return true;
        }
        return false;
    }

    // Element Object
    function Element(tag) {
        if (tag) {
            this.tag = tag;
            this.isRoot = false;
        } else {
            this.tag = new Tag("root");
            this.isRoot = true;
        }
        this.attributes = [];
        this.children = [];

        this.hasAttribute = function (name) {
            for (var i = 0; i < this.attributes.length; i++) {
                if (this.attributes[i].name == name) return true;
            }
            return false;
        };

        this.childrenToString = function () {
            return this.children.join("");
        };

        return this;
    }

    // Attribute Object
    function Attribute(name, value) {
        this.name = name;
        this.value = value;

        return this;
    }

    // Tag object
    function Tag(name, close, rawAttributes, options) {
        this.name = name.toLowerCase();
        this.nameOriginal = this.name;
        this.render = true;

        this.init = function () {
            if (this.name == "--") {
                this.isComment = true;
                this.isSelfClosing = true;
            } else {
                this.isComment = false;
                this.isSelfClosing = $.inArray(this.name, tagSelfClosing) > -1;
                this.isNonClosing = $.inArray(this.name, tagNonClosing) > -1;
                this.isClosing = (close != undefined && close.length > 0);

                this.isInline = $.inArray(this.name, tagInline) > -1;
                this.disallowNest = $.inArray(this.name, tagDisallowNest) > -1;
                this.requiredParent = tagRequiredParent[$.inArray(this.name, tagRequiredParent) + 1];
                this.allowEmpty = $.inArray(this.name, tagAllowEmpty) > -1;

                this.toProtect = $.inArray(this.name, tagProtect) > -1;
            }
            this.rawAttributes = rawAttributes;
            this.requiredAttributes = tagAttributesRequired[$.inArray(this.name, tagAttributesRequired) + 1];

            if (options) {
                if (!options.tagAttributesCache) options.tagAttributesCache = [];
                if ($.inArray(this.name, options.tagAttributesCache) == -1) {
                    var cacheItem = tagAttributes[$.inArray(this.name, tagAttributes) + 1].slice(0);

                    // add extra ones from options
                    for (var i = 0; i < options.allowedAttributes.length; i++) {
                        var attrName = options.allowedAttributes[i][0];
                        if ((
                            options.allowedAttributes[i].length == 1
                            || $.inArray(this.name, options.allowedAttributes[i][1]) > -1
                            ) && $.inArray(attrName, cacheItem) == -1) {
                            cacheItem.push(attrName);
                        }
                    }

                    options.tagAttributesCache.push(this.name);
                    options.tagAttributesCache.push(cacheItem);
                }

                this.allowedAttributes = options.tagAttributesCache[$.inArray(this.name, options.tagAttributesCache) + 1];
            }
        }

        this.init();

        this.rename = function (newName) {
            this.name = newName;
            this.init();
        };

        return this;
    }

    function startsWithWhitespace(item) {
        while (isElement(item) && item.children.length > 0) { item = item.children[0] }
        if (!isText(item)) return false;
        var text = textClean(item);
        return text.length > 0 && $.htmlClean.isWhitespace(text.charAt(0));
    }
    function endsWithWhitespace(item) {
        while (isElement(item) && item.children.length > 0) { item = item.children[item.children.length - 1] }
        if (!isText(item)) return false;
        var text = textClean(item);
        return text.length > 0 && $.htmlClean.isWhitespace(text.charAt(text.length - 1));
    }
    function isText(item) { return item.constructor == String; }
    function isInline(item) { return isText(item) || item.tag.isInline; }
    function isElement(item) { return item.constructor == Element; }
    function textClean(text) {
        return text
            .replace(/&nbsp;|\n/g, " ")
            .replace(/\s\s+/g, " ");
    }

    // trim off white space, doesn't use regex
    $.htmlClean.trim = function (text) {
        return $.htmlClean.trimStart($.htmlClean.trimEnd(text));
    };
    $.htmlClean.trimStart = function (text) {
        return text.substring($.htmlClean.trimStartIndex(text));
    };
    $.htmlClean.trimStartIndex = function (text) {
        for (var start = 0; start < text.length - 1 && $.htmlClean.isWhitespace(text.charAt(start)); start++);
        return start;
    };
    $.htmlClean.trimEnd = function (text) {
        return text.substring(0, $.htmlClean.trimEndIndex(text));
    };
    $.htmlClean.trimEndIndex = function (text) {
        for (var end = text.length - 1; end >= 0 && $.htmlClean.isWhitespace(text.charAt(end)); end--);
        return end + 1;
    };
    // checks a char is white space or not
    $.htmlClean.isWhitespace = function (c) { return $.inArray(c, whitespace) != -1; };

    // tags which are inline
    var tagInline = [
        "a", "abbr", "acronym", "address", "b", "big", "br", "button",
        "caption", "cite", "code", "del", "em", "font",
        "hr", "i", "input", "img", "ins", "label", "legend", "map", "q",
        "s", "samp", "select", "option", "param", "small", "span", "strike", "strong", "sub", "sup",
        "tt", "u", "var"];
    var tagDisallowNest = ["h1", "h2", "h3", "h4", "h5", "h6", "p", "th", "td", "object"];
    var tagAllowEmpty = ["th", "td"];
    var tagRequiredParent = [
        null,
        "li", ["ul", "ol"],
        "dt", ["dl"],
        "dd", ["dl"],
        "td", ["tr"],
        "th", ["tr"],
        "tr", ["table", "thead", "tbody", "tfoot"],
        "thead", ["table"],
        "tbody", ["table"],
        "tfoot", ["table"],
        "param", ["object"]
        ];
    var tagProtect = ["script", "style", "pre", "code"];
    // tags which self close e.g. <br />
    var tagSelfClosing = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
    // tags which do not close
    var tagNonClosing = ["!doctype", "?xml"];
    // attributes allowed on tags
    var tagAttributes = [
            ["class"],  // default, for all tags not mentioned
            "?xml", [],
            "!doctype", [],
            "a", ["accesskey", "class", "href", "name", "title", "rel", "rev", "type", "tabindex"],
            "abbr", ["class", "title"],
            "acronym", ["class", "title"],
            "blockquote", ["cite", "class"],
            "button", ["class", "disabled", "name", "type", "value"],
            "del", ["cite", "class", "datetime"],
            "form", ["accept", "action", "class", "enctype", "method", "name"],
            "input", ["accept", "accesskey", "alt", "checked", "class", "disabled", "ismap", "maxlength", "name", "size", "readonly", "src", "tabindex", "type", "usemap", "value"],
            "img", ["alt", "class", "height", "src", "width"],
            "ins", ["cite", "class", "datetime"],
            "label", ["accesskey", "class", "for"],
            "legend", ["accesskey", "class"],
            "link", ["href", "rel", "type"],
            "meta", ["content", "http-equiv", "name", "scheme", "charset"],
            "map", ["name"],
            "optgroup", ["class", "disabled", "label"],
            "option", ["class", "disabled", "label", "selected", "value"],
            "q", ["class", "cite"],
            "script", ["src", "type"],
            "select", ["class", "disabled", "multiple", "name", "size", "tabindex"],
            "style", ["type"],
            "table", ["class", "summary"],
            "th", ["class", "colspan", "rowspan"],
            "td", ["class", "colspan", "rowspan"],
            "textarea", ["accesskey", "class", "cols", "disabled", "name", "readonly", "rows", "tabindex"],
            "param", ["name", "value"],
            "embed", ["height", "src", "type", "width"]
        ];
    var tagAttributesRequired = [[], "img", ["alt"]];
    // white space chars
    var whitespace = ["", " ", "\t", "\n", "\r", "\f"];

})(jQuery);
var jsl = typeof(jsl) === 'undefined' ? {} : jsl;
/**
 * JSON Lint Parser gratefully provided by Zach Carter
 * https://github.com/zaach/jsonlint
**/
jsl.parser = function(){var a=!0,b=!1,c={},d=function(){var a={trace:function(){},yy:{},symbols_:{error:2,JSONString:3,STRING:4,JSONNumber:5,NUMBER:6,JSONNullLiteral:7,NULL:8,JSONBooleanLiteral:9,TRUE:10,FALSE:11,JSONText:12,JSONObject:13,EOF:14,JSONArray:15,JSONValue:16,"{":17,"}":18,JSONMemberList:19,JSONMember:20,":":21,",":22,"[":23,"]":24,JSONElementList:25,$accept:0,$end:1},terminals_:{2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},productions_:[0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[12,2],[16,1],[16,1],[16,1],[16,1],[16,1],[16,1],[13,2],[13,3],[20,3],[19,1],[19,3],[15,2],[15,3],[25,1],[25,3]],performAction:function(a,b,c,d,e,f,g){var h=f.length-1;switch(e){case 1:this.$=a;break;case 2:this.$=Number(a);break;case 3:this.$=null;break;case 4:this.$=!0;break;case 5:this.$=!1;break;case 6:return this.$=f[h-1];case 7:return this.$=f[h-1];case 8:this.$=f[h];break;case 9:this.$=f[h];break;case 10:this.$=f[h];break;case 11:this.$=f[h];break;case 12:this.$=f[h];break;case 13:this.$=f[h];break;case 14:this.$={};break;case 15:this.$=f[h-1];break;case 16:this.$=[f[h-2],f[h]];break;case 17:this.$={},this.$[f[h][0]]=f[h][1];break;case 18:this.$=f[h-2],f[h-2][f[h][0]]=f[h][1];break;case 19:this.$=[];break;case 20:this.$=f[h-1];break;case 21:this.$=[f[h]];break;case 22:this.$=f[h-2],f[h-2].push(f[h])}},table:[{12:1,13:2,15:3,17:[1,4],23:[1,5]},{1:[3]},{14:[1,6]},{14:[1,7]},{3:11,4:[1,12],18:[1,8],19:9,20:10},{3:18,4:[1,12],5:19,6:[1,25],7:16,8:[1,22],9:17,10:[1,23],11:[1,24],13:20,15:21,16:15,17:[1,4],23:[1,5],24:[1,13],25:14},{1:[2,6]},{1:[2,7]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{18:[1,26],22:[1,27]},{18:[2,17],22:[2,17]},{21:[1,28]},{18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{22:[1,30],24:[1,29]},{22:[2,21],24:[2,21]},{18:[2,8],22:[2,8],24:[2,8]},{18:[2,9],22:[2,9],24:[2,9]},{18:[2,10],22:[2,10],24:[2,10]},{18:[2,11],22:[2,11],24:[2,11]},{18:[2,12],22:[2,12],24:[2,12]},{18:[2,13],22:[2,13],24:[2,13]},{18:[2,3],22:[2,3],24:[2,3]},{18:[2,4],22:[2,4],24:[2,4]},{18:[2,5],22:[2,5],24:[2,5]},{18:[2,2],22:[2,2],24:[2,2]},{14:[2,15],18:[2,15],22:[2,15],24:[2,15]},{3:11,4:[1,12],20:31},{3:18,4:[1,12],5:19,6:[1,25],7:16,8:[1,22],9:17,10:[1,23],11:[1,24],13:20,15:21,16:32,17:[1,4],23:[1,5]},{14:[2,20],18:[2,20],22:[2,20],24:[2,20]},{3:18,4:[1,12],5:19,6:[1,25],7:16,8:[1,22],9:17,10:[1,23],11:[1,24],13:20,15:21,16:33,17:[1,4],23:[1,5]},{18:[2,18],22:[2,18]},{18:[2,16],22:[2,16]},{22:[2,22],24:[2,22]}],defaultActions:{6:[2,6],7:[2,7]},parseError:function(a,b){throw new Error(a)},parse:function(a){function o(){var a;a=b.lexer.lex()||1,typeof a!="number"&&(a=b.symbols_[a]||a);return a}function n(a){c.length=c.length-2*a,d.length=d.length-a,e.length=e.length-a}var b=this,c=[0],d=[null],e=[],f=this.table,g="",h=0,i=0,j=0,k=2,l=1;this.lexer.setInput(a),this.lexer.yy=this.yy,this.yy.lexer=this.lexer,typeof this.lexer.yylloc=="undefined"&&(this.lexer.yylloc={});var m=this.lexer.yylloc;e.push(m),typeof this.yy.parseError=="function"&&(this.parseError=this.yy.parseError);var p,q,r,s,t,u,v={},w,x,y,z;for(;;){r=c[c.length-1],this.defaultActions[r]?s=this.defaultActions[r]:(p==null&&(p=o()),s=f[r]&&f[r][p]);if(typeof s=="undefined"||!s.length||!s[0]){if(!j){z=[];for(w in f[r])this.terminals_[w]&&w>2&&z.push("'"+this.terminals_[w]+"'");var A="";this.lexer.showPosition?A="Parse error on line "+(h+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+z.join(", "):A="Parse error on line "+(h+1)+": Unexpected "+(p==1?"end of input":"'"+(this.terminals_[p]||p)+"'"),this.parseError(A,{text:this.lexer.match,token:this.terminals_[p]||p,line:this.lexer.yylineno,loc:m,expected:z})}if(j==3){if(p==l)throw new Error(A||"Parsing halted.");i=this.lexer.yyleng,g=this.lexer.yytext,h=this.lexer.yylineno,m=this.lexer.yylloc,p=o()}for(;;){if(k.toString()in f[r])break;if(r==0)throw new Error(A||"Parsing halted.");n(1),r=c[c.length-1]}q=p,p=k,r=c[c.length-1],s=f[r]&&f[r][k],j=3}if(s[0]instanceof Array&&s.length>1)throw new Error("Parse Error: multiple actions possible at state: "+r+", token: "+p);switch(s[0]){case 1:c.push(p),d.push(this.lexer.yytext),e.push(this.lexer.yylloc),c.push(s[1]),p=null,q?(p=q,q=null):(i=this.lexer.yyleng,g=this.lexer.yytext,h=this.lexer.yylineno,m=this.lexer.yylloc,j>0&&j--);break;case 2:x=this.productions_[s[1]][1],v.$=d[d.length-x],v._$={first_line:e[e.length-(x||1)].first_line,last_line:e[e.length-1].last_line,first_column:e[e.length-(x||1)].first_column,last_column:e[e.length-1].last_column},u=this.performAction.call(v,g,i,h,this.yy,s[1],d,e);if(typeof u!="undefined")return u;x&&(c=c.slice(0,-1*x*2),d=d.slice(0,-1*x),e=e.slice(0,-1*x)),c.push(this.productions_[s[1]][0]),d.push(v.$),e.push(v._$),y=f[c[c.length-2]][c[c.length-1]],c.push(y);break;case 3:return!0}}return!0}},f=function(){var a={EOF:1,parseError:function(a,b){if(this.yy.parseError)this.yy.parseError(a,b);else throw new Error(a)},setInput:function(a){this._input=a,this._more=this._less=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0};return this},input:function(){var a=this._input[0];this.yytext+=a,this.yyleng++,this.match+=a,this.matched+=a;var b=a.match(/\n/);b&&this.yylineno++,this._input=this._input.slice(1);return a},unput:function(a){this._input=a+this._input;return this},more:function(){this._more=!0;return this},pastInput:function(){var a=this.matched.substr(0,this.matched.length-this.match.length);return(a.length>20?"...":"")+a.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var a=this.match;a.length<20&&(a+=this._input.substr(0,20-a.length));return(a.substr(0,20)+(a.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var a=this.pastInput(),b=Array(a.length+1).join("-");return a+this.upcomingInput()+"\n"+b+"^"},next:function(){if(this.done)return this.EOF;this._input||(this.done=!0);var a,b,c,d;this._more||(this.yytext="",this.match="");var e=this._currentRules();for(var f=0;f<e.length;f++){b=this._input.match(this.rules[e[f]]);if(b){d=b[0].match(/\n.*/g),d&&(this.yylineno+=d.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:d?d[d.length-1].length-1:this.yylloc.last_column+b[0].length},this.yytext+=b[0],this.match+=b[0],this.matches=b,this.yyleng=this.yytext.length,this._more=!1,this._input=this._input.slice(b[0].length),this.matched+=b[0],a=this.performAction.call(this,this.yy,this,e[f],this.conditionStack[this.conditionStack.length-1]);if(a)return a;return}}if(this._input==="")return this.EOF;this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var a=this.next();return typeof a!="undefined"?a:this.lex()},begin:function(a){this.conditionStack.push(a)},popState:function(){return this.conditionStack.pop()},_currentRules:function(){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules}};a.performAction=function(a,b,c,d){var e=d;switch(c){case 0:break;case 1:return 6;case 2:b.yytext=b.yytext.substr(1,b.yyleng-2);return 4;case 3:return 17;case 4:return 18;case 5:return 23;case 6:return 24;case 7:return 22;case 8:return 21;case 9:return 10;case 10:return 11;case 11:return 8;case 12:return 14;case 13:return"INVALID"}},a.rules=[/^\s+/,/^-?([0-9]|[1-9][0-9]+)(\.[0-9]+)?([eE][-+]?[0-9]+)?\b/,/^"(\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^\0-\x09\x0a-\x1f"\\])*"/,/^\{/,/^\}/,/^\[/,/^\]/,/^,/,/^:/,/^true\b/,/^false\b/,/^null\b/,/^$/,/^./],a.conditions={INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13],inclusive:!0}};return a}();a.lexer=f;return a}();typeof a!="undefined"&&typeof c!="undefined"&&(c.parser=d,c.parse=function(){return d.parse.apply(d,arguments)},c.main=function(b){if(!b[1])throw new Error("Usage: "+b[0]+" FILE");if(typeof process!="undefined")var d=a("fs").readFileSync(a("path").join(process.cwd(),b[1]),"utf8");else var e=a("file").path(a("file").cwd()),d=e.join(b[1]).read({charset:"utf-8"});return c.parser.parse(d)},typeof b!="undefined"&&a.main===b&&c.main(typeof process!="undefined"?process.argv.slice(1):a("system").args));return c}()
/*jslint white: true, devel: true, onevar: true, browser: true, undef: true, nomen: true, regexp: true, plusplus: false, bitwise: true, newcap: true, maxerr: 50, indent: 4 */
var jsl = typeof jsl === 'undefined' ? {} : jsl;

/**
 * jsl.format - Provide json reformatting in a character-by-character approach, so that even invalid JSON may be reformatted (to the best of its ability).
 *
**/
jsl.format = (function () {

    function repeat(s, count) {
        return new Array(count + 1).join(s);
    }

    function formatJson(json) {
        var i           = 0,
            il          = 0,
            tab         = "    ",
            newJson     = "",
            indentLevel = 0,
            inString    = false,
            currentChar = null;

        for (i = 0, il = json.length; i < il; i += 1) { 
            currentChar = json.charAt(i);

            switch (currentChar) {
            case '{': 
            case '[': 
                if (!inString) { 
                    newJson += currentChar + "\n" + repeat(tab, indentLevel + 1);
                    indentLevel += 1; 
                } else { 
                    newJson += currentChar; 
                }
                break; 
            case '}': 
            case ']': 
                if (!inString) { 
                    indentLevel -= 1; 
                    newJson += "\n" + repeat(tab, indentLevel) + currentChar; 
                } else { 
                    newJson += currentChar; 
                } 
                break; 
            case ',': 
                if (!inString) { 
                    newJson += ",\n" + repeat(tab, indentLevel); 
                } else { 
                    newJson += currentChar; 
                } 
                break; 
            case ':': 
                if (!inString) { 
                    newJson += ": "; 
                } else { 
                    newJson += currentChar; 
                } 
                break; 
            case ' ':
            case "\n":
            case "\t":
                if (inString) {
                    newJson += currentChar;
                }
                break;
            case '"': 
                if (i > 0 && json.charAt(i - 1) !== '\\') {
                    inString = !inString; 
                }
                newJson += currentChar; 
                break;
            default: 
                newJson += currentChar; 
                break;                    
            } 
        } 

        return newJson; 
    }

    return { "formatJson": formatJson };

}());
// CodeMirror version 3.14
//
// CodeMirror is the only global var we claim
window.CodeMirror = (function() {
  "use strict";

  // BROWSER SNIFFING

  // Crude, but necessary to handle a number of hard-to-feature-detect
  // bugs and behavior differences.
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);

  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version) opera_version = Number(opera_version[1]);
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || (ie && !ie_lt9);

  // Optimize some code when these features are not used
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // CONSTRUCTOR

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
      options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);

    var docStart = typeof options.value == "string" ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile) focusInput(this);

    this.state = {keyMaps: [],
                  overlays: [],
                  modeGen: 0,
                  overwrite: false, focused: false,
                  suppressEdits: false, pasteIncoming: false,
                  draggingText: false,
                  highlight: new Delayed()};

    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie) setTimeout(bind(resetInput, this, true), 20);

    registerEventHandlers(this);
    // IE throws unspecified error in certain cases, when
    // trying to access activeElement before onload
    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }
    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);
    else onBlur(this);

    operation(this, function() {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    })();
  }

  // DISPLAY CONSTRUCTOR

  function makeDisplay(place, docStart) {
    var d = {};

    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");
    if (webkit) input.style.width = "1000px";
    else input.setAttribute("wrap", "off");
    // if border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) input.style.border = "1px solid black";
    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

    // Wraps and hides input textarea
    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The actual fake scrollbars.
    d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");
    d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    // DIVs containing the selection and the actual code
    d.lineDiv = elt("div", null, "CodeMirror-code");
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    // Blinky cursor, and element used to ensure cursor fits at the end of a line
    d.cursor = elt("div", "\u00a0", "CodeMirror-cursor");
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    d.otherCursor = elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");
    // Used to measure text size
    d.measure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],
                         null, "position: relative; outline: none");
    // Moved around its parent to cover visible view
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the text, causes scrolling
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
    // Will contain the gutters, if any
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Provides scrolling
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,
                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
    // Work around IE7 z-index bug
    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);

    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";

    // Current visible range (may be bigger than the view window).
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = "";
    // Set to true when a non-horizontal-scrolling widget is added. As
    // an optimization, widget aligning is skipped when d is false.
    d.alignWidgets = false;
    // Flag that indicates whether we currently expect input to appear
    // (after some event like 'keypress' or 'input') and are polling
    // intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();

    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;

    // Tracks when resetInput has punted to just putting a short
    // string instead of the (large) selection.
    d.inaccurateSelection = false;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    return d;
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += " CodeMirror-wrap";
      cm.display.sizer.style.minWidth = "";
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function keyMapChanged(cm) {
    var map = keyMap[cm.options.keyMap], style = map.style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
      (style ? " cm-keymap-" + style : "");
    cm.state.disableInput = map.disableInput;
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
  }

  function lineLength(doc, line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == "CodeMirror-linenumbers") {
        if (options.lineNumbers) found = true;
        else options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push("CodeMirror-linenumbers");
  }

  // SCROLLBARS

  // Re-synchronize the fake scrollbars with the actual size of the
  // content. Optionally force a scrollTop.
  function updateScrollbars(cm) {
    var d = cm.display, docHeight = cm.doc.height;
    var totalHeight = docHeight + paddingVert(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";
    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);
    var needsV = scrollHeight > (d.scroller.clientHeight + 1);
    if (needsV) {
      d.scrollbarV.style.display = "block";
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarV.firstChild.style.height =
        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + "px";
    } else d.scrollbarV.style.display = "";
    if (needsH) {
      d.scrollbarH.style.display = "block";
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarH.firstChild.style.width =
        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + "px";
    } else d.scrollbarH.style.display = "";
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
    } else d.scrollbarFiller.style.display = "";
    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";
      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
    } else d.gutterFiller.style.display = "";

    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";
  }

  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == "number") top = viewPort;
    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};
  }

  // LINE NUMBERS

  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + "px";
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {
      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }

  // DISPLAY DRAWING

  function updateDisplay(cm, changes, viewPort) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (;;) {
      if (!updateDisplayInner(cm, changes, visible)) break;
      updated = true;
      updateSelection(cm);
      updateScrollbars(cm);

      // Clip forced viewport to actual scrollable area
      if (viewPort)
        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,
                            typeof viewPort == "number" ? viewPort : viewPort.top);
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
        break;
      changes = [];
    }

    if (updated) {
      signalLater(cm, "update", cm);
      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
        signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);
    }
    return updated;
  }

  // Uses a set of changes plus the current scroll position to
  // determine which DOM updates have to be made, and makes the
  // updates.
  function updateDisplayInner(cm, changes, visible) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (changes.length == 0 &&
        visible.from > display.showingFrom && visible.to < display.showingTo)
      return;

    if (maybeUpdateLineNumberWidth(cm))
      changes = [{from: doc.first, to: doc.first + doc.size}];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";

    // Used to determine which lines need their line numbers updated
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) { positionsChangedFrom = changes[i].from; break; }

    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;
    }

    // Create a range of theoretically intact lines, and punch holes
    // in that using the change info.
    var intact = [{from: Math.max(display.showingFrom, doc.first),
                   to: Math.min(display.showingTo, end)}];
    if (intact[0].from >= intact[0].to) intact = [];
    else intact = computeIntact(intact, changes);
    // When merged lines are present, we might have to reduce the
    // intact ranges because changes in continued fragments of the
    // intact lines do require the lines to be redrawn.
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from) range.to = newTo;
          else { intact.splice(i--, 1); break; }
        }
      }

    // Clip off the parts that won't be visible
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from) range.from = from;
      if (range.to > to) range.to = to;
      if (range.from >= range.to) intact.splice(i--, 1);
      else intactLines += range.to - range.from;
    }
    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function(a, b) {return a.from - b.from;});

    // Avoid crashing on IE's "unspecified error" when in iframes
    try {
      var focused = document.activeElement;
    } catch(e) {}
    if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = "";
    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();

    var different = from != display.showingFrom || to != display.showingTo ||
      display.lastSizeC != display.wrapper.clientHeight;
    // This is just a bogus formula that detects when the editor is
    // resized or the font size changes.
    if (different) {
      display.lastSizeC = display.wrapper.clientHeight;
      startWorker(cm, 400);
    }
    display.showingFrom = from; display.showingTo = to;

    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {
      if (ie_lt8) {
        var bot = node.offsetTop + node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = getRect(node);
        height = box.bottom - box.top;
      }
      var diff = node.lineObj.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(node.lineObj, height);
        var widgets = node.lineObj.widgets;
        if (widgets) for (var i = 0; i < widgets.length; ++i)
          widgets[i].height = widgets[i].node.offsetHeight;
      }
    }
    updateViewOffset(cm);

    return true;
  }

  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    // Position the mover div to align with the current virtual scroll position
    cm.display.mover.style.top = off + "px";
  }

  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({from: range.from + diff, to: range.to + diff});
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({from: range.from, to: change.from});
          if (change.to < range.to)
            intact2.push({from: change.to + diff, to: range.to + diff});
        }
      }
      intact = intact2;
    }
    return intact;
  }

  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }

    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function(line) {
      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0) updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {
          var w = line.widgets[i];
          if (w.showIfHidden) {
            var prev = cur.previousSibling;
            if (/pre/i.test(prev.nodeName)) {
              var wrap = elt("div", null, null, "position: relative");
              prev.parentNode.replaceChild(wrap, prev);
              wrap.appendChild(prev);
              prev = wrap;
            }
            var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));
            if (!w.handleMouseEvents) wnode.ignoreEvents = true;
            positionLineWidget(w, wnode, prev, dims);
          }
        }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        // This line is intact. Skip to the actual node. Update its
        // line number if needed.
        while (cur.lineObj != line) cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        // For lines with widgets, make an attempt to find and reuse
        // the existing element, so that widgets aren't needlessly
        // removed and re-inserted into the dom
        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }
        // This line needs to be generated.
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse) cur = rm(cur);
          cur = cur.nextSibling;
        }

        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur) cur = rm(cur);
  }

  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;

    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;

    // Lines with gutter elements, widgets or a background class need
    // to be wrapped again, and have the extra elements added to the
    // wrapper div

    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0, insertBefore = null;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0, first = true; i < line.widgets.length; ++i) {
            var widget = line.widgets[i];
            if (!widget.above) { insertBefore = n; first = false; }
            if (widget.node == n.firstChild) {
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              break;
            }
          }
          if (i == line.widgets.length) { isOk = false; break; }
        }
      }
      reuse.insertBefore(lineElement, insertBefore);
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || "";
      }
    }
    if (!wrap) {
      wrap = elt("div", null, line.wrapClass, "position: relative");
      wrap.appendChild(lineElement);
    }
    // Kludge to make sure the styled element lies behind the selection (by z-index)
    if (line.bgClass)
      wrap.insertBefore(elt("div", null, line.bgClass + " CodeMirror-linebackground"), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt("div", null, null, "position: absolute; left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),
                                         wrap.firstChild);
      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        wrap.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineNo),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + display.lineNumInnerWidth + "px"));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
        }
    }
    if (ie_lt8) wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.ignoreEvents = true;
      positionLineWidget(widget, node, wrap, dims);
      if (widget.above)
        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
    return wrap;
  }

  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // SELECTION / CURSOR

  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = "none";
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = "none";

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, cm.doc.sel.head, "div");
      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                                        headPos.top + lineOff.top - wrapOff.top)) + "px";
      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                                         headPos.left + lineOff.left - wrapOff.left)) + "px";
    }
  }

  // No selection, plain cursor
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, "div");
    display.cursor.style.left = pos.left + "px";
    display.cursor.style.top = pos.top + "px";
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
    display.cursor.style.display = "";

    if (pos.other) {
      display.otherCursor.style.display = "";
      display.otherCursor.style.left = pos.other.left + "px";
      display.otherCursor.style.top = pos.other.top + "px";
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    } else { display.otherCursor.style.display = "none"; }
  }

  // Highlight selection
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = pl;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = clientWidth;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < pl + 1) left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);
      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);
      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;
      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(pl, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(pl, leftEnd.bottom, null, rightStart.top);
    }

    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = "";
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = "";
    display.blinker = setInterval(function() {
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";
    }, cm.options.cursorBlinkRate);
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {
      if (doc.frontier >= cm.display.showingFrom) { // Visible
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;
          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function() {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));
    return e.offsetLeft;
  }

  function measureChar(cm, line, ch, data, bias) {
    var dir = -1;
    data = data || measureLine(cm, line);

    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r) break;
      if (dir < 0 && pos == 0) dir = 1;
    }
    var rightV = (pos < ch || bias == "right") && r.topRight != null;
    return {left: pos < ch ? r.right : r.left,
            right: pos > ch ? r.left : r.right,
            top: rightV ? r.topRight : r.top,
            bottom: rightV ? r.bottomRight : r.bottom};
  }

  function findCachedMeasurement(cm, line) {
    var cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&
          cm.display.scroller.clientWidth == memo.width &&
          memo.classes == line.textClass + "|" + line.bgClass + "|" + line.wrapClass)
        return memo;
    }
  }

  function clearCachedMeasurement(cm, line) {
    var exists = findCachedMeasurement(cm, line);
    if (exists) exists.text = exists.measure = exists.markedSpans = null;
  }

  function measureLine(cm, line) {
    // First look in the cache
    var cached = findCachedMeasurement(cm, line);
    if (cached) return cached.measure;

    // Failing that, recompute and store result in cache
    var measure = measureLineInner(cm, line);
    var cache = cm.display.measureLineCache;
    var memo = {text: line.text, width: cm.display.scroller.clientWidth,
                markedSpans: line.markedSpans, measure: measure,
                classes: line.textClass + "|" + line.bgClass + "|" + line.wrapClass};
    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;
    else cache.push(memo);
    return measure;
  }

  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure);

    // IE does not cache element positions of inline elements between
    // calls to getBoundingClientRect. This makes the loop below,
    // which gathers the positions of all the characters on the line,
    // do an amount of layout work quadratic to the number of
    // characters. When line wrapping is off, we try to improve things
    // by first subdividing the line into a bunch of inline blocks, so
    // that IE can reuse most of the layout information from caches
    // for those blocks. This does interfere with line wrapping, so it
    // doesn't work when wrapping is on, but in that case the
    // situation is slightly better, since IE does cache line-wrapping
    // information and only recomputes per-line.
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt("div", null, null, "display: inline-block");
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }

    removeChildrenAndAdd(display.measure, pre);

    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    // Work around an IE7/8 bug where it will sometimes have randomly
    // replaced our pre with a clone at this point.
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);

    function categorizeVSpan(top, bot) {
      if (bot > maxBot) bot = maxBot;
      if (top < 0) top = 0;
      for (var j = 0; j < vranges.length; j += 2) {
        var rtop = vranges[j], rbot = vranges[j+1];
        if (rtop > bot || rbot < top) continue;
        if (rtop <= top && rbot >= bot ||
            top <= rtop && bot >= rbot ||
            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {
          vranges[j] = Math.min(top, rtop);
          vranges[j+1] = Math.max(bot, rbot);
          return j;
        }
      }
      vranges.push(top, bot);
      return j;
    }

    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {
      var size, node = cur;
      // A widget might wrap, needs special care
      if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
        if (cur.firstChild.nodeType == 1) node = cur.firstChild;
        var rects = node.getClientRects(), rLeft = rects[0], rRight = rects[rects.length - 1];
        if (rects.length > 1) {
          var vCatLeft = categorizeVSpan(rLeft.top - outer.top, rLeft.bottom - outer.top);
          var vCatRight = categorizeVSpan(rRight.top - outer.top, rRight.bottom - outer.top);
          data[i] = {left: rLeft.left - outer.left, right: rRight.right - outer.left,
                     top: vCatLeft, topRight: vCatRight};
          continue;
        }
      }
      size = getRect(node);
      var vCat = categorizeVSpan(size.top - outer.top, size.bottom - outer.top);
      var right = size.right;
      if (cur.measureRight) right = getRect(cur.measureRight).left;
      data[i] = {left: size.left - outer.left, right: right - outer.left, top: vCat};
    }
    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {
      var vr = cur.top, vrRight = cur.topRight;
      cur.top = vranges[vr]; cur.bottom = vranges[vr+1];
      if (vrRight != null) { cur.topRight = vranges[vrRight]; cur.bottomRight = vranges[vrRight+1]; }
    }
    return data;
  }

  function measureLineWidth(cm, line) {
    var hasBadSpan = false;
    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {
      var sp = line.markedSpans[i];
      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;
    }
    var cached = !hasBadSpan && findCachedMeasurement(cm, line);
    if (cached) return measureChar(cm, line, line.text.length, cached.measure, "right").right;

    var pre = lineContent(cm, line);
    var end = pre.appendChild(zeroWidthElement(cm.display.measure));
    removeChildrenAndAdd(cm.display.measure, pre);
    return getRect(end).right - getRect(cm.display.lineDiv).left;
  }

  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(cm, lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Context may be "window", "page", "div", or "local"/null
  // Result is in "div" coords
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = getRect(cm.display.sizer);
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = getRect(cm.display.lineSpace);
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);
  }

  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement) measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  function PosWithInfo(line, ch, outside, xRel) {
    var pos = new Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Coords must be lineSpace-local
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line",
                            lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar.test(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < 0 ? -1 : xDiff ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "x");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap changes in such a way that each
  // change won't have to update the cursor and display (which would
  // be awkward, slow, and error-prone), but instead updates are
  // batched and then all combined and executed at once.

  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      // An array of ranges of lines that have to be updated. See
      // updateDisplay.
      changes: [],
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      cursorActivity: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++) delayedCallbacks = [];
  }

  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;

    if (op.updateMaxLine) computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
      var width = measureLineWidth(cm, display.maxLine);
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null) {
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);
      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    if (!updated && op.selectionChanged) updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
      if (op.scrollToPos)
        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);

    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, "change", cm, op.textChanged);
    if (op.cursorActivity) signal(cm, "cursorActivity", cm);
    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm1, f) {
    return function() {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp) startOperation(cm);
      try { var result = f.apply(cm, arguments); }
      finally { if (withOp) endOperation(cm); }
      return result;
    };
  }
  function docOperation(f) {
    return function() {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp) startOperation(this.cm);
      try { result = f.apply(this, arguments); }
      finally { if (withOp) endOperation(this.cm); }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp) startOperation(cm);
    try { result = f(); }
    finally { if (withOp) endOperation(cm); }
    return result;
  }

  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({from: from, to: to, diff: lendiff});
  }

  // INPUT HANDLING

  function slowPoll(cm) {
    if (cm.display.pollingFast) return;
    cm.display.poll.set(cm.options.pollInterval, function() {
      readInput(cm);
      if (cm.state.focused) slowPoll(cm);
    });
  }

  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
      else {cm.display.pollingFast = false; slowPoll(cm);}
    }
    cm.display.poll.set(20, p);
  }

  // prevInput is a hack to work with IME. If we reset the textarea
  // on every change, that breaks IME. So we look for changes
  // compared to the previous content instead. (Modern browsers have
  // events that indicate IME taking place, but these are not widely
  // supported or compatible enough yet to rely on.)
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput) return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to)) return false;
    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
      resetInput(cm, true);
      return false;
    }

    var withOp = !cm.curOp;
    if (withOp) startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));

    var updateInput = cm.curOp.updateInput;
    var changeEvent = {from: from, to: to, text: splitLines(text.slice(same)),
                       origin: cm.state.pasteIncoming ? "paste" : "+input"};
    makeChange(cm.doc, changeEvent, "end");
    cm.curOp.updateInput = updateInput;
    signalLater(cm, "inputRead", cm, changeEvent);

    if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
    else cm.display.prevInput = text;
    if (withOp) endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }

  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = "";
      minimal = hasCopyEvent &&
        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? "-" : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused) selectInput(cm.display.input);
      if (ie && !ie_lt9) cm.display.inputHasSelection = content;
    } else if (user) {
      cm.display.prevInput = cm.display.input.value = "";
      if (ie && !ie_lt9) cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }

  function focusInput(cm) {
    if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // EVENT HANDLERS

  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    if (ie)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
        extendSelection(cm.doc, word.from, word.to);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    on(d.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(d, e)) e_preventDefault(e);
    });
    // Gecko browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for Gecko.
    if (!captureMiddleClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });
    on(d.scrollbarV, "scroll", function() {
      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, "scroll", function() {
      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });

    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }
    on(d.scrollbarH, "mousedown", reFocus);
    on(d.scrollbarV, "mousedown", reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    var resizeTimer;
    function onResize() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        // Might be a text scaling operation, clear size caches.
        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;
        clearCaches(cm);
        runInOp(cm, bind(regChange, cm));
      }, 100);
    }
    on(window, "resize", onResize);
    // Above handler holds on to the editor and its data structures.
    // Here we poll to unregister it when the editor is no longer in
    // the document, so that it can be garbage-collected.
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}
      if (p) setTimeout(unregister, 5000);
      else off(window, "resize", onResize);
    }
    setTimeout(unregister, 5000);

    on(d.input, "keyup", operation(cm, function(e) {
      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
      if (e.keyCode == 16) cm.doc.sel.shift = false;
    }));
    on(d.input, "input", bind(fastPoll, cm));
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));

    function drag_(e) {
      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }
    on(d.scroller, "paste", function(e){
      if (eventInWidget(d, e)) return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, "paste", function() {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });

    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = "";
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, "cut", prepareCopy);
    on(d.input, "copy", prepareCopy);

    // Needed to handle Tab key in KHTML
    if (khtml) on(d.sizer, "mouseup", function() {
        if (document.activeElement == d.input) d.input.blur();
        focusInput(cm);
    });
  }

  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
    }
  }

  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||
          target == display.scrollbarV || target == display.scrollbarV.firstChild ||
          target == display.scrollbarFiller || target == display.gutterFiller) return null;
    }
    var x, y, space = getRect(display.lineSpace);
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }
    return coordsChar(cm, x - space.left, y - space.top);
  }

  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    if (signalDOMEvent(this, e)) return;
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);

    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick) onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start) extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    // For button 1, if it was clicked inside the editor
    // (posFromMouse returning non-null), we have to adjust the
    // selection.
    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}

    if (!cm.state.focused) onFocus(cm);

    var now = +new Date, type = "single";
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = "triple";
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else { lastClick = {time: now, pos: start}; }

    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&
        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {
      var dragEnd = operation(cm, function(e2) {
        if (webkit) display.scroller.draggable = false;
        cm.state.draggingText = false;
        off(document, "mouseup", dragEnd);
        off(display.scroller, "drop", dragEnd);
        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
          e_preventDefault(e2);
          extendSelection(cm.doc, start);
          focusInput(cm);
        }
      });
      // Let the drag handler handle this.
      if (webkit) display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      // IE's approach to draggable
      if (display.scroller.dragDrop) display.scroller.dragDrop();
      on(document, "mouseup", dragEnd);
      on(display.scroller, "drop", dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == "single") extendSelection(cm.doc, clipPos(doc, start));

    var startstart = sel.from, startend = sel.to, lastPos = start;

    function doSelect(cur) {
      if (posEq(lastPos, cur)) return;
      lastPos = cur;

      if (type == "single") {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }

      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == "double") {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);
        else extendSelection(cm.doc, startstart, word.to);
      } else if (type == "triple") {
        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }

    var editorSize = getRect(display.wrapper);
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur) return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused) onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, "mousemove", move);
      off(document, "mouseup", up);
    }

    var move = operation(cm, function(e) {
      if (!ie && !e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  function clickInGutter(cm, e) {
    var display = cm.display;
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }

    if (mX >= Math.floor(getRect(display.gutters).right)) return false;
    e_preventDefault(e);
    if (!hasHandler(cm, "gutterClick")) return true;

    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom) return true;
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, "gutterClick", cm, line, gutter, e);
        break;
      }
    }
    return true;
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"}, "around");
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else {
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");
          cm.replaceSelection(text, null, "paste");
          focusInput(cm);
          onFocus(cm);
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    var txt = cm.getSelection();
    e.dataTransfer.setData("Text", txt);

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera) img.parentNode.removeChild(img);
    }
  }

  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
    if (gecko) updateDisplay(cm, []);
    startWorker(cm, 100);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }

  var maybeTransition;
  function handleKeyBinding(cm, e) {
    // Handle auto keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
      if (getKeyMap(cm.options.keyMap) == startMap) {
        cm.options.keyMap = (next.call ? next.call(null, cm) : next);
        keyMapChanged(cm);
      }
    }, 50);

    var name = keyName(e, true), handled = false;
    if (!name) return false;
    var keymaps = allKeyMaps(cm);

    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})
             || lookupKey(name, keymaps, function(b) {
                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
                });
    } else {
      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });
    }

    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }
      signalLater(cm, "keyHandled", cm, name, e);
    }
    return handled;
  }

  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                            function(b) { return doHandleBinding(cm, b, true); });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
    }
    return handled;
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused) onFocus(cm);
    if (ie && e.keyCode == 27) { e.returnValue = false; }
    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
    var code = e.keyCode;
    // IE does strange things with escape.
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    // First give onKeyEvent option a chance to handle this.
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("");
    }
  }

  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars &&
        this.options.smartIndent && !isReadOnly(this) &&
        this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function() {indentLine(cm, cm.doc.sel.to.line, "smart");}), 75);
    if (handleCharBinding(cm, e, ch)) return;
    if (ie && !ie_lt9) cm.display.inputHasSelection = null;
    fastPoll(cm);
  }

  function onFocus(cm) {
    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += " CodeMirror-focused";
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);
  }

  var detectingSelectAll;
  function onContextMenu(cm, e) {
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e)) return;

    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera) return; // Opera is difficult.
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);

    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = "absolute";
    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; outline: none;" +
      "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";
    focusInput(cm);
    resetInput(cm, true);
    // Adds "Select all" to context menu in FF
    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";

    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var extval = display.input.value = " " + (posEq(sel.from, sel.to) ? "" : display.input.value);
        display.prevInput = " ";
        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
      }
    }
    function rehide() {
      display.inputDiv.style.position = "relative";
      display.input.style.cssText = oldCSS;
      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);

      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || ie_lt9) prepareSelectAllHack();
        clearTimeout(detectingSelectAll);
        var i = 0, poll = function(){
          if (display.prevInput == " " && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);
          else resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && !ie_lt9) prepareSelectAllHack();
    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }

  // UPDATING

  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Make sure a position will be valid after the given change.
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos)) return clipPos(doc, pos);
    var diff = (change.text.length - 1) - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +
                       getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }

  // Hint can be null|"end"|"start"|"around"|{anchor,head}
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == "object") // Assumed to be {anchor, head} object
      return {anchor: clipPostChange(doc, change, hint.anchor),
              head: clipPostChange(doc, change, hint.head)};

    if (hint == "start") return {anchor: change.from, head: change.from};

    var end = changeEnd(change);
    if (hint == "around") return {anchor: change.from, head: end};
    if (hint == "end") return {anchor: end, head: end};

    // hint is null, leave the selection alone as much as possible
    var adjustPos = function(pos) {
      if (posLess(pos, change.from)) return pos;
      if (!posLess(change.to, pos)) return end;

      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};
  }

  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Replace the range from from to to by the strings in replacement.
  // change is a {from, to, text [, origin]} object
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [""]});
      if (split.length)
        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }

  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  function makeChangeFromHistory(doc, type) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history;
    var event = (type == "undo" ? hist.done : hist.undone).pop();
    if (!event) return;

    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,
                anchorAfter: event.anchorBefore, headAfter: event.headBefore,
                generation: hist.generation};
    (type == "undo" ? hist.undone : hist.done).push(anti);
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        (type == "undo" ? hist.done : hist.undone).length = 0;
        return;
      }

      anti.changes.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change, null)
                    : {anchor: event.anchorBefore, head: event.headBefore};
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];

      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  function shiftDoc(doc, distance) {
    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}
    doc.first += distance;
    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);
  }

  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else updateDoc(doc, change, spans, selAfter);
  }

  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
      cm.curOp.cursorActivity = true;

    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    regChange(cm, from.line, to.line + 1, lendiff);

    if (hasHandler(cm, "change")) {
      var changeObj = {from: from, to: to,
                       text: change.text,
                       removed: change.removed,
                       origin: change.origin};
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}
        cur.next = changeObj;
      } else cm.curOp.textChanged = changeObj;
    }
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);
  }

  // POSITION OBJECT

  function Pos(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  }
  CodeMirror.Pos = Pos;

  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}
  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}
  function copyPos(x) {return Pos(x.line, x.ch);}

  // SELECTION

  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}

  // If shift is held, this will move the selection anchor. Otherwise,
  // it'll set the whole selection.
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm) doc.cm.curOp.userSelChange = true;
  }

  function filterSelectionChange(doc, anchor, head) {
    var obj = {anchor: anchor, head: head};
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);
    return obj;
  }

  // Update the selection. Last two args are only used by
  // updateDoc, since they have to be expressed in the line
  // numbers before the update.
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }

    var sel = doc.sel;
    sel.goalColumn = null;
    // Skip over atomic spans.
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != "push");

    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;

    sel.anchor = anchor; sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;

    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =
        doc.cm.curOp.cursorActivity = true;

    signalLater(doc, "cursorActivity", doc);
  }

  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");
  }

  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find()[dir < 0 ? "from" : "to"];
            if (posEq(newPos, curPos)) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SCROLLING

  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head, cm.options.cursorScrollMargin);
    if (!cm.state.focused) return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == "none";
      if (hidden) {
        display.cursor.style.display = "";
        display.cursor.style.left = coords.left + "px";
        display.cursor.style.top = (coords.top - display.viewOffset) + "px";
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden) display.cursor.style.display = "none";
    }
  }

  function scrollPosIntoView(cm, pos, margin) {
    if (margin == null) margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) return coords;
    }
  }

  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft) x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }

  function updateScrollPos(cm, left, top) {
    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,
                                scrollTop: top == null ? cm.doc.scrollTop : top};
  }

  function addToScrollPos(cm, left, top) {
    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});
    var scroll = cm.display.scroller;
    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
  }

  // API UTILITIES

  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (how == null) how = "add";
    if (how == "smart") {
      if (!cm.doc.mode.indent) how = "prev";
      else var state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == "smart") {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    line.stateAfter = null;
  }

  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no)) regChange(cm, no, no + 1);
    else return null;
    return line;
  }

  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur) ? "w"
          : !group ? null
          : /\s/.test(cur) ? null
          : "p";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }
        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if (pos.xRel < 0 || end == line.length) --start; else ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar
        : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
        : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
      while (start > 0 && check(line.charAt(start - 1))) --start;
      while (end < line.length && check(line.charAt(end))) ++end;
    }
    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};
  }

  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }

  // PROTOTYPE

  // The publicly visible API. Note that operation(null, f) means
  // 'wrap f in an operation, performed on its `this` parameter'

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); focusInput(this); onFocus(this); fastPoll(this);},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](map);
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if ((typeof map == "string" ? maps[i].name : maps[i]) == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: operation(null, function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: operation(null, function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function(how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {start: stream.start,
              end: stream.pos,
              string: stream.current(),
              className: style || null, // Deprecated, use 'type' instead
              type: style || null,
              state: state};
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else return styles[mid * 2 + 2];
      }
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null) pos = sel.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || "page").top +
        (end ? lineObj.height : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: operation(null, function(line, gutterID, value) {
      return changeLine(this, line, function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: operation(null, function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    addLineClass: operation(null, function(handle, where, cls) {
      return changeLine(this, handle, function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),

    removeLineClass: operation(null, function(handle, where, cls) {
      return changeLine(this, handle, function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: operation(null, function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),

    removeLineWidget: function(widget) { widget.clear(); },

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: operation(null, onKeyDown),

    execCommand: function(cmd) {return commands[cmd](this);},

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: operation(null, function(dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),

    deleteH: operation(null, function(dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");
      else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");
      this.curOp.userSelChange = true;
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: operation(null, function(dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, "div");
      if (sel.goalColumn != null) pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);

      if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += " CodeMirror-overwrite";
      else
        this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");
    },
    hasFocus: function() { return this.state.focused; },

    scrollTo: operation(null, function(x, y) {
      updateScrollPos(this, x, y);
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};
    },

    scrollIntoView: operation(null, function(pos, margin) {
      if (typeof pos == "number") pos = Pos(pos, 0);
      if (!margin) margin = 0;
      var coords = pos;

      if (!pos || pos.line != null) {
        this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        this.curOp.scrollToPosMargin = margin;
        coords = cursorCoords(this, this.curOp.scrollToPos);
      }
      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
    }),

    setSize: function(width, height) {
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) this.display.wrapper.style.width = interpret(width);
      if (height != null) this.display.wrapper.style.height = interpret(height);
      this.refresh();
    },

    on: function(type, f) {on(this, type, f);},
    off: function(type, f) {off(this, type, f);},

    operation: function(f){return runInOp(this, f);},

    refresh: operation(null, function() {
      clearCaches(this);
      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
      regChange(this);
    }),

    swapDoc: operation(null, function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this, true);
      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
      return old;
    }),

    getInputField: function(){return this.display.input;},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };

  // OPTION DEFAULTS

  var optionHandlers = CodeMirror.optionHandlers = {};

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("electricChars", true);
  option("rtlMoveVisually", !windows);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", keyMapChanged);
  option("extraKeys", null);

  option("onKeyEvent", null);
  option("onDragEvent", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, updateScrollbars, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {onBlur(cm); cm.display.input.blur();}
    else if (!val) resetInput(cm, true);
  });
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true);
  option("pollInterval", 100);
  option("undoDepth", 40, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 500);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, function(cm){loadMode(cm); cm.refresh();}, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  CodeMirror.getMode = function(options, spec) {
    spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    return modeObj;
  };

  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because modes
  // sometimes need to do this.
  function copyState(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;

  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},
    killLine: function(cm) {
      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
      if (!sel && cm.getLine(from.line).length == from.ch)
        cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");
      else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");
    },
    deleteLine: function(cm) {
      var l = cm.getCursor().line;
      cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");
    },
    delLineLeft: function(cm) {
      var cur = cm.getCursor();
      cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelection(lineStart(cm, cm.getCursor().line));
    },
    goLineStartSmart: function(cm) {
      var cur = cm.getCursor(), start = lineStart(cm, cur.line);
      var line = cm.getLineHandle(start.line);
      var order = getOrder(line);
      if (!order || order[0].level == 0) {
        var firstNonWS = Math.max(0, line.text.search(/\S/));
        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
      } else cm.extendSelection(start);
    },
    goLineEnd: function(cm) {
      cm.extendSelection(lineEnd(cm, cm.getCursor().line));
    },
    goLineRight: function(cm) {
      var top = cm.charCoords(cm.getCursor(), "div").top + 5;
      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div"));
    },
    goLineLeft: function(cm) {
      var top = cm.charCoords(cm.getCursor(), "div").top + 5;
      cm.extendSelection(cm.coordsChar({left: 0, top: top}, "div"));
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t", "end", "+input");},
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.replaceSelection("\t", "end", "+input");
    },
    transposeChars: function(cm) {
      var cur = cm.getCursor(), line = cm.getLine(cur.line);
      if (cur.ch > 0 && cur.ch < line.length - 1)
        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),
                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
    },
    newlineAndIndent: function(cm) {
      operation(cm, function() {
        cm.replaceSelection("\n", "end", "+input");
        cm.indentLine(cm.getCursor().line, null, true);
      })();
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };

  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"
  };
  // Note that the save and find-related commands aren't defined by
  // default. Unknown commands are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    fallthrough: "basic"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };

  // KEYMAP DISPATCH

  function getKeyMap(val) {
    if (typeof val == "string") return keyMap[val];
    else return val;
  }

  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false) return "stop";
      if (found != null && handle(found)) return true;
      if (map.nofallthrough) return "stop";

      var fallthrough = map.fallthrough;
      if (fallthrough == null) return false;
      if (Object.prototype.toString.call(fallthrough) != "[object Array]")
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done) return done;
      }
      return false;
    }

    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done) return done != "stop";
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }
  function keyName(event, noShift) {
    if (opera && event.keyCode == 34 && event["char"]) return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) return false;
    if (event.altKey) name = "Alt-" + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
    if (!noShift && event.shiftKey) name = "Shift-" + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = document.body;
      // doc.activeElement occasionally throws on IE
      try { hasFocus = document.activeElement; } catch(e) {}
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    cm.save = save;
    cm.getTextArea = function() { return textarea; };
    cm.toTextArea = function() {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  // The character stream used by a mode's parser.
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
  }

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == 0;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue;
    },
    indentation: function() {return countColumn(this.string, null, this.tabSize);},
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);}
  };
  CodeMirror.StringStream = StringStream;

  // TEXTMARKERS

  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;

  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null) max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm);
    }
    if (withOp) endOperation(cm);
    signalLater(this, "clear");
  };

  TextMarker.prototype.find = function() {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null) from = Pos(found, span.from);
        if (span.to != null) to = Pos(found, span.to);
      }
    }
    if (this.type == "bookmark") return from;
    return from && {from: from, to: to};
  };

  TextMarker.prototype.changed = function() {
    var pos = this.find(), cm = this.doc.cm;
    if (!pos || !cm) return;
    var line = getLine(this.doc, pos.from.line);
    clearCachedMeasurement(cm, line);
    if (pos.from.line >= cm.display.showingFrom && pos.from.line < cm.display.showingTo) {
      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {
        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);
        break;
      }
      runInOp(cm, function() { cm.curOp.selectionChanged = true; });
    }
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  function markText(doc, from, to, options, type) {
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type);
    if (type == "range" && !posLess(from, to)) return marker;
    if (options) copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;
    }
    if (marker.collapsed) sawCollapsedSpans = true;

    if (marker.addToHistory)
      addToHistory(doc, {from: from, to: to, origin: "markText"},
                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);

    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {from: null, to: null, marker: marker};
      size += line.text.length;
      if (curLine == from.line) {span.from = from.ch; size -= from.ch;}
      if (curLine == to.line) {span.to = to.ch; size -= line.text.length - to.ch;}
      if (marker.collapsed) {
        if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);
        else updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error("Inserting collapsed marker overlapping an existing one");
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic) reCheckSelection(cm);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], "clear", function(){me.clear();});
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function() {
    return this.primary.find();
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.replacedWith;
    linkedDocs(doc, function(doc) {
      if (widget) options.replacedWith = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  // TEXTMARKER SPANS

  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || marker.type == "bookmark" && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push({from: span.from,
                                to: endsAfter ? null : span.to,
                                marker: marker});
      }
    }
    return nw;
  }

  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || marker.type == "bookmark" && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,
                                to: span.to == null ? null : span.to - endCh,
                                marker: marker});
      }
    }
    return nw;
  }

  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    if (sameLine && first) {
      // Make sure we didn't create any zero-length spans
      for (var i = 0; i < first.length; ++i)
        if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != "bookmark")
          first.splice(i--, 1);
      if (!first.length) first = null;
    }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;
        var newParts = [j, 1];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({from: p.from, to: m.from});
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if ((sp.from == null || sp.from < ch) &&
          (sp.to == null || sp.to > ch) &&
          (!found || found.width < sp.marker.width))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAt(line, -1); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAt(line, line.text.length + 1); }

  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }

  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.replacedWith) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }

  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // LINE WIDGETS

  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
    for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.cm = cm;
    this.node = node;
  };
  function widgetOperation(f) {
    return function() {
      var withOp = !this.cm.curOp;
      if (withOp) startOperation(this.cm);
      try {var result = f.apply(this, arguments);}
      finally {if (withOp) endOperation(this.cm);}
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function() {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) this.line.widgets = null;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function() {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(cm, handle, function(line) {
      (line.widgets || (line.widgets = [])).push(widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.display.scroller.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, 0, widget.height);
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  function makeLine(text, markedSpans, estimateHeight) {
    var line = {text: text};
    attachMarkedSpans(line, markedSpans);
    line.height = estimateHeight ? estimateHeight(line) : 1;
    return line;
  }

  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Run the given mode's parser over a line, update the styles
  // array, which contains alternating fragments of text and CSS
  // classes.
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == "" && mode.blankLine) mode.blankLine(state);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        // Webkit seems to refuse to render text nodes longer than 57444 characters
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      } else {
        style = mode.token(stream, state);
      }
      if (!flattenSpans || curStyle != style) {
        if (curStart < stream.start) f(stream.start, curStyle);
        curStart = stream.start; curStyle = style;
      }
      stream.start = stream.pos;
    }
    if (curStart < stream.pos) f(stream.pos, curStyle);
  }

  function highlightLine(cm, line, state) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen];
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {st.push(end, style);});

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = cur ? cur + " " + style : style;
          }
        }
      });
    }

    return st;
  }

  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array.
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == "" && mode.blankLine) mode.blankLine(state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }

  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style) return null;
    return styleToClassCache[style] ||
      (styleToClassCache[style] = "cm-" + style.replace(/ +/g, " cm-"));
  }

  function lineContent(cm, realLine, measure) {
    var merged, line = realLine, empty = true;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(cm.doc, merged.find().from.line);

    var builder = {pre: elt("pre"), col: 0, pos: 0, display: !measure,
                   measure: null, measuredSomething: false, cm: cm};
    if (line.textClass) builder.pre.className = line.textClass;

    do {
      if (line.text) empty = false;
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if ((ie || webkit) && cm.getOption("lineWrapping"))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      if (measure && line == realLine && !builder.measuredSomething) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.measuredSomething = true;
      }
      if (next) line = getLine(cm.doc, next.to.line);
    } while (next);

    if (measure && !builder.measuredSomething && !measure[0])
      measure[0] = builder.pre.appendChild(empty ? elt("span", "\u00a0") : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode("\u00a0"));

    var order;
    // Work around problem with the reported dimensions of single-char
    // direction spans on IE (issue #1129). See also the comment in
    // cursorCoords.
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to) --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),
                                               span.nextSibling);
      }
    }

    signal(cm, "renderLine", cm, realLine, builder.pre);
    return builder.pre;
  }

  var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle) {
    if (!text) return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          builder.col += tabWidth;
        } else {
          var token = elt("span", "\u2022", "cm-invalidchar");
          token.title = "\\u" + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      return builder.pre.appendChild(elt("span", [content], fullStyle));
    }
    builder.pre.appendChild(content);
  }

  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    var wrapping = builder.cm.options.lineWrapping;
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= "\ud800" && ch < "\udbff" && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && wrapping && spanAffectsWrapping(text, i)) {
        builder.pre.appendChild(elt("wbr"));
      }
      var span = builder.measure[builder.pos] =
        buildToken(builder, ch, style,
                   start && startStyle, i == text.length - 1 && endStyle);
      // In IE single-space nodes wrap differently than spaces
      // embedded in larger text nodes, except when set to
      // white-space: normal (issue #1268).
      if (ie && wrapping && ch == " " && i && !/\s/.test(text.charAt(i - 1)) &&
          i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
        span.style.whiteSpace = "normal";
      builder.pos += ch.length;
    }
    if (text.length) builder.measuredSomething = true;
  }

  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = " ";
      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
      out += " ";
      return out;
    }
    return function(builder, text, style, startStyle, endStyle) {
      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle);
    };
  }

  function buildCollapsedSpan(builder, size, widget) {
    if (widget) {
      if (!builder.display) widget = widget.cloneNode(true);
      if (builder.measure) {
        builder.measure[builder.pos] = size ? widget
          : builder.pre.appendChild(zeroWidthElement(builder.cm.display.measure));
        builder.measuredSomething = true;
      }
      builder.pre.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), styleToClass(styles[i+1]));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.collapsed && (!collapsed || collapsed.marker.size < m.size))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.replacedWith)
            foundBookmark = m.replacedWith;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,
                             collapsed.from != null && collapsed.marker.replacedWith);
          if (collapsed.to == null) return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed) buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "");
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = styleToClass(styles[i++]);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // First adjust the line structure
    if (from.ch == 0 && to.ch == 0 && lastText == "") {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(makeLine(text[i], spansFor(i), estimateHeight));
        added.push(makeLine(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    collapse: function(lines) {
      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));
    },
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;
    },
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([makeLine("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.history = makeHistory();
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    insert: function(at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue"},
                 {head: top, anchor: top}, true);
    },
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},
    setLine: function(line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function(line) {
      if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
      else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));
    },

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var sel = this.sel, pos;
      if (start == null || start == "head") pos = sel.head;
      else if (start == "anchor") pos = sel.anchor;
      else if (start == "end" || start === false) pos = sel.to;
      else pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},

    setCursor: docOperation(function(line, ch, extend) {
      var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);
      if (extend) extendSelection(this, pos);
      else setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function(anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function(from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),

    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},
    replaceSelection: function(code, collapse, origin) {
      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || "around");
    },
    undo: docOperation(function() {makeChangeFromHistory(this, "undo");}),
    redo: docOperation(function() {makeChangeFromHistory(this, "redo");}),

    setExtending: function(val) {this.sel.extend = val;},

    historySize: function() {
      var hist = this.history;
      return {undo: hist.done.length, redo: hist.undone.length};
    },
    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration();
    },
    changeGeneration: function() {
      this.history.lastOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = makeHistory(this.history.maxGeneration);
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,
                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  Doc.prototype.eachLine = Doc.prototype.iter;

  // The Doc methods that should be available on CodeMirror instances
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent) n.height += diff;
  }

  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0, e = chunk.children.length; i < e; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }

  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function makeHistory(startGen) {
    return {
      // Arrays of history events. Doing something adds an event to
      // done and clears undo. Undoing moves events from done to
      // undone, redoing moves them in the other direction.
      done: [], undone: [], undoDepth: Infinity,
      // Used to track when changes can be merged into a single undo
      // event
      lastTime: 0, lastOp: null, lastOrigin: null,
      // Used by the isClean() method
      generation: startGen || 1, maxGeneration: startGen || 1
    };
  }

  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  function historyChangeFromChange(doc, change) {
    var histChange = {from: change.from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur = lst(hist.done);

    if (cur &&
        (hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*"))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;
    } else {
      // Can not be merged, start a new event.
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation,
             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,
             anchorAfter: selAfter.anchor, headAfter: selAfter.head};
      hist.done.push(cur);
      hist.generation = ++hist.maxGeneration;
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }

  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,
                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT OPERATORS

  function stopMethod() {e_stop(this);}
  // Ensure an event has a stop method.
  function addStop(event) {
    if (!event.stop) event.stop = stopMethod;
    return event;
  }

  function e_preventDefault(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  }

  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }

  function signalDOMEvent(cm, e) {
    signal(cm, e.type, cm, e);
    return e_defaultPrevented(e);
  }

  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  function Delayed() {this.id = null;}
  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
      if (string.charAt(i) == "\t") n += tabSize - (n % tabSize);
      else ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  function selectInput(node) {
    if (ios) { // Mobile Safari apparently has a bug where select() is broken.
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else {
      // Suppress mysterious IE10 errors
      try { node.select(); }
      catch(_e) {}
    }
  }

  function indexOf(collection, elt) {
    if (collection.indexOf) return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt) return i;
    return -1;
  }

  function createObj(base, props) {
    function Obj() {}
    Obj.prototype = base;
    var inst = new Obj();
    if (props) copyObj(props, inst);
    return inst;
  }

  function copyObj(obj, target) {
    if (!target) target = {};
    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
    return target;
  }

  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i) a.push(undefined);
    return a;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") setTextContent(e, content);
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = "";
      e.appendChild(document.createTextNode(str));
    } else e.textContent = str;
  }

  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function(f) { getRect = f; };

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie_lt9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  // For a reason I have yet to figure out, some browsers disallow
  // word wrapping between certain characters *only* if a new inline
  // element is started between them. This makes it hard to reliably
  // measure the position of things, since that requires inserting an
  // extra span. This terribly fragile set of tests matches the
  // character combinations that suffer from this phenomenon on the
  // various browsers.
  function spanAffectsWrapping() { return false; }
  if (gecko) // Only for "$'"
    spanAffectsWrapping = function(str, i) {
      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;
    };
  else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
    spanAffectsWrapping = function(str, i) {
      return /\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1));
    };
  else if (webkit)
    spanAffectsWrapping = function(str, i) {
      if (i > 1 && str.charCodeAt(i - 1) == 45 && /\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i)))
        return true;
      return /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));
    };

  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null) return knownScrollbarWidth;
    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported) return elt("span", "\u200b");
    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};
  CodeMirror.splitLines = splitLines;

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == 'function';
  })();

  // KEY NAMING

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 91: "Mod", 92: "Mod", 93: "Mod", 109: "-", 107: "=", 127: "Delete",
                  186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63276: "PageUp", 63277: "PageDown", 63275: "End", 63273: "Home",
                  63234: "Left", 63232: "Up", 63235: "Right", 63233: "Down", 63302: "Insert", 63272: "Delete"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from)
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
    }
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) { bidiOther = null; return i; }
      if (cur.from == pos || cur.to == pos) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          bidiOther = found;
          return i;
        } else {
          bidiOther = i;
          return found;
        }
      }
    }
    bidiOther = null;
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
    return pos;
  }

  // This is somewhat involved. It is needed in order to move
  // 'visually' through bi-directional text -- i.e., pressing left
  // should make the cursor go left, even when in RTL text. The
  // tricky part is the 'jumps', where RTL and LTR text touch each
  // other. This often requires the cursor offset to move more than
  // one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";
    function charType(code) {
      if (code <= 0xff) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);
      else if (0x700 <= code && code <= 0x8ac) return "r";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len - 1 && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len - 1 ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push({from: start, to: i, level: 0});
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, {from: nstart, to: j, level: 2});
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift({from: 0, to: m[0].length, level: 0});
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push({from: len - m[0].length, to: len, level: 0});
      }
      if (order[0].level != lst(order).level)
        order.push({from: len, to: len, level: order[0].level});

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "3.14.0";

  return CodeMirror;
})();

(function() {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
    (document.documentMode == null || document.documentMode < 8);

  var Pos = CodeMirror.Pos;

  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};
  function findMatchingBracket(cm, where, strict) {
    var state = cm.state.matchBrackets;
    var maxScanLen = (state && state.maxScanLineLength) || 10000;

    var cur = where || cm.getCursor(), line = cm.getLineHandle(cur.line), pos = cur.ch - 1;
    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];
    if (!match) return null;
    var forward = match.charAt(1) == ">", d = forward ? 1 : -1;
    if (strict && forward != (pos == cur.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(cur.line, pos + 1));

    var stack = [line.text.charAt(pos)], re = /[(){}[\]]/;
    function scan(line, lineNo, start) {
      if (!line.text) return;
      var pos = forward ? 0 : line.text.length - 1, end = forward ? line.text.length : -1;
      if (line.text.length > maxScanLen) return null;
      if (start != null) pos = start + d;
      for (; pos != end; pos += d) {
        var ch = line.text.charAt(pos);
        if (re.test(ch) && cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style) {
          var match = matching[ch];
          if (match.charAt(1) == ">" == forward) stack.push(ch);
          else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};
          else if (!stack.length) return {pos: pos, match: true};
        }
      }
    }
    for (var i = cur.line, found, e = forward ? Math.min(i + 100, cm.lineCount()) : Math.max(-1, i - 100); i != e; i+=d) {
      if (i == cur.line) found = scan(line, i, pos);
      else found = scan(cm.getLineHandle(i), i);
      if (found) break;
    }
    return {from: Pos(cur.line, pos), to: found && Pos(i, found.pos),
            match: found && found.match, forward: forward};
  }

  function matchBrackets(cm, autoclear) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var found = findMatchingBracket(cm);
    if (!found || cm.getLine(found.from.line).length > maxHighlightLen ||
       found.to && cm.getLine(found.to.line).length > maxHighlightLen)
      return;

    var style = found.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
    var one = cm.markText(found.from, Pos(found.from.line, found.from.ch + 1), {className: style});
    var two = found.to && cm.markText(found.to, Pos(found.to.line, found.to.ch + 1), {className: style});
    // Kludge to work around the IE bug from issue #1193, where text
    // input stops going to the textare whever this fires.
    if (ie_lt8 && cm.state.focused) cm.display.input.focus();
    var clear = function() {
      cm.operation(function() { one.clear(); two && two.clear(); });
    };
    if (autoclear) setTimeout(clear, 800);
    else return clear;
  }

  var currentlyHighlighted = null;
  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
      if (!cm.somethingSelected()) currentlyHighlighted = matchBrackets(cm, false);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init)
      cm.off("cursorActivity", doMatchBrackets);
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
    }
  });

  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
  CodeMirror.defineExtension("findMatchingBracket", function(pos, strict){
    return findMatchingBracket(this, pos, strict);
  });
})();

(function() {
  var modes = ["clike", "css", "javascript"];
  for (var i = 0; i < modes.length; ++i)
    CodeMirror.extendMode(modes[i], {blockCommentStart: "/*",
                                     blockCommentEnd: "*/",
                                     blockCommentContinue: " * "});

  function continueComment(cm) {
    var pos = cm.getCursor(), token = cm.getTokenAt(pos);
    var mode = CodeMirror.innerMode(cm.getMode(), token.state).mode;
    var space;

    if (token.type == "comment" && mode.blockCommentStart) {
      var end = token.string.indexOf(mode.blockCommentEnd);
      var full = cm.getRange(CodeMirror.Pos(pos.line, 0), CodeMirror.Pos(pos.line, token.end)), found;
      if (end != -1 && end == token.string.length - mode.blockCommentEnd.length) {
        // Comment ended, don't continue it
      } else if (token.string.indexOf(mode.blockCommentStart) == 0) {
        space = full.slice(0, token.start);
        if (!/^\s*$/.test(space)) {
          space = "";
          for (var i = 0; i < token.start; ++i) space += " ";
        }
      } else if ((found = full.indexOf(mode.blockCommentContinue)) != -1 &&
                 found + mode.blockCommentContinue.length > token.start &&
                 /^\s*$/.test(full.slice(0, found))) {
        space = full.slice(0, found);
      }
    }

    if (space != null)
      cm.replaceSelection("\n" + space + mode.blockCommentContinue, "end");
    else
      return CodeMirror.Pass;
  }

  CodeMirror.defineOption("continueComments", null, function(cm, val, prev) {
    if (prev && prev != CodeMirror.Init)
      cm.removeKeyMap("continueComment");
    var map = {name: "continueComment"};
    map[typeof val == "string" ? val : "Enter"] = continueComment;
    cm.addKeyMap(map);
  });
})();

// TODO actually recognize syntax of TypeScript constructs

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonMode = parserConfig.json;
  var isTS = parserConfig.typescript;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this")
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "class": kw("class"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        "super": kw("super"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end && !escaped)
        return false;
      escaped = !escaped && next == "\\";
    }
    return escaped;
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function jsTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'")
      return chain(stream, state, jsTokenString(ch));
    else if (/[\[\]{}\(\),;\:\.]/.test(ch))
      return ret(ch);
    else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    }
    else if (/\d/.test(ch) || ch == "-" && stream.eat(/\d/)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    }
    else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, jsTokenComment);
      }
      else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      }
      else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               /^[\[{}\(,;:]$/.test(state.lastType)) {
        nextUntilUnescaped(stream, "/");
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      }
      else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", null, stream.current());
      }
    }
    else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    }
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", null, stream.current());
    }
    else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function jsTokenString(quote) {
    return function(stream, state) {
      if (!nextUntilUnescaped(stream, quote))
        state.tokenize = jsTokenBase;
      return ret("string", "string");
    };
  }

  function jsTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = jsTokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    return function(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(arguments.callee);
    };
  }

  function statement(type) {
    if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse(cx.state.indented));
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                                      poplex, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                         block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                        statement, poplex, popcontext);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), commasep(expressionNoComma, "]"), poplex, maybeop);
    if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeop);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, maybeoperatorComma);
  }
  function maybeoperatorNoComma(type, value, me) {
    if (!me) me = maybeoperatorNoComma;
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expression);
      return cont(expression);
    }
    if (type == ";") return;
    if (type == "(") return cont(pushlex(")", "call"), commasep(expressionNoComma, ")"), poplex, me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), expression, expect("]"), poplex, me);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
    } else if (type == "number" || type == "string") {
      cx.marked = type + " property";
    }
    if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expressionNoComma);
  }
  function getterSetter(type) {
    if (type == ":") return cont(expression);
    if (type != "variable") return cont(expect(":"), expression);
    cx.marked = "property";
    return cont(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      else return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (type == ":") return cont(typedef);
    return pass();
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
    return pass();
  }
  function vardef1(type, value) {
    if (type == "variable") {
      register(value);
      return isTS ? cont(maybetype, vardef2) : cont(vardef2);
    }
    return pass();
  }
  function vardef2(type, value) {
    if (value == "=") return cont(expressionNoComma, vardef2);
    if (type == ",") return cont(vardef1);
  }
  function maybeelse(indent) {
    return function(type, value) {
      if (type == "keyword b" && value == "else") {
        cx.state.lexical = new JSLexical(indent, 0, "form", null, cx.state.lexical);
        return cont(statement, poplex);
      }
      return pass();
    };
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef1, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybein);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybein(_type, value) {
    if (value == "in") return cont(expression);
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in") return cont(expression);
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type, value) {
    if (type == "variable") {register(value); return isTS ? cont(maybetype) : cont();}
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: jsTokenBase,
        lastType: null,
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        globalVars: parserConfig.globalVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (state.tokenize != jsTokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == jsTokenComment) return CodeMirror.Pass;
      if (state.tokenize != jsTokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? 4 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: ":{}",
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",

    jsonMode: jsonMode
  };
});

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

CodeMirror.defineMode("velocity", function() {
    function parseWords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
    }

    var keywords = parseWords("#end #else #break #stop #[[ #]] " +
                              "#{end} #{else} #{break} #{stop}");
    var functions = parseWords("#if #elseif #foreach #set #include #parse #macro #define #evaluate " +
                               "#{if} #{elseif} #{foreach} #{set} #{include} #{parse} #{macro} #{define} #{evaluate}");
    var specials = parseWords("$foreach.count $foreach.hasNext $foreach.first $foreach.last $foreach.topmost $foreach.parent $velocityCount");
    var isOperatorChar = /[+\-*&%=<>!?:\/|]/;

    function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
    }
    function tokenBase(stream, state) {
        var beforeParams = state.beforeParams;
        state.beforeParams = false;
        var ch = stream.next();
        // start of string?
        if ((ch == '"' || ch == "'") && state.inParams)
            return chain(stream, state, tokenString(ch));
        // is it one of the special signs []{}().,;? Seperator?
        else if (/[\[\]{}\(\),;\.]/.test(ch)) {
            if (ch == "(" && beforeParams) state.inParams = true;
            else if (ch == ")") state.inParams = false;
            return null;
        }
        // start of a number value?
        else if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
        }
        // multi line comment?
        else if (ch == "#" && stream.eat("*")) {
            return chain(stream, state, tokenComment);
        }
        // unparsed content?
        else if (ch == "#" && stream.match(/ *\[ *\[/)) {
            return chain(stream, state, tokenUnparsed);
        }
        // single line comment?
        else if (ch == "#" && stream.eat("#")) {
            stream.skipToEnd();
            return "comment";
        }
        // variable?
        else if (ch == "$") {
            stream.eatWhile(/[\w\d\$_\.{}]/);
            // is it one of the specials?
            if (specials && specials.propertyIsEnumerable(stream.current().toLowerCase())) {
                return "keyword";
            }
            else {
                state.beforeParams = true;
                return "builtin";
            }
        }
        // is it a operator?
        else if (isOperatorChar.test(ch)) {
            stream.eatWhile(isOperatorChar);
            return "operator";
        }
        else {
            // get the whole word
            stream.eatWhile(/[\w\$_{}]/);
            var word = stream.current().toLowerCase();
            // is it one of the listed keywords?
            if (keywords && keywords.propertyIsEnumerable(word))
                return "keyword";
            // is it one of the listed functions?
            if (functions && functions.propertyIsEnumerable(word) ||
                stream.current().match(/^#[a-z0-9_]+ *$/i) && stream.peek()=="(") {
                state.beforeParams = true;
                return "keyword";
            }
            // default: just a "word"
            return null;
        }
    }

    function tokenString(quote) {
        return function(stream, state) {
            var escaped = false, next, end = false;
            while ((next = stream.next()) != null) {
                if (next == quote && !escaped) {
                    end = true;
                    break;
                }
                escaped = !escaped && next == "\\";
            }
            if (end) state.tokenize = tokenBase;
            return "string";
        };
    }

    function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
            if (ch == "#" && maybeEnd) {
                state.tokenize = tokenBase;
                break;
            }
            maybeEnd = (ch == "*");
        }
        return "comment";
    }

    function tokenUnparsed(stream, state) {
        var maybeEnd = 0, ch;
        while (ch = stream.next()) {
            if (ch == "#" && maybeEnd == 2) {
                state.tokenize = tokenBase;
                break;
            }
            if (ch == "]")
                maybeEnd++;
            else if (ch != " ")
                maybeEnd = 0;
        }
        return "meta";
    }
    // Interface

    return {
        startState: function() {
            return {
                tokenize: tokenBase,
                beforeParams: false,
                inParams: false
            };
        },

        token: function(stream, state) {
            if (stream.eatSpace()) return null;
            return state.tokenize(stream, state);
        }
    };
});

CodeMirror.defineMIME("text/velocity", "velocity");

CodeMirror.defineMode("xml", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;

  var Kludges = parserConfig.htmlMode ? {
    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                      'track': true, 'wbr': true},
    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                       'th': true, 'tr': true},
    contextGrabbers: {
      'dd': {'dd': true, 'dt': true},
      'dt': {'dd': true, 'dt': true},
      'li': {'li': true},
      'option': {'option': true, 'optgroup': true},
      'optgroup': {'optgroup': true},
      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
      'rp': {'rp': true, 'rt': true},
      'rt': {'rp': true, 'rt': true},
      'tbody': {'tbody': true, 'tfoot': true},
      'td': {'td': true, 'th': true},
      'tfoot': {'tbody': true},
      'th': {'td': true, 'th': true},
      'thead': {'tbody': true, 'tfoot': true},
      'tr': {'tr': true}
    },
    doNotIndent: {"pre": true},
    allowUnquoted: true,
    allowMissing: true
  } : {
    autoSelfClosers: {},
    implicitlyClosed: {},
    contextGrabbers: {},
    doNotIndent: {},
    allowUnquoted: false,
    allowMissing: false
  };
  var alignCDATA = parserConfig.alignCDATA;

  // Return variables for tokenizers
  var tagName, type;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        var isClose = stream.eat("/");
        tagName = "";
        var c;
        while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;
        if (!tagName) return "error";
        type = isClose ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      return "error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      return state.tokenize(stream, state);
    } else {
      stream.eatWhile(/[^\s\u00a0=<>\"\']/);
      return "word";
    }
  }

  function inAttribute(quote) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  var curState, curStream, setStyle;
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }

  function pushContext(tagName, startOfLine) {
    var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || (curState.context && curState.context.noIndent);
    curState.context = {
      prev: curState.context,
      tagName: tagName,
      indent: curState.indented,
      startOfLine: startOfLine,
      noIndent: noIndent
    };
  }
  function popContext() {
    if (curState.context) curState.context = curState.context.prev;
  }

  function element(type) {
    if (type == "openTag") {
      curState.tagName = tagName;
      curState.tagStart = curStream.column();
      return cont(attributes, endtag(curState.startOfLine));
    } else if (type == "closeTag") {
      var err = false;
      if (curState.context) {
        if (curState.context.tagName != tagName) {
          if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
            popContext();
          }
          err = !curState.context || curState.context.tagName != tagName;
        }
      } else {
        err = true;
      }
      if (err) setStyle = "error";
      return cont(endclosetag(err));
    }
    return cont();
  }
  function endtag(startOfLine) {
    return function(type) {
      var tagName = curState.tagName;
      curState.tagName = curState.tagStart = null;
      if (type == "selfcloseTag" ||
          (type == "endTag" && Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase()))) {
        maybePopContext(tagName.toLowerCase());
        return cont();
      }
      if (type == "endTag") {
        maybePopContext(tagName.toLowerCase());
        pushContext(tagName, startOfLine);
        return cont();
      }
      return cont();
    };
  }
  function endclosetag(err) {
    return function(type) {
      if (err) setStyle = "error";
      if (type == "endTag") { popContext(); return cont(); }
      setStyle = "error";
      return cont(arguments.callee);
    };
  }
  function maybePopContext(nextTagName) {
    var parentTagName;
    while (true) {
      if (!curState.context) {
        return;
      }
      parentTagName = curState.context.tagName.toLowerCase();
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||
          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext();
    }
  }

  function attributes(type) {
    if (type == "word") {setStyle = "attribute"; return cont(attribute, attributes);}
    if (type == "endTag" || type == "selfcloseTag") return pass();
    setStyle = "error";
    return cont(attributes);
  }
  function attribute(type) {
    if (type == "equals") return cont(attvalue, attributes);
    if (!Kludges.allowMissing) setStyle = "error";
    else if (type == "word") setStyle = "attribute";
    return (type == "endTag" || type == "selfcloseTag") ? pass() : cont();
  }
  function attvalue(type) {
    if (type == "string") return cont(attvaluemaybe);
    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return cont();}
    setStyle = "error";
    return (type == "endTag" || type == "selfCloseTag") ? pass() : cont();
  }
  function attvaluemaybe(type) {
    if (type == "string") return cont(attvaluemaybe);
    else return pass();
  }

  return {
    startState: function() {
      return {tokenize: inText, cc: [], indented: 0, startOfLine: true, tagName: null, tagStart: null, context: null};
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol()) {
        state.startOfLine = true;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace()) return null;

      setStyle = type = tagName = null;
      var style = state.tokenize(stream, state);
      state.type = type;
      if ((style || type) && style != "comment") {
        curState = state; curStream = stream;
        while (true) {
          var comb = state.cc.pop() || element;
          if (comb(type || style)) break;
        }
      }
      state.startOfLine = false;
      return setStyle || style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      if ((state.tokenize != inTag && state.tokenize != inText) ||
          context && context.noIndent)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      if (state.tagName) return state.tagStart + indentUnit * multilineTagIndentFactor;
      if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      if (context && /^<\//.test(textAfter))
        context = context.prev;
      while (context && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return 0;
    },

    electricChars: "/",
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: parserConfig.htmlMode ? "html" : "xml"
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

CodeMirror.defineMode("css", function(config) {
  return CodeMirror.getMode(config, "text/css");
});

CodeMirror.defineMode("css-base", function(config, parserConfig) {
  "use strict";

  var indentUnit = config.indentUnit,
      hooks = parserConfig.hooks || {},
      atMediaTypes = parserConfig.atMediaTypes || {},
      atMediaFeatures = parserConfig.atMediaFeatures || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = !!parserConfig.allowNested,
      type = null;

  function ret(style, tp) { type = tp; return style; }

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      // result[0] is style and result[1] is type
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {stream.eatWhile(/[\w\\\-]/); return ret("def", stream.current());}
    else if (ch == "=") ret(null, "compare");
    else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    }
    else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    }
    else if (/\d/.test(ch)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    }
    else if (ch === "-") {
      if (/\d/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^[^-]+-/)) {
        return ret("meta", "meta");
      }
    }
    else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    }
    else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    }
    else if (ch == ":") {
      return ret("operator", ch);
    }
    else if (/[;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    }
    else if (ch == "u" && stream.match("rl(")) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "variable");
    }
    else {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "variable");
    }
  }

  function tokenString(quote, nonInclusive) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped)
          break;
        escaped = !escaped && ch == "\\";
      }
      if (!escaped) {
        if (nonInclusive) stream.backUp(1);
        state.tokenize = tokenBase;
      }
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\']/, false))
      state.tokenize = tokenString(")", true);
    else
      state.tokenize = tokenBase;
    return ret(null, "(");
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              stack: []};
    },

    token: function(stream, state) {

      // Use these terms when applicable (see http://www.xanthir.com/blog/b4E50)
      //
      // rule** or **ruleset:
      // A selector + braces combo, or an at-rule.
      //
      // declaration block:
      // A sequence of declarations.
      //
      // declaration:
      // A property + colon + value combo.
      //
      // property value:
      // The entire value of a property.
      //
      // component value:
      // A single piece of a property value. Like the 5px in
      // text-shadow: 0 0 5px blue;. Can also refer to things that are
      // multiple terms, like the 1-4 terms that make up the background-size
      // portion of the background shorthand.
      //
      // term:
      // The basic unit of author-facing CSS, like a single number (5),
      // dimension (5px), string ("foo"), or function. Officially defined
      //  by the CSS 2.1 grammar (look for the 'term' production)
      //
      //
      // simple selector:
      // A single atomic selector, like a type selector, an attr selector, a
      // class selector, etc.
      //
      // compound selector:
      // One or more simple selectors without a combinator. div.example is
      // compound, div > .example is not.
      //
      // complex selector:
      // One or more compound selectors chained with combinators.
      //
      // combinator:
      // The parts of selectors that express relationships. There are four
      // currently - the space (descendant combinator), the greater-than
      // bracket (child combinator), the plus sign (next sibling combinator),
      // and the tilda (following sibling combinator).
      //
      // sequence of selectors:
      // One or more of the named type of selector chained with commas.

      state.tokenize = state.tokenize || tokenBase;
      if (state.tokenize == tokenBase && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (style && typeof style != "string") style = ret(style[0], style[1]);

      // Changing style returned based on context
      var context = state.stack[state.stack.length-1];
      if (style == "variable") {
        if (type == "variable-definition") state.stack.push("propertyValue");
        return "variable-2";
      } else if (style == "property") {
        var word = stream.current().toLowerCase();
        if (context == "propertyValue") {
          if (valueKeywords.hasOwnProperty(word)) {
            style = "string-2";
          } else if (colorKeywords.hasOwnProperty(word)) {
            style = "keyword";
          } else {
            style = "variable-2";
          }
        } else if (context == "rule") {
          if (!propertyKeywords.hasOwnProperty(word)) {
            style += " error";
          }
        } else if (context == "block") {
          // if a value is present in both property, value, or color, the order
          // of preference is property -> color -> value
          if (propertyKeywords.hasOwnProperty(word)) {
            style = "property";
          } else if (colorKeywords.hasOwnProperty(word)) {
            style = "keyword";
          } else if (valueKeywords.hasOwnProperty(word)) {
            style = "string-2";
          } else {
            style = "tag";
          }
        } else if (!context || context == "@media{") {
          style = "tag";
        } else if (context == "@media") {
          if (atMediaTypes[stream.current()]) {
            style = "attribute"; // Known attribute
          } else if (/^(only|not)$/.test(word)) {
            style = "keyword";
          } else if (word == "and") {
            style = "error"; // "and" is only allowed in @mediaType
          } else if (atMediaFeatures.hasOwnProperty(word)) {
            style = "error"; // Known property, should be in @mediaType(
          } else {
            // Unknown, expecting keyword or attribute, assuming attribute
            style = "attribute error";
          }
        } else if (context == "@mediaType") {
          if (atMediaTypes.hasOwnProperty(word)) {
            style = "attribute";
          } else if (word == "and") {
            style = "operator";
          } else if (/^(only|not)$/.test(word)) {
            style = "error"; // Only allowed in @media
          } else {
            // Unknown attribute or property, but expecting property (preceded
            // by "and"). Should be in parentheses
            style = "error";
          }
        } else if (context == "@mediaType(") {
          if (propertyKeywords.hasOwnProperty(word)) {
            // do nothing, remains "property"
          } else if (atMediaTypes.hasOwnProperty(word)) {
            style = "error"; // Known property, should be in parentheses
          } else if (word == "and") {
            style = "operator";
          } else if (/^(only|not)$/.test(word)) {
            style = "error"; // Only allowed in @media
          } else {
            style += " error";
          }
        } else if (context == "@import") {
          style = "tag";
        } else {
          style = "error";
        }
      } else if (style == "atom") {
        if(!context || context == "@media{" || context == "block") {
          style = "builtin";
        } else if (context == "propertyValue") {
          if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
            style += " error";
          }
        } else {
          style = "error";
        }
      } else if (context == "@media" && type == "{") {
        style = "error";
      }

      // Push/pop context stack
      if (type == "{") {
        if (context == "@media" || context == "@mediaType") {
          state.stack.pop();
          state.stack[state.stack.length-1] = "@media{";
        }
        else {
          var newContext = allowNested ? "block" : "rule";
          state.stack.push(newContext);
        }
      }
      else if (type == "}") {
        var lastState = state.stack[state.stack.length - 1];
        if (lastState == "interpolation") style = "operator";
        state.stack.pop();
        if (context == "propertyValue") state.stack.pop();
      }
      else if (type == "interpolation") state.stack.push("interpolation");
      else if (type == "@media") state.stack.push("@media");
      else if (type == "@import") state.stack.push("@import");
      else if (context == "@media" && /\b(keyword|attribute)\b/.test(style))
        state.stack.push("@mediaType");
      else if (context == "@mediaType" && stream.current() == ",") state.stack.pop();
      else if (context == "@mediaType" && type == "(") state.stack.push("@mediaType(");
      else if (context == "@mediaType(" && type == ")") state.stack.pop();
      else if ((context == "rule" || context == "block") && type == ":") state.stack.push("propertyValue");
      else if (context == "propertyValue" && type == ";") state.stack.pop();
      else if (context == "@import" && type == ";") state.stack.pop();
      return style;
    },

    indent: function(state, textAfter) {
      var n = state.stack.length;
      if (/^\}/.test(textAfter))
        n -= state.stack[state.stack.length-1] == "propertyValue" ? 2 : 1;
      return state.baseIndent + n * indentUnit;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/"
  };
});

(function() {
  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var atMediaTypes = keySet([
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ]);

  var atMediaFeatures = keySet([
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid"
  ]);

  var propertyKeywords = keySet([
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-iteration-count",
    "animation-name", "animation-play-state", "animation-timing-function",
    "appearance", "azimuth", "backface-visibility", "background",
    "background-attachment", "background-clip", "background-color",
    "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "font", "font-feature-settings", "font-family",
    "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid-cell", "grid-column", "grid-column-align",
    "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",
    "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",
    "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marker-offset", "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "rendering-intent",
    "resize", "rest", "rest-after", "rest-before", "richness", "right",
    "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-shadow",
    "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters", "color-profile",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"
  ]);

  var colorKeywords = keySet([
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",
    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ]);

  var valueKeywords = keySet([
    "above", "absolute", "activeborder", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "background",
    "backwards", "baseline", "below", "bidi-override", "binary", "bengali",
    "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break-all", "break-word", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "compact", "condensed", "contain", "content",
    "content-box", "context-menu", "continuous", "copy", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari",
    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",
    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",
    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "justify", "kannada", "katakana", "katakana-iroha", "khmer",
    "landscape", "lao", "large", "larger", "left", "level", "lighter",
    "line-through", "linear", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "malayalam", "match",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "overlay", "overline", "padding", "padding-box", "painted",
    "paused", "persian", "plus-darker", "plus-lighter", "pointer", "portrait",
    "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",
    "radio", "read-only", "read-write", "read-write-plaintext-only", "relative",
    "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",
    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "single", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke",
    "sub", "subpixel-antialiased", "super", "sw-resize", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ]);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    atMediaTypes: atMediaTypes,
    atMediaFeatures: atMediaFeatures,
    propertyKeywords: propertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    hooks: {
      "<": function(stream, state) {
        function tokenSGMLComment(stream, state) {
          var dashes = 0, ch;
          while ((ch = stream.next()) != null) {
            if (dashes >= 2 && ch == ">") {
              state.tokenize = null;
              break;
            }
            dashes = (ch == "-") ? dashes + 1 : 0;
          }
          return ["comment", "comment"];
        }
        if (stream.eat("!")) {
          state.tokenize = tokenSGMLComment;
          return tokenSGMLComment(stream, state);
        }
      },
      "/": function(stream, state) {
        if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        }
        return false;
      }
    },
    name: "css-base"
  });

  CodeMirror.defineMIME("text/x-scss", {
    atMediaTypes: atMediaTypes,
    atMediaFeatures: atMediaFeatures,
    propertyKeywords: propertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    allowNested: true,
    hooks: {
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.peek() == ":") {
          return ["variable", "variable-definition"];
        }
        return ["variable", "variable"];
      },
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "#": function(stream) {
        if (stream.eat("{")) {
          return ["operator", "interpolation"];
        } else {
          stream.eatWhile(/[\w\\\-]/);
          return ["atom", "hash"];
        }
      }
    },
    name: "css-base"
  });
})();

CodeMirror.defineMode("htmlmixed", function(config, parserConfig) {
  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});
  var cssMode = CodeMirror.getMode(config, "css");

  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;
  scriptTypes.push({matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i,
                    mode: CodeMirror.getMode(config, "javascript")});
  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {
    var conf = scriptTypesConf[i];
    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});
  }
  scriptTypes.push({matches: /./,
                    mode: CodeMirror.getMode(config, "text/plain")});

  function html(stream, state) {
    var tagName = state.htmlState.tagName;
    var style = htmlMode.token(stream, state.htmlState);
    if (tagName == "script" && /\btag\b/.test(style) && stream.current() == ">") {
      // Script block: mode to change to depends on type attribute
      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i);
      scriptType = scriptType ? scriptType[1] : "";
      if (scriptType && /[\"\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);
      for (var i = 0; i < scriptTypes.length; ++i) {
        var tp = scriptTypes[i];
        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {
          if (tp.mode) {
            state.token = script;
            state.localMode = tp.mode;
            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));
          }
          break;
        }
      }
    } else if (tagName == "style" && /\btag\b/.test(style) && stream.current() == ">") {
      state.token = css;
      state.localMode = cssMode;
      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));
    }
    return style;
  }
  function maybeBackup(stream, pat, style) {
    var cur = stream.current();
    var close = cur.search(pat), m;
    if (close > -1) stream.backUp(cur.length - close);
    else if (m = cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur[0]);
    }
    return style;
  }
  function script(stream, state) {
    if (stream.match(/^<\/\s*script\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*script\s*>/,
                       state.localMode.token(stream, state.localState));
  }
  function css(stream, state) {
    if (stream.match(/^<\/\s*style\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*style\s*>/,
                       cssMode.token(stream, state.localState));
  }

  return {
    startState: function() {
      var state = htmlMode.startState();
      return {token: html, localMode: null, localState: null, htmlState: state};
    },

    copyState: function(state) {
      if (state.localState)
        var local = CodeMirror.copyState(state.localMode, state.localState);
      return {token: state.token, localMode: state.localMode, localState: local,
              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
    },

    token: function(stream, state) {
      return state.token(stream, state);
    },

    indent: function(state, textAfter) {
      if (!state.localMode || /^\s*<\//.test(textAfter))
        return htmlMode.indent(state.htmlState, textAfter);
      else if (state.localMode.indent)
        return state.localMode.indent(state.localState, textAfter);
      else
        return CodeMirror.Pass;
    },

    electricChars: "/{}:",

    innerMode: function(state) {
      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
    }
  };
}, "xml", "javascript", "css");

CodeMirror.defineMIME("text/html", "htmlmixed");

CodeMirror.defineMode("sql", function(config, parserConfig) {
  "use strict";

  var client         = parserConfig.client || {},
      atoms          = parserConfig.atoms || {"false": true, "true": true, "null": true},
      builtin        = parserConfig.builtin || {},
      keywords       = parserConfig.keywords || {},
      operatorChars  = parserConfig.operatorChars || /^[*+\-%<>!=&|~^]/,
      support        = parserConfig.support || {},
      hooks          = parserConfig.hooks || {},
      dateSQL        = parserConfig.dateSQL || {"date" : true, "time" : true, "timestamp" : true};

  function tokenBase(stream, state) {
    var ch = stream.next();

    // call hooks from the mime type
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }

    if (support.hexNumber == true &&
      ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/))
      || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {
      // hex
      // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html
      return "number";
    } else if (support.binaryNumber == true &&
      (((ch == "b" || ch == "B") && stream.match(/^'[01]+'/))
      || (ch == "0" && stream.match(/^b[01]+/)))) {
      // bitstring
      // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html
      return "number";
    } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {
      // numbers
      // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html
          stream.match(/^[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/);
      support.decimallessFloat == true && stream.eat('.');
      return "number";
    } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {
      // placeholders
      return "variable-3";
    } else if (ch == "'" || (ch == '"' && support.doubleQuote)) {
      // strings
      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
      state.tokenize = tokenLiteral(ch);
      return state.tokenize(stream, state);
    } else if ((((support.nCharCast == true && (ch == "n" || ch == "N"))
        || (support.charsetCast == true && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)))
        && (stream.peek() == "'" || stream.peek() == '"'))) {
      // charset casting: _utf8'str', N'str', n'str'
      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
      return "keyword";
    } else if (/^[\(\),\;\[\]]/.test(ch)) {
      // no highlightning
      return null;
    } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {
      // 1-line comment
      stream.skipToEnd();
      return "comment";
    } else if ((support.commentHash && ch == "#")
        || (ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" ")))) {
      // 1-line comments
      // ref: https://kb.askmonty.org/en/comment-syntax/
      stream.skipToEnd();
      return "comment";
    } else if (ch == "/" && stream.eat("*")) {
      // multi-line comments
      // ref: https://kb.askmonty.org/en/comment-syntax/
      state.tokenize = tokenComment;
      return state.tokenize(stream, state);
    } else if (ch == ".") {
      // .1 for 0.1
      if (support.zerolessFloat == true && stream.match(/^(?:\d+(?:e[+-]?\d+)?)/i)) {
        return "number";
      }
      // .table_name (ODBC)
      // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
      if (support.ODBCdotTable == true && stream.match(/^[a-zA-Z_]+/)) {
        return "variable-2";
      }
    } else if (operatorChars.test(ch)) {
      // operators
      stream.eatWhile(operatorChars);
      return null;
    } else if (ch == '{' &&
        (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {
      // dates (weird ODBC syntax)
      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
      return "number";
    } else {
      stream.eatWhile(/^[_\w\d]/);
      var word = stream.current().toLowerCase();
      // dates (standard SQL syntax)
      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
      if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))
        return "number";
      if (atoms.hasOwnProperty(word)) return "atom";
      if (builtin.hasOwnProperty(word)) return "builtin";
      if (keywords.hasOwnProperty(word)) return "keyword";
      if (client.hasOwnProperty(word)) return "string-2";
      return null;
    }
  }

  // 'string', with char specified in quote escaped by '\'
  function tokenLiteral(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      return "string";
    };
  }
  function tokenComment(stream, state) {
    while (true) {
      if (stream.skipTo("*")) {
        stream.next();
        if (stream.eat("/")) {
          state.tokenize = tokenBase;
          break;
        }
      } else {
        stream.skipToEnd();
        break;
      }
    }
    return "comment";
  }

  function pushContext(stream, state, type) {
    state.context = {
      prev: state.context,
      indent: stream.indentation(),
      col: stream.column(),
      type: type
    };
  }

  function popContext(state) {
    state.indent = state.context.indent;
    state.context = state.context.prev;
  }

  return {
    startState: function() {
      return {tokenize: tokenBase, context: null};
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (state.context && state.context.align == null)
          state.context.align = false;
      }
      if (stream.eatSpace()) return null;

      var style = state.tokenize(stream, state);
      if (style == "comment") return style;

      if (state.context && state.context.align == null)
        state.context.align = true;

      var tok = stream.current();
      if (tok == "(")
        pushContext(stream, state, ")");
      else if (tok == "[")
        pushContext(stream, state, "]");
      else if (state.context && state.context.type == tok)
        popContext(state);
      return style;
    },

    indent: function(state, textAfter) {
      var cx = state.context;
      if (!cx) return CodeMirror.Pass;
      if (cx.align) return cx.col + (textAfter.charAt(0) == cx.type ? 0 : 1);
      else return cx.indent + config.indentUnit;
    }
  };
});

(function() {
  "use strict";

  // `identifier`
  function hookIdentifier(stream) {
    // MySQL/MariaDB identifiers
    // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
    var ch;
    while ((ch = stream.next()) != null) {
      if (ch == "`" && !stream.eat("`")) return "variable-2";
    }
    return null;
  }

  // variable token
  function hookVar(stream) {
    // variables
    // @@prefix.varName @varName
    // varName can be quoted with ` or ' or "
    // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html
    if (stream.eat("@")) {
      stream.match(/^session\./);
      stream.match(/^local\./);
      stream.match(/^global\./);
    }

    if (stream.eat("'")) {
      stream.match(/^.*'/);
      return "variable-2";
    } else if (stream.eat('"')) {
      stream.match(/^.*"/);
      return "variable-2";
    } else if (stream.eat("`")) {
      stream.match(/^.*`/);
      return "variable-2";
    } else if (stream.match(/^[0-9a-zA-Z$\.\_]+/)) {
      return "variable-2";
    }
    return null;
  };

  // short client keyword token
  function hookClient(stream) {
    // \N means NULL
    // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html
    if (stream.eat("N")) {
        return "atom";
    }
    // \g, etc
    // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html
    return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;
  }

  // these keywords are used by all SQL dialects (however, a mode can still overwrite it)
  var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from having in insert into is join like not on or order select set table union update values where ";

  // turn a space-separated list into an array
  function set(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  // A generic SQL Mode. It's not a standard, it just try to support what is generally supported
  CodeMirror.defineMIME("text/x-sql", {
    name: "sql",
    keywords: set(sqlKeywords + "begin"),
    builtin: set("bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric"),
    atoms: set("false true null unknown"),
    operatorChars: /^[*+\-%<>!=]/,
    dateSQL: set("date time timestamp"),
    support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
  });

  CodeMirror.defineMIME("text/x-mysql", {
    name: "sql",
    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
    keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general global grant grants group groupby_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
    builtin: set("bool boolean bit blob decimal double enum float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
    atoms: set("false true null unknown"),
    operatorChars: /^[*+\-%<>!=&|^]/,
    dateSQL: set("date time timestamp"),
    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
    hooks: {
      "@":   hookVar,
      "`":   hookIdentifier,
      "\\":  hookClient
    }
  });

  CodeMirror.defineMIME("text/x-mariadb", {
    name: "sql",
    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
    keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
    builtin: set("bool boolean bit blob decimal double enum float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
    atoms: set("false true null unknown"),
    operatorChars: /^[*+\-%<>!=&|^]/,
    dateSQL: set("date time timestamp"),
    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
    hooks: {
      "@":   hookVar,
      "`":   hookIdentifier,
      "\\":  hookClient
    }
  });

  // the query language used by Apache Cassandra is called CQL, but this mime type
  // is called Cassandra to avoid confusion with Contextual Query Language
  CodeMirror.defineMIME("text/x-cassandra", {
    name: "sql",
    client: { },
    keywords: set("use select from using consistency where limit first reversed first and in insert into values using consistency ttl update set delete truncate begin batch apply create keyspace with columnfamily primary key index on drop alter type add any one quorum all local_quorum each_quorum"),
    builtin: set("ascii bigint blob boolean counter decimal double float int text timestamp uuid varchar varint"),
    atoms: set("false true"),
    operatorChars: /^[<>=]/,
    dateSQL: { },
    support: set("commentSlashSlash decimallessFloat"),
    hooks: { }
  });

  // this is based on Peter Raganitsch's 'plsql' mode
  CodeMirror.defineMIME("text/x-plsql", {
    name:       "sql",
    client:     set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),
    keywords:   set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),
    functions:  set("abs acos add_months ascii asin atan atan2 average bfilename ceil chartorowid chr concat convert cos cosh count decode deref dual dump dup_val_on_index empty error exp false floor found glb greatest hextoraw initcap instr instrb isopen last_day least lenght lenghtb ln lower lpad ltrim lub make_ref max min mod months_between new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null nvl others power rawtohex reftohex round rowcount rowidtochar rpad rtrim sign sin sinh soundex sqlcode sqlerrm sqrt stddev substr substrb sum sysdate tan tanh to_char to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid upper user userenv variance vsize"),
    builtin:    set("bfile blob character clob dec float int integer mlslabel natural naturaln nchar nclob number numeric nvarchar2 real rowtype signtype smallint string varchar varchar2"),
    operatorChars: /^[*+\-%<>!=~]/,
    dateSQL:    set("date time timestamp"),
    support:    set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")
  });
}());

/*
  How Properties of Mime Types are used by SQL Mode
  =================================================

  keywords:
    A list of keywords you want to be highlighted.
  functions:
    A list of function names you want to be highlighted.
  builtin:
    A list of builtin types you want to be highlighted (if you want types to be of class "builtin" instead of "keyword").
  operatorChars:
    All characters that must be handled as operators.
  client:
    Commands parsed and executed by the client (not the server).
  support:
    A list of supported syntaxes which are not common, but are supported by more than 1 DBMS.
    * ODBCdotTable: .tableName
    * zerolessFloat: .1
    * doubleQuote
    * nCharCast: N'string'
    * charsetCast: _utf8'string'
    * commentHash: use # char for comments
    * commentSlashSlash: use // for comments
    * commentSpaceRequired: require a space after -- for comments
  atoms:
    Keywords that must be highlighted as atoms,. Some DBMS's support more atoms than others:
    UNKNOWN, INFINITY, UNDERFLOW, NaN...
  dateSQL:
    Used for date/time SQL standard syntax, because not all DBMS's support same temporal types.
*/

/**
 * xui
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:   
 * @author:  sushuang(sushuang@baidu.com)
 */

/**
 * @namespace
 */
var xui = {};
/**
 * xui.XPorject
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    Javascript
 *          []
 *              (1) 
 *              (2) /
 * @author:  sushuang(sushuang@baidu.com)
 * @version: 1.0.1
 */

/**
 * @usage [XProject]
 *          XProject
 *          
 *
 *          
 *          window.$ns = xui.XProject.namespace;
 *          window.$link = xui.XProject.link;
 *          
 * 
 * @usage []
 *          
 *
 *          // 
 *          $ns('aaa.bbb.ccc');
 *  
 *          // 
 *          aaa.bbb.ccc.SomeClass = function () {
 *              // do something ...
 *          }
 *
 *          
 *          // 
 *          $ns('aaa.bbb.ccc').SomeClass = function () { 
 *              // do something ...
 *          }
 *
 *          
 *          // 
 *          $ns('aaa.bbb.ccc'); 
 *          (function () {
 *              // $ns()
 *              $ns().SomeClass = function () { 
 *                  // do something ...
 *              }
 *          })();
 *        
 * @usage [//link]
 *          
 *          /
 *          
 *
 *          (function () {
 *              // 
 *              // 
 *              var OTHER_CONTROL1 = aaa.bbb.SomeClass;
 *              var OTHER_SERVICE2 = tt.ee.SomeService;
 *              var OTHER_MODEL3 = qq.uu.ii.SomeModel;
 *              
 *              // 
 *              $ns('aaa.bb').MyControl = function () { 
 *                  this.otherControl = new OTHER_CONTROL();
 *                  ...
 *              }
 *              ...
 *          })();
 *          
 *          /OK
 *          C++/Java
 * 
 *          
 *          (function () {
 *              // 
 *              var OTHER_CONTROL1, OTHER_SERVICE2, OTHER_MODEL3;
 *              // 
 *              $link(function () {
 *                  OTHER_CONTROL1 = aaa.bbb.SomeClass;
 *                  OTHER_SERVICE2 = tt.ee.SomeService;
 *                  OTHER_MODEL3 = qq.uu.ii.SomeModel;
 *              });
 *              //
 *              $ns('aa.bb').MyControl = function () { 
 *                  this.otherControl = new OTHER_CONTROL();
 *                  // ...
 *              }
 *              // ...
 *          })();
 *            
 *          xui.XProject.doLink()
 */

(function () {
    
    var XPROJECT = xui.XProject = {};
    var NS_BASE = window;
    var TRIMER = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );

    /**
     * 
     *
     * @type {Array.<Function>}
     * @private
     */
    var linkSet = [];
    /**
     * 
     *
     * @type {Array.<Function>}
     * @private
     */
    var endSet = [];
    /**
     * 
     *
     * @type {Object}
     * @private
     */
    var lastNameSpace;
    
    /**
     * (1) namespace("aaa.bbb.ccc")
     * (2) NS_BASE.aaa.bbb.ccc
     * (3) namespace()
     *      namespaceisRecordfalse
     * 
     * NS_BASEwindow (@see setNamespaceBase) 
     *
     * @public
     * @param {string=} namespacePath 
     *              ".""aaa.bbb.ccc"
     *              
     * @param {boolean} isRecord true
     * @return {Object} 
     */
    XPROJECT.namespace = function (namespacePath, isRecord) {
        if (arguments.length == 0) {
            return lastNameSpace;
        }
        
        var context = NS_BASE;
        var pathArr = parseInput(namespacePath).split('.');
        for (var i = 0 ;i < pathArr.length; i ++) {
            context = getOrCreateObj(context, parseInput(pathArr[i]));
        }
        
        if (isRecord !== false) {
            lastNameSpace = context
        }
        
        return context;
    };
    
    /**
     * 
     *
     * @public
     * @param {Function} func 
     */
    XPROJECT.link = function (func) {
        if (!isFunction(func)) {
            throw new Error (
                'Input of link must be a function but not ' + func
            );
        }
        linkSet.push(func);
    };
    
    /**
     * 
     *
     * @public
     */
    XPROJECT.doLink = function () {
        for(var i = 0, o; o = linkSet[i]; i++) {
            o.call(null);
        }
        linkSet = []; 
    };
    
    /**
     * 
     *
     * @public
     * @param {Function} func 
     */
    XPROJECT.end = function (func) {
        if (!isFunction(func)) {
            throw new Error (
                'Input of link must be a function but not ' + func
            );
        }
        endSet.push(func);
    };
    
    /**
     * 
     *
     * @public
     */
    XPROJECT.doEnd = function () {
        for(var i = 0, o; o = endSet[i]; i++) {
            o.call(null);
        }
        endSet = []; 
    };
    
    /**
     * window
     *
     * @public
     * @param {Object} namespaceBase 
     */
    XPROJECT.setNamespaceBase = function (namespaceBase) {
        namespaceBase && (NS_BASE = namespaceBase);
    };

    /**
     * window
     *
     * @public
     * @return {Object} 
     */
    XPROJECT.getNamespaceBase = function () {
        return NS_BASE;
    };
    
    /**
     * Parse
     *
     * @private
     * @param {string} input 
     * @return {boolean} parse
     */
    function parseInput(input) {
        var o;
        if ((o = trim(input)) == '') {
            throw new Error('Error input: ' + str);   
        } 
        else {
            return o;
        }
    }
    
    /**
     * 
     *
     * @private
     * @param {Object} context 
     * @param {string} attrName 
     * @return {Object} 
     */
    function getOrCreateObj(context, attrName) {
        var o = context[attrName];
        return o != null ? o : (context[attrName] = {});
    }
    
    /**
     * 
     *
     * @private
     * @param {*} variable 
     * @return {boolean} 
     */
    function isFunction(variable) {
        return Object.prototype.toString.call(variable) == '[object Function]';
    }
    
    /**
     * trim
     *
     * @private
     * @param {string} 
     * @return {string} 
     */
    function trim(source) {
        return source == null ? '' : String(source).replace(TRIMER, '');
    }
    
})();

// Copyright (c) 2009, Baidu Inc. All rights reserved.
// 
// Licensed under the BSD License
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//      http:// tangram.baidu.com/license.html
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
 /**
 * @namespace T Tangram
 * @name T
 * @version 1.5.2.2
*/

/**
 * 
 * ajax charset=UTF-8
 */

/**
 * baidu
 * @author: allstar, erik, meizz, berg
 */
var T,
    baidu = T = baidu || {version: "1.5.2.2"}; 

//guidTangram
//window[undefined]
baidu.guid = "$BAIDU$";

//Tangram
//window[baidu.guid]
baidu.$$ = window[baidu.guid] = window[baidu.guid] || {global:{}};

/**
 * XMLHttpRequest
 * @namespace baidu.ajax
 */
baidu.ajax = baidu.ajax || {};

/**
 * 
 * @namespace baidu.fn
 */
baidu.fn = baidu.fn || {};


/**
 * .
 * @author rocy
 * @name baidu.fn.blank
 * @function
 * @grammar baidu.fn.blank()
 * @meta standard
 * @return {Function} 
 * @version 1.3.3
 */
baidu.fn.blank = function () {};

/** 
 * 
 * @name baidu.fn.bind
 * @function
 * @grammar baidu.fn.bind(handler[, obj, args])
 * @param {Function|String} handler 
 * @param {Object} obj thisthis
 * @param {args* 0..n} args 
 * @version 1.3
 *
 * @returns {Function} 
 */
baidu.fn.bind = function(func, scope) {
    var xargs = arguments.length > 2 ? [].slice.call(arguments, 2) : null;
    return function () {
        var fn = baidu.lang.isString(func) ? scope[func] : func,
            args = (xargs) ? xargs.concat([].slice.call(arguments, 0)) : arguments;
        return fn.apply(scope || fn, args);
    };
};

/**
 * ajax
 * @author: allstar, erik, berg
 * @name baidu.ajax.request
 * @function
 * @grammar baidu.ajax.request(url[, options])
 * @param {string}  url url
 * @param {Object}  options 
 * @config {String}     [method]            GET
 * @config {Boolean}  [async]           true
 * @config {String}     [data]              GET
 * @config {Object}     [headers]           http request header
 * @config {number}   [timeout]       ms
 * @config {String}     [username]          
 * @config {String}     [password]          
 * @config {Function} [onsuccess]       function(XMLHttpRequest xhr, string responseText)
 * @config {Function} [onfailure]       function(XMLHttpRequest xhr)
 * @config {Function} [onbeforerequest] function(XMLHttpRequest xhr)
 * @config {Function} [on{STATUS_CODE}]     on302on404on500function(XMLHttpRequest xhr)3XX4xx
 * @config {Boolean}  [noCache]             false1.1.1
 * 
 * @meta standard
 * @see baidu.ajax.get,baidu.ajax.post,baidu.ajax.form
 *             
 * @returns {XMLHttpRequest} XMLHttpRequest
 */
baidu.ajax.request = function (url, opt_options) {
    var options     = opt_options || {},
        data        = options.data || "",
        async       = !(options.async === false),
        username    = options.username || "",
        password    = options.password || "",
        method      = (options.method || "GET").toUpperCase(),
        headers     = options.headers || {},
        // lilipatch
        timeout     = options.timeout || 0,
        eventHandlers = {},
        tick, key, xhr;

    /**
     * readyState
     * 
     * @ignore
     */
    function stateChangeHandler() {
        if (xhr.readyState == 4) {
            try {
                var stat = xhr.status;
            } catch (ex) {
                // Firefoxstatus
                fire('failure');
                return;
            }
            
            fire(stat);
            
            // http://www.never-online.net/blog/article.asp?id=261
            // case 12002: // Server timeout      
            // case 12029: // dropped connections
            // case 12030: // dropped connections
            // case 12031: // dropped connections
            // case 12152: // closed by server
            // case 13030: // status and statusText are unavailable
            
            // IE error sometimes returns 1223 when it 
            // should be 204, so treat it as success
            if ((stat >= 200 && stat < 300)
                || stat == 304
                || stat == 1223) {
                fire('success');
            } else {
                fire('failure');
            }
            
            /*
             * NOTE: Testing discovered that for some bizarre reason, on Mozilla, the
             * JavaScript <code>XmlHttpRequest.onreadystatechange</code> handler
             * function maybe still be called after it is deleted. The theory is that the
             * callback is cached somewhere. Setting it to null or an empty function does
             * seem to work properly, though.
             * 
             * On IE, there are two problems: Setting onreadystatechange to null (as
             * opposed to an empty function) sometimes throws an exception. With
             * particular (rare) versions of jscript.dll, setting onreadystatechange from
             * within onreadystatechange causes a crash. Setting it from within a timeout
             * fixes this bug (see issue 1610).
             * 
             * End result: *always* set onreadystatechange to an empty function (never to
             * null). Never set onreadystatechange from within onreadystatechange (always
             * in a setTimeout()).
             */
            window.setTimeout(
                function() {
                    // .
                    // new Function baidu.fn.blank ,
                    // IE. By rocy 2011-01-05 .
                    xhr.onreadystatechange = baidu.fn.blank;
                    if (async) {
                        xhr = null;
                    }
                }, 0);
        }
    }
    
    /**
     * XMLHttpRequest
     * 
     * @ignore
     * @return {XMLHttpRequest} XMLHttpRequest
     */
    function getXHR() {
        if (window.ActiveXObject) {
            try {
                return new ActiveXObject("Msxml2.XMLHTTP");
            } catch (e) {
                try {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                } catch (e) {}
            }
        }
        if (window.XMLHttpRequest) {
            return new XMLHttpRequest();
        }
    }
    
    /**
     * 
     * 
     * @ignore
     * @param {String} type 
     */
    function fire(type) {
        type = 'on' + type;
        var handler = eventHandlers[type],
            globelHandler = baidu.ajax[type];
        
        // 
        if (handler) {
            if (tick) {
              clearTimeout(tick);
            }

            if (type != 'onsuccess') {
                handler(xhr);
            } else {
                //xhr.responseText,.
                try {
                    xhr.responseText;
                } catch(error) {
                    return handler(xhr);
                }
                handler(xhr, xhr.responseText);
            }
        } else if (globelHandler) {
            //onsuccess
            if (type == 'onsuccess') {
                return;
            }
            globelHandler(xhr);
        }
    }
    
    
    for (key in options) {
        // optionseventHandlers
        // optionseventHandlers
        // 
        eventHandlers[key] = options[key];
    }
    
    headers['X-Requested-With'] = 'XMLHttpRequest';
    if (xutil.url) {
        var dataMap = xutil.url.parseParam(data)
        headers['X-RouteBizKey'] = dataMap['_rbk'];
        dataMap = null;
    }
    
    
    try {
        xhr = getXHR();
        
        if (method == 'GET') {
            if (data) {
                url += (url.indexOf('?') >= 0 ? '&' : '?') + data;
                data = null;
            }
            if(options['noCache'])
                url += (url.indexOf('?') >= 0 ? '&' : '?') + 'b' + (+ new Date) + '=1';
        }
        
        if (username) {
            xhr.open(method, url, async, username, password);
        } else {
            xhr.open(method, url, async);
        }
        
        if (async) {
            xhr.onreadystatechange = stateChangeHandler;
        }
        
        // openhttp
        // FIXME ; charset=UTF-8
        if (method == 'POST') {
            xhr.setRequestHeader("Content-Type",
                (headers['Content-Type'] || "application/x-www-form-urlencoded; charset=UTF-8"));
        }
        
        for (key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
        
        fire('beforerequest');

        if (timeout) {
          tick = setTimeout(function(){
            xhr.onreadystatechange = baidu.fn.blank;
            xhr.abort();
            fire("timeout");
          }, timeout);
        }
        xhr.send(data);
        
        if (!async) {
            stateChangeHandler();
        }
    } catch (ex) {
        fire('failure');
    }
    
    return xhr;
};


/**
 * get
 * @name baidu.ajax.get
 * @function
 * @grammar baidu.ajax.get(url[, onsuccess])
 * @param {string}  url         url
 * @param {Function} [onsuccess] function(XMLHttpRequest xhr, string responseText)
 * @meta standard
 * @see baidu.ajax.post,baidu.ajax.request
 *             
 * @returns {XMLHttpRequest}    XMLHttpRequest
 */
baidu.ajax.get = function (url, onsuccess) {
    return baidu.ajax.request(url, {'onsuccess': onsuccess});
};

/**
 * post
 * @name baidu.ajax.post
 * @function
 * @grammar baidu.ajax.post(url, data[, onsuccess])
 * @param {string}  url         url
 * @param {string}  data        
 * @param {Function} [onsuccess] function(XMLHttpRequest xhr, string responseText)
 * @meta standard
 * @see baidu.ajax.get,baidu.ajax.request
 *             
 * @returns {XMLHttpRequest}    XMLHttpRequest
 */
baidu.ajax.post = function (url, data, onsuccess) {
    return baidu.ajax.request(
        url, 
        {
            'onsuccess': onsuccess,
            'method': 'POST',
            'data': data
        }
    );
};

/**
 * json
 * @namespace baidu.json
 */
baidu.json = baidu.json || {};


/**
 * json
 * @name baidu.json.stringify
 * @function
 * @grammar baidu.json.stringify(value)
 * @param {JSON} value json
 * @remark
 * ecma-262JSON.stringify
 * @meta standard
 * @see baidu.json.parse,baidu.json.encode
 *             
 * @returns {string} 
 */
baidu.json.stringify = (function () {
    /**
     * 
     * @private
     */
    var escapeMap = {
        "\b": '\\b',
        "\t": '\\t',
        "\n": '\\n',
        "\f": '\\f',
        "\r": '\\r',
        '"' : '\\"',
        "\\": '\\\\'
    };
    
    /**
     * 
     * @private
     */
    function encodeString(source) {
        if (/["\\\x00-\x1f]/.test(source)) {
            source = source.replace(
                /["\\\x00-\x1f]/g, 
                function (match) {
                    var c = escapeMap[match];
                    if (c) {
                        return c;
                    }
                    c = match.charCodeAt();
                    return "\\u00" 
                            + Math.floor(c / 16).toString(16) 
                            + (c % 16).toString(16);
                });
        }
        return '"' + source + '"';
    }
    
    /**
     * 
     * @private
     */
    function encodeArray(source) {
        var result = ["["], 
            l = source.length,
            preComma, i, item;
            
        for (i = 0; i < l; i++) {
            item = source[i];
            
            switch (typeof item) {
            case "undefined":
            case "function":
            case "unknown":
                break;
            default:
                if(preComma) {
                    result.push(',');
                }
                result.push(baidu.json.stringify(item));
                preComma = 1;
            }
        }
        result.push("]");
        return result.join("");
    }
    
    /**
     * 
     * @private
     */
    function pad(source) {
        return source < 10 ? '0' + source : source;
    }
    
    /**
     * 
     * @private
     */
    function encodeDate(source){
        return '"' + source.getFullYear() + "-" 
                + pad(source.getMonth() + 1) + "-" 
                + pad(source.getDate()) + "T" 
                + pad(source.getHours()) + ":" 
                + pad(source.getMinutes()) + ":" 
                + pad(source.getSeconds()) + '"';
    }
    
    return function (value) {
        switch (typeof value) {
        case 'undefined':
            return 'undefined';
            
        case 'number':
            return isFinite(value) ? String(value) : "null";
            
        case 'string':
            return encodeString(value);
            
        case 'boolean':
            return String(value);
            
        default:
            if (value === null) {
                return 'null';
            } else if (value instanceof Array) {
                return encodeArray(value);
            } else if (value instanceof Date) {
                return encodeDate(value);
            } else {
                var result = ['{'],
                    encode = baidu.json.stringify,
                    preComma,
                    item;
                    
                for (var key in value) {
                    if (Object.prototype.hasOwnProperty.call(value, key)) {
                        item = value[key];
                        switch (typeof item) {
                        case 'undefined':
                        case 'unknown':
                        case 'function':
                            break;
                        default:
                            if (preComma) {
                                result.push(',');
                            }
                            preComma = 1;
                            result.push(encode(key) + ':' + encode(item));
                        }
                    }
                }
                result.push('}');
                return result.join('');
            }
        }
    };
})();

/**
 * json
 * @name baidu.json.parse
 * @function
 * @grammar baidu.json.parse(data)
 * @param {string} source 
 * @remark
 * ecma-262JSON.parse
 * @meta standard
 * @see baidu.json.stringify,baidu.json.decode
 *             
 * @returns {JSON} json
 */
baidu.json.parse = function (data) {
    //2010/12/09parse
    return (new Function("return (" + data + ")"))();
};

/**
 * jsonbaidu.json.stringify
 * @name baidu.json.encode
 * @function
 * @grammar baidu.json.encode(value)
 * @param {JSON} value json
 * @meta out
 * @see baidu.json.decode,baidu.json.stringify
 *             
 * @returns {string} 
 */
baidu.json.encode = baidu.json.stringify;

/**
 * jsonbaidu.json.parse
 * @name baidu.json.decode
 * @function
 * @grammar baidu.json.decode(source)
 * @param {string} source 
 * @meta out
 * @see baidu.json.encode,baidu.json.parse
 *             
 * @returns {JSON} json
 */
baidu.json.decode = baidu.json.parse;

/**
 * 
 * @namespace baidu.browser
 */
baidu.browser = baidu.browser || {};


(function(){
    var ua = navigator.userAgent;
    /*
     * safariipad,,ipad UA :
     * Mozilla/5.0(iPad; U; CPU iPhone OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Version/4.0.4 Mobile/7B314 Safari/531.21.10
     */
    
    /**
     * safari, ipad
     * @property safari safari
     * @grammar baidu.browser.safari
     * @meta standard
     * @see baidu.browser.ie,baidu.browser.firefox,baidu.browser.opera,baidu.browser.chrome   
     */
    baidu.browser.safari = /(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(ua) && !/chrome/i.test(ua) ? + (RegExp['\x241'] || RegExp['\x242']) : undefined;
})();

//IE 8documentMode
//$$1  \x241
/**
 * ie
 * @name baidu.browser.ie
 * @field
 * @grammar baidu.browser.ie
 * @returns {Number} IE
 */
baidu.browser.ie = baidu.ie = /msie (\d+\.\d+)/i.test(navigator.userAgent) ? (document.documentMode || + RegExp['\x241']) : undefined;

/**
 * opera
 * @property opera opera
 * @grammar baidu.browser.opera
 * @meta standard
 * @see baidu.browser.ie,baidu.browser.firefox,baidu.browser.safari,baidu.browser.chrome
 * @returns {Number} opera
 */

/**
 * opera 10opera
 * Browser identificationVersion + 
 * opera9.80
 */
baidu.browser.opera = /opera(\/| )(\d+(\.\d+)?)(.+?(version\/(\d+(\.\d+)?)))?/i.test(navigator.userAgent) ?  + ( RegExp["\x246"] || RegExp["\x242"] ) : undefined;

/**
 * dom
 * @namespace baidu.dom 
 */
baidu.dom = baidu.dom || {};

/**
 * 
 * @namespace baidu.lang
 */
baidu.lang = baidu.lang || {};


/**
 * 
 * @namespace baidu.event
 * @property target     
 * @property pageX      x
 * @property pageY      y
 * @property keyCode    
 */
baidu.event = baidu.event || {};


/**
 * 
 * @name baidu.event.EventArg
 * @class
 * @grammar baidu.event.EventArg(event[, win])
 * @param {Event}   event   
 * @param {Window}  [win]   window
 * @meta standard
 * @remark 1.1.0
 * @see baidu.event.get
 */
baidu.event.EventArg = function (event, win) {
    win = win || window;
    event = event || win.event;
    var doc = win.document;
    
    this.target = /** @type {Node} */ (event.target) || event.srcElement;
    this.keyCode = event.which || event.keyCode;
    for (var k in event) {
        var item = event[k];
        // preventDefault
        if ('function' != typeof item) {
            this[k] = item;
        }
    }
    
    if (!this.pageX && this.pageX !== 0) {
        this.pageX = (event.clientX || 0) 
                        + (doc.documentElement.scrollLeft 
                            || doc.body.scrollLeft);
        this.pageY = (event.clientY || 0) 
                        + (doc.documentElement.scrollTop 
                            || doc.body.scrollTop);
    }
    this._event = event;
};

/**
 * 
 * @name preventDefault
 * @grammar eventArgObj.preventDefault()
 * @returns {baidu.event.EventArg} EventArg
 */
baidu.event.EventArg.prototype.preventDefault = function () {
    if (this._event.preventDefault) {
        this._event.preventDefault();
    } else {
        this._event.returnValue = false;
    }
    return this;
};

/**
 * 
 * @name stopPropagation
 * @grammar eventArgObj.stopPropagation()
 * @returns {baidu.event.EventArg} EventArg
 */
baidu.event.EventArg.prototype.stopPropagation = function () {
    if (this._event.stopPropagation) {
        this._event.stopPropagation();
    } else {
        this._event.cancelBubble = true;
    }
    return this;
};

/**
 * 
 * @name stop
 * @grammar eventArgObj.stop()
 * @returns {baidu.event.EventArg} EventArg
 */
baidu.event.EventArg.prototype.stop = function () {
    return this.stopPropagation().preventDefault();
};

/**
 * stringString
 * @name baidu.lang.isString
 * @function
 * @grammar baidu.lang.isString(source)
 * @param {Any} source 
 * @shortcut isString
 * @meta standard
 * @see baidu.lang.isObject,baidu.lang.isNumber,baidu.lang.isArray,baidu.lang.isElement,baidu.lang.isBoolean,baidu.lang.isDate
 *             
 * @returns {boolean} 
 */
baidu.lang.isString = function (source) {
    return '[object String]' == Object.prototype.toString.call(source);
};

// 
baidu.isString = baidu.lang.isString;

/**
 * DOM
 * ****
 * 
 * @param {string|HTMLElement} id idDOM
 * @meta standard
 * @return {HTMLElement} DOMnull
 */
baidu.dom._g = function (id) {
    if (baidu.lang.isString(id)) {
        return document.getElementById(id);
    }
    return id;
};

// 
baidu._g = baidu.dom._g;

/**
 * 
 * @name baidu.dom.contains
 * @function
 * @grammar baidu.dom.contains(container, contained)
 * @param {HTMLElement|string} container id
 * @param {HTMLElement|string} contained id
 * @meta standard
 * @see baidu.dom.intersect
 *             
 * @returns {boolean} containedcontainerDOM
 */
baidu.dom.contains = function (container, contained) {

    var g = baidu.dom._g;
    container = g(container);
    contained = g(contained);

    //fixme: (IE)
    return container.contains
        ? container != contained && container.contains(contained)
        : !!(container.compareDocumentPosition(contained) & 16);
};

/**
 * 
 * @namespace baidu.object
 */
baidu.object = baidu.object || {};


/**
 * 
 * @author erik
 * @name baidu.object.extend
 * @function
 * @grammar baidu.object.extend(target, source)
 * @param {Object} target 
 * @param {Object} source 
 * @see baidu.array.merge
 * @remark
 * 
1.key<br>
2.prototype
        
 * @shortcut extend
 * @meta standard
 *             
 * @returns {Object} 
 */
baidu.extend =
baidu.object.extend = function (target, source) {
    for (var p in source) {
        if (source.hasOwnProperty(p)) {
            target[p] = source[p];
        }
    }
    
    return target;
};

/**
 * 
 * @name baidu.object.values
 * @function
 * @grammar baidu.object.values(source)
 * @param {Object} source 
 * @see baidu.object.keys
 *             
 * @returns {Array} 
 */
baidu.object.values = function (source) {
    var result = [], resultLen = 0, k;
    for (k in source) {
        if (source.hasOwnProperty(k)) {
            result[resultLen++] = source[k];
        }
    }
    return result;
};

/**
 * numberNumber
 * @name baidu.lang.isNumber
 * @function
 * @grammar baidu.lang.isNumber(source)
 * @param {Any} source 
 * @meta standard
 * @see baidu.lang.isString,baidu.lang.isObject,baidu.lang.isArray,baidu.lang.isElement,baidu.lang.isBoolean,baidu.lang.isDate
 *             
 * @returns {boolean} 
 * @remark NaNfalseJavascriptNumber
 */
baidu.lang.isNumber = function (source) {
    return '[object Number]' == Object.prototype.toString.call(source) && isFinite(source);
};

/**
 * ieloadunload
 * @name baidu.event.fire
 * @function
 * @grammar baidu.event.fire(element, type, options)
 * @param {HTMLElement|string|window} element id
 * @param {string} type 
 * @param {Object} options 
                
 * @param {Boolean} options.bubbles 
 * @param {Boolean} options.cancelable 
 * @param {window|null} options.view  Event  AbstractView
 * @param {1|Number} options.detail  Event 
 * @param {Number} options.screenX  Event  x 
 * @param {Number} options.screenY number  Event  y 
 * @param {Number} options.clientX  Event  x 
 * @param {Number} options.clientY  Event  y 
 * @param {Boolean} options.ctrlKey  Event  ctrl 
 * @param {Boolean} options.altKey  Event  alt 
 * @param {Boolean} options.shiftKey  Event  shift 
 * @param {Boolean} options.metaKey  Event  meta 
 * @param {Number} options.button  Event 
 * @param {Number} options.keyCode  Event 
 * @param {Number} options.charCode  Event 
 * @param {HTMLElement} options.relatedTarget  Event  EventTarget
 * @version 1.3
 *             
 * @returns {HTMLElement} 
 */
(function(){
    var browser = baidu.browser,
    keys = {
        keydown : 1,
        keyup : 1,
        keypress : 1
    },
    mouses = {
        click : 1,
        dblclick : 1,
        mousedown : 1,
        mousemove : 1,
        mouseup : 1,
        mouseover : 1,
        mouseout : 1
    },
    htmls = {
        abort : 1,
        blur : 1,
        change : 1,
        error : 1,
        focus : 1,
        load : browser.ie ? 0 : 1,
        reset : 1,
        resize : 1,
        scroll : 1,
        select : 1,
        submit : 1,
        unload : browser.ie ? 0 : 1
    },
    bubblesEvents = {
        scroll : 1,
        resize : 1,
        reset : 1,
        submit : 1,
        change : 1,
        select : 1,
        error : 1,
        abort : 1
    },
    parameters = {
        "KeyEvents" : ["bubbles", "cancelable", "view", "ctrlKey", "altKey", "shiftKey", "metaKey", "keyCode", "charCode"],
        "MouseEvents" : ["bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget"],
        "HTMLEvents" : ["bubbles", "cancelable"],
        "UIEvents" : ["bubbles", "cancelable", "view", "detail"],
        "Events" : ["bubbles", "cancelable"]
    };
    baidu.object.extend(bubblesEvents, keys);
    baidu.object.extend(bubblesEvents, mouses);
    function parse(array, source){//arraysourceobjsourcearray
        var i = 0, size = array.length, obj = {};
        for(; i < size; i++){
            obj[array[i]] = source[array[i]];
            delete source[array[i]];
        }
        return obj;
    };
    function eventsHelper(type, eventType, options){//IE
        options = baidu.object.extend({}, options);
        var param = baidu.object.values(parse(parameters[eventType], options)),
            evnt = document.createEvent(eventType);
        param.unshift(type);
        if("KeyEvents" == eventType){
            evnt.initKeyEvent.apply(evnt, param);
        }else if("MouseEvents" == eventType){
            evnt.initMouseEvent.apply(evnt, param);
        }else if("UIEvents" == eventType){
            evnt.initUIEvent.apply(evnt, param);
        }else{//HTMMLEvents, Events
            evnt.initEvent.apply(evnt, param);
        }
        baidu.object.extend(evnt, options);//options,eventEvents
        return evnt;
    };
    function eventObject(options){//ie
        var evnt;
        if(document.createEventObject){
            evnt = document.createEventObject();
            baidu.object.extend(evnt, options);
        }
        return evnt;
    };
    function keyEvents(type, options){//keyEvents
        options = parse(parameters["KeyEvents"], options);
        var evnt;
        if(document.createEvent){
            try{//operakeyEvents
                evnt = eventsHelper(type, "KeyEvents", options);
            }catch(keyError){
                try{
                    evnt = eventsHelper(type, "Events", options);
                }catch(evtError){
                    evnt = eventsHelper(type, "UIEvents", options);
                }
            }
        }else{
            options.keyCode = options.charCode > 0 ? options.charCode : options.keyCode;
            evnt = eventObject(options);
        }
        return evnt;
    };
    function mouseEvents(type, options){//mouseEvents
        options = parse(parameters["MouseEvents"], options);
        var evnt;
        if(document.createEvent){
            evnt = eventsHelper(type, "MouseEvents", options);//mouseEvents
            if(options.relatedTarget && !evnt.relatedTarget){
                if("mouseout" == type.toLowerCase()){
                    evnt.toElement = options.relatedTarget;
                }else if("mouseover" == type.toLowerCase()){
                    evnt.fromElement = options.relatedTarget;
                }
            }
        }else{
            options.button = options.button == 0 ? 1
                                : options.button == 1 ? 4
                                    : baidu.lang.isNumber(options.button) ? options.button : 0;
            evnt = eventObject(options);
        }
        return evnt;
    };
    function htmlEvents(type, options){//htmlEvents
        options.bubbles = bubblesEvents.hasOwnProperty(type);
        options = parse(parameters["HTMLEvents"], options);
        var evnt;
        if(document.createEvent){
            try{
                evnt = eventsHelper(type, "HTMLEvents", options);
            }catch(htmlError){
                try{
                    evnt = eventsHelper(type, "UIEvents", options);
                }catch(uiError){
                    evnt = eventsHelper(type, "Events", options);
                }
            }
        }else{
            evnt = eventObject(options);
        }
        return evnt;
    };
    baidu.event.fire = function(element, type, options){
        var evnt;
        type = type.replace(/^on/i, "");
        element = baidu.dom._g(element);
        options = baidu.object.extend({
            bubbles : true,
            cancelable : true,
            view : window,
            detail : 1,
            screenX : 0,
            screenY : 0,
            clientX : 0,
            clientY : 0,
            ctrlKey : false,
            altKey  : false,
            shiftKey: false,
            metaKey : false,
            keyCode : 0,
            charCode: 0,
            button  : 0,
            relatedTarget : null
        }, options);
        if(keys[type]){
            evnt = keyEvents(type, options);
        }else if(mouses[type]){
            evnt = mouseEvents(type, options);
        }else if(htmls[type]){
            evnt = htmlEvents(type, options);
        }else{
            throw(new Error(type + " is not support!"));
        }
        if(evnt){//tigger event
            if(element.dispatchEvent){
                element.dispatchEvent(evnt);
            }else if(element.fireEvent){
                element.fireEvent("on" + type, evnt);
            }
        }
    }
})();
/**
 * EventArg
 * @name baidu.event.get
 * @function
 * @grammar baidu.event.get(event[, win])
 * @param {Event} event 
 * @param {window} [win] window
 * @meta standard
 * @see baidu.event.EventArg
 *             
 * @returns {EventArg} 
 */
baidu.event.get = function (event, win) {
    return new baidu.event.EventArg(event, win);
};

/**
 * 
 * @name baidu.event.getEvent
 * @function
 * @param {Event} event eventby dengping.
 * @grammar baidu.event.getEvent()
 * @meta standard
 * @return {Event} event.
 */

baidu.event.getEvent = function(event) {
    if (window.event) {
        return window.event;
    } else {
        var f = arguments.callee;
        do { //Qwrap see http://www.qwrap.com/ by dengping
            if (/Event/.test(f.arguments[0])) {
                return f.arguments[0];
            }
        } while (f = f.caller);
        return null;
    }
};

/**
 * 
 * @name baidu.event.getKeyCode
 * @function
 * @grammar baidu.event.getKeyCode(event)
 * @param {Event} event 
 *             
 * @returns {number} 
 */
baidu.event.getKeyCode = function (event) {
    return event.which || event.keyCode;
};

/**
 * x
 * @name baidu.event.getPageX
 * @function
 * @grammar baidu.event.getPageX(event)
 * @param {Event} event 
 * @see baidu.event.getPageY
 *             
 * @returns {number} x
 */
baidu.event.getPageX = function (event) {
    var result = event.pageX,
        doc = document;
    if (!result && result !== 0) {
        result = (event.clientX || 0) 
                    + (doc.documentElement.scrollLeft 
                        || doc.body.scrollLeft);
    }
    return result;
};

/**
 * y
 * @name baidu.event.getPageY
 * @function
 * @grammar baidu.event.getPageY(event)
 * @param {Event} event 
 * @see baidu.event.getPageX
 *             
 * @returns {number} y
 */
baidu.event.getPageY = function (event) {
    var result = event.pageY,
        doc = document;
    if (!result && result !== 0) {
        result = (event.clientY || 0) 
                    + (doc.documentElement.scrollTop 
                        || doc.body.scrollTop);
    }
    return result;
};

/**
 * 
 * @name baidu.event.getTarget
 * @function
 * @grammar baidu.event.getTarget(event)
 * @param {Event} event 
 * @meta standard
 * @returns {HTMLElement} 
 */
 
baidu.event.getTarget = function (event) {
    return event.target || event.srcElement;
};

/**
 * 
 * @private
 * @meta standard
 */
baidu.event._listeners = baidu.event._listeners || [];



/**
 * 
 * @name baidu.event.on
 * @function
 * @grammar baidu.event.on(element, type, listener)
 * @param {HTMLElement|string|window} element id
 * @param {string} type 
 * @param {Function} listener 
 * @remark
 * 
1. <br>
2. iframe
    
 * @shortcut on
 * @meta standard
 * @see baidu.event.un
 * @returns {HTMLElement|window} 
 */
baidu.event.on = /**@function*/function (element, type, listener) {
    type = type.replace(/^on/i, '');
    element = baidu.dom._g(element);

    var realListener = function (ev) {
            // 1. EventArgument,  frame
            // 2. elementthis
            listener.call(element, ev);
        },
        lis = baidu.event._listeners,
        filter = baidu.event._eventFilter,
        afterFilter,
        realType = type;
    type = type.toLowerCase();
    // filter
    if(filter && filter[type]){
        afterFilter = filter[type](element, type, realListener);
        realType = afterFilter.type;
        realListener = afterFilter.listener;
    }
    
    // 
    if (element.addEventListener) {
        element.addEventListener(realType, realListener, false);
    } else if (element.attachEvent) {
        element.attachEvent('on' + realType, realListener);
    }
  
    // 
    lis[lis.length] = [element, type, listener, realListener, realType];
    return element;
};

// 
baidu.on = baidu.event.on;

/**
 * 
 * @name baidu.event.un
 * @function
 * @grammar baidu.event.un(element, type, listener)
 * @param {HTMLElement|string|window} element id
 * @param {string} type 
 * @param {Function} listener 
 * @shortcut un
 * @meta standard
 * @see baidu.event.on
 *             
 * @returns {HTMLElement|window} 
 */
baidu.event.un = function (element, type, listener) {
    element = baidu.dom._g(element);
    type = type.replace(/^on/i, '').toLowerCase();
    
    var lis = baidu.event._listeners, 
        len = lis.length,
        isRemoveAll = !listener,
        item,
        realType, realListener;
    
    //listenerjson
    //
    //unlistener
    //
    //
    while (len--) {
        item = lis[len];
        
        // listenerelementlistenertype
        // listenerelementtype
        if (item[1] === type
            && item[0] === element
            && (isRemoveAll || item[2] === listener)) {
            realType = item[4];
            realListener = item[3];
            if (element.removeEventListener) {
                element.removeEventListener(realType, realListener, false);
            } else if (element.detachEvent) {
                element.detachEvent('on' + realType, realListener);
            }
            lis.splice(len, 1);
        }
    }
    
    return element;
};

// 
baidu.un = baidu.event.un;



/**
 * 
 * @name baidu.event.once
 * @function
 * @grammar baidu.event.once(element, type, listener)
 * @param {HTMLElement|string} element id
 * @param {string} type 
 * @param {Function} listener 
 * @version 1.3
 * @see baidu.event.un,baidu.event.on
 *             
 * @returns {HTMLElement} 
 */
baidu.event.once = /**@function*/function(element, type, listener){
    element = baidu.dom._g(element);
    function onceListener(event){
        listener.call(element,event);
        baidu.event.un(element, type, onceListener);
    } 
    
    baidu.event.on(element, type, onceListener);
    return element;
};

/**
 * 
 * @name baidu.event.preventDefault
 * @function
 * @grammar baidu.event.preventDefault(event)
 * @param {Event} event 
 * @meta standard
 * @see baidu.event.stop,baidu.event.stopPropagation
 */
baidu.event.preventDefault = function (event) {
   if (event.preventDefault) {
       event.preventDefault();
   } else {
       event.returnValue = false;
   }
};

/**
 * 
 * @name baidu.event.stopPropagation
 * @function
 * @grammar baidu.event.stopPropagation(event)
 * @param {Event} event 
 * @see baidu.event.stop,baidu.event.preventDefault
 */
baidu.event.stopPropagation = function (event) {
   if (event.stopPropagation) {
       event.stopPropagation();
   } else {
       event.cancelBubble = true;
   }
};



/**
 * 
 * @name baidu.event.stop
 * @function
 * @grammar baidu.event.stop(event)
 * @param {Event} event 
 * @see baidu.event.stopPropagation,baidu.event.preventDefault
 */
baidu.event.stop = function (event) {
    var e = baidu.event;
    e.stopPropagation(event);
    e.preventDefault(event);
};

baidu.event._eventFilter = baidu.event._eventFilter || {};

/**
 * /IEmouseleave/mouseenter
 * 
 * @name baidu.event._eventFilter._crossElementBoundary
 * @function
 * @grammar baidu.event._eventFilter._crossElementBoundary(listener, e)
 * 
 * @param {function} listener   
 * @param {DOMEvent} e          DOM
 */

baidu.event._eventFilter._crossElementBoundary = function(listener, e){
    var related = e.relatedTarget,
        current = e.currentTarget;
    if(
       related === false || 
       // currentrelatedbodycontainsfalse
       current == related ||
       // FirefoxXULrelatedTarget
       // parentNode
       // thanks jquery & mootools
       (related && (related.prefix == 'xul' ||
       //currentrelatedcurrent
       baidu.dom.contains(current, related)))
      ){
        return ;
    }
    return listener.call(current, e);
};

/**
 * IEmouseenter;
 * mouseenter,
 *    .
 */
baidu.event._eventFilter.mouseenter = window.attachEvent ? null : function(element,type, listener){
    return {
        type: "mouseover",
        listener: baidu.fn.bind(baidu.event._eventFilter._crossElementBoundary, this, listener)
    }
};

/**
 * IEmouseleave;
 * mouseleave,
 *    .
 */
baidu.event._eventFilter.mouseleave = window.attachEvent ? null : function(element,type, listener){
    return {
        type: "mouseout",
        listener: baidu.fn.bind(baidu.event._eventFilter._crossElementBoundary, this, listener)
    }
};

/**
 * dom
 * @author allstar
 * @name baidu.dom.ready
 * @function
 * @grammar baidu.dom.ready(callback)
 * @param {Function} callback .
 * @remark
 * js, 
 * @meta standard
 */
(function() {

    var ready = baidu.dom.ready = function() {
        var readyBound = false,
            readyList = [],
            DOMContentLoaded;

        if (document.addEventListener) {
            DOMContentLoaded = function() {
                document.removeEventListener('DOMContentLoaded', DOMContentLoaded, false);
                ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function() {
                if (document.readyState === 'complete') {
                    document.detachEvent('onreadystatechange', DOMContentLoaded);
                    ready();
                }
            };
        }
        /**
         * @private
         */
        function ready() {
            if (!ready.isReady) {
                ready.isReady = true;
                for (var i = 0, j = readyList.length; i < j; i++) {
                    readyList[i]();
                }
            }
        }
        /**
         * @private
         */
        function doScrollCheck(){
            try {
                document.documentElement.doScroll("left");
            } catch(e) {
                setTimeout( doScrollCheck, 1 );
                return;
            }   
            ready();
        }
        /**
         * @private
         */
        function bindReady() {
            if (readyBound) {
                return;
            }
            readyBound = true;

            if (document.readyState === 'complete') {
                ready.isReady = true;
            } else {
                if (document.addEventListener) {
                    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);
                    window.addEventListener('load', ready, false);
                } else if (document.attachEvent) {
                    document.attachEvent('onreadystatechange', DOMContentLoaded);
                    window.attachEvent('onload', ready);

                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) {}

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            }
        }
        bindReady();

        return function(callback) {
            ready.isReady ? callback() : readyList.push(callback);
        };
    }();

    ready.isReady = false;
})();
;T.undope=true;
/*
 * e-json
 * Copyright 2010 Baidu Inc. All rights reserved.
 * 
 * path:          e-json.js
 * desc:          E-JSON
 * author:        erik
 * depend:        baidu.ajax.request, baidu.json.parse
 * modification:  (1) statusfail0bug
 *                (2) jsonhtmljsonjson 
 *                (by sushuang)
 */

/**
 * E-JSON
 */
baidu.ejson = function () {

    DEFAULT_ERROR_STATUS = 99999;

    /**
     * E-JSON
     *
     * @inner
     */
    function request(url, options) {
        var onsuccess = options.onsuccess;
        var onfailure = options.onfailure;

        // baidu.ajax.requestsuccess
        options.onsuccess = function (xhr) {
            process(xhr.responseText, onsuccess, onfailure);
            options = null;
        };

        // e-jsonproccessstatus
        options.onfailure = function (xhr) {
            process({
                    status: (xhr.status || DEFAULT_ERROR_STATUS), // abort302xhr.stauts0tangramonfailure, onfailure
                    statusInfo: xhr.statusText,
                    data: xhr.responseText
                },
                onsuccess,
                onfailure);
            options = null;
        };

        return baidu.ajax.request(url, options);
    }

    /**
     * E-JSON
     *
     * @inner
     */ 
    function process(source, onsuccess, onfailure) {
        onfailure = onfailure || new Function();
        onsuccess = onsuccess || new Function();

//        //json
//        baidu.json.parse = function(source){
//            return eval("(" + source + ")");
//        };
//        
        var obj;
        try { 
            obj = typeof source == 'string' ? baidu.json.parse(source) : source;
        } catch (e) { 
            // sourceHTMLcatch
            obj = source;
        }
        
        // Objectfailure
        if (!obj || typeof obj != 'object') {
            onfailure(1, obj);
            return;
        }

        // 
        if (!obj.status) {
            onsuccess(obj.data, obj);
        } else {
            onfailure(obj.status, obj);
        }
    }
 
    return {        
        DEFAULT_ERROR_STATUS: DEFAULT_ERROR_STATUS,

        /**
         * E-JSON
         * 
         * @public
         * @param {string} url url
         * @param {Object} options 
         */
        request: request,
        
        /**
         * getE-JSON
         * 
         * @public
         * @param {string}   url url
         * @param {Function} onsuccess (data)
         * @param {Function} onfailure ()
         */
        get: function (url, onsuccess, onfailure) {
            request(url, 
                {
                    method      : 'get', 
                    onsuccess   : onsuccess, 
                    onfailure   : onfailure
                });
        },
        
        /**
         * postE-JSON
         *
         * @public
         * @param {string} url         url
         * @param {string} postData    post
         * @param {Function} onsuccess (data)
         * @param {Function} onfailure ()
         */
        post: function (url, postData, onsuccess, onfailure) {
            return request(url, 
                {
                    method      : 'post', 
                    data        : postData, 
                    onsuccess   : onsuccess, 
                    onfailure   : onfailure
                });
        },

        /**
         * E-JSON
         *
         * @public
         * @param {string|Object}   source    
         * @param {Function}        onsuccess (data)
         * @param {Function}        onfailure ()
         */
        process: process
    };
}();



/**
 * xutil
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 *          
 * @author:  sushuang(sushuang@baidu.com)
 */

/**
 * @namespace
 */
var xutil = {
    lang: {},
    number: {},
    string: {},
    fn: {},
    object: {},
    date: {},
    url: {},
    collection: {},
    file: {},
    dom: {},
    uid: {},
    graphic: {},
    ajax: {}
};
/**
 * xutil.LinkedHashMap
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           id
 *           
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

/**
 * @usage 
 *    (1) HashMap
 *        var h1 = new LinkedHashMap();
 *        h1.set('name', 'ss');
 *        h1.set('age', 123);
 *        var name = h1.get('name');
 * 
 *    (2) nextprevious
 *        // idHashMapkey
 *        var h2 = new LinkedHashMap(null, 'id'); 
 *        h2.addLast({ id: 23, name: 'ss' });
 *        h2.addFirst({ id: 34, name: 'bbb' });
 *        h2.appendAll(
 *          [
 *              { id: 99, name: 'xx' }, 
 *              { id: 543, name: 'trr' }
 *          ]
 *        );
 *        // {id:23, name: 'ss'}
 *        var data1 = h2.get(23); 
 *        // {id: 23, name: 'ss'}index
 *        var data2 = h2.getAt(1); 
 *        // {id: 34, name: 'bbb'}
 *        var data3 = h2.first(); 
 *        // 
 *        foreach(function(key, item, index) { ... }) 
 * 
 *    (3) listkeyvalue
 *        // 'id'HashMapkey
 *        // {id: 55, name: 'aa'}
 *        var h3 = new LinkedHashMap([{ id: 55, name: 'aa' }], 'id');
 *        h3.addLast({ id: 23, name: 'ss' });
 *        // idHashMapkey
 *        // name
 *        var h4 = new LinkedHashMap(null, 'id', 'name');
 *        h4.addLast({ id: 23, name: 'ss' });
 *        h4.addFirst('bb', 24); //
 */
(function () {

    var namespace = xutil;
    
    /**
     * 
     * LinkedHashMaplist
     * 
     * @public
     * @constructor
     * @param {Array.<Object>} list 
     *          nullLinkedHashMap
     * @param {(string|Function)=} defautlKeyAttr 
     *          listHashMapkey
     *          Function
     *              param {*} list
     *              return {*} HashMapkey
     * @param {(string|Function)=} defaultValueAttr 
     *          listHashMapvalue
     *          listHashMapvalue
     *          Function
     *              param {*} list
     *              return {*} HashMapvalue
     * @return {LinkedHashMap} 
     */
    var LINKED_HASH_MAP = namespace.LinkedHashMap = 
            function (list, defautlKeyAttr, defaultValueAttr) {
                this._oMap = {};
                this._oHead = null;
                this._oTail = null;
                this._nLength = 0;
                this.setDefaultAttr(defautlKeyAttr, defaultValueAttr);
                list && this.appendAll(list);
            };
    var LINKED_HASH_MAP_CLASS = LINKED_HASH_MAP.prototype;

    /**
     * defautlKeyAttrdefaultValueAttr
     *
     * @public
     * @param {(string|Function)=} defautlKeyAttr 
     * @param {(string|Function)=} defaultValueAttr 
     */
    LINKED_HASH_MAP_CLASS.setDefaultAttr = function (
        defautlKeyAttr, defaultValueAttr
    ) {
        this._sDefaultKeyAttr = defautlKeyAttr;
        this._sDefaultValueAttr = defaultValueAttr;
    };

    /**
     * 
     * 
     * @public
     * @param {Array} list 
     * @param {(string|Function)=} keyAttr 
     *      listHashMapkey
     *      defautlKeyAttrlistkey
     * @param {(string|Function)=} valueAttr 
     *      listHashMapvalue
     *      defautlValueAttrlistvalue
     *      defautlValueAttrlistHashMapvalue
     * @return {LinkedHashMap} 
     */
    LINKED_HASH_MAP_CLASS.appendAll = function (list, keyAttr, valueAttr) {
        keyAttr == null && (keyAttr = this._sDefaultKeyAttr);
        if (keyAttr == null) { return this; }
        valueAttr == null && (valueAttr = this._sDefaultValueAttr);

        list = list || [];
        for (var i = 0, len = list.length, item; i < len; i ++) {
            if (!(item = list[i])) { continue; }
            this.addLast(
                this.$retieval(item, valueAttr), 
                this.$retieval(item, keyAttr)
            );
        }
        return this;
    };

    /**
     * 
     * 
     *      my.addLast('asdf', 11)
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      
     *      my.addLast({ aa: 11, vv: 'asdf' })
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa');
     *      
     *      my.addLast({ aa: 11, vv: 'asdf' })
     *      11key{ aa: 11, vv: 'asdf' }value
     * 
     * key
     *
     * @public
     * @param {(*|Object)} item 
     * @param {string=} key HashMap
     * @return {LinkedHashMap} 
     */
    LINKED_HASH_MAP_CLASS.addLast = function (item, key) {
        if (key == null) {
            // 
            key = this.$retieval(item, this._sDefaultKeyAttr);
            item = this.$retieval(item, this._sDefaultValueAttr);
        }

        var node = { key: key, item: item, pre: null, next: null }; 
        this._oMap[key] = node;
        this.$insert(node, this._oTail, null);
        return this;
    };

    /**
     * 
     * 
     *      my.addFirst('asdf', 11)
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      
     *      my.addFirst({ aa: 11, vv: 'asdf' })
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa');
     *      
     *      my.addFirst({ aa: 11, vv: 'asdf' })
     *      11key{ aa: 11, vv: 'asdf' }value
     * 
     * key
     *
     * @public
     * @param {(*|Object)} item 
     * @param {string=} key HashMap
     * @return {LinkedHashMap} 
     */
    LINKED_HASH_MAP_CLASS.addFirst = function (item, key) {
        if (key == null) {
            // 
            key = this.$retieval(item, this._sDefaultKeyAttr);
            item = this.$retieval(item, this._sDefaultValueAttr);
        }

        var node = { key: key, item: item, pre: null, next: null };
        this._oMap[key] = node;
        this.$insert(node, null, this._oHead);
        return this;
    };

    /**
     * 
     * 
     *      my.insertBefore('asdf', 11, 333)
     *      11key'asdf'value333refKey  
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      
     *      my.insertBefore({ aa: 11, vv: 'asdf' }, 333)
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa');
     *      
     *      my.insertBefore({ aa: 11, vv: 'asdf' }, 333)
     *      11key{ aa: 11, vv: 'asdf' }value
     * 
     * key
     *
     * @public
     * @param {(*|Object)} item 
     * @param {string=} key itemHashMap
     * @param {string} refKey refKey
     * @return {LinkedHashMap} 
     */
    LINKED_HASH_MAP_CLASS.insertBefore = function () {
        var item;
        var key;
        var refKey;
        var arg = arguments;
        if (arg.length == 2) {
            // 
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            refKey = arg[1];
        }
        else {
            // 
            item = arg[0];
            key = arg[1];
            refKey = arg[2];
        }        

        var refNode = this._oMap[refKey];
        var node = { key: key, item: item, pre: null, next: null };
        if (refNode) {
            this._oMap[key] = node;
            this.$insert(node, refNode.pre, refNode);
        }
        return this;
    };

    /**
     * 
     * 
     *      my.insertAfter('asdf', 11, 333)
     *      11key'asdf'value333refKey  
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      
     *      my.insertAfter({ aa: 11, vv: 'asdf' }, 333)
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa');
     *      
     *      my.insertAfter({ aa: 11, vv: 'asdf' }, 333)
     *      11key{ aa: 11, vv: 'asdf' }value
     * 
     * key
     * 
     * @public
     * @param {(*|Object)} item 
     * @param {string=} key itemHashMap
     * @param {string} refKey refKey
     * @return {LinkedHashMap} 
     */
    LINKED_HASH_MAP_CLASS.insertAfter = function () {
        var item;
        var key;
        var refKey;
        var arg = arguments;
        if (arg.length == 2) {
            // 
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            refKey = arg[1];
        }
        else {
            // 
            item = arg[0];
            key = arg[1];
            refKey = arg[2];
        }

        var refNode = this._oMap[refKey];
        var node = { key: key, item: item, pre: null, next: null };
        if (refNode) {
            this._oMap[key] = node;
            this.$insert(node, refNode, refNode.next);
        }
        return this;
    };

    /**
     * 
     * 
     *      my.insertAt('asdf', 11, 0)
     *      11key'asdf'value0index     
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      
     *      my.insertAt({ aa: 11, vv: 'asdf' }, 0)
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa');
     *      
     *      my.insertAt({ aa: 11, vv: 'asdf' }, 0)
     *      11key{ aa: 11, vv: 'asdf' }value
     * 
     * key
     *
     * @public
     * @param {(*|Object)} item 
     * @param {string=} key itemHashMap
     * @param {Object} index 0
     * @return {LinkedHashMap} 
     */
    LINKED_HASH_MAP_CLASS.insertAt = function () {
        var item;
        var key;
        var index;
        var arg = arguments;
        if (arg.length == 2) {
            // 
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            index = arg[1];
        }
        else {
            // 
            item = arg[0];
            key = arg[1];
            index = arg[2];
        }

        if (index != null && index == this.size()) {
            this.addLast(item, key);
        }
        else {
            var ref = this.getAt(index);
            if (ref && ref.key != null) {
                this.insertBefore(item, key, ref.key);
            }
        }
        return this;
    };

    /**
     * LinkedHashMap
     *
     * @public
     */
    LINKED_HASH_MAP_CLASS.clean = function () {
        this._oMap = {};
        this._oHead = null;
        this._oTail = null;
        this._nLength = 0;
        this._sDefaultKeyAttr = null;
        this._sDefaultValueAttr = null;
    };

    /**
     * LinkedHashMapdefaultKeyAttrdefaultValueAttr
     *
     * @public
     */
    LINKED_HASH_MAP_CLASS.cleanWithoutDefaultAttr = function () {
        this._oMap = {};
        this._oHead = null;
        this._oTail = null;
        this._nLength = 0;
    };

    /**
     * 
     * 
     *      my.set(11, 'asdf')
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      
     *      my.set({ aa: 11, vv: 'asdf' })
     *      11key'asdf'value
     * 
     *      
     *      var my = new LinkedHashMap(null, 'aa');
     *      
     *      my.set({ aa: 11, vv: 'asdf' })
     *      11key{ aa: 11, vv: 'asdf' }value
     * 
     * key
     * 
     * @public
     * @param {Object=} key itemHashMap
     * @param {(*|Object)} item 
     * @return {LinkedHashMap} 
     */
    LINKED_HASH_MAP_CLASS.set = function () {
        var key;
        var item;
        var arg = arguments;
        if (arg.length == 1) {
            // 
            item = arg[0];
        } 
        else {
            // 
            key = arg[0];
            item = arg[1];
        }

        // 
        var node = this._oMap[key]
        if (node) {
            node.item = item;
        }
        // 
        else {
            this.addLast(item, key);
        }
        return this;
    };
    
    /**
     * 
     * 
     * @public
     * @param {Object} key itemHashMap
     * @return {*} null
     */
    LINKED_HASH_MAP_CLASS.get = function (key) {
        var node = this._oMap[key];
        return node ? node.item : null;
    };
    
    /**
     * index
     * 
     * @public
     * @param {Object} index 0
     * @return {Object} ret 
     *              
     *              { key:'321', value: { id: '321', name: 'ss' } }
     *              null
     * @return {number} ret.key HashMapkey
     * @return {*} ret.item 
     */
    LINKED_HASH_MAP_CLASS.getAt = function (index) {
        var ret = {};
        this.foreach(function (key, item, i) {
            if (index == i) {
                ret.key = key;
                ret.item = item;
                return false;
            }
        });
        return ret.key != null ? ret : null;
    };

    /**
     * keyindex
     * 
     * @public
     * @param {Object} key itemHashMap
     * @param {number} index 0-1
     */
    LINKED_HASH_MAP_CLASS.getIndex = function (key) {
        var index = -1;
        this.foreach(function (k, item, i) {
            if (k == key) {
                index = i;
                return false;
            }
        });
        return index;
    };
    
    /**
     * key
     * 
     * @public
     * @param {Object} item 
     * @param {Object} key itemHashMap
     */
    LINKED_HASH_MAP_CLASS.getKey = function (item) {
        var key;
        this.foreach(function (k, o, i) {
            if (o.item == item) {
                key = k;
                return false;   
            }
        });
        return key;
    };

    /**
     * 
     * 
     * @public
     * @param {Object} key itemHashMap
     * @return {boolean} 
     */
    LINKED_HASH_MAP_CLASS.containsKey = function (key) {
        return !!this.get(key);
    };

    /**
     * Array
     * 
     * @public
     * @return {Array} 
     */
    LINKED_HASH_MAP_CLASS.list = function () {
        var ret = [];
        this.foreach(function (key, item) { ret.push(item); });
        return ret;
    };

    /**
     * 
     * 
     * @public
     * @param {Function} visitFunc 
     *          param {string} key key
     *          param {*} item 
     *          param {number} index 
     *          return {boolan} false
     */
    LINKED_HASH_MAP_CLASS.foreach = function (visitFunc) {
        var node = this._oHead;
        var i = 0;
        var goOn = true;
        while (node) {
            if (visitFunc(node.key, node.item, i++) === false) { 
                break; 
            }
            node = node.next;
        }
    };

    /**
     * key
     * 
     * @public
     * @param {Object} key itemHashMap
     * @return {*} 
     */
    LINKED_HASH_MAP_CLASS.remove = function (key) {
        var node = this._oMap[key];
        if (node) {
            delete this._oMap[key];
            var preNode = node.pre;
            var nextNode = node.next;
            preNode && (preNode.next = nextNode);
            nextNode && (nextNode.pre = preNode);
            this._nLength --; 
            (this._oHead == node) && (this._oHead = nextNode); 
            (this._oTail == node) && (this._oTail = preNode);
        }
        return node ? node.item : null;
    };

    /**
     * LinkedHashMap
     * 
     * @public
     * @return {number} LinkedHashMap
     */
    LINKED_HASH_MAP_CLASS.size = function () {
        return this._nLength;
    };

    /**
     * 
     * 
     * @public
     * @return {*} 
     */
    LINKED_HASH_MAP_CLASS.first = function () {
        return this._oHead ? this._oHead.item : null;
    };
    
    /**
     * key
     * 
     * @public
     * @return {string} key
     */
    LINKED_HASH_MAP_CLASS.firstKey = function () {
        return this._oHead ? this._oHead.key : null;
    };

    /**
     * 
     * 
     * @public
     * @return {*} 
     */
    LINKED_HASH_MAP_CLASS.last = function () {
        return this._oTail ? this._oTail.item : null;
    };
    
    /**
     * key
     * 
     * @public
     * @return {string} key
     */
    LINKED_HASH_MAP_CLASS.lastKey = function () {
        return this._oTail ? this._oTail.key : null;
    };

    
    /**
     * keynull
     * 
     * @public
     * @param {Object} key itemHashMap
     * @param {boolean=} circular false
     * @return {*} 
     */
    LINKED_HASH_MAP_CLASS.next = function (key, circular) {
        var node = this.$next(key, circular);
        return node ? node.item : null;
    };
    
    /**
     * keykeynull
     * 
     * @public
     * @param {Object} key itemHashMap
     * @param {boolean=} circular false
     * @return {string} key
     */
    LINKED_HASH_MAP_CLASS.nextKey = function (key, circular) {
        var node = this.$next(key, circular);
        return node ? node.key : null;
    };
    

    /**
     * keynull
     * 
     * @public
     * @param {Object} key itemHashMap
     * @param {boolean=} circular false
     * @return {*} 
     */
    LINKED_HASH_MAP_CLASS.previous = function (key, circular) {
        var node = this.$previous(key, circular);
        return node ? node.item : null;
    };
    
    /**
     * keykeynull
     * 
     * @public
     * @param {Object} key itemHashMap
     * @param {boolean=} circular false
     * @return {string} key
     */
    LINKED_HASH_MAP_CLASS.previousKey = function (key, circular) {
        var node = this.$previous(key, circular);
        return node ? node.key : null;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$next = function (key, circular) {
        var node = this._oMap[key];
        if (!node) { return null; }
        var next = (circular && node == this._oTail) 
                ? this._oHead : node.next;
        return next;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$previous = function (key, circular) {
        var node = this._oMap[key];
        if (!node) { return null; }
        var pre = (circular && node == this._oHead) 
                ? this._oTail : node.pre;
        return pre;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$retieval = function (item, attr) {
        var k;
        if (Object.prototype.toString.call(attr) == '[object Function]') {
            k = attr(item);
        } 
        else if (attr == null) {
            k = item;
        } 
        else {
            k = item[attr];
        }
        return (k === void 0) ? null : k;
    };   

    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$insert = function (node, preNode, nextNode) {
        node.pre = preNode;
        node.next = nextNode;
        preNode ? (preNode.next = node) : (this._oHead = node);
        nextNode ? (nextNode.pre = node) : (this._oTail = node);
        this._nLength ++;
    };
    
})();

/**
 * xutil.ajax
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    Ajaxajax
 *          
 *          (1) 
 *          (2) 
 *             showWaiting
 *          (3) 
 *          (4) completefinalize
 *          (5) 
 *              /
 *              abortabort
 *              tokenId
 *              tokenId
 *              pending
 *              
 *              abort
 *              TODO
 *              businessKey
 *          (6) abort
 *              webabort
 *              dom
 *          (7) 
 *              createSyncWrap
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  tangram.ajax, e-json, xutil.ajax
 */

(function () {
    
    var AJAX = xutil.ajax;
    var exRequest = baidu.ejson.request;
        
    /**
     * 
     */
    /**
     * ajax
     * ajaxoptions
     *
     * @type {Object}
     * @public
     * @see ajax.request
     */
    AJAX.DEFAULT_OPTIONS = null;
    /**
     * 
     * 
     * false
     *
     * @type {Function}
     * @public
     * @param {number} status ajax
     * @param {(Object|string)} obj e-json
     * @param {Function} defaultCase 
     */
    AJAX.DEFAULT_FAILURE_HANDLER = null;
    /**
     * 
     * 
     *
     * @type {Function}
     * @public
     */
    AJAX.DEFAULT_TIMEOUT_HANDLER = null;
    /**
     * 
     *
     * @type {Function}
     * @public
     * @return {string} a=5&a=2&b=xxx
     */
    AJAX.DEFAULT_PARAM = null;
    /**
     * 
     *
     * @type {Function}
     * @public
     */
    AJAX.SHOW_WAITING_HANDLER = null;
    /**
     * 
     *
     * @type {Function}
     * @public
     */
    AJAX.HIDE_WAITING_HANDLER = null;
    /**
     * false
     *
     * @type {Function}
     * @public
     */
    AJAX.DEFAULT_SHOW_WAITING = false;
        
    /**
     * xhr
     * {requestId: {xhr: <xhr>, clear: <clear>}}
     * 
     * @type {Object}
     * @private
     */
    var xhrSet = {};
    /**
     * businessKey
     * {businessKey: requestId}
     *
     * @type {Object}
     * @private
     */
    var businessSet = {};
    /**
     * requestId
     * xhrSet
     * {requestId: 1}
     *
     * @type {Object}
     * @private
     */
    var waitingSet = {};
    /**
     * waitingSet
     *
     * @type {number}
     * @private
     */
    var waitingCount = 0;
    /**
     * ID
     *
     * @type {number}
     * @private
     */
    var uniqueIndex = 1;
    
    /**
     * append
     *
     * @private
     * @param {string} data 
     */
    function appendDefaultParams(data) {
        var paramArr = [];

        if (hasValue(data) && data !== '') {
            paramArr.push(data);
        }

        var defaultParamStr = AJAX.DEFAULT_PARAM ? AJAX.DEFAULT_PARAM() : '';
        if (hasValue(defaultParamStr) && defaultParamStr !== '') {
            paramArr.push(defaultParamStr);
        }

        return paramArr.join('&');
    }
    
    /**
     * 
     *
     * @private
     * @param {string} msg 
     */
    function log(msg) {
        isObject(window.console) 
            && isFunction(window.console.log) 
            && window.console.log(msg);
    }
    
    /**
     * 
     *
     * @private
     * @param {string} requestId ID
     * @param {boolean} showWaiting 
     */
    function handleShowWaiting(requestId, showWaiting) {
        if (showWaiting) {
            waitingSet[requestId] = 1;
            (waitingCount ++) == 0
                && AJAX.SHOW_WAITING_HANDLER 
                && AJAX.SHOW_WAITING_HANDLER();
        }
    }
    
    /**
     * 
     *
     * @private
     * @param {string} requestId ID
     */
    function handleHideWaiting(requestId) {
        if (waitingSet[requestId]) {
            delete waitingSet[requestId];
            (-- waitingCount) <= 0 
                && AJAX.HIDE_WAITING_HANDLER 
                && AJAX.HIDE_WAITING_HANDLER();
        }
    }
    
    /**
     * abort
     *
     * @private
     * @param {string} businessKey 
     * @param {string} requestId ID
     */
    function handleBusinessAbort(businessKey, requestId) {
        var oldRequestId;
        if (hasValue(businessKey)) {
            (oldRequestId = businessSet[businessKey]) 
                && AJAX.abort(oldRequestId, true);
            businessSet[businessKey] = requestId;
        }
    }
    
    /**
     * 
     *
     * @private
     * @param {string} businessKey 
     */
    function handleBusinessClear(businessKey) {
        if (hasValue(businessKey)) {
            delete businessSet[businessKey];   
        }
    }
    
    /**
     * 
     * 
     * @public
     * @param {string} url
     * @param {Objet} options
     * @param {string} options.data GETURL
     * @param {string} options.method http method, 'POST''GET', 'POST'
     * @param {string} options.businessKey abort
     *              
     *              
     *              abort
     *              
     *              
     *              
     *              
     * @param {boolean} options.showWaiting true
     *              SHOW_WAITING_HANDLERHIDE_WAITING_HANDLER
     *              falseDEFAULT_SHOW_WAITING
     * @param {Function} options.onsuccess 
     *              param {Object} data e-json
     *              param {Object} obj e-json
     * @param {Function} options.onfailure 
     *              param {number} status e-json
     *              param {(Object|string)} obj e-json
     * @param {Function} options.oncomplete 
     *              onsuccessonfailure
     *              param {(Object|string)} obj e-json 
     *              return {boolean} falseonsuccesonfailure
     * @param {Function} options.onfinalize 
     *              onsuccessonfailure
     *              param {(Object|string)} obj e-json
     * @param {Function} options.defaultFailureHandler 
     *              
     *              param {number} status e-json
     *              param {(Object|string)} obj e-json
     * @param {number} options.timeout 
     * @param {Function} options.ontimeout 
     * @param {string} options.syncName createSyncWrap
     * @param {Object} options.syncWrap createSyncWrap
     * @return {string} options.requestId requestabort
     */
    AJAX.request = function (url, options) {
        options = extend(
            extend(
                {}, AJAX.DEFAULT_OPTIONS || {}
            ), 
            options || {}
        );
        var requestId = 'AJAX_' + (++uniqueIndex);
        var businessKey = options.businessKey;
        var defaultFailureHandler = 
                options.defaultFailureHandler || null;
        var timeout = options.timeout || 0;
        var ontimeout = options.ontimeout;
        var onfailure = options.onfailure;
        var onsuccess = options.onsuccess;
        var oncomplete = options.oncomplete;
        var onfinalize = options.onfinalize;
        var showWaiting = options.showWaiting || AJAX.DEFAULT_SHOW_WAITING;
        var syncWrap = options.syncWrap;
        var syncName = options.syncName;
        var xhr;
        
        function clear() {
            defaultFailureHandler = ontimeout = 
            onfailure = onsuccess = 
            onfinalize = oncomplete = xhr = options = null;

            delete xhrSet[requestId];
            handleBusinessClear(businessKey);
            handleHideWaiting(requestId);
        }

        // tangramajax
        options.noCache = true;

        options.method = options.method || 'POST';

        options.data = appendDefaultParams(options.data || '');

        // sucess handler
        options.onsuccess = function (data, obj) {
            if (requestId in xhrSet) { // abort
                try {
                    if (!oncomplete || oncomplete(obj) !== false) {
                        onsuccess(data, obj);
                    }
                    onfinalize && onfinalize(obj);
                } 
                catch (e) {
                    AJAX.errorMsg = e.message;
                }
                finally {
                    syncWrap && syncWrap.done(syncName);
                    clear();
                }
            }
        };

        // failure handler
        options.onfailure = function (status, obj) {
            var needDef;
            if (requestId in xhrSet) { // abort
                try {
                    if (!oncomplete || oncomplete(obj) !== false) {
                        needDef = onfailure(status, obj);
                    }
                    onfinalize && onfinalize(obj);
                } 
                catch (e) {
                    AJAX.errorMsg = e.message;
                }
                finally {
                    if (needDef !== false) {
                        if (AJAX.DEFAULT_FAILURE_HANDLER) {
                            AJAX.DEFAULT_FAILURE_HANDLER(
                                status, obj, defaultFailureHandler
                            );
                        }
                        else if (defaultFailureHandler) {
                            defaultFailureHandler(status, obj);
                        }
                    }
                    syncWrap && syncWrap.done(syncName);
                    clear();
                }
            }
        };

        // timeout handler
        options.ontimeout = function () {
            try {
                if (!oncomplete || oncomplete(obj) !== false) {
                    ontimeout && ontimeout();
                }
                onfinalize && onfinalize(obj);
            } 
            catch (e) {
                AJAX.errorMsg = e.message;
            }
            finally {
                AJAX.DEFAULT_TIMEOUT_HANDLER 
                    && AJAX.DEFAULT_TIMEOUT_HANDLER();
                syncWrap && syncWrap.done(syncName);
                clear();
            }
        };

        if (timeout > 0) {
            options.timeout = timeout;
            options.ontimeout = timeoutHandler;
        } 
        else {
            delete options.timeout;
        }
        
        handleShowWaiting(requestId, showWaiting);
        
        handleBusinessAbort(requestId, businessKey);
        
        // 
        xhrSet[requestId] = {
            xhr: exRequest(url, options),
            clear: clear
        };
        
        return requestId;
    }

    /**
     * POST
     * 
     * @public
     * @param {string} url
     * @param {string} data GETURL
     * @param {Function} onsuccess @see AJAX.request
     * @param {Function} onfailure @see AJAX.request
     * @param {Objet} options @see AJAX.request
     * @return {string} requestId requestabort
     */
    AJAX.post = function (url, data, onsuccess, onfailure, options) {
        options = options || {};
        options.method = 'POST';
        options.data = data;
        options.onsuccess = onsuccess;
        options.onfailure = onfailure;
        return AJAX.request(url, options);
    };

    /**
     * GET
     * 
     * @public
     * @param {string} url
     * @param {string} data GETURL
     * @param {Function} onsuccess @see AJAX.request
     * @param {Function} onfailure @see AJAX.request
     * @param {Objet} options @see AJAX.request
     * @return {string} requestId requestabort
     */
    AJAX.get = function (url, data, onsuccess, onfailure, options) {
        options = options || {};
        options.method = 'GET';
        options.data = data;
        options.onsuccess = onsuccess;
        options.onfailure = onfailure;
        return AJAX.request(url, options);        
    };

    /**
     * requestId
     * 
     * 
     * @public
     * @param {string} requestId request
     *          abort
     * @param {boolean} silence abortonfailure
     *          truefalsetrue
     */
    AJAX.abort = function (requestId, silence) {
        var willAbort = [];
        var i;
        var wrap;
        silence = silence || true;
        
        if (hasValue(requestId)) {
            (requestId in xhrSet) && willAbort.push(requestId);
        } 
        else {
            for (i in xhrSet) { willAbort.push(i); }
        }
        
        for (i = 0; requestId = willAbort[i]; i++) {
            try {
                wrap = xhrSet[requestId];
                silence && delete xhrSet[requestId];
                wrap.xhr.abort();
                wrap.clear.call(null);
            } catch (e) {
                log(
                    '[ERROR] abort ajax error. requestId=' + 
                        requestId + ', e=' + e
                );
            }
        }
    };
    
    /**
     * businessKey
     * 
     * 
     * @public
     * @param {string} businessKey 
     * @param {boolean} silence abortonfailure
     *          truefalsetrue
     */
    AJAX.abortBusiness = function (businessKey, silence) {
        var requestId = businessSet[businessKey];
        if (hasValue(requestId)) {
            delete businessSet[businessKey];
            AJAX.abort(requestId);
        }
    };

    /**
     * 
     * 
     * @public
     * @usage callbackXab
     *        (1) 
     *          var reqWrap = ajax.syncRequest(
     *              ['a', 'b'], 
     *              function() { ... this is the callback } 
     *          );
     *        (2) 
     *          // a
     *          ajax.request(url, { syncName: 'a', syncWrap: reqWrap }); 
     *          // b
     *          ajax.request(url, { syncName: 'b', syncWrap: reqWrap });
     *          reqWrapab
     * 
     * @param {Array} syncNameList 
     * @param {Function} callback 
     * @return {Object} request
     */
    AJAX.createSyncWrap = function (syncNameList, callback) {
        return new SyncWrap(syncNameList, callback);
    };

    /**
     * 
     *
     * @constructor
     * @private
     * @param {Array} syncNameList 
     * @param {Array} callback 
     */
    function SyncWrap(syncNameList, callback) {
        var i;
        this.syncNameMap = {};
        for (i = 0, syncNameList = syncNameList || []; i < syncNameList.length; i ++) {
            this.syncNameMap[syncNameList[i]] = 0;
        }
        this.callback = callback || new Function();
    }

    /**
     * 
     *
     * @public
     * @param {string} syncName 
     */
    SyncWrap.prototype.done = function (syncName) {
        var name;
        this.syncNameMap[syncName] = 1;
        for (name in this.syncNameMap) {
            if (!this.syncNameMap[name]) { return; }
        }
        this.callback.call(null);
    };

    /**
     * 
     *
     * @private
     * @param {Object} target 
     * @param {Object} source 
     * @return {Object} 
     */
    function extend(target, source) {
        for (var key in source) { target[key] = source[key]; }
        return target;
    }

    /**
     * 
     *
     * @private
     * @param {*} variable 
     * @return {boolean} 
     */
    function isFunction(variable) {
        return Object.prototype.toString.call(variable) == '[object Function]';        
    }

    /**
     * 
     *
     * @private
     * @param {*} variable 
     * @return {boolean} 
     */
    function hasValue(variable) {
        return variable != null;
    }

    /**
     * 
     *
     * @private
     * @param {*} variable 
     * @return {boolean} 
     */
    function isObject(variable) {
        return variable === Object(variable);
    }

})();

/**
 * xutil.collection
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.object
 */

(function () {
    
    var COLLECTION = xutil.collection;
    var OBJECT = xutil.object;
    
    /**
     * targetlistfield
     * 
     * @public
     * @param {*} target 
     * @param {Array} list 
     * @param {string} field 
     *      listvalueInList
     * @param {Function} equalsFunc ==
     *          
     *          param {*} target 
     *          param {*} valueInList list
     *          return {boolean} 
     * @return {boolean} 
     */
    COLLECTION.inList = function (target, list, field, equalsFunc) {
        if (target == null || !list) {
            return false;
        }

        for(var i = 0, l = list.length, v; i < l; i ++) {
            v = list[i];
            if (v == null && field) { continue; }

            v = field ? v[field] : v;
            if (equalsFunc ? equalsFunc(target, v) : (target == v)) {
                return true;
            }
        }

        return false;
    };

    /**
     * SQL
     * 
     * @public
     * @param {*} target 
     * @param {Array} list 
     * @param {string} selectField select
     * @param {string} whereField where
     * @param {*} whereValue where
     * @param {Function} equalsFunc ==
     *          
     *          param {*} target 
     *          param {8} valueInList list
     *          return {boolean} 
     * @return {Array} 
     */
    COLLECTION.selectFromWhere = function (
        fromList, selectField, whereField, whereValue, equalsFunc
    ) {
        var ret = [];

        if (whereValue == null || !fromList || !whereField || !selectField) {
            return ret;
        }

        for(var i = 0, l = fromList.length, v, s; i < l; i ++) {
            if (!(v = fromList[i])) { continue };

            s = v[whereField];
            if (equalsFunc ? equalsFunc(whereValue, s) : whereValue == s) {
                ret.push(v[selectField]);
            }
        }

        return ret;
    };
    
    /**
     * SQL
     * 
     * @public
     * @param {*} target 
     * @param {Array} list 
     * @param {string} selectField select
     * @param {string} whereField where
     * @param {*} whereValue where
     * @param {Function} equalsFunc ==
     *          param {*} target 
     *          param {*} valueInList list
     *          return {boolean} 
     * @return {*} 
     */
    COLLECTION.selectSingleFromWhere = function (
        fromList, selectField, whereField, whereValue, compareFunc
    ) {
        var result = COLLECTION.selectFromWhere(
                fromList, selectField, whereField, whereValue, compareFunc
            );
        return (result && result.length>0) ? result[0] : null;
    };
    
    /**
     *  ()
     * 
     * @public
     * @param {string} field listvalueInList
     * @param {(string|Function)} compareFunc 
     *          stringFunctioncompareFunc"<" 
     *          String: ">", 
     *                                "<"
     *          Function: v1v2
     *              param {*} v1 
     *              param {*} v2 
     *              return {boolean} true:v1v2false:v1v2
     * @param {boolean} willNew true:listlist; 
     *          false:list; :false
     * @return {Array} 
     */
    COLLECTION.sortList = function (list, field, compareFunc, willNew) {
        
        willNew && (list = OBJECT.clone(list));
        field = field != null ? field : null;    
        
        if (compareFunc == '>') {
            compareFunc = function (v1, v2) { 
                var b1 = v1 != null;
                var b2 = v2 != null;
                return (b1 && b2) 
                            ? (v1 >= v2) /**/ 
                            : (b1 || !b2); /*true*/
            }
        } 
        else if (compareFunc == '<') {
            compareFunc = function (v1, v2) { 
                var b1 = v1 != null;
                var b2 = v2 != null;
                return (b1 && b2) 
                            ? (v1 <= v2) /**/ 
                            : (!b1 || b2); /*true*/
            }
        }
        
        var item1;
        var item2; 
        var v1;
        var v2;
        var switched = true;

        for (var i = 0, li = list.length - 1; i < li && switched; i ++) {
            switched = false;
            
            for (var j = 0, lj = list.length - i - 1; j < lj; j ++) {
                item1 = list[j];
                v1 = item1 != null ? (field ? item1[field] : item1) : null;
                item2 = list[j + 1];
                v2 = item2 != null ? (field ? item2[field] : item2) : null;
                if (!compareFunc(v1, v2)) {
                    list[j] = item2;
                    list[j + 1] = item1;
                    switched = true;
                }
            }
        }

        return list;    
    };
    
    /**
     * 
     * 
     * 
     * @public
     * @usage
     *      travelTree(root, funciton (node, options) { 
     *          do something ... 
     *      }, '_aChildren');
     * 
     * @param {Object} travelRoot 
     * @param {Function} callback 
     *          
     *          param {Object} node 
     *          param {Object} options 
     *          param {number} options.level 0
     *          param {number} options.index 0
     *          param {Object} options.parent 
     *          param {Object} options.globalParam 
     *          param {Object} options.parentParam
     *              callback
     *              callback
     *          param {Object} options.childrenParam 
     *              callback
     *              callback
     *          return {number} STOP_ALL_TRAVEL
     *              STOP_SUB_TREE_TRAVEL
     * @param {string} childrenField 'children'
     * @param {boolean} postorder truefalse
     * @param {Object} globalParam 
     */
    COLLECTION.travelTree = function (
        travelRoot, callback, childrenField, postorder, globalParam
    ) {
        $travelTree(
            travelRoot, 
            callback, 
            childrenField, 
            postorder, 
            0, 
            null, 
            { index:0 }, 
            {}, 
            {}, 
            globalParam || {}
        );
    }

    // 
    COLLECTION.STOP_ALL_TRAVEL = 1; 
    // 
    COLLECTION.STOP_SUB_TREE_TRAVEL = 2; 
    
    function $travelTree(
        travelRoot, 
        callback, 
        childrenField, 
        postorder, 
        level, 
        parent, 
        indexRef, 
        inToChildrenParam, 
        inToParentParam, 
        globalParam
    ) {
        if (travelRoot == null) {
            return;
        }
            
        postorder = !!postorder;
        
        var conti;
        var toChildrenParam;
        var toParentParam;

        if (!postorder) {
            conti = callback.call(
                null, 
                travelRoot, 
                {
                    level: level, 
                    index: indexRef.index, 
                    parent: parent, 
                    childrenParam: (toChildrenParam = {}), 
                    parentParam: inToChildrenParam,
                    globalParam: globalParam
                }
            );
            indexRef.index ++;
        }
        
        if (conti === COLLECTION.STOP_ALL_TRAVEL) {
            return conti; 
        }
        if (conti === COLLECTION.STOP_SUB_TREE_TRAVEL) { 
            return; 
        }
        
        var children = travelRoot[childrenField || 'children'] || [];
        for (var i = 0, len = children.length, node; i < len; i ++) {
            node = children[i];
            
            conti = $travelTree(
                node, 
                callback, 
                childrenField, 
                postorder, 
                level + 1, 
                travelRoot, 
                indexRef, 
                toChildrenParam, 
                (toParentParam = {}), 
                globalParam
            );
                
            if (conti === COLLECTION.STOP_ALL_TRAVEL) { 
                return conti; 
            }
        }
        
        if (postorder && conti !== COLLECTION.STOP_ALL_TRAVEL) { 
            conti = callback.call(
                null, 
                travelRoot, 
                {
                    level: level, 
                    index: indexRef.index, 
                    parent: parent, 
                    childrenParam: toParentParam, 
                    parentParam: inToParentParam,
                    globalParam: globalParam
                }
            );
            indexRef.index ++;
        }
        
        if (conti === COLLECTION.STOP_ALL_TRAVEL) { 
            return conti; 
        }
    };    

})();

/**
 * xutil.date
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @change: format#isValidFormatPatternby MENGRAN at 2013-12-06
 * @file:   
 *          
 * @author: sushuang(sushuang@baidu.com)
 * @depend: xutil.lang, xutil.number
 */

(function () {
    
    var DATE = xutil.date;
    var LANG = xutil.lang;
    var NUMBER = xutil.number;
        
    var DAY_MILLISECOND = 24*60*60*1000;
    
    /**
     * 
     * 'yyyy-MM-dd hh:mm''yyyy-MM-dd''yyyy-MM''yyyy'
     * 
     *
     * @type {string}
     * @public
     */
    DATE.DATE_FORMAT = 'yyyy-MM-dd';
    DATE.MINUTE_FORMAT = 'yyyy-MM-dd hh:mm';
    DATE.SECONDS_FORMAT = 'yyyy-MM-dd HH:mm:ss';

    /*
    *
    */
    DATE.TIME_REG = /h{1,2}:m{1,2}:s{1,2}$/i;
    
    /**
     * Add by MENGRAN at 2013-12-6
     * pattern
     * 
     * @public
     * @param {string} format 
     * @return {boolean} 
     */
    DATE.isValidFormatPattern = function (format) {
        if (format && 
            (format === DATE.DATE_FORMAT || format === DATE.MINUTE_FORMAT || format === DATE.SECONDS_FORMAT)) { return true; }
        return false;
    };

    /**
     * 
     * 
     * @public
     * @param {Date} currDate 
     * @param {string} format yyyy-MM-dd
     * @return {string} 
     */
    DATE.dateToString = function (date, format) {
        if (!date) { return ''; }
        format = format || DATE.DATE_FORMAT;
        return DATE.format(date, format);
    };
    
    /**
     * 
     * 
     * @public
     * @param {Date} date 
     * @param {string} format yyyy-MM-dd
     * @return {string} 
     */
    DATE.dateToStringM = function (date) {
        return DATE.dateToString(date, DATE.MINUTE_FORMAT);
    };
    
    
    /**
     * 
     * 
     * @public
     * @param {string} dateStr yyyy-MM-dd   yyyy-MM  yyyy
     * @return {Date} null
     */
    DATE.stringToDate = function (dateStr) {
        if (dateStr) {
            return DATE.parse(dateStr);
        }
        return null;
    };
    
    /**
     * 
     * 
     * @public
     * @param {Date} date 
     * @return {Date} 
     */
    DATE.getYesterday = function (date) {
        if (!date) { return null; }
        return DATE.addDay(date, -1, true);
    };
    
    /**
     * 
     * 
     * @public
     * @param {Date} date 
     * @return {string} 
     */
    DATE.getYesterdayString = function (date) {
        if (!date) { return null; }
        return DATE.dateToString(DATE.getYesterday(date));
    };
    
    /**
     * 
     * 
     * @public
     * @param {Date} date 
     * @param {boolean=} mode 
     *      true:   false:
     * @param {boolean=} remain false
     *                         true
     *                         false
     */
    DATE.getWeekend = function (date, mode, remain) {
        var weekend = remain ? date : new Date(date);
        var offset = mode 
                ? (6 - weekend.getDay()) 
                : (7 - weekend.getDay()) % 7;
        weekend.setDate(weekend.getDate() + offset);
        return weekend;
    }
    
    /**
     * 
     * 
     * @public
     * @param {Date} date 
     * @param {boolean=} mode 
     *      true:   false:
     * @param {boolean=} remain false
     *                         true
     *                         false
     */
    DATE.getWorkday = function (date, mode, remain) {
        var workday = remain ? date : new Date(date);
        var d = workday.getDate();
        d = mode 
                ? (d - workday.getDay()) 
                : (d - (6 + workday.getDay()) % 7);
        workday.setDate(d);
        return workday;
    }
    
    /**
     * 
     * 
     * @public
     * @param {(string|Date)} date 
     * @return {number} 
     */
    DATE.dateCountFromYearBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var startDate = new Date(date.getTime());
        startDate.setDate(1);
        startDate.setMonth(0);
        return DATE.dateMinus(date, startDate) + 1;
    };
    
    /**
     * 
     * 
     * @public
     * @param {(string|Date)} date 
     * @return {number} 
     */
    DATE.dateCountFromQuarterBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        return DATE.dateMinus(date, DATE.getQuarterBegin(date)) + 1;
    };
    
    /**
     * 
     * 
     * @public
     * @param {(string|Date)} date 
     * @return {number} 
     */
    DATE.dateCountFromMonthBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var startDate = new Date(date.getTime());
        startDate.setDate(1);
        return DATE.dateMinus(date, startDate) + 1;
    };
    
    /**
     * 1~4
     * 
     * @public
     * @param {(string|Date)} date 
     * @return {number} 1~4
     */
    DATE.getQuarter = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        return Math.floor(date.getMonth() / 3) + 1 ;
    };
    
    /**
     * 
     * 
     * @public
     * @param {(string|Date)} date 
     * @return {Date} 
     */
    DATE.getQuarterBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var quarter = DATE.getQuarter(date);
        var mon = [0, 0, 3, 6, 9];
        return new Date(date.getFullYear(), mon[quarter], 1);
    };

    
    /**
     * 
     * 
     * @public
     * @param {(string|Date)} date1 1
     * @param {(string|Date)} date2 2
     * @return {string} 
     */
    DATE.sameDate = function (date1, date2) {
        if (!date1 || !date2) { return false; }
        LANG.isString(date1) && (date1 = DATE.stringToDate(date1));
        LANG.isString(date2) && (date2 = DATE.stringToDate(date2));
        return date1.getFullYear() == date2.getFullYear() 
               && date1.getMonth() == date2.getMonth()
               && date1.getDate() == date2.getDate();
    };
    
    /**
     * 
     * 
     * @public
     * @param {(string|Date)} date1 1
     * @param {(string|Date)} date2 2
     * @return {string} 
     *      -1: date1 < date2;  0: date1 == date2;  1: date1 > date2
     */
    DATE.compareDate = function (date1, date2) {
        var year1;
        var year2;
        var month1;
        var month2;
        var date1;
        var date2;

        LANG.isString(date1) && (date1 = DATE.stringToDate(date1));
        LANG.isString(date2) && (date2 = DATE.stringToDate(date2));
        if ((year1 = date1.getFullYear()) == (year2 = date2.getFullYear())) {
            if ((month1 = date1.getMonth()) == (month2 = date2.getMonth())) {
                if ((date1 = date1.getDate()) == (date2 = date2.getDate())) {
                    return 0;
                } 
                else { return date1 < date2 ? -1 : 1; }
            } 
            else { return month1 < month2 ? -1 : 1; }
        } 
        else { return year1 < year2 ? -1 : 1; }
    };
    
    /**
     * date1 - date2
     * date12012-03-13date22012-03-15-21.32
     * 
     * @public
     * @param {(string|Date)} date1 1
     * @param {(string|Date)} date2 2
     * @return {string} 
     *      -1: date1 < date2;  0: date1 == date2;  1: date1 > date2
     * @return {number} 
     */
    DATE.dateMinus = function (date1, date2) {
        // 
        date1 = DATE.stringToDate(DATE.dateToString(date1)); 
        // 
        date2 = DATE.stringToDate(DATE.dateToString(date2)); 
        var t = date1.getTime() - date2.getTime();
        var d = Math.round(t / DAY_MILLISECOND);
        return d;
    };
    
    /**
     * 
     * 
     * @public
     * @param {Date} date 
     * @param {number} num 
     * @param {boolean} willNew true
     *                          false
     *                          false
     * @return {Date} 
     */
    DATE.addDay = function (date, num, willNew) {
        if (!date) { return null; }
        num = num || 0;
        if (willNew) {
            return new Date(date.getTime() + num * DAY_MILLISECOND);
        } 
        else {
            date.setDate(date.getDate() + num);
            return date;
        }
    };
    
    /**
     * 
     * 
     * @public
     * @param {Date} date 
     * @param {number} num 
     * @param {boolean} willNew true
     *                          false
     *                          false
     * @return {Date} 
     */    
    DATE.addMonth = function (date, num, willNew) {
        if (!date) { return null; }
        num = num || 0;
        willNew && (date = new Date(date.getTime()));
        date.setMonth(date.getMonth() + num);
        return date;
    };  
    
    /**
     * num
     * 
     * @public
     * @param {(string|Date)} date
     * @param {number} num 
     * @return {Object} 
     *              {number} year 
     *              {number} month 1~12
     */
    DATE.nextMonth = function (date, num) {
        var year = date.getFullYear();
        var month = date.getMonth();
        return {
            year: year + Math.floor((month + num) / 12),
            month: (month + num + Math.abs(num * 12)) % 12 + 1
        }
    };
    
    /**
     * num
     * 
     * @public
     * @param {(string|Date)} date 
     * @param {number} num 
     * @return {Object} 
     *              {number} year 
     *              {number} quarter 1~4
     */
    DATE.nextQuarter = function (date, num) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date));

        var quarter = DATE.getQuarter(date);
        var year = date.getFullYear();
        return {
            year: year + Math.floor((quarter - 1 + num) / 4),
            quarter: (quarter - 1 + num + Math.abs(num * 4)) % 4 + 1
        };
    };
    
    /**
     * 
     * 
     * @public
     * @param {(string|Date)} date 
     * @param {string} weekPrefix ''
     * @return {string} 
     */
    DATE.getDay = function (date, weekPrefix) {
        if (!date) { return ''; }
        LANG.isString(date) && (date = DATE.stringToDate(date));
        weekPrefix = weekPrefix || '';
        var ret;
        switch (date.getDay()) {
            case 1: ret = weekPrefix + ''; break;
            case 2: ret = weekPrefix + ''; break;
            case 3: ret = weekPrefix + ''; break;
            case 4: ret = weekPrefix + ''; break;
            case 5: ret = weekPrefix + ''; break;
            case 6: ret = weekPrefix + ''; break;
            case 0: ret = weekPrefix + ''; break;
            default: ret = ''; break;
        }
        return ret;
    };
    
    /**
     *  (@see tangram)
     * 
     * hh:  0  12 
     * h:  0  12 
     * HH:  0  24 
     * H:  0  24 
     * mm:  0 
     * m:  0 
     * ss:  0 
     * s:  0 
     * yyyy:  0 
     * yy:  0 
     * MM:  0 
     * M:  0 
     * dd:  0 
     * d:  0 
     * 
     * @public
     * @param {Date} source 
     * @param {string} pattern 
     * @return {string} 
     */
    DATE.format = function (source, pattern) {
        var pad = NUMBER.pad;
        if (!LANG.isString(pattern)) {
            return source.toString();
        }
    
        function replacer(patternPart, result) {
            pattern = pattern.replace(patternPart, result);
        }
        
        var year    = source.getFullYear();
        var month   = source.getMonth() + 1;
        var date2   = source.getDate();
        var hours   = source.getHours();
        var minutes = source.getMinutes();
        var seconds = source.getSeconds();
    
        replacer(/yyyy/g, pad(year, 4));
        replacer(/yy/g, pad(parseInt(year.toString().slice(2), 10), 2));
        replacer(/MM/g, pad(month, 2));
        replacer(/M/g, month);
        replacer(/dd/g, pad(date2, 2));
        replacer(/d/g, date2);
    
        replacer(/HH/g, pad(hours, 2));
        replacer(/H/g, hours);
        replacer(/hh/g, pad(hours % 12, 2));
        replacer(/h/g, hours % 12);
        replacer(/mm/g, pad(minutes, 2));
        replacer(/m/g, minutes);
        replacer(/ss/g, pad(seconds, 2));
        replacer(/s/g, seconds);
    
        return pattern;
    };

    /**
    * 
    *@public
    *@param source 
    *
    **/
    DATE.formatTime = function(source,pattern){
        var pad = NUMBER.pad;
        if (!LANG.isString(pattern)) {
            return source.toString();
        }

        var hour = parseInt(source /3600);

        var day = parseInt(hour / 24);
        hour = parseInt(hour%24);
        var min = parseInt(source%3600 /60);
        var sec = Math.round(source % 60);
        if(day == 0){
            pattern = 'hh:mm:ss';
        }
        function replacer(patternPart, result) {
            pattern = pattern.replace(patternPart, result);
        }

        replacer(/d/ig,day);
        replacer(/hh/ig, hour);
        replacer(/h/ig, hour);
        replacer(/mm/ig, pad(min, 2));
        replacer(/m/ig, min);
        replacer(/ss/ig, pad(sec, 2));
        replacer(/s/ig, sec);
        return pattern;
    }
    
    
    /**
     *  (@see tangram)
     *  parse 
     * /-//"7/20/96"
     *  "July 10 1995"  2  4  2  70
     * 
     * 
     * "Ju" 
     *  1996  11  9 "Tuesday November 9 1996"  date  "Friday November 9 1996"
     * JScript  (UTC)  (GMT) 
     * "10:""10:11" "10:11:12" 
     *  24  12  "PM"  "23:15 PM"  
     * 
     *             
     * @public
     * @param {string} source 
     * @return {Date} 
     */
    DATE.parse = function (source) {
        var reg = new RegExp("^\\d+(\\-|\\/)\\d+(\\-|\\/)\\d+\x24");
        if ('string' == typeof source) {
            if (reg.test(source) || isNaN(Date.parse(source))) {
                var d = source.split(/ |T/);
                var d1 = d.length > 1 
                        ? d[1].split(/[^\d]/)
                        : [0, 0, 0];
                var d0 = d[0].split(/[^\d]/);
                
                return new Date(
                    d0[0],
                    (d0[1] != null ? (d0[1] - 1) : 0 ), 
                    (d0[2] != null ? d0[2] : 1), 
                    (d1[0] != null ? d1[0] : 0), 
                    (d1[1] != null ? d1[1] : 0), 
                    (d1[2] != null ? d1[2] : 0)
                );
            } 
            else {
                return new Date(source);
            }
        }
        
        return new Date();
    };

})();

/**
 * xutil.dom
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DOM
 * @author:  sushuang(sushuang@baidu.com)
 */

(function () {
    
    var DOM = xutil.dom;
    var objProtoToString = Object.prototype.toString;
    var TRIMER_REG = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );
    var SPACE_REG = /\s/;
    var USER_AGENT = navigator.userAgent;
    var DOCUMENT = document;
    var REGEXP = RegExp;

    DOM.isStrict = DOCUMENT.compatMode == 'CSS1Compat';
    DOM.ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) 
        ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined;
    DOM.firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) 
        ? REGEXP.$1 - 0 : undefined;
    DOM.operaVersion = /opera\/(\d+\.\d)/i.test(USER_AGENT) 
        ? REGEXP.$1 - 0 : undefined;
    DOM.safariVersion = /(\d+\.\d)(\.\d)?\s+safari/i.test(USER_AGENT) 
        && !/chrome/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined;
    DOM.chromeVersion = /chrome\/(\d+\.\d+)/i.test(USER_AGENT) 
        ? + REGEXP['\x241'] : undefined;
    
    /**
     * DOM (@see tangram)
     * 
     * @public
     * @param {(string|HTMLElement)} id idDOM
     * @return {(HTMLElement|null)} null
     */
    DOM.g = function (id) {
        if (objProtoToString.call(id) == '[object String]') {
            return document.getElementById(id);
        } 
        else if (id && id.nodeName && (id.nodeType == 1 || id.nodeType == 9)) {
            return id;
        }
        return null;
    };
    
    /**
     * className 
     * DOMDOM
     * @public
     * 
     * @param {string} className classclass
     *          
     * @param {(string|HTMLElement)} element document
     * @return {Array} className.
     */
    DOM.q = function (className, element) {
        var result = [];

        if (!className 
            || !(className = String(className).replace(TRIMER_REG, ''))
        ) {
            return result;
        }
        
        if (element == null) {
            element = document;
        } 
        else if (!(element = DOM.g(element))) {
            return result;
        }
        
        if (element.getElementsByClassName) {
            return element.getElementsByClassName(className);
        } 
        else {
            var elements = element.all || element.getElementsByTagName("*");
            for (var i = 0, node, clzz; node = elements[i]; i++) {
                if ((clzz = node.className) != null) {
                    var startIndex = clzz.indexOf(className);
                    var endIndex = startIndex + className.length;
                    if (startIndex >= 0
                        && (
                            clzz.charAt(startIndex - 1) == '' 
                            || SPACE_REG.test(clzz.charAt(startIndex - 1))
                        )
                        && (
                            clzz.charAt(endIndex) == '' 
                            || SPACE_REG.test(clzz.charAt(endIndex))
                        )
                    ) {
                        result[result.length] = node;
                    }
                }
            }
        }
    
        return result;
    };

    /**
     *  Element 
     * 
     * @public
     * @param {HTMLElement} el Element 
     * @param {string} className 
     */
    DOM.addClass = function (el, className) {
        // 
        //  removeClass 
        el.className += ' ' + className;
    };

    /**
     *  Element 
     * 
     * @public
     * @param {HTMLElement} el Element 
     * @param {string} className 
     */
    DOM.removeClass = function (el, className) {
        var oldClasses = el.className.split(/\s+/).sort();
        var newClasses = className.split(/\s+/).sort();
        var i = oldClasses.length;
        var j = newClasses.length;

        for (; i && j; ) {
            if (oldClasses[i - 1] == newClasses[j - 1]) {
                oldClasses.splice(--i, 1);
            }
            else if (oldClasses[i - 1] < newClasses[j - 1]) {
                j--;
            }
            else {
                i--;
            }
        }
        el.className = oldClasses.join(' ');
    };    

    /**
     *  
     * 
     * @public
     * @param {HTMLElement} el Element 
     * @param {string} className true
     */
    DOM.hasClass = function (el, className) {
        var oldClasses = el.className.split(/\s+/).sort();
        var newClasses = className.split(/\s+/).sort();
        var i = oldClasses.length;
        var j = newClasses.length;

        for (; i && j; ) {
            if (oldClasses[i - 1] == newClasses[j - 1]) {
                j--;
            }
            i--;
        }

        return j <= 0;
    };

    /**
     *  Element  Element 
     *  IE Element  removeChild parentNode  Element 
     * inputparentNode
     *  W3C  parentElement
     *
     * @public
     * @param {HTMLElement} el Element 
     * @return {HTMLElement}  Element  null
     */
    DOM.getParent = DOM.ieVersion 
        ? function (el) {
            return el.parentElement;
        } 
        : function (el) {
            return el.parentNode;
        };

    /**
     * 
     *
     * @public
     * @param {HTMLElement} el Element 
     * @return {Array.<HTMLElement>} 
     */
    DOM.children = function (el) {
        if (!el) { return []; }

        for (var result = [], o = el.firstChild; o; o = o.nextSibling) {
            if (o.nodeType == 1) {
                result.push(o);
            }
        }
        return result;    
    };

    /**
     * 
     *
     * @public
     * @param {HTMLElement} el Element 
     */
    DOM.remove = function (el) {
        if (el) {
            var tmpEl = DOM.getParent(el);
            tmpEl && tmpEl.removeChild(el);
        }
    }

})();


/**
 * xutil.file
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var FILE = xutil.file;
            
    /**
     * 
     * windowslinux
     * windows\/:*?"<>|
     * linux/
     */
    FILE.FILE_NAME_FORBIDEN_CHARACTER = {
        '\\' : '',
        '/' : '',
        ':' : '',
        '*' : '',
        '?' : '', 
        '"' : '',
        '<' : '',
        '>' : '',
        '|' : ''
    };
    
    /**
     * 
     * windowslinux
     * 
     * 
     * @public
     * @param {string} name 
     * @return {string} 
     */    
    FILE.fixFileName = function (name) {
        if (name == null) {
            return name;
        }
        return name.replace(
            /./g, 
            function (w) {
                return FILE.FILE_NAME_FORBIDEN_CHARACTER[w] || w;
            }
        );
    };
    
})();

/**
 * xutil.fn
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang
 */

(function () {
    
    var FN = xutil.fn;
    var LANG = xutil.lang;
    var slice = Array.prototype.slice;
    var nativeBind = Function.prototype.bind;
    
    /**
     * 
     * **ECMAScript 5** native `Function.bind`
     * 
     * @public
     * @param {Function|string} func 
     * @param {Object} context 
     * @param {Any...} 
     * @rerturn {Funtion} 
     */
    FN.bind = function (func, context) {
        var args;
        if (nativeBind && func.bind === nativeBind) {
            return nativeBind.apply(func, slice.call(arguments, 1));
        }
        func = LANG.isString(func) ? context[func] : func;
        args = slice.call(arguments, 2);
        return function () {
            return func.apply(
                context || func, args.concat(slice.call(arguments))
            );
        };
    };

})();

/**
 * xutil.graphic
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var GRAPHIC = xutil.graphic; 

    /**
     * 
     *
     * @public
     * @param {Object...} bound...
     *      bound{left:..,top:..,width:..height:..}
     * @return {Object} boundnull
     */
    GRAPHIC.unionBoundBox = function () {
        var left;
        var top;
        var right;
        var bottom;
        var width;
        var height;
        var bound = null, subBound;

        for(var i = 0, l = arguments.length; i < l; i ++) {
            if( !( subBound = arguments[i])) {
                continue;
            }

            if( !bound) {
                bound = subBound;
            } 
            else {
                left = subBound.left < bound.left 
                    ? subBound.left : bound.left;
                top = subBound.top < bound.top 
                    ? subBound.top : bound.top;
                right = subBound.left + subBound.width;
                width = right > bound.left + bound.width 
                    ? right - bound.left : bound.width;
                bottom = subBound.top + subBound.height;
                height = bottom > bound.top + bound.height 
                    ? bottom - bound.top : bound.height;
                bound.left = left;
                bound.top = top;
                bound.width = width;
                bound.height = height;
            }
        }
        return bound;
    };

})();
        
/**
 * xutil.lang
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang, xutil.string
 */

(function () {
    
    var LANG = xutil.lang;
    var STRING = xutil.string;
    var objProto = Object.prototype;
    var objProtoToString = objProto.toString;
    var hasOwnProperty = objProto.hasOwnProperty;
 
    /**
     * 
     * nullundefinedfalse
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */
    LANG.hasValue = function (variable) {
        // undefinednulltruefalse
        return variable != null;
    };
    
    /**
     * 
     * nullundefinedfalse
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */
    LANG.hasValueNotBlank = function (variable) {
        return LANG.hasValue(variable)
           && (!LANG.isString(variable) || STRING.trim(variable) != '');
    };

    /**
     * 
     * variablestring
     * variableArray
     * variableObject
     * 
     * @public
     * @param {(string|Array|Object)} variable 
     * @return {boolean} 
     */    
    LANG.isBlank = function (variable) {
        if (LANG.isString(variable)) { 
            return trim(variable) == '';
        } 
        else if (LANG.isArray(variable)) {
            return variable.length == 0;
        } 
        else if (LANG.isObject(variable)) {
            for (var k in variable) {
                if (hasOwnProperty.call(variable, k)) {
                    return false;   
                }
            }
            return true;
        } 
        else {
            return !!variable;
        }
    };

    /**
     * undefined
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isUndefined = function (variable) {
        return typeof variable == 'undefined';
    };
    
    /**
     * null
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isNull = function (variable) {
        return variable === null;
    };
    
    /**
     * number
     * NaNFinitetrue
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isNumber = function (variable) {
        return objProtoToString.call(variable) == '[object Number]';
    };
    
    /**
     * number
     * NaNFinitefalse
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isNormalNumber = function (variable) {
        return LANG.isNumber(variable) 
            && !isNaN(variable) && isFinite(variable);
    };

    /**
     * Finite
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isFinite = function (variable) {
        return LANG.isNumber(variable) && isFinite(variable);
    };
    
    /**
     * NaN
     * jsisNaNundefinedtrue
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isNaN = function (variable) {
        // NaN'==='
        return variable !== variable;
    };

    /**
     * string
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isString = function (variable) {
        return objProtoToString.call(variable) == '[object String]';
    };
    
    /**
     * boolean
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isBoolean = function (variable) {
        return variable === true 
            || variable === false 
            || objProtoToString.call(variable) == '[object Boolean]';        
    };
    
    /**
     * Function
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isFunction = function (variable) {
        return objProtoToString.call(variable) == '[object Function]';
    };
    
    /**
     * Object
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isObject = function (variable) {
         return variable === Object(variable);
    };
    
    /**
     * Array
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isArray = Array.isArray || function (variable) {
        return objProtoToString.call(variable) == '[object Array]';
    };
       
    /**
     * Date
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isDate = function (variable) {
        return objProtoToString.call(variable) == '[object Date]';
    };  
    
    /**
     * RegExp
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */    
    LANG.isRegExp = function (variable) {
        return objProtoToString.call(variable) == '[object RegExp]';
    };  
    
    /**
     * DOM Element
     * 
     * @public
     * @param {*} variable 
     * @return {boolean} 
     */
    LANG.isElement = function (variable) {
        return !!(variable && variable.nodeType == 1);
    };
      
    /**
     * number
     * stringnumber, '123'123, '44px'44
     * parseFloat
     * NaN
     * 
     * @public
     * @param {*} input 
     * @param {*} defaultValue defaultValueundefinedinput
     * @return {(number|*)} numberdefaultValue
     */
    LANG.toNumber = function (input, defaultValue) {
        defaultValue = 
            typeof defaultValue != 'undefined' ? defaultValue : input;
        return isFinite(input = parseFloat(input)) ? input : defaultValue;
    };
    
    /**
     * string"true""false"boolean
     * string"true"false
     * stringjsbooleaninput
     * 
     * @public
     * @param {(string|*)} input 
     * @return {boolean} 
     */
    LANG.stringToBoolean = function (input) {
        if (LANG.isString(input)) {
            return trim(input) == 'true';
        } 
        else {
            return !!input; 
        }
    };

})();

/**
 * xutil.number
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @change: formatNumberdateformatby MENGRAN at 2013-12-06
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var NUMBER = xutil.number;
    var DATE = xutil.date; // Add by MENGRAN at 2013-12-6
            
    /**
     * (1st, 2nd, 3rd, 4th, ...)
     * 
     * @public
     * @param {number} number 
     * @return {string} 
     */    
    NUMBER.ordinalSuffix = function (number) {
        if (number == 1) {
            return 'st';
        } 
        else if (number == 2) {
            return 'nd';
        } 
        else if (number == 3) {
            return 'rd';
        } 
        else {
            return 'th';
        }
    };
    
    /**
     * 0
     * 
     * @public
     * @param {(number|string)} source , 
     * @param {number} length 
     * @return {string} 
     */
    NUMBER.pad = function (source, length) {
        var pre = "";
        var negative = (source < 0);
        var string = String(Math.abs(source));
    
        if (string.length < length) {
            pre = (new Array(length - string.length + 1)).join('0');
        }
    
        return (negative ?  "-" : "") + pre + string;
    };
    
    /**
     * 
     * 
     *      '23,444,12.98'
     *      '23,444$', '23,444%', '#23,444'
     *      
     *      IEEE 754
     *      '+23.45%'
     *      
     * @public
     * @example formatNumber(10000/3, "I,III.DD%"); "3,333.33%"
     * @param {number} num 
     * @param {string} formatStr 
     *              I, 
     *              DD
     * @param {string} usePositiveSign 
     * @param {number} cutMode 
     *                      0:
     *                      2:IEEE 754
     *                      other
     * @param {boolean} percentMultiply formatStr/[ID]%/100
     *                      false
     * @return {string} 
     */
    NUMBER.formatNumber = function (
        num, formatStr, usePositiveSign, cutMode, percentMultiply
    ) {
        if (!formatStr) {
            return num;
        }
        // add by majun  2014-3-20 14:27:53
        // number
        if(isNaN(num)){
            return num;
        }

        // Add by MENGRAN at 2013-12-6
        // numberdate
        if (DATE.isValidFormatPattern(formatStr)) {
            return DATE.format(DATE.parse(num), formatStr);
        }

        if(DATE.TIME_REG.test(formatStr)){
            return DATE.formatTime(num,formatStr);
        }

        if (percentMultiply && /[ID]%/.test(formatStr)) {
            num = num * 100;
        }

        num = NUMBER.fixNumber(num, formatStr, cutMode); 
        var str;
        var numStr = num.toString();
        var tempAry = numStr.split('.');
        var intStr = tempAry[0];
        var decStr = (tempAry.length > 1) ? tempAry[1] : "";
            
        str = formatStr.replace(/I+,*I*/g, function () {
            var matchStr = arguments[0];
            var commaIndex = matchStr.lastIndexOf(",");
            var replaceStr;
            var splitPos;
            var parts = [];
                
            if (commaIndex >= 0 && commaIndex != intStr.length - 1) {
                splitPos = matchStr.length - 1 - commaIndex;
                var diff;
                while (
                    (diff = intStr.length - splitPos) > 0
                    && splitPos > 0 /**/
                ) {
                    parts.push(intStr.substr(diff, splitPos));
                    intStr = intStr.substring(0, diff);
                }
                parts.push(intStr);
                parts.reverse();
                if (parts[0] == "-") {
                    parts.shift();
                    replaceStr = "-" + parts.join(",");
                } 
                else {
                    replaceStr = parts.join(",");
                }
            } 
            else {
                replaceStr = intStr;
            }
            
            if (usePositiveSign && replaceStr && replaceStr.indexOf('-') < 0) {
                replaceStr = '+' + replaceStr;
            }
            
            return replaceStr;
        });
        
        str = str.replace(/D+/g, function () {
            var matchStr = arguments[0]; 
            var replaceStr = decStr;
            
            if (replaceStr.length > matchStr.length) {
                replaceStr = replaceStr.substr(0, matchStr.length);
            } 
            else {
                replaceStr += (
                    new Array(matchStr.length - replaceStr.length)
                ).join('0');
            }
            return replaceStr;
        });
        // if ( !/[1-9]+/.test(str) ) { // 
            // str.replace(/^(\+|\-)./, '');
        // } 
        return str;
    };
    
    /**
     * 
     * 
     *      
     *      IEEE 754
     * 
     * @public
     * @param {number} cutMode 
     *                      0:
     *                      2:IEEE 754
     */
    NUMBER.fixNumber = function (num, formatStr, cutMode) {
        var formatDec = /D+/.exec(formatStr);
        var formatDecLen = (formatDec && formatDec.length>0) 
                ? formatDec[0].length : 0;
        var p;
            
        if (!cutMode) { // 
            p = Math.pow(10, formatDecLen);
            return ( Math.round (num * p ) ) / p ;
        } 
        else if (cutMode == 2) { // 
            return Number(num).toFixed(formatDecLen);
        } 
        else { // 
            return Number(num);
        }
    };

})();

/**
 * xutil.object
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var OBJECT = xutil.object;
    var objProtoToString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var arraySlice = Array.prototype.slice;
    
    /**
     * getByPathsetByPathcontext
     * 
     */
    OBJECT.PATH_DEFAULT_CONTEXT = window;

    /**
     * 
     * window
     * 
     * 
     * null
     * trim
     * 
     *      window
     *      var obj = { asdf: { zxcv: { qwer: 12 } } };
     *      getByPath('obj.asdf.zxcv.qwer'); 12
     *      var obj = { aaa: [123, { fff: 678 }] };
     *      getByPath('aaa.2.fff', obj);
     *      getByPath('aaa[2].fff', obj);678
     * 
     * @public
     * @param {string} path xxx.sss.aaa[2][3].SomeObj
     *      nullundefinedcontext
     * @param {Object=} context window
     *     OBJECT.PATH_DEFAULT_CONTEXT
     * @param {Object=} options 
     * @param {string=} objDelimiter 
     * @param {string=} arrBegin 
     * @param {string=} arrEnd 
     * @return {*} SomeObj
     */
    OBJECT.getByPath = function (path, context, options) {
        options = options || {};
        context = context || OBJECT.PATH_DEFAULT_CONTEXT;

        if (path == null) { return context; }

        var arrBegin = options.arrBegin || '[';
        var arrEnd = options.arrEnd || ']';
        var pathArr = path.split(
                options.objDelimiter != null ? options.objDelimiter : '.'
            );

        for (var i = 0, j, pai, pajs, paj; i < pathArr.length; i ++) {
            pai = pathArr[i];
            pajs = pai.split(arrBegin);

            for (j = 0; j < pajs.length; j ++) {
                paj = pajs[j];
                j > 0 && (paj = paj.split(arrEnd)[0]);

                // context
                if (context !== Object(context)) {
                    return;
                }

                context = context[paj];
            }
        }
        return context;
    };

    /**
     * 
     * window
     * /
     * 
     * 
     * trim
     * 
     *      setByPath('obj.asdf.zxcv', 12); 
     *      windowobj{ asdf: { zxcv: 12 } };
     *      setByPath('asdf.aaa[2].fff', 678, obj);
     *      setByPath('obj.asdf.aaa[2].fff', 678);
     *      objobj
     *          { 
     *              asdf: { 
     *                  zxcv: 12,
     *                  aaa: [undefined, { fff: 678 }] 
     *              } 
     *          };
     * 
     * @public
     * @param {string} path xxx.sss.aaa[2][3].SomeObj
     * @param {*} value 
     * @param {Object=} context OBJECT.PATH_DEFAULT_CONTEXT
     *     OBJECT.PATH_DEFAULT_CONTEXT
     * @param {Object=} options 
     * @param {string=} objDelimiter 
     * @param {string=} arrBegin 
     * @param {string=} arrEnd 
     * @param {string=} conflict .
     *      undefinednull
     *      var obj = { a: 5 };
     *      setByPath('a.c.d', obj, 444)
     *      conflict
     *          'THROW': 
     *          'IGNORE': 
     *          'OVERLAP': 
     */
    OBJECT.setByPath = function (path, value, context, options) {
        options = options || {};
        context = context || OBJECT.PATH_DEFAULT_CONTEXT;
        
        if (path == null) { return; }

        var arrBegin = options.arrBegin || '[';
        var arrEnd = options.arrEnd || ']';
        var conflict = options.conflict || 'THROW';
        var pathArr = path.split(
                options.objDelimiter != null ? options.objDelimiter : '.'
            );

        for (var i = 0, j, pai, pajs, paj, pv; i < pathArr.length; i ++) {
            pai = pathArr[i];
            pajs = pai.split(arrBegin);

            for (j = 0; j < pajs.length; j ++) {
                paj = pajs[j];
                j > 0 && (paj = paj.split(arrEnd)[0]);
                pv = context[paj];

                // 
                if (i == pathArr.length - 1 && j == pajs.length - 1) {
                    context[paj] = value;
                    return;
                }
                else {
                    // 
                    if (pv != null && pv !== Object(pv)) {
                        if (conflict == 'THROW') {
                            throw new Error('Path conflict: ' + path);
                        }
                        else if (conflict == 'IGNORE') {
                            return;
                        }
                    }

                    context = pv !== Object(pv)
                        // 
                        ? (
                            context[paj] = pajs.length > 1 && j < pajs.length - 1 
                            ? [] : {}
                        )
                        : context[paj];
                }
            }
        }
    };
    
    /**
     * setterset
     * 
     * @public
     * @param {Object} container 
     * @param {string} key 
     * @param {*} value 
     */
    OBJECT.set = function (container, key, value) {
        if (isFunction(container['set'])) {
            container['set'](key, value);
        } 
        else {
            container[key];
        }
    };

    /**
     * key/key
     * 
     * @public
     * @param {string=} key fanhuitrue
     * @param {Object} context enable/disable
     * @return {boolean} enable
     */
    OBJECT.objKey = (function () {

        /**
         * key
         */
        var KEY_ATTR_NAME = '\x07__OBJ__KEY__';

        /**
         * key
         * 
         * @public
         * @param {Object} context 
         * @param {string=} key nullundefinedfalse
         * @param {string=} keyName key
         *      key
         * @return {boolean} key
         */
        function has(context, key, keyName) {
            if (key == null) { return false; }

            var hasKey = false;
            var keyList = getKeyList(context, keyName);

            for (var i = 0; i < keyList.length; i ++) {
                if (key == keyList[i]) {
                    hasKey = true;
                }
            }

            return hasKey;        
        }

        /**
         * key
         * 
         * @public
         * @param {Object} context 
         * @param {string=} keyName key
         *      key
         * @return {number} key
         */
        function size(context, keyName) {
            return getKeyList(context, keyName).length;
        }

        /**
         * key
         * 
         * @public
         * @param {Object} context enable/disable
         * @param {string=} key nullundefinedkey
         * @param {string=} keyName key
         *      key
         */
        function add(context, key, keyName) {
            if (key == null) { return; }

            if (!has(context, key, keyName)) {
                getKeyList(context, keyName).push(key);
            }
        }

        /**
         * key
         * 
         * @public
         * @param {Object} context enable/disable
         * @param {string=} key nullundefinedkey
         * @param {string=} keyName key
         *      key
         */
        function remove(context, key, keyName) {
            if (key == null) { return; }

            var keyList = getKeyList(context, keyName);

            for (var i = 0; i < keyList.length; ) {
                if (key == keyList[i]) {
                    keyList.splice(i, 1);
                }
                else {
                    i ++;
                }
            }
        }

        /**
         * keylist
         * 
         * @private
         * @param {Object} context 
         * @param {string=} keyName key
         *      key
         * @return {Array} 
         */
        function getKeyList(context, keyName) {
            if (keyName == null) {
                keyName = '';
            }

            if (!context[KEY_ATTR_NAME + keyName]) {
                context[KEY_ATTR_NAME + keyName] = [];
            }

            return context[KEY_ATTR_NAME + keyName];
        }

        return {
            add: add,
            remove: remove,
            has: has,
            size: size,
            KEY_ATTR_NAME: KEY_ATTR_NAME
        };

    })();

    /**
     * getterget
     * 
     * @public
     * @param {Object} container 
     * @param {string} key 
     * @return {*} 
     */
    OBJECT.get = function (container, key) {
        if (isFunction(container['get'])) {
            return container['get'](key);
        } 
        else {
            return container[key];
        }
    };

    /**
     * 
     * 
     * @public
     * @param {Object} o 
     * @return {boolean} 
     */
    OBJECT.isEmptyObj = function (o) {    
        if (o !== Object(o)) {
            return false;
        }
        for (var i in o) {
            return false;
        }
        return true;
    };
                
    /**
     * 
     * targetsource
     * prototype
     * 
     * @public
     * @usage extend(target, source1, source2, source3);
     * @param {(Object|Array)} target
     * @param {(Object|Array)...} source 
     *          sourceextendtarget
     * @return {(Object|Array)} 
     */
    OBJECT.extend = function (target) {
        var sourceList = arraySlice.call(arguments, 1);
        for (var i = 0, source, key; i < sourceList.length; i ++) {
            if (source = sourceList[i]) {
                for (key in source) {
                    if (source.hasOwnProperty(key)) {
                        target[key] = source[key];
                    }
                }
            }
        }
        return target;
    };
    
    /**
     * 
     * extend
     * 
     * targetsource
     * prototype
     * 
     * @public
     * @param {(Object|Array)} target 
     * @param {(Object|Array)} source 
     * @param {(Array.<string>|Object)} inclusion 
     *          {Array.<string>}
     *              ['aa', 'bb']sourceaabb
     *              targetaaaa
     *          {Object}
     *              {'sAa': 'aa', 'sBb': 'bb'}sourceaabb
     *              targetsAasBb
     *          nullundefined
     *              sourcetarget
     * @param {Array.<string>} exclusion 
     *              inclusionexclusion.
     *          {Array.<string>}
     *              ['aa', 'bb']sourceaabbtargetaaaa
     *          nullundefined
     * @return {(Object|Array)} 
     */
    OBJECT.assign = function (target, source, inclusion, exclusion) {
        var i;
        var len;
        var inclusionMap = makeClusionMap(inclusion);
        var exclusionMap = makeClusionMap(exclusion);

        for (var i in source) {
            if (source.hasOwnProperty(i)) {
                if (!inclusion) {
                    if (exclusionMap[i] == null) {
                        target[i] = source[i];
                    }
                }
                else {
                    if (inclusionMap[i] != null && exclusionMap[i] == null) {
                        target[inclusionMap[i]] = source[i];
                    }
                }
            }
        }

        return target;
    };       
    
    /**
     * 
     * 
     * 
     * 
     *      
     *      
     *      Date
     *      (literal object @see isPlainObject)
     * 
     *      DOMRegExpnew somefunc()
     * 
     * @public
     * @param {(Object|Array)} source 
     * @param {Object=} options 
     * @param {Array.<string>} options.exclusion 
     * @return {(Object|Array)} 
     */
    OBJECT.clone = function (source, options) {
        options = options || {};
        var result;
        var i;
        var isArr;
        var exclusionMap = makeClusionMap(options.exclusion);

        if (isPlainObject(source)
            // key
            || (isArr = isArray(source))
        ) {
            result = isArr ? [] : {};
            for (i in source) {
                if (source.hasOwnProperty(i) && !(i in exclusionMap)) {
                    result[i] = OBJECT.clone(source[i]);
                }
            }
        } 
        else if (isDate(source)) {
            result = new Date(source.getTime());
        } 
        else {
            result = source;
        }
        return result;
    };

    /**
     * 
     * 
     * @public
     * @param {(Object|Array)} target 
     * @param {(Object|Array)} source 
     * @param {Object} options 
     * @param {boolean} options.overwrite true
     * @param {(boolean|string)} options.clone 
     *      trueclone
     *      false
     *      'WITHOUT_ARRAY'
     * @param {Array.<string>} options.exclusion 
     * @return {(Object|Array)} 
     */
    OBJECT.merge = function (target, source, options) {
        options = options || {};
        var overwrite = options.overwrite;
        overwrite == null && (overwrite = true);
        var clone = options.clone;
        clone == null && (clone = true);

        var exclusionMap = makeClusionMap(options.exclusion);

        if (isPlainObject(target) && isPlainObject(source)) {
            doMerge(target, source, overwrite, clone, exclusionMap);
        }
        return target;
    };

    function doMerge(target, source, overwrite, clone, exclusionMap) {
        var s;
        var t;
        
        for (var i in source) {
            s = source[i];
            t = target[i];

            if (!(i in exclusionMap) && source.hasOwnProperty(i)) {
                if (isPlainObject(t) && isPlainObject(s)) {
                    doMerge(t, s, overwrite, clone, exclusionMap);
                } 
                else if (overwrite || !(i in target)) {
                    target[i] = clone && (
                            clone != 'WITHOUT_ARRAY' || !isArray(s)
                        )
                        ? OBJECT.clone(s) 
                        : s;
                }
            }
        }
    }

    /**
     * 
     *
     * @public
     * @param {Function} subClass 
     * @param {Function} superClass 
     * @return {Object} 
     */
    OBJECT.inherits = function (subClass, superClass) {
        var oldPrototype = subClass.prototype;
        var clazz = new Function();

        clazz.prototype = superClass.prototype;
        OBJECT.extend(subClass.prototype = new clazz(), oldPrototype);
        subClass.prototype.constructor = subClass;
        subClass.superClass = superClass.prototype;

        return subClass.prototype;
    };

    /**
     * 
     * 
     *
     * @public
     * @param {Function} superClass null
     * @param {Function} subClassConstructor 
     *          
     * @return {Function} 
     */
    OBJECT.inheritsObject = function (superClass, subClassConstructor) {
        var agent = function (options) {
                return new agent.client(options);
            }; 
        var client = agent.client = function (options) {
                options = options || {};
                superClass && superClass.client.call(this, options);
                subClassConstructor && subClassConstructor.call(this, options);
            };
            
        superClass && OBJECT.inherits(agent, superClass);
        OBJECT.inherits(client, agent);
        client.agent = agent;

        return agent;
    };

    /**
     * 
     * 
     *
     * @public
     * @param {Function} superClass null
     * @param {Function} subClassConstructor 
     *          
     * @return {Function} 
     */
    OBJECT.createSingleton = function (superClass, subClassConstructor) {
        var instance;
        var agent = function (options) {
                return instance || (instance = new agent.client(options));
            };
        var client = agent.client = function (options) {
                options = options || {};
                superClass && superClass.client.call(this, options);
                subClassConstructor && subClassConstructor.call(this, options);
            };
            
        superClass && OBJECT.inherits(agent, superClass);
        OBJECT.inherits(client, agent);
        client.agent = agent;

        return agent;
    };

    /**
     *  (@see jquery, tangram)
     * (literal)
     * {}new Object()
     * DOMDateRegExp
     * /new somefunc()
     * 
     * 
     * 
     * @public
     * @param {Object} obj 
     * @return {boolean} 
     */
    var isPlainObject = OBJECT.isPlainObject = function (obj) {
        
        // ObjectDOM
        if (!obj || Object.prototype.toString.call(obj) != '[object Object]'
            // IEDOMtrue
            // isPrototypeOf
            || !('isPrototypeOf' in obj)) {
            return false;
        }

        try {
            // new somefunc()
            if (// constructor
                obj.constructor
                // constructor
                && !hasOwnProperty.call(obj, 'constructor') 
                // isPrototypeOfconstructorObject
                && !hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')
            ) {
                return false;
            }
        } catch ( e ) {
            // IE8,9host objects(window.location)constructor
            // @see jquery #9897
            return false;
        }

        // 
        // 
        for (var key in obj) {}
        return key === undefined || hasOwnProperty.call(obj, key);
    };

    /**
     * 
     */
    function isArray(o) {
        return objProtoToString.call(o) == '[object Array]';
    }

    /**
     * function
     */
    function isFunction(o) {
        return objProtoToString.call(o) == '[object Function]';
    }

    /**
     * Date
     */
    function isDate(o) {
        return objProtoToString.call(o) == '[object Date]';
    }

    /**
     * inclusion map, exclusion map
     */
    function makeClusionMap (clusion) {
        var i;
        var clusionMap = {};

        if (isArray(clusion)) {
            for (i = 0; i < clusion.length; i ++) {
                clusionMap[clusion[i]] = clusion[i];
            }
        } 
        else if (clusion === Object(clusion)) { 
            for (i in clusion) {
                clusionMap[clusion[i]] = i;
            }
        }

        return clusionMap;
    }

})();

/**
 * xutil.string
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang
 */

(function () {
    
    var STRING = xutil.string;
    var LANG = xutil.lang;
    var TRIMER = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );
    
    /**
     *  (@see tangram)
     * 
     * @pubilc
     * @param {string} source 
     * @returns {string} 
     */
    STRING.trim = function (source) {
        return source == null 
            ? ""
            : String(source).replace(TRIMER, "");
    };
    
    /**
     * HTML
     * 
     * @public
     * @param {string} text 
     * @param {number} blankLength 
     *      1
     */
    STRING.encodeHTMLWithBlank = function (text, blankLength) {
        var blankArr=[];
        blankLength = blankLength || 1;
        for(var i = 0; i < blankLength; i++) {
            blankArr.push('&nbsp;');
        }
        return STRING.encodeHTML(text).replace(/ /g, blankArr.join(''));
    };
    
    /**
     * html (@see tangram)
     * 5&<>"'
     * 
     * @public
     * @param {string} source 
     * @returns {string} html
     */
    STRING.encodeHTML = function (source) {
        return String(source)
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");
    };
        
    /**
     * html(@see tangram)
     * 
     * @public
     * @param {string} source 
     * @returns {string} html
     */
    STRING.decodeHTML = function (source) {
        var str = String(source)
                    .replace(/&quot;/g,'"')
                    .replace(/&lt;/g,'<')
                    .replace(/&gt;/g,'>')
                    .replace(/&amp;/g, "&");
        //
        return str.replace(/&#([\d]+);/g, function (_0, _1){
            return String.fromCharCode(parseInt(_1, 10));
        });
    };

    /**
     * 
     * decodeURIComponentapplication/x-www-form-urlencoded
     * "encode"
     * 
     *      encodeURIComponentURI
     *          http://en.wikipedia.org/wiki/Application/x-www-form-urlencoded#The_application.2Fx-www-form-urlencoded_type
     *      formapplication/x-www-form-urlencoded
     *          http://www.w3.org/TR/REC-html40-971218/interact/forms.html#h-17.13.3.3
     *          encode
     *          encode/decode
     *              form
     *              java.net.URIEncode/java.net.URIDecoder
     *              decode
     *          encodedi-stubencode
     *
     * @public
     * @param {string} str 
     * @return {string} 
     */
    STRING.decodePercent = function (str) {
        if (str == null) { return ''; }
        return decodeURIComponent(str.replace(/\+/g, '%20'));
    };    
        
    /**
     * 
     * 
     * @public
     * @param {string} source 
     * @param {string} defaultText sourcedefaultText''
     *      '-'
     * @param {boolean} needEncodeHTML HTMLfalse
     * @param {Object} htmlEncoder HTMLSTRING.encodeHTML
     */
    STRING.toShowText = function (source, defaultText, needEncodeHTML, htmlEncoder) {
        defaultText =  LANG.hasValue(defaultText) ? defaultText : '';
        htmlEncoder = htmlEncoder || STRING.encodeHTML;
        var text = LANG.hasValueNotBlank(source) ? source : defaultText;
        needEncodeHTML && (text = htmlEncoder(text));
        return text;
    };
    
    /**
     * toShowText
     *
     * @public
     */
    STRING.htmlText = function (source, defaultText, needEncodeHTML) {
        if (defaultText == null) {
            defaultText = '';
        }
        if (needEncodeHTML == null) {
            needEncodeHTML = true
        }
        return STRING.toShowText(source, defaultText, needEncodeHTML);
    }

    /**
     * html/xml
     * encode
     * 
     * @public
     * @param {string} source 
     * @return {string} 
     */
    STRING.escapeTag = function (source) {
        if (!LANG.hasValueNotBlank(source)) {
            return '';
        }
        return String(source).replace(/<.*?>/g,'');
    };
    
    /**
     * (@see tangram)
     * \.*+?^=!:${}()|[]/\
     * 
     * @public
     * @param {string} source 
     * @return {string} 
     */
    STRING.escapeReg = function (source) {
        return String(source)
                .replace(
                    new RegExp("([.*+?^=!:\x24{}()|[\\]\/\\\\])", "g"), 
                    '\\\x241'
                );
    };    
    
    /**
     * ASCIIASCII
     * 
     * @public
     * @param {string} str 
     * @return {number} 
     */
    STRING.textLength = function (str){
        if (!LANG.hasValue(str)) { return 0; };
        return str.replace(/[^\x00-\xFF]/g,'**').length;
    };

    /**
     * ASCII
     * ASCII
     * 
     * @public
     * @param {string} str 
     * @param {number} start 
     * @param {number} length 
     * @return {string} 
     */
    STRING.textSubstr = function (str, start, length) {
        if (!LANG.hasValue(str)) {
            return '';
        }
        var count=0;
        for(var i = start, l = str.length; i < l && count < length; i++) {
            str.charCodeAt(i) > 255 ? (count += 2) : (count++);
        }
        count > length && i--;
        return str.substring(start, i); 
    };
    
    /**
     * ASCIIASCII
     * 
     * @public
     * @param {string} str 
     * @param {number} length 
     * @param {string} lineSeparater \r
     * @return {string} 
     */
    STRING.textWrap = function (str, length, lineSeparater) {
        lineSeparater = lineSeparater || '\r';
        if (length < 2)  {
            throw Error ('illegle length');
        }
        if (!LANG.hasValueNotBlank(str)) {
            return '';
        }
        
        var i = 0;
        var lineStart=0;
        var l=str.length;
        var count=0;
        var textArr=[];
        var lineStart;

        while(true) {
            if (i>=l) {
                textArr.push(str.substring(lineStart, l+1));
                break;  
            }
            str.charCodeAt(i)>255 ? (count+=2) : (count++);
            if(count>=length) {
                (count>length) && (i=i-1);
                textArr.push(str.substring(lineStart, i+1));
                lineStart = i+1;
                count = 0;
            }
            i++;
        }
        return textArr.join(lineSeparater);     
    };
 
    /**
     *  (@see tangram)
     *
     * @public
     * @usage 
     *      template('asdf#{0}fdsa#{1}8888', 'PA1', 'PA2') 
     *      asdfPA1fdsaPA28888
     *      template('asdf#{name}fdsa#{area}8888, { name: 'PA1', area: 'PA2' }) 
     *      asdfPA1fdsaPA28888   
     * @param {string} source 
     * @param {(Object|...string)} options 
     * @return {string} 
     */
    STRING.template = function (source, options) {
        source = String(source);
        var data = Array.prototype.slice.call(arguments, 1);
        var toString = Object.prototype.toString;

        if(data.length) {
            data = data.length == 1 ? 
                (options !== null && 
                    (/\[object Array\]|\[object Object\]/.test(
                        toString.call(options)
                    )) 
                        ? options : data
                ) : data;

            return source.replace(
                /#\{(.+?)\}/g, 
                function (match, key) {
                    var replacer = data[key];
                    if('[object Function]' == toString.call(replacer)) {
                        replacer = replacer(key);
                    }
                    return ('undefined' == typeof replacer ? '' : replacer);
                }
            );

        }
        return source;
    };

    /**
     * XX
     * @public 
     * 
     * @param {string} str
     * @param {string} end
     * @return {boolean} 
     */
    STRING.endWith = function (str, end) {
        if (str && end) {
            return str.lastIndexOf(end) 
                === str.length - end.length;
        }
        return false;
    }; 

})();

/**
 * xutil.uid
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    ID
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  none
 */

(function () {
    
    var UID = xutil.uid;
    var INCREASED_UID_BASE_PUBLIC = 1;
    var INCREASED_UID_BASE_PRIVATE = {};
    
    /**
     * worker
     * @public
     * 
     * @param {Object} options
     * @param {string} options.key UID
     *          UIDkeyUID
     *          keyUIDkeyUID
     * @return {string} UID
     */
    UID.getIncreasedUID = function (key) {
        if (key != null) {
            !INCREASED_UID_BASE_PRIVATE[key] 
                && (INCREASED_UID_BASE_PRIVATE[key] = 1);
            return INCREASED_UID_BASE_PRIVATE[key] ++;
        } 
        else {
            return INCREASED_UID_BASE_PUBLIC ++ ;
        }
    };
    
    /**
     * 
     */
    UID.getUID = UID.getIncreasedUID;
    
})();


/**
 * xutil.url
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang
 */

(function () {
    
    var URL = xutil.url;
    var LANG = xutil.lang;
    var objProtoToString = Object.prototype.toString;
    var arrayProtoSlice = Array.prototype.slice;

    /**
     * jsdecodeURIComponent
     * undefinednull
     * 
     * @public
     * @param {string} input 
     * @return {string} 
     */
    URL.decodeURIComponent = function (input) { 
        return LANG.hasValueNotBlank(input) 
            ? decodeURIComponent(input) : input;
    };
    
    /**
     * URL
     * 
     * @public
     * @param {string} url url
     * @param {string} paramStr 
     * @param {number} urlType url1:URL; 2:erURL 
     * @return {string} url
     */
    URL.appendParam = function (url, paramStr, urlType) {
        urlType = urlType || 1;

        if (url.indexOf('?') < 0) {
            url += (urlType == 2 ? '~' : '?') + paramStr;
        } 
        else {
            url += '&' + paramStr;
        }

        return url;
    };

    /**
     * url
     * 
     * @public
     * @param {string} url
     * @param {string} paramName 
     * @param {string} newValue paramName
     * @param {number} urlType url1:URL; 2:erURL 
     * @return {string} url
     */
    URL.replaceIntoParam = function (url, paramName, newValue, urlType) {
        var retUrl = url;
        
        if (!retUrl || !LANG.hasValueNotBlank(paramName)) { 
            return retUrl; 
        }
        newValue = newValue != null ? newValue : '';

        var regexp = new RegExp('([&~?])' + paramName + '=[^&]*');
        var paramStr = paramName + '=' + newValue;
        if (regexp.test(retUrl)) { // 
            // js
            retUrl = retUrl.replace(regexp, '$1' + paramStr); 
        } 
        else { // 
            retUrl = URL.appendParam(retUrl, paramStr, urlType);
        }
        return retUrl;
    };

    /**
     * 
     * 
     * @public
     * @usage url.parseParam('asdf=123&qwer=654365&t=43&t=45&t=67'); 
     *          
     *          {asdf:123, qwer:654365, t: [43, 45, 67]}
     * @param {string} paramStr 
     * @param {Object} options 
     * @param {Object} options.dontParseBoolean "true""false"truefalse
     *          
     * @return {Object} 
     */
    URL.parseParam = function (paramStr, options) {
        var paramMap = {};
        options = options || {};

        if (paramStr == null) {
            return paramMap;
        }

        var paramArr = paramStr.split('&');
        for (var i = 0, len = paramArr.length, o; i < len; i++) {
            o = paramArr[i] != null ? paramArr[i] : '';
            o = o.split('=');
            var key = o[0];
            var value = o[1];

            if (!options.dontParseBoolean) {
                value == 'true' && (value = true);
                value == 'false' && (value = false);
            }
            
            if (key == null) { continue; }

            if (paramMap.hasOwnProperty(key)) {
                if (objProtoToString.call(paramMap[key]) == '[object Array]') {
                    paramMap[key].push(value);
                } 
                else {
                    paramMap[key] = [paramMap[key], value];   
                }
            } 
            else {
                paramMap[key] = value;   
            }
        }
        return paramMap;
    };

    /**
     * string
     * nullundefined
     * urlencoding
     * 
     * @public
     * @usage url.stringifyParam({asdf:123, qwer:654365, t: [43, 45, 67]})
     *          
     *          ['asdf=123', 'qwer=654365', 't=43', 't=45', 't=67'] 
     *          join('&')'asdf=123&qwer=654365&t=43&t=45&t=67'
     *
     * @param {Object} paramObj 
     *      key
     *      value{string}{Array.<string>}   
     * @param {boolean} useEncoding urlencodingfalse
     * @return {Array.<string>} 
     */
    URL.stringifyParam = function (paramObj, useEncoding) {
        var paramArr = [];
        var textParam = URL.textParam;

        function pushParam(name, value) {
            paramArr.push(
                textParam(name, !useEncoding) 
                + '=' 
                + textParam(value, !useEncoding)
            );
        }    

        var name;
        var value;
        var i;
        for (name in (paramObj || {})) {
            value = paramObj[name];
            if (Object.prototype.toString.call(value) == '[object Array]') {
                for (i = 0; i < value.length; i ++) {
                    pushParam(name, value[i]);
                }
            }
            else {
                pushParam(name, value);
            }
        }
        return paramArr;
    };

    /**
     * 
     * (1) null/undefined
     * (2) encodeURIComponent
     *
     * @public
     * @param {string} str 
     * @param {boolean} dontEncoding false
     * @param {string} defaultValue ''
     * @return {string} 
     */
    URL.textParam = function (str, dontEncoding, defaultValue) {
        typeof defaultValue == 'undefined' && (defaultValue = '');
        str = str == null ? defaultValue : str;
        return dontEncoding ? str : encodeURIComponent(str);
    };

    /**
     * 
     * null/undefined
     *
     * @public
     * @param {(string|number)} value 
     * @param {string} defaultValue ''
     * @return {string} 
     */
    URL.numberParam = function (value, defaultValue) {
        typeof defaultValue == 'undefined' && (defaultValue = '');
        return (value == null || value === '') ? defaultValue : value;
    };

    /**
     * 
     * array aaa=1&aaa=233&aaa=443 ...
     * null/undefined
     * 
     * @public
     * @param {array} arr arr
     *              (1) ['asdf', 'zxcv', 'qwer']
     *                  attrName
     *              (2) [{ t: 'asdf' }, { t: 'zxcv' }]
     *                  attrNamet
     * @param {string} paramName 
     *                  'aaa'
     *                  aaa=asdf&aaa=zxcv&aaa=qwer
     * @param {string=} attrName arr
     * @param {Function=} paramFunc ,
     *                  xutil.url.textParam
     * @param {...*} paramFunc_args paramFunc
     * @return {Array} ['aa=1', 'aa=33', 'aa=543']
     *              join('&')aa=1&aa=33&aa=543
     */
    URL.wrapArrayParam = function (arr, paramName, attrName, paramFunc) {
        if (!arr || !arr.length) {
            return [];
        }
        
        paramFunc = paramFunc || URL.textParam;
        var args = arrayProtoSlice.call(arguments, 4);

        var paramArr = [];
        for (var i = 0, item; i < arr.length; i ++) {
            item = arr[i];
            if (item === Object(item)) { // itemObject
                item = item[attrName];
            }
            item = paramFunc.apply(null, [item].concat(args));
            paramArr.push(paramName + '=' + item);
        }

        return paramArr;
    };

})();

/**
 * xutil.validator
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.lang
 */

(function () {
    
    var VALIDATOR = xutil.validator = {};

    var REGEXP_CASH = /^\d+(\.\d{1,2})?$/;
    var REGEXP_CASH_CAN_NAGE = /^(\+|-)?\d+(\.\d{1,2})?$/;
    var REGEXP_EMAIL = /^[_\w-]+(\.[_\w-]+)*@([\w-])+(\.[\w-]+)*((\.[\w]{2,})|(\.[\w]{2,}\.[\w]{2,}))$/;
    var REGEXP_URL = /^[^.]+(\.[^.]+)+$/;
    var REGEXP_MOBILE = /^1\d{10}$/;
    var REGEXP_ZIP_CODE = /^\d{6}$/;
    
    /**
     * 
     * 
     * @pubilc
     * @param {string} value 
     * @param {boolean} canNagetive false
     * @returns {boolean} 
     */
    VALIDATOR.isCash = function (value, canNagetive) {
        return canNagetive 
            ? REGEXP_CASH_CAN_NAGE.test(value) : REGEXP_CASH.test(value);
    };   

    /**
     * 
     * 
     * @pubilc
     * @param {string} value 
     * @returns {boolean} 
     */
    VALIDATOR.isURL = function (value) {
        return REGEXP_URL.test(value); 
    };

    /**
     * 
     * 
     * @pubilc
     * @param {string} value 
     * @returns {boolean} 
     */
    VALIDATOR.isMobile = function (value) {
        return REGEXP_MOBILE.test(value);
    };    

    /**
     * 
     * 
     * @pubilc
     * @param {string} value 
     * @returns {boolean} 
     */
    VALIDATOR.isEMAIL = function (value) {
        return REGEXP_EMAIL.test(value);
    };
    
    /**
     * 
     * 
     * @pubilc
     * @param {string} value 
     * @returns {boolean} 
     */
    VALIDATOR.isZipCode = function (value) {
        return REGEXP_ZIP_CODE.test(value);
    };
    
})();

/**
 * ecui.XObject
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.object
 * @version: 1.0.1
 */

(function () {

    //----------------------------------
    // 
    //----------------------------------
    
    var xobject = xutil.object;
    var inheritsObject = xobject.inheritsObject;
    var objProtoToString = Object.prototype.toString;
    var arrayProtoSlice = Array.prototype.slice;
    
    //----------------------------------
    // 
    //----------------------------------
    
    /**
     * 
     *
     * @class
     */
    var XOBJECT = xui.XObject = 
            inheritsObject(null, xobjectConstructor);
    var XOBJECT_CLASS = XOBJECT.prototype;
    
    /**
     * 
     *
     * @public
     * @constructor
     * @param {Object} options      
     */
    function xobjectConstructor(options) {
        /**
         * 
         * key: eventName
         * value: {Array.<Object>} 
         *
         * @type {Object} 
         * @private
         */
        this._oEventHandlerMap = {};

        /**
         * 
         *
         * @type {boolean} 
         * @private
         */
        this._bDisabled = false;
    }

    //----------------------------------
    // 
    //----------------------------------

    /**
     * 
     *
     * @public
     */
    XOBJECT_CLASS.init = function () {};
    
    /**
     * 
     * businessKey
     *
     * @public
     */
    XOBJECT_CLASS.dispose = function () {
        this._oEventHandlerMap = {};
    };

    /**
     * 
     *
     * @public
     * @return {boolean} 
     */
    XOBJECT_CLASS.isDisabled = function () {
        return !!this._bDisabled;
    };
    
    /**
     * 
     *
     * @public
     * @return {boolean} 
     */
    XOBJECT_CLASS.disable = function () {
        if (!this._bDisabled) {
            this._bDisabled = true;
            return true;
        }
        return false;
    };
    
    /**
     * 
     *
     * @public
     * @return {boolean} 
     */
    XOBJECT_CLASS.enable = function () {
        if (this._bDisabled) {
            this._bDisabled = false;
            return true;
        }
        return false;
    };
    
    //------------------------------------------
    // //Observer
    //------------------------------------------
    
    /**
     * 
     * 
     *
     * @public
     * @param {(string|Object|Array)} eventName 
     *                  string
     *                  ObjectArray
     * @param {Function} handler 
     * @param {Object=} context handlerthis
     *                  thisXDatasource
     * @param {...*} args handler
     * @usage
     *      [] 
     *          myModel.attach('sync.result', this.eventHandler, this);
     *      [] 
     *          var bind = xutil.fn.bind;
     *          myModel.attach(
     *              {    
     *                  'sync.parse': bind(this.handler1, this, arg1, arg2),
     *                  'sync.preprocess': bind(this.handler2, this),
     *                  'sync.result.INIT': bind(this.handler3, this),
     *                  'sync.result.DATA': [
     *                      bind(this.handler4, this),
     *                      bind(this.handler5, this, arg3),
     *                      bind(this.handler6, this)
     *                  ]
     *              }
     *      [] 
     *          myModel.attach(
     *              ['sync.parse', this.handler1, this, arg1, arg2],
     *              ['sync.preprocess', this.handler2, this],
     *              ['sync.result.INIT', this.handler3, this],
     *              ['sync.result.DATA', this.handler4, this],
     *              ['sync.result.DATA', this.handler5, this, arg3],
     *              ['sync.result.DATA', this.handler6, this]
     *          );
     */
    XOBJECT_CLASS.attach = function (eventName, handler, context, args) {
        parseArgs.call(this, attach, arrayProtoSlice.call(arguments));
    };

    /**
     * 
     *
     * @private
     * @this {xui.XObject} XObject
     * @param {Object} handlerWrap 
     */
    function attach(handlerWrap) {
        handlerWrap.once = false;
        doAttach.call(this, handlerWrap);
    }

    /**
     * 
     * 
     *
     * @public
     * @param {(string|Object|Array)} eventName 
     *                  string
     *                  ObjectArrayattach
     * @param {Function} handler 
     * @param {Object=} context handlerthis
     *                  thisXDatasource
     * @param {...*} args handler
     * @usage attach
     */
    XOBJECT_CLASS.attachOnce = function (eventName, handler, context, args) {
        parseArgs.call(this, attachOnce, arrayProtoSlice.call(arguments));
    };

    /**
     * 
     *
     * @private
     * @this {xui.XObject} XObject
     * @param {Object} handlerWrap 
     */
    function attachOnce(handlerWrap) {
        handlerWrap.once = true;
        doAttach.call(this, handlerWrap);
    }
    
    /**
     * 
     * 
     *
     * @private
     * @this {xui.XObject} XObject
     * @param {Object} handlerWrap 
     */
    function doAttach(handlerWrap) {
        var handlerList = this._oEventHandlerMap[handlerWrap.eventName];
        if (!handlerList) {
            handlerList = this._oEventHandlerMap[handlerWrap.eventName] = [];
        }
        if (getHandlerWrapIndex.call(this, handlerWrap) < 0) {
            handlerList.push(handlerWrap);
        }
    }

    /**
     * 
     * contexthandlercontext
     * 
     * 
     *      handlerprototypecontext
     *      
     *  
     * contexthandler
     *
     * @public
     * @param {(string|Object|Array)} eventName
     *                  string
     *                  ObjectArray
     * @param {Function} handler 
     * @param {Object=} context handlerthis
     *                  thisXDatasource
     * @usage
     *      [] 
     *          myModel.detach('sync.result', this.eventHandler);
     *      [] 
     *          myModel.detach(
     *              {    
     *                  'sync.parse': handler1,
     *                  'sync.preprocess': handler2,
     *                  'sync.result.DATA': [
     *                      handler5,
     *                      handler6
     *                  ]
     *              }
     *      [] 
     *          myModel.detach(
     *              ['sync.parse', this.handler1],
     *              ['sync.result.INIT', this.handler3],
     *              ['sync.result.DATA', this.handler4],
     *              ['sync.result.DATA', this.handler5],
     *              ['sync.result.DATA', this.handler6]
     *          );
     */
    XOBJECT_CLASS.detach = function (eventName, handler, context) {
        parseArgs.call(this, doDetach, arrayProtoSlice.call(arguments));        
    };

    /**
     * 
     *
     * @private
     * @this {xui.XObject} XObject
     * @param {Object} handlerWrap 
     */
    function doDetach(handlerWrap) {
        var index = getHandlerWrapIndex.call(this, handlerWrap);
        if (index >= 0) {
            this._oEventHandlerMap[handlerWrap.eventName].splice(index, 1);
        }
    }    
    
    /**
     * 
     *
     * @public
     * @param {string} eventName 
     */
    XOBJECT_CLASS.detachAll = function (eventName) {
        delete this._oEventHandlerMap[eventName];
    };
    
    /**
     * 
     *
     * @public
     * @param {string} eventName 
     * @param {Array} paramList 
     * @return {boolean} 
     *      falsefalsetrue
     */
    XOBJECT_CLASS.notify = function (eventName, paramList) {
        var result = true;
        var onceList = [];
        var handlerList = this._oEventHandlerMap[eventName] || [];

        var i;
        var o;
        var handlerWrap;
        for (i = 0; handlerWrap = handlerList[i]; i++) {
            o = handlerWrap.handler.apply(
                handlerWrap.context, 
                (handlerWrap.args || []).concat(paramList || [])
            );
            (o === false) && (result = false);

            if (handlerWrap.once) {
                onceList.push(handlerWrap);
            }
        }
        for (i = 0; handlerWrap = onceList[i]; i++ ) {
            this.detach(eventName, handlerWrap.handler, handlerWrap.context);
        }
        return result;
    };

    /**
     * handlerWrap
     *
     * @private
     * @this {xui.XObject} XObject
     * @param {string} eventName 
     * @param {Function} handler 
     * @param {Object} context handlerthis
     *                  thisXDatasource
     * @param {...*} args handler
     * @return {Object} wrap
     */
    function makeWrap(eventName, handler, context, args) {
        args = arrayProtoSlice.call(arguments, 3);
        args.length == 0 && (args = null);

        return {
            eventName: eventName,
            handler: handler,
            context: context || this,
            args: args
        };
    }
    
    /**
     * 
     *
     * @private
     * @this {xui.XObject} XObject
     * @param {Function} func 
     * @param {Array} args 
     */
    function parseArgs(func, args) {
        var firstArg = args[0];

        if (objProtoToString.call(firstArg) == '[object String]') {
            func.call(this, makeWrap.apply(this, args));
        }

        else if (objProtoToString.call(firstArg) == '[object Array]') {
            for (var i = 0; i < args.length; i ++) {
                func.call(this, makeWrap.apply(this, args[i]));
            }
        }

        else if (firstArg === Object(firstArg)) {
            var hand;
            for (var eventName in firstArg) {
                hand = firstArg[eventName];

                if (objProtoToString.call(hand) == '[object Array]') {
                    for (var i = 0; i < hand.length; i ++) {
                        func.call(
                            this,
                            makeWrap.call(this, eventName, hand[i])
                        );
                    }
                }
                else {
                    func.call(this, makeWrap.call(this, eventName, hand));
                }
            }
        }
    }
    
    /**
     * index
     *
     * @private
     * @this {xui.XObject} XObject
     * @param {Object} handlerWrap 
     */
    function getHandlerWrapIndex(handlerWrap) {
        var handlerList = this._oEventHandlerMap[handlerWrap.eventName];
        if (handlerList) {
            for (var i = 0, wrap; wrap = handlerList[i]; i++ ) {
                if (wrap.handler === handlerWrap.handler
                    && wrap.context === handlerWrap.context
                ) {
                    return i;   
                }
            }
        }
        return -1;
    };
    
})();

/**
 * xui.XDatasource
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:   
 *
 *          ModelView
 *          
 *          @see OPTIONS_NAME
 *          /
 *          XDatasource@usage
 *
 *          
 *              (1) Ajax
 *              (2) 
 *                      
 *                          
 *                          
 *                      
 *                          
 *                          JSONHTML
 *                          
 *                      
 *                          Ajax
 *                  
 *                      "businessData"
 *                      "local""local"
 *                      "url"Ajax
 *              (3) Oberver
 *              (4) datasourceId
 *              (5) 
 *                  
 *              (6) abort
 *                  js
 *                  
 *
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 * @version: 1.0.1
 */

/**
 *                             -----------------
 *                             |       |
 *                             -----------------
 * ____________________________________________________________________________
 * @usage XDatasource
 *        [] 
 *          ___________________________________________________________________
 *          (1) XDatasourceMyDatasource:
 * 
 *              MyDatasource
 *              URL
 *              MyDatasourceOPTIONS_NAME
 *              
 *              stringFunction
 * 
 *              // MyDatasource
 *              var MyDatasource = function() {}; 
 *              inherits(MyDatasource, XDatasource);
 *              
 *              // url
 *              MyDatasource.prototype.url = '/order/go.action'; 
 *
 *              // param
 *              MyDatasource.prototype.param = function(options) {
 *                  var paramArr = [];
 *                  paramArr.push('name=' + options.args.name);
 *                  paramArr.push('year=' + options.args.year);
 *                  paramArr.push('id=' + this._nId);
 *                  return paramArr.join('&');
 *              }
 *
 *              // 
 *              MyDatasource.prototype.parse = function(data, obj, options) {
 *                  // do something ...
 *                  return data;
 *              }
 * 
 *          ___________________________________________________________________
 *          (2) MyDatasource
 *              
 *              MyDatasource
 *              sync
 *              MyDatasource,
 *
 *              
 *              MyDatasource myDatasource = new MyDatasource();
 *              
 *              myDatasource.attach(
 *                  'sync.result', 
 *                  function(data, obj, options) {
 *                      // do something ...,  
 *                  }
 *              );
 *              myDatasource.attach(
 *                  'sync.error', 
 *                  function(status, obj, options) {
 *                      // do something ...,  
 *                  }
 *              );
 *              myDatasource.attach(
 *                  'sync.timeout', 
 *                  function(options) { 
 *                      // do something ...,  
 *                  }
 *              );
 *
 *              scope
 *              bind
 *              attachscope
 *
 *              
 *              xui.XObjectattach
 *
 *              
 *              thisscope
 *              var bind = xutil.fn.bind;
 *              myDatasource.attach(
 *                  {
 *                      'sync.preprocess.TABLE_DATA': bind(this.disable, this),
 *                      'sync.result.TABLE_DATA': bind(this.$handleListLoaded, this),
 *                      'sync.finalize.TABLE_DATA': [  
 *                          // 
 *                          bind(this.enable, this),
 *                          bind(this.$resetDeleteBtnView, this)
 *                      ],
 *                      'sync.result.DELETE': bind(this.$handleDeleteSuccess, this)
 *                  }
 *              ); 
 *
 *              
 *              scope
 *              myDatasource.attach(
 *                  ['sync.preprocess.TABLE_DATA', this.disable, this],
 *                  ['sync.result.TABLE_DATA', this.$handleListLoaded, this],
 *                  ['sync.finalize.TABLE_DATA', this.enable, this],
 *                  ['sync.finalize.TABLE_DATA', this.$resetDeleteBtnView, this],
 *                  ['sync.result.DELETE': this.$handleDeleteSuccess, this]
 *              );
 *              
 *              myDatasource.sync()
 *              
 * 
 *              options.args
 *              paramparsesync
 *
 *              myDatasource.sync( 
 *                  { 
 *                      args: { name: 'ss', year: 2012 } 
 *                  } 
 *              ); 
 *
 *              paramparse'ss', 2012
 * 
 *              syncdatasourceId
 *              myDatasource.sync( { datasourceId:'ds1' } );
 *              sync.result.ds1sync.result
 *              errortimeout
 * 
 *          ___________________________________________________________________
 *          (3) sync
 *              JSONdom
 *              "local"
 * 
 *              
 *              MyDatasource.prototype.local = function() {
 *                   var data;
 *                   try {
 *                      JSON.parse(
 *                          decodeHTML(
 *                              document.getElementById('DATA').innerHTML
 *                          )
 *                      );
 *                      return this.wrapEJson(data);
 *                   } catch (e) {
 *                      return this.wrapEJson(null, 99999, 'business error');
 *                   }
 *              };
 *
 *              synclocal
 *              successparseresult (@see OPTIONS_NAME.local)
 *          
 *          ___________________________________________________________________
 *          (4) syncOK
 *              businessData
 * 
 *              
 *              myDatasource.businessData = someData;
 *              syncsomeDataresult
 *              (@see OPTIONS_NAME.businessData)
 * 
 *          ___________________________________________________________________
 *          (5) XDatasource
 *              urlresult(@see OPTIONS_NAME)XDatasource.Set
 *              syncdatasourceIdsync
 *
 *              
 *              MyDatasource.prototype.url = new xui.XDatasource.Set();
 *              MyDatasource.prototype.url['ORDER'] = 'order.action';
 *              MyDatasource.prototype.url['ADD'] = 'add.action';
 *
 *              // 
 *              MyDatasource.prototype.result = new xui.XDatasource.Set(
 *                  {
 *                      'ORDER': function() { ... }
 *                      'ADD': function() { ... }
 *                  }
 *              );
 *
 *              MyDatasource.prototype.param = function() { // func_all... };
 *              MyDatasource.prototype.param['ORDER'] = 
 *                  function() { // func_order... };
 *
 *              myDatasource.sync( { datasourceId: 'ORDER' } ); 
 *              
 *                  myDatasource.sync('ORDER'); 
 *              order.actionresultfunc_order
 *
 *              param['ORDER']
 *              paramfunc_all
 * 
 * ____________________________________________________________________________
 * @usage XDatasource
 *              XDatasource
 *
 *              
 *              CombinedXDatasource c = new CombinedXDatasource();
 *              c.addSyncCombine(datasource1);
 *              c.addSyncCombine(datasource2, 'DATASOURCE_LIST');
 *
 *              
 *              c.sync()datasource1parse
 *              sync.result/sync.error/sycn.timeout
 *              c.sync( { datasourceId: 'DATASOURCE_LIST' } )
 *              datasource1datasource2parse
 *              sync.result/sync.error/sycn.timeout
 * 
 * ____________________________________________________________________________
 * @usage /XDatasource
 *              url
 *              
 *              XDatasource.extend(
 *                  MyXDatasource, 
 *                  { url: ..., method: ... }
 *              );
 *              
 */

(function () {
    
    //--------------------------
    // 
    //--------------------------

    var XOBJECT = xui.XObject;
    var xajax = xutil.ajax;
    var xlang = xutil.lang;
    var xobject = xutil.object;
    var inheritsObject = xobject.inheritsObject;
    var extend = xobject.extend;
    var clone = xobject.clone;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var isObject = xlang.isObject;
    var hasValue = xlang.hasValue;
    var sliceArray = Array.prototype.slice;
    
    //--------------------------
    // 
    //--------------------------

    /**
     * Model
     * 
     * @class
     * @extends xui.XObject
     */
    var XDATASOURCE = xui.XDatasource = 
            inheritsObject(XOBJECT, xdatasourceConstructor);
    var XDATASOURCE_CLASS = XDATASOURCE.prototype;

    /**
     * 
     *
     * @public
     * @constructor
     * @param {Object} options
     */
    function xdatasourceConstructor(options) {
        /**
         * 
         *
         * @type {Object}
         * @private
         */
        this._oEventHandlerMap = {};
        /**
         * keydatasourceId
         *
         * @type {Object}
         * @private
         */
        this._oSyncCombineSet = {};
        /**
         * datasourceId
         *
         * @type {Array.<xui.XDatasource>}
         * @private
         */
        this._aSyncCombineSetDefault = [];
        /**
         * requestkeyrequestId
         *
         * @type {Object}
         * @private
         */
        this._oRequestSet = {};
        /**
         * syncdatasourceId
         *
         * @type {string}
         * @private
         */
        this._sCurrentDatasourceId;
    }

    /**
     * hash mapdatasourceId
     * 
     * keydatasourceId
     * valuedatasourceId/
     * 
     * @class
     * @constructor
     * @param {Object=} set nullSet
     */
    var SET = XDATASOURCE.Set = function (set) {
        set && extend(this, set);
    };
    
    //---------------------------
    // 
    //---------------------------

    /**
     * 
     * successerror
     *
     * @type {number} 
     * @protected
     */
    XDATASOURCE_CLASS.DEFAULT_ERROR_STATUS = 999999999999;

    /**
     * XDatasource
     * 
     *
     * @protected
     */
    XDATASOURCE_CLASS.OPTIONS_NAME = [
        /**
         * sync
         * syncpreprocess
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          Function
         *              @param {Object} options sync
         * @protected
         */
        'preprocess',

        /**
         * OK,
         * OKsync
         *
         * @type {(Function|Any|xui.XDatasource.Set)} 
         *          Function
         *              @param {Object} options sync
         *              @return {Any} businessData  
         * @protected
         */
        'businessData', 
        
        /**
         * 
         * HTML
         * <div style="display:none" id="xxx"> ...some data... </div>
         * 
         * @type {(Function|Object|xui.XDatasource.Set)}
         *          Function, 
         *             param {Object} options sync
         *             return {Object} e-json
         *                  wrapEJson
         *          Objecte-json
         * @protected
         */
        'local',
        
        /**
         * url
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          Function, 
         *             param {Object} options sync
         *             return {string} url  
         * @protected
         */
        'url', 
        
        /**
         * HTTP'POST''GET'POST
         *
         * @type {(Function|string|xui.XDatasource.Set)}
         *          Function, 
         *             param {Object} options sync
         *             return {string} 
         * @protected
         */
        'method', 
        
        /**
         * businessKey (@see xajax)
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          Function, 
         *             param {Object} options sync
         *             return {string} 
         * @protected
         */
        'businessKey', 
        
        /**
         * 
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          Function, 
         *             param {Object} options sync
         *             return {string}    
         * @protected
         */
        'param',
        
        /**
         * 
         * 
         * @type {(Function|Any|xui.XDatasource.Set)}
         *          Function, 
         *             param {(Object|string)} data 
         *             param {(Object|string)} ejsonObj 
         *             param {Object} options sync
         *             return {Any} data 
         * @protected
         */
        'parse',
        
        /**
         * 
         *
         * @type {(Function|xui.XDatasource.Set)}
         *          Function, 
         *             param {(Object|string)} data parse
         *             param {(Object|string)} ejsonObj 
         *             param {Object} options sync
         * @protected
         */
        'result',
        
        /**
         * 
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          Function, 
         *             param {(Object|string)} status 
         *             param {(Object|string)} ejsonObj 
         *             param {Object} options sync
         * @protected
         */
        'error',
        
        /**
         * 
         * 
         * @type {(Function|xui.XDatasource.Set)} 
         *          Function, 
         *             param {Object} options sync
         * @protected
         */
        'timeout',

        /**
         * resulterror
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          Function, 
         *             param {Object} options sync
         * @protected
         */
        'complete',
        
        /**
         * 
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          Function, 
         *             param {Object} options sync
         * @protected
         */
        'finalize',
        
        /**
         * (ms)
         *
         * @type {(Function|number|xui.XDatasource.Set)} 
         *          Function, 
         *             param {Object} options sync
         *             return {number} timout
         * @protected
         */
        'timeoutTime',
        
        /**
         * XDatasource
         * syncurlparseresult
         * 
         * @type {(Function|string|number)} 
         *          Function, 
         *             param {Object} options sync
         *             return {string} datasourceId
         * @protected
         */
        'datasourceId',

        /**
         * ajax
         *
         * @type {(Function|Object|xui.XDatasource.Set)}
         *          Function, 
         *             param {Object} options sync
         *             return {Object} ajax
         * @protected
         */
        'ajaxOptions'
    ];
    
    //-------------------------------------------------------------
    //                                         
    //-------------------------------------------------------------

    /**
     * 
     * (1) 
     * (2) Ajax
     *
     * @public
     * @param {(Object|string)} options 
     *                   @see OPTIONS_NAME sync
     *                  xdatasource
     *                  stringdatasourceId
     *                  Object
     * @param {Object} options.datasourceId id
     * @param {Object} options.args 
     * @return {string} requestId Id
     */
    XDATASOURCE_CLASS.sync = function (options) {
        if (isString(options)) {
            options = { datasourceId: options, args: {} };
        } 
        else {
            options = options || {};
            options.args = options.args || {};
        }

        var datasourceId = getDatasourceId.call(this, options);
        this._sCurrentDatasourceId = datasourceId;

        // 
        handleSyncPreprocess.call(this, datasourceId, options);

        var data;
        var ejsonObj;
        var url;
        var requestId;

        // 
        if (hasValue(
                data = handleAttr.call(
                    this, datasourceId, 'businessData', options
                )
            )
        ) { 
            handleSyncHasData.call(this, datasourceId, options, data);
        }

        // 
        else if (
            hasValue(
                ejsonObj = handleAttr.call(
                    this, datasourceId, 'local', options
                )
            )
        ) { 
            handleSyncLocal.call(this, datasourceId, options, ejsonObj);
        }    

        //  
        else if (
            hasValue(
                url = handleAttr.call(this, datasourceId, 'url', options)
            )
        ){ 
            requestId = handleSyncRemote.call(
                this, datasourceId, options, url
            );
        }

        delete this._sCurrentDatasourceId;

        return requestId;
    };
    
    /**
     * 
     * businessKey
     *
     * @public
     */
    XDATASOURCE_CLASS.dispose = function () {
        this.abortAll();
        this._oSyncCombineSet = null;
        this._aSyncCombineSetDefault = null;
        XDATASOURCE.superClass.dispose.call(this);
    };
    
    /**
     * parse
     *
     * @protected
     * @param {*} data ejsonObjectdata
     * @param {Object} ejsonObj e-json
     */
    XDATASOURCE_CLASS.parse = function (data, ejsonObj) { 
        return data; 
    };
    
    /**
     * datasourceId
     *
     * @protected
     * @param {Object} options sync
     * @return {string} datasourceId Id
     */
    XDATASOURCE_CLASS.datasourceId = function (options) { 
        return void 0; 
    };
    
    /**
     * 
     * 
     *
     * @public
     * @param {*} businessData 
     * @param {string} datsourceId datasourceId
     */
    XDATASOURCE_CLASS.setBusinessData = function (businessData, datasourceId) {
        this.businessData = businessData || null;
        notifyEvent.call(
            this, datasourceId, 'set.businessdata', {}, [businessData]
        );
    };
    
    /**
     * datasourceIdsync
     * syncoptions.datasourceId
     *
     * @public
     * @return {string} datasourceId
     */
    XDATASOURCE_CLASS.getCurrentDatasourceId = function () {
        return this._sCurrentDatasourceId;
    };
    
    /**
     * Model
     *
     * @public
     */
    XDATASOURCE_CLASS.abortAll = function () {
        var requestIdSet = clone(this._oRequestSet);
        for (var requestId in requestIdSet) {
            this.abort(requestId);
        }
        this.notify('abortAll', [requestIdSet]);
    };
    
    /**
     * Model
     *
     * @public
     * @param {string} requestId Idsync
     */
    XDATASOURCE_CLASS.abort = function (requestId) {
        xajax.abort(requestId, true);
        delete this._oRequestSet[requestId];
    };
    
    /**
     * ejson
     *
     * @public
     * @param {*} data 
     * @param {number} status 
     *              000
     * @param {string} statusInfo 
     * @return {Object} e-json
     */
    XDATASOURCE_CLASS.wrapEJson = function (data, status, statusInfo) {
        return { data: data, status: status || 0, statusInfo: statusInfo };
    };
    
    /**
     * successerror
     * parseresult
     * parseresult
     * error
     *
     * @protected
     * @param {number=} status DEFAULT_ERROR_STATUS
     * @param {string=} statusInfo 
     */
    XDATASOURCE_CLASS.$goError = function (status, statusInfo) {
        this._bGoError = true;
        this._nErrorStatus = status == null ? DEFAULT_ERROR_STATUS : status;
        if (statusInfo != null) {
            this._sErrorStatusInfo = statusInfo; 
        }
    };

    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     */
    function handleSyncPreprocess(datasourceId, options) {
        handleAttr.call(this, datasourceId, 'preprocess', options);
        notifyEvent.call(this, datasourceId, 'sync.preprocess', options);
    }

    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     * @param {*} data 
     */
    function handleSyncHasData(datasourceId, options, data) {
        handleAttr.call(
            this, datasourceId, 'result', options, 
            [data, this.wrapEJson(data)]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.result', options, 
            [data, this.wrapEJson(data)]
        );
    }

    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     * @param {(Object|string)} ejsonObj e-json
     */
    function handleSyncLocal(datasourceId, options, ejsonObj) {
        handleCallback.call(
            this, datasourceId, handleComplete, options, ejsonObj
        );

        if (!ejsonObj.status) { 
            // status0 (@see e-json)
            handleCallback.call(
                this, datasourceId, handleSuccess, options, ejsonObj.data, ejsonObj
            );
        }
        else {
            handleCallback.call(
                this, datasourceId, handleFailure, options, ejsonObj.status, ejsonObj
            );
        }

        handleCallback.call(
            this, datasourceId, handleFinalize, options, ejsonObj
        );
    }

    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     * @param {string} url url
     * @return {string} requestId ID
     */
    function handleSyncRemote(datasourceId, options, url) {
        var opt = {};
        var me = this;
        var paramStr;

        // ajax
        opt.method = 
            handleAttr.call(me, datasourceId, 'method', options) 
            || 'POST';

        opt.businessKey = 
            handleAttr.call(me, datasourceId, 'businessKey', options);

        opt.data = 
            hasValue(
                paramStr = handleAttr.call(me, datasourceId, 'param', options)
            )
            ? paramStr : '';

        opt.timeout = 
            handleAttr.call(me, datasourceId, 'timeoutTime', options) 
            || undefined;

        opt.onsuccess = function (data, ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleSuccess, options, data, ejsonObj
            );
        };

        opt.onfailure = function (status, ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleFailure, options, status, ejsonObj
            );
        };

        opt.oncomplete = function (ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleComplete, options, ejsonObj
            );
            // requestId
            delete me._oRequestSet[requestId];
        };

        opt.onfinalize = function (ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleFinalize, options, ejsonObj
            );
        };

        opt.ontimeout = function () {
            handleCallback.call(
                me, datasourceId, handleTimeout, options
            );
        };

        opt = extend(
            opt, 
            handleAttr.call(me, datasourceId, 'ajaxOptions', options) || {}
        );
        
        this._sBusinessKey = opt.businessKey;

        // ajax
        var requestId = xajax.request(url, opt);
        this._oRequestSet[requestId] = 1;

        return requestId;
    }

    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Function} callback 
     * @param {Object} options 
     */    
    function handleCallback(datasourceId, callback, options) {
        var args= sliceArray.call(arguments, 3, arguments.length);

        callback.apply(this, [datasourceId, options].concat(args));

        var i;
        var o;
        var list;

        // sync combines
        if (hasValue(datasourceId)) {
            list = this._oSyncCombineSet[datasourceId] || [];
            for (i = 0; o = list[i]; i++) {
                callback.apply(o, [datasourceId, {}].concat(args));
            }
        }

        list = this._aSyncCombineSetDefault || [];
        for (i = 0; o = list[i]; i++) {
            callback.apply(o, [datasourceId, {}].concat(args));
        }
    }
    
    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     * @param {*} data 
     * @param {(Object|string)} ejsonObj e-json
     */    
    function handleSuccess(datasourceId, options, data, ejsonObj) {
        this._bGoError = false;

        function goFailure() {
            if (this._sErrorStatusInfo != null) {
                ejsonObj.statusInfo = this._sErrorStatusInfo;
            }
            handleCallback.call(
                this, 
                datasourceId, 
                handleFailure, 
                options, 
                this._nErrorStatus, 
                ejsonObj
            );
            this._bGoError = false;
            this._nErrorStatus = null;
            this._sErrorStatusInfo = null;
        }
        
        var data = handleAttr.call(
            this, datasourceId, 'parse', options, [data, ejsonObj]
        );
        if (this._bGoError) {
            goFailure.call(this);
            return;
        }

        handleAttr.call(
            this, datasourceId, 'result', options, [data, ejsonObj]
        );
        if (this._bGoError) {
            goFailure.call(this);
            return;
        }

        notifyEvent.call(
            this, datasourceId, 'sync.result', options, [data, ejsonObj]
        );
    }
    
    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     * @param {number} status 
     * @param {(Object|string)} ejsonObj e-json
     */    
    function handleFailure(datasourceId, options, status, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'error', options, [status, ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.error', options, [status, ejsonObj]
        );        
    }

    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     * @param {(Object|string)} ejsonObj e-json
     */    
    function handleComplete(datasourceId, options, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'complete', options, [ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.complete', options, [ejsonObj]
        );        
    }
    
    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     * @param {(Object|string)} ejsonObj e-json
     */    
    function handleFinalize(datasourceId, options, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'finalize', options, [ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.finalize', options, [ejsonObj]
        );        
    }
    
    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {Object} options 
     */    
    function handleTimeout(datasourceId, options) {
        handleAttr.call(this, datasourceId, 'timeout', options);
        notifyEvent.call(this, datasourceId, 'sync.timeout', options);
    }
    
    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {string} name 
     * @param {Object} options 
     * @param {Array} args 
     */    
    function handleAttr(datasourceId, name, options, args) {
        options = options || {};
        args = args || [];
        args.push(options);
        
        var o;
        var datasourceId;

        // options
        if (typeof options[name] != 'undefined') {
            o = options[name];
        } 
        else {
            // datasourceId
            o = this[name];
            // datasourceId
            if (hasValue(datasourceId) 
                && isObject(o) 
                && hasValue(o[datasourceId])
            ) {
                o = o[datasourceId];
            }
        }

        if (o instanceof SET) { o = null; }

        return isFunction(o) ? o.apply(this, args) : o;
    }
    
    /**
     * 
     *
     * @private
     * @param {string} datasourceId id
     * @param {string} eventName 
     * @param {Object} options 
     * @param {Array} args 
     */    
    function notifyEvent(datasourceId, eventName, options, args) {
        options = options || {};
        args = args || [];
        args.push(options);
        if (hasValue(datasourceId)) {
            this.notify(eventName + '.' + datasourceId, args);
        }
        this.notify(eventName, args);        
    }

    /**
     * id
     *
     * @private
     * @param {Object} options 
     * @return {string} id
     */    
    function getDatasourceId (options) {
        options = options || {};
        var datasourceId = hasValue(options.datasourceId) 
            ? options.datasourceId : this.datasourceId;
        return isFunction(datasourceId) 
            ? datasourceId.call(this, options) : datasourceId;
    }
    
    //-------------------------------------------------------------
    // [XDatasource/]                                               
    //-------------------------------------------------------------
    
    /**
     * syncXDatasource
     * XDatasource
     * syncXDatasource
     * 
     *
     * @public
     * @param {xui.XDatasource} xdatasource XDatasource
     * @param {string} datasourceId datasourceId
     *          datasourceId
     */
    XDATASOURCE_CLASS.addSyncCombine = function (xdatasource, datasourceId) {
        if (!(xdatasource instanceof XDATASOURCE)) { 
            return;
        }

        var o;
        if (hasValue(datasourceId)) {
            if (!(o = this._oSyncCombineSet[datasourceId])) {
                o = this._oSyncCombineSet[datasourceId] = [];
            }
            o.push(xdatasource);
        } 
        else {
            this._aSyncCombineSetDefault.push(xdatasource);
        }
    };
    
    /**
     * XDatasource
     * XDatasource
     * syncXDatasource
     * 
     *
     * @public
     * @param {xui.XDatasource} xdatasource XDatasource
     * @param {string} datasourceId addSyncCombine
     */
    XDATASOURCE_CLASS.removeSyncCombine = function (xdatasource, datasourceId) {
        if (!(xdatasource instanceof XDATASOURCE)) { return; }

        var o = hasValue(datasourceId) 
                    ? (this._oSyncCombineSet[datasourceId] || []) 
                    : (this._aSyncCombineSetDefault || []);

        for (var j = 0; j < o.length;) {
            (xdatasource === o[j]) ? o.splice(j, 1) : j++;
        }
    };
    
    //-------------------------------------------------------------
    // XDatasource
    //-------------------------------------------------------------
    
    /**
     * 
     * XDatasourceextend
     *
     * @public
     * @static
     * @param {Object} clz XDatasource
     * @param {Object} options  (@see OPTIONS_NAME)
     */
    XDATASOURCE.extend = function (clz, options) {
        if (clz instanceof XDATASOURCE && clz !== XDATASOURCE) {
            extend(clz.prototype, options);
        }
    };
    
})();

/**
 * xui.XView
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 * @usage:   
 *          (1) xui.XView.domReady
 *          (2) 
 *              <script type="text/javascript">
 *                  xui.XView.start("aaa.bbb.ccc.SomePageView");
 *              </script>
 *              SomePageView
 */

(function () {
    
    var XOBJECT = xui.XObject;
    var getByPath = xutil.object.getByPath;
    var inheritsObject = xutil.object.inheritsObject;
    
    /**
     * 
     *
     * @class
     */
    var XVIEW = xui.XView = inheritsObject(
        XOBJECT, 
        function (options) {
            this._el = options.el;
        }
    );
    var XVIEW_CLASS = XVIEW.prototype;

    /** 
     * DOM
     *
     * @public
     */
    XVIEW_CLASS.getEl = function() {
        return this._el;
    };

    /** 
     * DOM
     *
     * @public
     */
    XVIEW_CLASS.setEl = function(el) {
        this._el = el;
    };

    /** 
     * 
     *
     * @public
     */
    XVIEW_CLASS.dispose = function() {
        this._el = null;
    };

    /**
     * 
     * 
     * @public
     * @static
     * @param {string} viewPath 
     * @param {Object} options  
     * @return {ecui.ui.Control} 
     */    
    XVIEW.start = function (viewPath, options) {
        var viewClass;
        
        XVIEW.$domReady(
            function () {
                XVIEW.$preStart && XVIEW.$preStart(viewPath, options);

                viewPath && (viewClass = getByPath(viewPath));
                viewClass && (new viewClass(options)).init();

                XVIEW.$postStart && XVIEW.$postStart(viewPath, options);
            }
        );
    };

    /**
     * 
     * 
     * @private
     * @abstract
     * @static
     * @param {string} viewPath 
     * @param {Object} options  
     */
    XVIEW.$preStart = function (viewPath, options) {};

    /**
     * 
     * 
     * @private
     * @abstract
     * @static
     * @param {string} viewPath 
     * @param {Object} options  
     */
    XVIEW.$postStart = function (viewPath, options) {};

    /**
     * DOM READY
     * 
     * @private
     * @abstract
     * @static
     * @param {Function} callback
     */
    XVIEW.$domReady = null;

})();

/**
 * project declaration
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui.XProject
 */

// (function() { ... })()
// 
// 
 
// DI
xui.XProject.setNamespaceBase(
    window.__$DI__NS$__ = window.__$DI__NS$__ || {}
);

// 
var $namespace = xui.XProject.namespace;

// 
var $link = xui.XProject.link;

// 
var $end = xui.XProject.end;

// 
var $getNamespaceBase = xui.XProject.getNamespaceBase;

// DI
var di = $namespace('di');

// FIXME
// 
$getNamespaceBase().xui = xui;
$getNamespaceBase().xutil = xutil;

xutil.object.PATH_DEFAULT_CONTEXT = $getNamespaceBase();
var ecui;
(function () {

//{assign var="phases" value="define,body" delimiter=","}//
//{foreach item="item" from=$phases}//
//{assign var="phase" value=$item}//
//{include file="adapter.js"}//
//{include file="core.js"}//
//{include file="control.js"}//
//{include file="input-control.js"}//
//{include file="button.js"}//
//{include file="scrollbar.js"}//
//{include file="panel.js"}//
//{include file="items.js"}//
//{include file="checkbox.js"}//
//{include file="radio.js"}//
//{include file="select.js"}//

//{include file="combox.js"}//
//{include file="form.js"}//
//{include file="tree-view.js"}//
//{include file="month-view.js"}//
//{include file="table.js"}//
//{include file="locked-table.js"}//
//{include file="popup-menu.js"}//
//{include file="listbox.js"}//
//{include file="tab.js"}//
//{include file="decorate.js"}//
//{include file="combine.js"}//

//*{include file="label.js"}//
//*{include file="progress.js"}//
//*{include file="collection.js"}//
//*{include file="calendar.js"}//
//*{include file="format-edit.js"}//
//*{include file="radio-tree.js"}//
//*{include file="check-tree.js"}//
//*{include file="color.js"}//
//*{include file="palette.js"}//
//*{include file="multi-select.js"}//
//*{include file="locked-table.js"}//
//*{include file="messagebox.js"}//
//*{include file="shield.js"}//
//*{include file="tween.js"}//
//{/foreach}//
})();

//{if 0}//
(function () {
//{/if}//
//{if $phase == "define"}//

//__gzip_unitize__i
//__gzip_unitize__list
//__gzip_unitize__o
//__gzip_unitize__el
//__gzip_unitize__params
    var core = ecui = {},
        array = core.array = {},
        dom = core.dom = {},
        ext = core.ext = {},
        json = core.json = {},
        string = core.string = {},
        ui = core.ui = {},
        util = core.util = {};

    //__gzip_original__WINDOW
    ///__gzip_original__DOCUMENT
    //__gzip_original__DATE
    //__gzip_original__FUNCTION
    //__gzip_original__MATH
    //__gzip_original__REGEXP
    //__gzip_original__ABS
    //__gzip_original__CEIL
    ///__gzip_original__FLOOR
    ///__gzip_original__MAX
    ///__gzip_original__MIN
    //__gzip_original__POW
    ///__gzip_original__ROUND
    ///__gzip_original__PARSEINT
    //__gzip_original__ISNAN
    var undefined,
        WINDOW = window,
        DOCUMENT = document,
        DATE = Date,
        FUNCTION = Function,
        MATH = Math,
        REGEXP = RegExp,
        ABS = MATH.abs,
        CEIL = MATH.ceil,
        FLOOR = MATH.floor,
        MAX = MATH.max,
        MIN = MATH.min,
        POW = MATH.pow,
        ROUND = MATH.round,
        PARSEINT = parseInt,
        ISNAN = isNaN;

    var USER_AGENT = navigator.userAgent,
        isStrict = DOCUMENT.compatMode == 'CSS1Compat',
        ieVersion = dom.ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        firefoxVersion = dom.firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,
        operaVersion = dom.operaVersion = /opera\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,
        safariVersion = dom.safariVersion = 
            /(\d+\.\d)(\.\d)?\s+safari/i.test(USER_AGENT) && !/chrome/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined;

    // 
    var charset = {
            utf8: {
                byteLength: function (source) {
                    return source.replace(/[\x80-\u07ff]/g, '  ').replace(/[\u0800-\uffff]/g, '   ').length;
                },

                codeLength: function (code) {
                    return code > 2047 ? 3 : code > 127 ? 2 : 1;
                }
            },

            gbk: {
                byteLength: function (source) {
                    return source.replace(/[\x80-\uffff]/g, '  ').length;
                },

                codeLength: function (code) {
                    return code > 127 ? 2 : 1;
                }
            },

            '': {
                byteLength: function (source) {
                    return source.length;
                },

                codeLength: function (code) {
                    return 1;
                }
            }
        };

    //  css 
    var styleFixer = {
            display:
                ieVersion < 8 ? {
                    get: function (el, style) {
                        return style.display == 'inline' && style.zoom == 1 ? 'inline-block' : style.display;
                    },

                    set: function (el, value) {
                        if (value == 'inline-block') {
                            value = 'inline';
                            el.style.zoom = 1;
                        }
                        el.style.display = value;
                    }
                } : firefoxVersion < 3 ? {
                    get: function (el, style) {
                        return style.display == '-moz-inline-box' ? 'inline-block' : style.display;
                    },

                    set: function (el, value) {
                        el.style.display = value == 'inline-block' ? '-moz-inline-box' : value;
                    }
                } : undefined,

            opacity:
                ieVersion ? {
                    get: function (el, style) {
                        return /alpha\(opacity=(\d+)/.test(style.filter) ? ((REGEXP.$1 - 0) / 100) + '' : '1';
                    },

                    set: function (el, value) {
                        el.style.filter =
                            el.style.filter.replace(/alpha\([^\)]*\)/gi, '') + 'alpha(opacity=' + value * 100 + ')';
                    }
                } : undefined,

            'float': ieVersion ? 'styleFloat' : 'cssFloat'
        };

        /**
         * 
         * indexOf  -1
         * @public
         * 
         * @param {Array} list 
         * @param {Object} obj 
         * @return {number}  -1
         */
    var indexOf = array.indexOf = function (list, obj) {
            for (var i = list.length; i--; ) {
                if (list[i] === obj) {
                    break;
                }
            }
            return i;
        },

        /**
         * 
         * @public
         * 
         * @param {Array} list 
         * @param {Object} obj 
         */
        remove = array.remove = function (list, obj) {
            for (var i = list.length; i--; ) {
                if (list[i] === obj) {
                    list.splice(i, 1);
                }
            }
        },

        /**
         *  Element 
         * @public
         * 
         * @param {HTMLElement} el Element 
         * @param {string} className 
         */
        addClass = dom.addClass = function (el, className) {
            // 
            //  removeClass 
            el.className += ' ' + className;
        },

        /**
         *  parentNode  Element  Element 
         * @public
         * 
         * @param {HTMLElement} el Element 
         * @return {Array} Element 
         */
        children = dom.children = function (el) {
            for (var result = [], o = el.firstChild; o; o = o.nextSibling) {
                if (o.nodeType == 1) {
                    result.push(o);
                }
            }
            return result;    
        },

        /**
         *  Element  Element 
         * contain  Element 
         * @public
         * 
         * @param {HTMLElement} container  Element 
         * @param {HTMLElement} contained  Element 
         * @return {boolean} contained  container  DOM 
         */
        contain = dom.contain = firefoxVersion ? function (container, contained) {
            return container == contained || !!(container.compareDocumentPosition(contained) & 16);
        } : function (container, contained) {
            return container.contains(contained);
        },

        /**
         *  Element 
         * @public
         * 
         * @param {string} className 
         * @param {string} cssText 
         * @param {string} tagName  div 
         * @return {HTMLElement}  Element 
         */
        createDom = dom.create = function (className, cssText, tagName) {
            tagName = DOCUMENT.createElement(tagName || 'DIV');
            if (className) {
                tagName.className = className;
            }
            if (cssText) {
                tagName.style.cssText = cssText;
            }
            return tagName;
        },

        /**
         *  Element  Element 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {HTMLElement}  Element 
         */
        first = dom.first = function (el) {
            return matchNode(el.firstChild, 'nextSibling');
        },

        /**
         *  Element 
         *  IE Element  getAttribute 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @param {string} name 
         * @return {string} 
         */
        getAttribute = dom.getAttribute = ieVersion < 8 ? function (el, name) {
            return el[name];
        } : function (el, name) {
            return el.getAttribute(name);
        },

        /**
         *  Element  Element 
         *  IE Element  removeChild parentNode  Element  W3C  parentElement
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {HTMLElement}  Element  null
         */
        getParent = dom.getParent = ieVersion ? function (el) {
            return el.parentElement;
        } : function (el) {
            return el.parentNode;
        },

        /**
         *  Element 
         * getPosition  Element 
         * left {number} X
         * top  {number} Y
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {Object} 
         */
        getPosition = dom.getPosition = function (el) {
            var top = 0,
                left = 0,
                body = DOCUMENT.body,
                html = getParent(body);

            if (ieVersion) {
                if(!isStrict) {
                    // IE  body 
                    o = getStyle(body);
                    if (ISNAN(top = PARSEINT(o.borderTopWidth))) {
                        top = -2;
                    }
                    if (ISNAN(left = PARSEINT(o.borderLeftWidth))) {
                        left = -2;
                    }
                }

                o = el.getBoundingClientRect();
                top += html.scrollTop + body.scrollTop - html.clientTop + FLOOR(o.top);
                left += html.scrollLeft + body.scrollLeft - html.clientLeft + FLOOR(o.left);
            }
            else if (el == body) {
                top = html.scrollTop + body.scrollTop;
                left = html.scrollLeft + body.scrollLeft;
            }
            else if (el != html) {
                for (o = el; o; o = o.offsetParent) {
                    top += o.offsetTop;
                    left += o.offsetLeft;
                }

                if (operaVersion || (/webkit/i.test(USER_AGENT) && getStyle(el, 'position') == 'absolute')) {
                    top -= body.offsetTop;
                }

                for (var o = getParent(el), style = getStyle(el); o != body; o = getParent(o), style = el) {
                    left -= o.scrollLeft;
                    if (!operaVersion) {
                        el = getStyle(o);
                        //  html 
                        html = firefoxVersion && el.overflow != 'visible' && style.position == 'absolute' ? 2 : 1;
                        top += toNumber(el.borderTopWidth) * html - o.scrollTop;
                        left += toNumber(el.borderLeftWidth) * html;
                    }
                    else if (o.tagName != 'TR') {
                        top -= o.scrollTop;
                    }
                }
            }

            return {top: top, left: left};
        },

        /**
         *  Element  CssStyle 
         * getStyle  Element  CssStyle 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @param {string} name 
         * @return {CssStyle|Object} CssStyle 
         */
        getStyle = dom.getStyle = function (el, name) {
            var fixer = styleFixer[name],
                style = el.currentStyle || (ieVersion ? el.style : getComputedStyle(el, null));

            return name ? fixer && fixer.get ? fixer.get(el, style) : style[fixer || name] : style;
        },

        /**
         *  Element 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {string} Element 
         */
        getText = dom.getText = firefoxVersion ? function (el) {
            return el.textContent;
        } : function (el) {
            return el.innerText;
        },

        /**
         *  Element  Element 
         *  Element  Element  remove 
         * @public
         *
         * @param {HTMLElement} el  Element 
         * @param {HTMLElement} target  Element 
         * @return {HTMLElement}  Element 
         */
        insertAfter = dom.insertAfter = function (el, target) {
            var parent = getParent(target);
            return parent ? parent.insertBefore(el, target.nextSibling) : removeDom(el);
        },

        /**
         *  Element  Element 
         *  Element  Element  remove 
         * @public
         *
         * @param {HTMLElement} el  Element 
         * @param {HTMLElement} target  Element 
         * @return {HTMLElement}  Element 
         */
        insertBefore = dom.insertBefore = function (el, target) {
            var parent = getParent(target);
            return parent ? parent.insertBefore(el, target) : removeDom(el);
        },

        /**
         *  Element  html 
         * @public
         * 
         * @param {HTMLElement} el Element 
         * @param {string} position  html  beforeBegin,afterBegin,beforeEnd,afterEnd
         * @param {string} html  html 
         */
        insertHTML = dom.insertHTML = firefoxVersion ? function (el, position, html) {
            var name = {
                    AFTERBEGIN: 'selectNodeContents',
                    BEFOREEND: 'selectNodeContents',
                    BEFOREBEGIN: 'setStartBefore',
                    AFTEREND: 'setEndAfter'
                }[position.toUpperCase()],
                range = DOCUMENT.createRange();

            range[name](el);
            range.collapse(position.length > 9);
            range.insertNode(range.createContextualFragment(html));
        } : function (el, position, html) {
            el.insertAdjacentHTML(position, html);
        },

        /**
         *  Element  Element 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {HTMLElement}  Element 
         */
        last = dom.last = function (el) {
            return matchNode(el.lastChild, 'previousSibling');
        },

        /**
         *  Element  Element 
         * @public
         *
         * @param {HTMLElement} source  Element 
         * @param {HTMLElement} target  Element 
         * @param {boolean} all  DOM  ElementNode 
         */
        moveElements = dom.moveElements = function (source, target, all) {
            //__transform__el_o
            for (var el = source.firstChild; el; el = source) {
                source = el.nextSibling;
                if (all || el.nodeType == 1) {
                    target.appendChild(el);
                }
            }
        },

        /**
         *  Element  Element 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {HTMLElement} Element 
         */
        next = dom.next = function (el) {
            return matchNode(el.nextSibling, 'nextSibling');
        },

        /**
         *  Element 
         * @public
         * 
         * @param {HTMLElement} el Element 
         * @return {HTMLElement}  Element 
         */
        removeDom = dom.remove = function (el) {
            var parent = getParent(el);
            if (parent) {
                parent.removeChild(el);
            }
            return el;
        },

        /**
         *  Element 
         * @public
         * 
         * @param {HTMLElement} el Element 
         * @param {string} className 
         */
        removeClass = dom.removeClass = function (el, className) {
            var oldClasses = el.className.split(/\s+/).sort(),
                newClasses = className.split(/\s+/).sort(),
                i = oldClasses.length,
                j = newClasses.length;

            for (; i && j; ) {
                if (oldClasses[i - 1] == newClasses[j - 1]) {
                    oldClasses.splice(--i, 1);
                }
                else if (oldClasses[i - 1] < newClasses[j - 1]) {
                    j--;
                }
                else {
                    i--;
                }
            }
            el.className = oldClasses.join(' ');
        },

        /**
         * 
         * setInput 
         * @public
         *
         * @param {HTMLElement} el InputElement 
         * @param {string} name  el 
         * @param {string} type  el 
         * @return {HTMLElement}  InputElement 
         */
        setInput = dom.setInput = function (el, name, type) {
            if (!el) {
                if (type == 'textarea') {
                    el = createDom('', '', 'textarea');
                }
                else {
                    if (ieVersion < 9) {
                        return createDom('', '', '<input type="' + (type || '') + '" name="' + (name || '') + '">');
                    }
                    el = createDom('', '', 'input');
                }
            }

            name = name === undefined ? el.name : name;
            type = type === undefined ? el.type : type;

            if (el.name != name || el.type != type) {
                if ((ieVersion && type != 'textarea') ||
                        el.type != type && (el.type == 'textarea' || type == 'textarea')) {
                    insertHTML(
                        el,
                        'AFTEREND',
                        '<' + (type == 'textarea' ? 'textarea' : 'input type="' + type + '"') +
                            ' name="' + name + '" class="' + el.className +
                            '" style="' + el.style.cssText + '" ' + (el.disabled ? 'disabled' : '') +
                            (el.readOnly ? ' readOnly' : '') + '>'
                    );
                    name = el;
                    (el = el.nextSibling).value = name.value;
                    if (type == 'radio') {
                        el.checked = name.checked;
                    }
                    removeDom(name);
                }
                else {
                    el.type = type;
                    el.name = name;
                }
            }
            return el;
        },

        /**
         *  Element 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @param {string} name 
         * @param {string} value 
         */
        setStyle = dom.setStyle = function (el, name, value) {
            var fixer = styleFixer[name];
            if (fixer && fixer.set) {
                fixer.set(el, value);
            }
            else {
                el.style[fixer || name] = value;
            }
        },

        /**
         *  Element 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @param {string} text Element 
         */
        setText = dom.setText = firefoxVersion ? function (el, text) {
            el.textContent = text;
        } : function (el, text) {
            el.innerText = text;
        },

        /**
         * JSONJSONJSON
         * @public
         *
         * @param {string} text json
         * @return {Object} json
         */
        parse = json.parse = function (text) {
            return new Function('return (' + text + ')')();
        },

        /**
         * JSON
         * @public
         *
         * @param {Object} source 
         * @return {string} json
         */
        stringify = json.stringify = (function () {
//__gzip_unitize__result
//__gzip_unitize__source
            var escapeMap = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"' : '\\"',
                    '\\': '\\\\'
                };

            /**
             * 
             * @private
             *
             * @param {string} source 
             */
            function encodeString(source) {
                if (/["\\\x00-\x1f]/.test(source)) {
                    source = source.replace(
                        /["\\\x00-\x1f]/g,
                        function (match) {
                            var o = escapeMap[match];
                            if (o) {
                                return o;
                            }
                            o = match.charCodeAt();
                            return '\\u00' + FLOOR(o / 16) + (o % 16).toString(16);
                        }
                    );
                }
                return '"' + source + '"';
            }

            /**
             * 
             * @private
             *
             * @param {Array} source 
             */
            function encodeArray(source) {
                var i = 0,
                    result = [],
                    o,
                    l = source.length;

                for (var i = 0, result = [], o, l = source.length; i < l; i++) {
                    if ((o = stringify(source[i])) !== undefined) {
                        result.push(o);
                    }
                }
                return '[' + result.join(',') + ']';
            }

            /**
             * 
             * @private
             *
             * @param {number} source 10
             */
            function pad(source) {
                return source < 10 ? '0' + source : source;
            }

            /**
             * 
             * @private
             *
             * @param {Date} source 
             */
            function encodeDate(source) {
                return '"' + source.getFullYear() + '-' + pad(source.getMonth() + 1) + '-' +
                        pad(source.getDate()) + 'T' + pad(source.getHours()) + ':' +
                        pad(source.getMinutes()) + ':' + pad(source.getSeconds()) + '"';
            }

            return function (source) {
                switch (typeof source) {
                case 'undefined':
                case 'function':
                case 'unknown':
                    return undefined;
                case 'number':
                    if (!isFinite(source)) {
                        return 'null';
                    }
                    // 
                case 'boolean':
                    return source.toString();
                case 'string':
                    return encodeString(source);
                default:
                    if (source === null) {
                        return 'null';
                    }
                    else if (source instanceof Array) {
                        return encodeArray(source);
                    }
                    else if (source instanceof Date) {
                        return encodeDate(source);
                    }
                    else {
                        var result = [],
                            o;

                        for (var i in source) {
                            if ((o = stringify(source[i])) !== undefined) {
                                result.push(encodeString(i) + ':' + o);
                            }
                        }

                        return '{' + result.join(',') + '}';
                    }
                }
            };
        })(),

        /**
         *  html 
         * @public
         *
         * @param {string} source 
         * @return {string} 
         */
        decodeHTML = string.decodeHTML = (function () {
            var codeTable = {
                quot: '"',
                lt: '<',
                gt: '>',
                amp: '&'
            };

            return function (source) {
                //
                return source.replace(/&(quot|lt|gt|amp|#([\d]+));/g, function(match, $1, $2) {
                    return codeTable[$1] || String.fromCharCode(+$2);
                });
            };
        })(),

        /**
         *  html 
         * encodeHTML  &<>"
         * @public
         *
         * @param {string} source 
         * @return {string} 
         */
        encodeHTML = string.encodeHTML = function (source) {
            return source.replace(/[&<>"']/g, function (c) {
                return '&#' + c.charCodeAt(0) + ';';
            });
        },

        /**
         * 
         *  length 
         * 
         * @param {string} source 
         * @param {string} charsetName 
         * @return {number} 
         */
        getByteLength = string.getByteLength = function (source, charsetName) {
            return charset[charsetName || ''].byteLength(source);
        },

        /**
         * 
         *  slice 
         * 
         * @param {string} source 
         * @param {number} length 
         * @param {string} charsetName 
         * @return {string} 
         */
        sliceByte = string.sliceByte = function (source, length, charsetName) {
            for (var i = 0, func = charset[charsetName || ''].codeLength; i < source.length; i++) {
                length -= func(source.charCodeAt(i));
                if (length < 0) {
                    return source.slice(0, i);
                }
            }

            return source;
        },

        /**
         * 
         * toCamelCase  xxx-xxx  xxxXxx
         * @public
         *
         * @param {string} source 
         * @return {string} 
         */
        toCamelCase = string.toCamelCase = function (source) {
            if (source.indexOf('-') < 0) {
                return source;
            }
            return source.replace(/\-./g, function (match) {
                return match.charAt(1).toUpperCase();
            });
        },

        /**
         * 
         * 
         * @param {string} source 
         * @return {string} 
         */
        toHalfWidth = string.toHalfWidth = function (source) {
            return source.replace(/[\u3000\uFF01-\uFF5E]/g, function (c) {
                return String.fromCharCode(MAX(c.charCodeAt(0) - 65248, 32));
            });
        },

        /**
         * 
         * @public
         *
         * @param {string} source 
         * @return {string} 
         */
        trim = string.trim = function (source) {
            return source && source.replace(/^\s+|\s+$/g, '');
        },

        /**
         * 
         * @public
         *
         * @param {Date} source 
         * @param {string} pattern 
         * @return {string} 
         */
        formatDate = string.formatDate = function (source, pattern) {
            var year = source.getFullYear(),
                month = source.getMonth() + 1,
                date = source.getDate(),
                hours = source.getHours(),
                minutes = source.getMinutes(),
                seconds = source.getSeconds();

            return pattern.replace(/(y+|M+|d+|H+|h+|m+|s+)/g, function (match) {
                var length = match.length;
                switch (match.charAt()) {
                case 'y':
                    return length > 2 ? year : year.toString().slice(2);
                case 'M':
                    match = month;
                    break;
                case 'd':
                    match = date;
                    break;
                case 'H':
                    match = hours;
                    break;
                case 'h':
                    match = hours % 12;
                    break;
                case 'm':
                    match = minutes;
                    break;
                case 's':
                    match = seconds;
                }
                return length > 1 && match < 10 ? '0' + match : match;
            });
        },

        /**
         * 
         * @public
         *
         * @param {Object} obj 
         * @param {string} type 
         * @param {Function} func 
         */
        attachEvent = util.attachEvent = ieVersion ? function (obj, type, func) {
            obj.attachEvent('on' + type, func);
        } : function (obj, type, func) {
            obj.addEventListener(type, func, false);
        },

        /*
         * 
         * blank  blank  cancel
         * @public
         */
        blank = util.blank = function () {
        },

        /**
         * 
         * callSuper 
         * @public
         *
         * @param {Object} object 
         * @param {string} name 
         * @return {Object} 
         */
        callSuper = util.callSuper = function (object, name) {
            /**
             * 
             * @private
             *
             * @param {Object} clazz 
             * @param {Function} caller  caller 
             * @return {Function}  undefined null
             */
            function findPrototype(clazz, caller) {
                for (; clazz; clazz = clazz.constructor.superClass) {
                    if (clazz[name] == caller) {
                        for (; clazz = clazz.constructor.superClass; ) {
                            if (clazz[name] != caller) {
                                return clazz[name];
                            }
                        }
                        return null;
                    }
                }
            }

            //__gzip_original__clazz
            var clazz = object.constructor.prototype,
                caller = callSuper.caller,
                func = findPrototype(clazz, caller);

            if (func === undefined) {
                // ItemsprototypecallerItems.xxx.callcaller.caller
                func = findPrototype(clazz, caller.caller);
            }

            if (func) {
                return func.apply(object, caller.arguments);
            }
        },

        /*
         *  false
         * cancel  false cancel  blank
         * @public
         *
         * @return {boolean} false
         */
        cancel = util.cancel = function () {
            return false;
        },

        /**
         * 
         * @public
         *
         * @param {Object} obj 
         * @param {string} type 
         * @param {Function} func 
         */
        detachEvent = util.detachEvent = ieVersion ? function (obj, type, func) {
            obj.detachEvent('on' + type, func);
        } : function (obj, type, func) {
            obj.removeEventListener(type, func, false);
        },

        /**
         * 
         * @public
         *
         * @param {Object} target 
         * @param {Object} source 
         * @return {Object} 
         */
        extend = util.extend = function (target, source) {
            for (var key in source) {
                target[key] = source[key];
            }
            return target;
        },

        /**
         * 
         * getView 
         * top        {number} X
         * right      {number} Y
         * bottom     {number} X
         * left       {number} Y
         * width      {number} 
         * height     {number} 
         * pageWidth  {number} 
         * pageHeight {number} 
         * @public
         *
         * @return {Object} 
         */
        getView = util.getView = function () {
            //__gzip_original__clientWidth
            //__gzip_original__clientHeight
            var body = DOCUMENT.body,
                html = getParent(body),
                client = isStrict ? html : body,
                scrollTop = html.scrollTop + body.scrollTop,
                scrollLeft = html.scrollLeft + body.scrollLeft,
                clientWidth = client.clientWidth,
                clientHeight = client.clientHeight;

            return {
                top: scrollTop,
                right: scrollLeft + clientWidth,
                bottom: scrollTop + clientHeight,
                left: scrollLeft,
                width: clientWidth,
                height: clientHeight,
                pageWidth: MAX(html.scrollWidth, body.scrollWidth, clientWidth),
                pageHeight: MAX(html.scrollHeight, body.scrollHeight, clientHeight)
            };
        },

        /**
         * 
         * @public
         *
         * @param {Function} subClass 
         * @param {Function} superClass 
         * @return {Object} subClass  prototype 
         */
        inherits = util.inherits = function (subClass, superClass) {
            var oldPrototype = subClass.prototype,
                clazz = new FUNCTION();
                
            clazz.prototype = superClass.prototype;
            extend(subClass.prototype = new clazz(), oldPrototype);
            subClass.prototype.constructor = subClass;
            subClass.superClass = superClass.prototype;

            return subClass.prototype;
        },

        /**
         * 
         * setDefault 
         * @public
         *
         * @param {Object} obj 
         * @param {string} key 
         * @param {Object} value 
         */
        setDefault = util.setDefault = function (obj, key, value) {
            if (!obj.hasOwnProperty(key)) {
                obj[key] = value;
            }
        },

        /**
         * 
         * @public
         *
         * @param {Function} func 
         * @param {number} delay 
         * @param {Object} caller  func this 
         * @param {Object} ...  func 
         * @return {Function} 
         */
        timer = util.timer = function (func, delay, caller) {
            function build() {
                return (delay < 0 ? setInterval : setTimeout)(function () {
                    func.apply(caller, args);
                    // delay<0delay>=0delay
                    if (!(delay < 0)) {
                        func = caller = args = null;
                    }
                }, ABS(delay));
            }

            var args = Array.prototype.slice.call(arguments, 3),
                handle = build(),
                pausing;

            /**
             * 
             * @public
             *
             * @param {boolean} pause  true true 
             */
            return function (pause) {
                (delay < 0 ? clearInterval : clearTimeout)(handle);
                if (pause) {
                    if (pausing) {
                        handle = build();
                    }
                    pausing = !pausing;
                }
                else {
                    func = caller = args = null;
                }
            };
        },

        /**
         * 
         * toNumber  9px  9 0
         * @public
         *
         * @param {Object} obj 
         * @return {number} 
         */
        toNumber = util.toNumber = function (obj) {
            return PARSEINT(obj) || 0;
        },

        /**
         * 
         * @public
         *
         * @param {Function} func 
         */
        ready = dom.ready = (function () {
            var hasReady = false,
                list = [],
                check,
                numStyles;

            function ready() {
                if (!hasReady) {
                    hasReady = true;
                    for (var i = 0, o; o = list[i++]; ) {
                        o();
                    }
                }
            }

            if (DOCUMENT.addEventListener && !operaVersion) {
                DOCUMENT.addEventListener('DOMContentLoaded', ready, false);
            }
            else if (ieVersion && WINDOW == top) {
                check = function () {
                    try {
                        DOCUMENT.documentElement.doScroll('left');
                        ready();
                    }
                    catch (e) {
                        timer(check, 0);
                    }
                };
            }
            else if (safariVersion) {
                check = function () {
                    var i = 0,
                        list,
                        o = DOCUMENT.readyState;

                    if (o != 'loaded' && o != 'complete') {
                        timer(check, 0);
                    }
                    else {
                        if (numStyles === undefined) {
                            numStyles = 0;
                            if (list = DOCUMENT.getElementsByTagName('style')) {
                                numStyles += list.length;
                            }
                            if (list = DOCUMENT.getElementsByTagName('link')) {
                                for (; o = list[i++]; ) {
                                    if (getAttribute(o, 'rel') == 'stylesheet') {
                                        numStyles++;
                                    }
                                }
                            }
                        }
                        if (DOCUMENT.styleSheets.length != numStyles) {
                            timer(check, 0);
                        }
                        else {
                            ready();
                        }
                    }
                };
            }

            if (check) {
                check();
            }

            attachEvent(WINDOW, 'load', ready);

            return function (func) {
                if (hasReady) {
                    func();
                }
                else {
                    list.push(func);
                }
            };
        })();
//{else}//
    /**
     *  Element  Element 
     * @private
     *
     * @param {HTMLElement} el Element 
     * @param {string} direction Element 
     * @return {HTMLElement}  Element 
     */
    function matchNode(el, direction) {
        for (; el; el = el[direction]) {
            if (el.nodeType == 1) {
                break;
            }
        }
        return el;
    }

    try {
        DOCUMENT.execCommand("BackgroundImageCache", false, true);
    }
    catch (e) {
    }
//{/if}//
//{if 0}//
})();
//{/if}//

//{if 0}//
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ext = core.ext,
        string = core.string,
        util = core.util,
        ui = core.ui,

        undefined,
        WINDOW = window,
        DOCUMENT = document,
        DATE = Date,
        MATH = Math,
        REGEXP = RegExp,
        ABS = MATH.abs,
        MAX = MATH.max,
        MIN = MATH.min,
        ISNAN = isNaN,

        USER_AGENT = navigator.userAgent,
        isStrict = DOCUMENT.compatMode == 'CSS1Compat',
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,

        indexOf = array.indexOf,
        remove = array.remove,
        addClass = dom.addClass,
        contain = dom.contain,
        createDom = dom.create,
        getAttribute = dom.getAttribute,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getStyle = dom.getStyle,
        insertHTML = dom.insertHTML,
        ready = dom.ready,
        removeDom = dom.remove,
        removeClass = dom.removeClass,
        setStyle = dom.setStyle,
        toCamelCase = string.toCamelCase,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        extend = util.extend,
        getView = util.getView,
        inherits = util.inherits,
        timer = util.timer,
        toNumber = util.toNumber;
//{/if}//
//{if $phase == "define"}//
    var NORMAL  = core.NORMAL  = 0,
        LOADING = core.LOADING = 1,
        REPAINT = core.REPAINT = 2;

//__gzip_unitize__event
    var $bind,
        $connect,
        $clearState,
        $create,
        $fastCreate,
        calcHeightRevise,
        calcLeftRevise,
        calcTopRevise,
        calcWidthRevise,
        createControl,
        disposeControl,
        drag,

        /**
         *  Element  ECUI 
         * findControl  Element  Element ( $bind ) ECUI findControl 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {ecui.ui.Control} ECUI  null
         */
        findControl = core.findControl = function (el) {
            for (; el; el = getParent(el)) {
                if (el.getControl) {
                    return el.getControl();
                }
            }

            return null;
        },
        getActived,
        getAttributeName,
        getFocused,
        getHovered,
        getKey,
        getMouseX,
        getMouseY,
        getOptions,
        getScrollNarrow,
        getStatus,
        inheritsControl,
        intercept,
        isContentBox,
        loseFocus,
        mask,
        needInitClass,
        query,
        restore,
        setFocused,
        triggerEvent,
        wrapEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ];

    (function () {
        /**
         *  ECUI 
         * @public
         *
         * @param {string} type 
         * @param {Event} event 
         */
        ///__gzip_original__UI_EVENT_CLASS
        var UI_EVENT = ui.Event = function (type, event) {
                this.type = type;

                if (event) {
                    this.pageX = event.pageX;
                    this.pageY = event.pageY;
                    this.which = event.which;
                    this.target = event.target;
                    this._oNative = event;
                }
                else {
                    this.pageX = mouseX;
                    this.pageY = mouseY;
                    this.which = keyCode;
                    this.target = DOCUMENT;
                }
            },
            UI_EVENT_CLASS = UI_EVENT.prototype,

            ecuiName = 'ecui',        // Element  ecui 
            isGlobalId,               //  ecui 
            structural,               // DOM01class2

            flgContentBox,            // 
            flgFixedOffset,           // 
            scrollNarrow,             // 

            initRecursion = 0,        // init 
            lastClientWidth,          // 

            plugins = {},             // 
            maskElements = [],        // 

            mouseX,                   // X
            mouseY,                   // Y
            keyCode = 0,              // keypresskeyupkeyCode
            lastClick,                // 

            status,                   // 
            allControls = [],         // 
            independentControls = [], // create($create)
            namedControls,            // 
            uniqueIndex = 0,          // 
            connectedControls = {},   // 

            activedControl,           // 
            hoveredControl,           // 
            focusedControl,           // 

            eventListeners = {},      // 

            envStack = [],            // 
            currEnv = {               // 

                // 
                click: function (event) {
                    event =wrapEvent(event);

                    //__transform__control_o
                    var control = findControl(event.target);

                    if (control && control.isDisabled()) {
                        event.preventDefault();
                    }
                },

                // 
                mousedown: function (event) {
                    if (activedControl) {
                        // ALT+TAB
                        // 
                        bubble(activedControl, 'deactivate');
                        activedControl = null;
                        return;
                    }

                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl(),
                        // ieiframe
                        flag = ieVersion < 8 && isScrollClick(event),
                        target = control;

                    if (!(lastClick && isDblClick())) {
                        lastClick = {time: new DATE().getTime()};
                    }

                    if (control) {
                        if (flag) {
                            // IE8
                            // 
                            // 
                            return;
                        }

                        for (; target; target = target.getParent()) {
                            if (target.isFocusable()) {
                                if (!(target != control && target.contain(focusedControl))) {
                                    // 
                                    // 
                                    // 
                                    setFocused(target);
                                }
                                break;
                            }
                        }

                        if (!flag) {
                            // 
                            mousedown(control, event);
                        }
                    }
                    else {
                        if (control = findControl(target = event.target)) {
                            // 
                            onselectstart(control, event);
                            // INPUT/SELECT/TEXTAREA/BUTTON
                            if (target.tagName == 'INPUT' || target.tagName == 'SELECT' ||
                                    target.tagName == 'TEXTAREA' || target.tagName == 'BUTTON') {
                                timer(function () {
                                    target.blur();
                                });
                            }
                        }
                        // 
                        setFocused();
                        //  activedControl  nulldownundefined
                        activedControl = undefined;
                    }
                },

                // 
                mouseover: function (event) {
                    if (currEnv.type != 'drag' && currEnv.type != 'zoom') {
                        event = wrapEvent(event);

                        //__transform__control_o
                        var control = event.getControl(),
                            parent = getCommonParent(control, hoveredControl);

                        bubble(hoveredControl, 'mouseout', event, parent);
                        bubble(control, 'mouseover', event, parent);

                        hoveredControl = control;
                    }
                },

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl();

                    bubble(control, 'mousemove', event);
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl(),
                        commonParent;

                    if (activedControl !== null) {
                        //  null  mousedown  mouseup
                        //  down  up
                        //  ie  dblclick  mouseup
                        // dblclick  ie  mousedown/mouseup/click/mouseup/dblclick
                        bubble(control, 'mouseup', event);

                        if (activedControl) {
                            commonParent = getCommonParent(control, activedControl);
                            bubble(commonParent, 'click', event);
                            // ()
                            //  Element  remove/append  click 
                            if (lastClick) {
                                if (isDblClick() && lastClick.target == control) {
                                    bubble(commonParent, 'dblclick', event);
                                    lastClick = null;
                                }
                                else {
                                    lastClick.target = control;
                                }
                            }
                            bubble(activedControl, 'deactivate', event);
                        }

                        //  activeControl 
                        activedControl = null;
                    }
                }
            },

            dragEnv = { // 
                type: 'drag',

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target,
                        // 
                        expectX = target.getX() + mouseX - currEnv.x,
                        expectY = target.getY() + mouseY - currEnv.y,
                        // 
                        x = MIN(MAX(expectX, currEnv.left), currEnv.right),
                        y = MIN(MAX(expectY, currEnv.top), currEnv.bottom);

                    if (triggerEvent(target, 'dragmove', event, [x, y])) {
                        target.setPosition(x, y);
                    }

                    currEnv.x = mouseX + target.getX() - expectX;
                    currEnv.y = mouseY + target.getY() - expectY;
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target;
                    triggerEvent(target, 'dragend', event);
                    activedControl = currEnv.actived;
                    restore();

                    currEnv.mouseover(event);
                    currEnv.mouseup(event);
                }
            },

            interceptEnv = { // 
                type: 'intercept',

                mousedown: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target,
                        env = currEnv,
                        control = event.getControl();

                    lastClick = null;

                    if (!isScrollClick(event)) {
                        if (control && !control.isFocusable()) {
                            // 
                            mousedown(control, event);
                        }
                        else if (triggerEvent(target, 'intercept', event)) {
                            // 
                            restore();
                        }
                        else if (!event.cancelBubble) {
                            if (env == currEnv) {
                                // 
                                // 
                                if (control) {
                                    mousedown(control, event);
                                }
                            }
                            else {
                                // 
                                currEnv.mousedown(event);
                            }
                        }
                    }
                }
            },

            zoomEnv = { // 
                type: 'zoom',

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__gzip_original__minWidth
                    //__gzip_original__maxWidth
                    //__gzip_original__minHeight
                    //__gzip_original__maxHeight
                    //__transform__target_o
                    var target = currEnv.target,
                        width = currEnv.width = mouseX - currEnv.x + currEnv.width,
                        height = currEnv.height = mouseY - currEnv.y + currEnv.height,
                        minWidth = currEnv.minWidth,
                        maxWidth = currEnv.maxWidth,
                        minHeight = currEnv.minHeight,
                        maxHeight = currEnv.maxHeight;

                    currEnv.x = mouseX;
                    currEnv.y = mouseY;

                    width = minWidth > width ? minWidth : maxWidth < width ? maxWidth : width;
                    height = minHeight > height ? minHeight : maxHeight < height ? maxHeight : height;

                    // 
                    target.setPosition(currEnv.left + MIN(width, 0), currEnv.top + MIN(height, 0));
                    if (triggerEvent(target, 'zoom', event)) {
                        target.setSize(ABS(width), ABS(height));
                    }
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target;
                    triggerEvent(target, 'zoomend', event);
                    activedControl = currEnv.actived;
                    restore();

                    repaint();
                    currEnv.mouseover(event);
                    currEnv.mouseup(event);
                }
            },

            /**
             *  Element  DOM 
             * init  Element ( getAttributeName ) ECUI  document.body ecui.init(document.body)
             * @public
             *
             * @param {Element} el Element 
             */
            init = core.init = function (el) {
                if (!initEnvironment() && el) {
                    var i = 0,
                        list = [],
                        options = el.all || el.getElementsByTagName('*'),
                        elements = [el],
                        o, namedMap = {};

                    if (!(initRecursion++)) {
                        //  init resize
                        detachEvent(WINDOW, 'resize', repaint);
                    }

                    for (; o = options[i++]; ) {
                        if (getAttribute(o, ecuiName)) {
                            elements.push(o);
                        }
                    }

                    for (i = 0; el = elements[i]; i++) {
                        options = getOptions(el);
                        //  el  control
                        // datainsightecui
                        // ie7
                        break;
                        if (o = options.type) {
                            options.main = el;
                            list.push($create(ui[toCamelCase(o.charAt(0).toUpperCase() + o.slice(1))], options));
                            if (options.id) {
                                 namedMap[options.id] = list[list.length - 1];
                            }
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.cache();
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.init();
                    }

                    if (!(--initRecursion)) {
                        attachEvent(WINDOW, 'resize', repaint);
                    }

                    return namedMap;
                }
            },

            /**
             * 
             * repaint  onresize  repaint 
             * @public
             */
            repaint = core.repaint = function () {
                var i = 0,
                    list = [],
                    widthList = [],
                    o;

                if (ieVersion) {
                    //  ie6/7 
                    o = (isStrict ? DOCUMENT.documentElement : DOCUMENT.body).clientWidth;
                    if (lastClientWidth != o) {
                        lastClientWidth = o;
                    }
                    else {
                        // scroll
                        onscroll(new UI_EVENT('scroll'));
                        return;
                    }
                }

                status = REPAINT;
                o = currEnv.type;
                // 
                mask(false);
                if (o != 'zoom') {
                    // 
                    if (o == 'drag') {
                        currEnv.mouseup();
                    }
                    // 
                    for (o = null; o !== undefined; o = list[i++]) {
                        for (var j = 0, controls = query({parent: o}); o = controls[j++]; ) {
                            if (o.isShow() && o.isResizable()) {
                                list.push(o);
                            }
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        // resizerepaintreflow
                        o.repaint = blank;
                        triggerEvent(o, 'resize');
                        delete o.repaint;

                        if (ieVersion < 8) {
                            // ie6/7
                            o = getStyle(j = o.getMain());
                            if (o.width == 'auto' && o.display == 'block') {
                                j.style.width = '100%';
                            }
                        }
                    }

                    if (ieVersion < 8) {
                        // 100%ie
                        // reflow
                        for (i = 0; o = list[i]; ) {
                            widthList[i++] = o.getMain().offsetWidth;
                        }
                        for (; o = list[i--]; ) {
                            o.getMain().style.width =
                                widthList[i] - (flgContentBox ? o.$getBasicWidth() * 2 : 0) + 'px';
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.cache(true, true);
                    }
                    for (i = 0; o = list[i++]; ) {
                        o.$setSize(o.getWidth(), o.getHeight());
                    }
                }

                if (ieVersion < 8) {
                    //  ie6/7 
                    timer(mask, 0, null, true);
                }
                else {
                    mask(true);
                }
                status = NORMAL;
            };

        /**
         *  Element  ECUI  
         *  Element  ECUI 
         * @protected
         *
         * @param {HTMLElement} el Element 
         * @param {ecui.ui.Control} control ECUI 
         */
        $bind = core.$bind = function (el, control) {
            el._cControl = control;
            el.getControl = getControlByElement;
        };

        /**
         * 
         *  $clearState 
         * @protected
         *
         * @param {ecui.ui.Control} control ECUI 
         */
        $clearState = core.$clearState = function (control) {
            var o = control.getParent();

            loseFocus(control);
            if (control.contain(activedControl)) {
                bubble(activedControl, 'deactivate', null, activedControl = o);
            }
            if (control.contain(hoveredControl)) {
                bubble(hoveredControl, 'mouseout', null, hoveredControl = o);
            }
        };

        /**
         *  ECUI  
         * ( ECUI )$connect  targetId ( create )
         * @protected
         *
         * @param {Object} caller 
         * @param {Function} func  func.call(caller, ecui.get(targetId)) 
         * @param {string} targetId  ECUI   ecui  id 
         */
        $connect = core.$connect = function (caller, func, targetId) {
            if (targetId) {
                var target = namedControls[targetId];
                if (target) {
                    func.call(caller, target);
                }
                else {
                    (connectedControls[targetId] = connectedControls[targetId] || [])
                        .push({func: func, caller: caller});
                }
            }
        };

        /**
         *  ECUI 
         * $create  $create  cacheinit  repaint options 
         * id         {string}  id $connect  get 
         * main       {HTMLElement}  Element ( getMain ) Element 
         * parent     {ecui.ui.Control}  Element 
         * primary    {string} ( getMainClass ) className 
         * @protected
         *
         * @param {Function} type 
         * @param {Object} options ( ECUI )
         * @return {ecui.ui.Control} ECUI 
         */
        $create = core.$create = function (type, options) {
            type = type.client || type;
            options = options || {};

            //__gzip_original__parent
            var i = 0,
                parent = options.parent,
                el = options.main,
                o = options.primary || '',
                className;

            options.uid = 'ecui-' + (++uniqueIndex);

            if (el) {
                if (structural) {
                    className = el.className;
                }
                else {
                    el.className = className = el.className + ' ' + o + type.agent.TYPES;
                }

                // 
                if (!o) {
                    /\s*([^\s]+)/.test(className);
                    options.primary = REGEXP.$1;
                }

                // 
                if (el.getControl) {
                    return el.getControl();
                }
            }
            else {
                // 
                el = options.main = createDom(o + type.agent.TYPES);
                if (!o) {
                    options.primary = type.agent.types[0];
                }
            }

            // 
            type = new type(el, options);

            if (parent) {
//{if 0}//
                if (parent instanceof ui.Control) {
//{else}//                if (parent instanceof UI_CONTROL) {
//{/if}//
                    type.setParent(parent);
                }
                else {
                    type.appendTo(parent);
                }
            }
            else {
                type.$setParent(findControl(getParent(type.getOuter())));
            }

            oncreate(type, options);
            independentControls.push(type);

            // 
            if (el = connectedControls[options.id]) {
                for (connectedControls[options.id] = null; o = el[i++]; ) {
                    o.func.call(o.caller, type);
                }
            }

            return type;
        };

        /**
         *  ECUI 
         * $fastCreate  query ( $create )$fastCreate  Element  className 
         * @protected
         *
         * @param {Function} type 
         * @param {HTMLElement} el  Element 
         * @param {ecui.ui.Control} parent 
         * @param {Object} options ( ECUI )
         * @return {ecui.ui.Control} ECUI 
         */
        $fastCreate = core.$fastCreate = function (type, el, parent, options) {
            type = type.client || type;
            options = options || {};

            options.uid = 'ecui-' + (++uniqueIndex);
            if (!options.primary) {
                /\s*([^\s]+)/.test(el.className);
                options.primary = REGEXP.$1;
            }

            type = new type(el, options);
            type.$setParent(parent);

            oncreate(type, options);

            return type;
        };

        /**
         * 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 
         * @param {string} name 
         * @param {Function} caller 
         */
        core.addEventListener = function (control, name, caller) {
            name = control.getUID() + name;
            (eventListeners[name] = eventListeners[name] || []).push(caller);
        };

        /**
         * ( padding, border  height )
         * IE  W3C  calcHeightRevise  offsetHeight  height 
         * @public
         *
         * @param {CssStyle} style CssStyle 
         * @return {number} 
         */
        calcHeightRevise = core.calcHeightRevise = function (style) {
            return flgContentBox ? toNumber(style.borderTopWidth) + toNumber(style.borderBottomWidth) +
                    toNumber(style.paddingTop) + toNumber(style.paddingBottom)
                : 0;
        };

        /**
         * ( border  left )
         * opera offsetLeft  left  border  calcLeftRevise  offsetLeft  left 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {number} 
         */
        calcLeftRevise = core.calcLeftRevise = function (el) {
            //__transform__style_o
            var style = getStyle(el.offsetParent);
            return !firefoxVersion || style.overflow != 'visible' && getStyle(el, 'position') == 'absolute' ?
                toNumber(style.borderLeftWidth) * flgFixedOffset : 0;
        };

        /**
         * ( border  top )
         * opera offsetTop  top  border  calcTopRevise  offsetTop  top 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @return {number} 
         */
        calcTopRevise = core.calcTopRevise = function (el) {
            //__transform__style_o
            var style = getStyle(el.offsetParent);
            return !firefoxVersion || style.overflow != 'visible' && getStyle(el, 'position') == 'absolute' ?
                toNumber(style.borderTopWidth) * flgFixedOffset : 0;
        };

        /**
         * ( padding,border  width )
         * IE  W3C  calcWidthRevise  offsetWidth  width 
         * @public
         *
         * @param {CssStyle} style CssStyle 
         * @return {number} 
         */
        calcWidthRevise = core.calcWidthRevise = function (style) {
            return flgContentBox ? toNumber(style.borderLeftWidth) + toNumber(style.borderRightWidth) +
                    toNumber(style.paddingLeft) + toNumber(style.paddingRight)
                : 0;
        };

        /**
         *  ECUI 
         *  ECUI   $create options 
         * id        {string}  id $connect  get 
         * main      {HTMLElement}  Element ( getMain ) Element 
         * parent    {ecui.ui.Control}  Element 
         * primary   {string} ( getMainClass ) className 
         * @public
         *
         * @param {string|Function} type 
         * @param {Object} options ( ECUI )
         * @return {ecui.ui.Control} ECUI 
         */
        createControl = core.create = function (type, options) {
            type = $create('string' == typeof(type) ? ui[type] : type, options);
            type.cache();
            type.init();
            return type;
        };

        /**
         *  ECUI 
         * @public
         *
         * @param {ecui.ui.Control|HTMLElement} control  Element 
         */
        disposeControl = core.dispose = function (control) {
            var i = allControls.length,
//{if 0}//
                type = control instanceof ui.Control,
//{else}//                type = control instanceof UI_CONTROL,
//{/if}//
                namedMap = {},
                controls = [],
                o;

            if (type) {
                $clearState(control);
            }
            else {
                o = findControl(getParent(control));
                if (focusedControl && contain(control, focusedControl.getOuter())) {
                    setFocused(o);
                }
                if (activedControl && contain(control, activedControl.getOuter())) {
                    bubble(activedControl, 'deactivate', null, activedControl = o);
                }
                if (hoveredControl && contain(control, hoveredControl.getOuter())) {
                    bubble(hoveredControl, 'mouseout', null, hoveredControl = o);
                }
            }

            for (o in namedControls) {
                namedMap[namedControls[o].getUID()] = o;
            }

            for (; i--; ) {
                o = allControls[i];
                if (type ? control.contain(o) : !!o.getOuter() && contain(control, o.getOuter())) {
                    // 
                    controls.push(o);
                    remove(independentControls, o);
                    if (o = namedMap[o.getUID()]) {
                        delete namedControls[o];
                    }
                    allControls.splice(i, 1);
                }
            }

            for (; o = controls[++i]; ) {
                o.$dispose();
            }
        };

        /**
         *  ECUI  
         *  drag  {'controls'|menu} ondragstartondragmove  ondragend range 
         * top    {number} Y
         * right  {number} X
         * bottom {number} Y
         * left   {number} X
         * @public
         *
         * @param {ecui.ui.Control} control  ECUI 
         * @param {ecui.ui.Event} event 
         * @param {Object} range  offsetParent  
         *                       offsetParent  body
         */
        drag = core.drag = function (control, event, range) {
            if (event.type == 'mousedown') {
                //__gzip_original__currStyle
                var parent = control.getOuter().offsetParent,
                    style = getStyle(parent);

                // 
                extend(dragEnv, parent.tagName == 'BODY' || parent.tagName == 'HTML' ? getView() : {
                    top: 0,
                    right: parent.offsetWidth - toNumber(style.borderLeftWidth) - toNumber(style.borderRightWidth),
                    bottom: parent.offsetHeight - toNumber(style.borderTopWidth) - toNumber(style.borderBottomWidth),
                    left: 0
                });
                extend(dragEnv, range);
                dragEnv.right = MAX(dragEnv.right - control.getWidth(), dragEnv.left);
                dragEnv.bottom = MAX(dragEnv.bottom - control.getHeight(), dragEnv.top);

                initDragAndZoom(control, event, dragEnv, 'drag');
            }
        };

        /**
         *  ECUI 
         * ( ECUI ) ecui  id get  Element  getControl 
         * @public
         *
         * @param {string} id ECUI  Element  id 
         * @return {ecui.ui.Control}  ECUI  null
         */
        core.get = function (id) {
            initEnvironment();
            return namedControls[id] || null;
        };

        /**
         *  ECUI 
         * 
         * @public
         *
         * @return {ecui.ui.Control}  ECUI  null
         */
        getActived = core.getActived = function () {
            return activedControl || null;
        };

        /**
         * 
         * getAttributeName ( ECUI ) BODY  data-ecui  ecui 
         * @public
         *
         * @return {string} 
         */
        getAttributeName = core.getAttributeName = function () {
            return ecuiName;
        };

        /**
         * 
         * /
         * @public
         *
         * @return {ecui.ui.Control}  ECUI  null
         */
        getFocused = core.getFocused = function () {
            return focusedControl || null;
        };

        /**
         * 
         * 
         * @public
         *
         * @return {ecui.ui.Control}  ECUI  null
         */
        getHovered = core.getHovered = function () {
            return hoveredControl;
        };

        /**
         * 
         * getKey  keydown  keyCode/which  keypress ()
         * @public
         *
         * @return {number} 
         */
        getKey = core.getKey = function () {
            return keyCode;
        };

        /**
         * XX
         * getMouseX X Element  borderLeftWidth 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI XX
         * @return {number} X
         */
        getMouseX = core.getMouseX = function (control) {
            if (control) {
                control = control.getBody();
                return mouseX - getPosition(control).left - toNumber(getStyle(control, 'borderLeftWidth'));
            }
            return mouseX;
        };

        /**
         * YY
         * getMouseY Y Element  borderTopWidth 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI YY
         * @return {number} Y
         */
        getMouseY = core.getMouseY = function (control) {
            if (control) {
                control = control.getBody();
                return mouseY - getPosition(control).top - toNumber(getStyle(control, 'borderTopWidth'));
            }
            return mouseY;
        };

        /**
         * 
         * @public
         *
         * @return {Object} 
         */
        core.getNamedControls = function () {
            return extend({}, namedControls);
        };

        /**
         *  Element 
         * @public
         *
         * @param {HTMLElement} el Element 
         * @param {string} attributeName ( getAttributeName )
         * @return {Object} 
         */
        getOptions = core.getOptions = function (el, attributeName) {
            attributeName = attributeName || ecuiName;

            var text = getAttribute(el, attributeName),
                options;

            if (text) {
                el.removeAttribute(attributeName);
                if (core.onparseoptions) {
                    if (options = core.onparseoptions(text)) {
                        return options;
                    }
                }

                for (
                    options = {};
                    /^(\s*;)?\s*(ext\-)?([\w\-]+)\s*(:\s*([^;\s]+(\s+[^;\s]+)*)\s*)?($|;)/.test(text);
                ) {
                    text = REGEXP["$'"];

                    el = REGEXP.$5;
                    attributeName = REGEXP.$2 ? (options.ext = options.ext || {}) : options;
                    attributeName[toCamelCase(REGEXP.$3)] =
                        !el || el == 'true' ? true : el == 'false' ? false : ISNAN(+el) ? el : +el;
                }

                return options;
            }
            else {
                return {};
            }
        };

        /**
         * 
         * getScrollNarrow 
         * @public
         *
         * @return {number} 
         */
        getScrollNarrow = core.getScrollNarrow = function () {
            return scrollNarrow;
        };

        /**
         * 
         * getStatus NORMAL()LOADING()REPAINT()
         * @public
         *
         * @return {boolean} 
         */
        getStatus = core.getStatus = function () {
            return status;
        };

        /**
         * 
         * @public
         *
         * @param {Function} superClass 
         * @param {string} type 
         * @param {Function} preprocess 
         * @param {Function} subClass 
         * @return {Function} 
         */
        inheritsControl = core.inherits = function (superClass, type, preprocess, subClass) {
            var agent = function (options) {
                    return createControl(agent.client, options);
                },
                client = agent.client = function (el, options) {
                    if (agent.preprocess) {
                        el = agent.preprocess.call(this, el, options) || el;
                    }
                    if (superClass) {
                        superClass.client.call(this, el, options);
                    }
                    if (subClass) {
                        subClass.call(this, el, options);
                    }
                };

            agent.preprocess = preprocess;

            if (superClass) {
                inherits(agent, superClass);

                if (type && type.charAt(0) == '*') {
                    (agent.types = superClass.types.slice())[0] = type.slice(1);
                }
                else {
                    agent.types = (type ? [type] : []).concat(superClass.types);
                }
            }
            else {
                // ecui.ui.Control
                agent.types = [];
            }
            agent.TYPES = ' ' + agent.types.join(' ');

            inherits(client, agent);
            client.agent = agent;

            return agent;
        };

        /**
         *  ECUI 
         * intercept  $intercept  $intercept  restore 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 
         */
        intercept = core.intercept = function (control) {
            interceptEnv.target = control;
            setEnv(interceptEnv);
        };

        /**
         *  content-box 
         * isContentBox  box-sizing 
         * @public
         *
         * @return {boolean}  content-box 
         */
        isContentBox = core.isContentBox = function () {
            return flgContentBox;
        };

        /**
         * 
         * loseFocus  setFocused  loseFocus  loseFocus 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 
         */
        loseFocus = core.loseFocus = function (control) {
            if (control.contain(focusedControl)) {
                setFocused(control.getParent());
            }
        };

        /**
         * 
         *  z-index  32767 Element  z-index  32767body  ecui-maskIE6/7  select 
         * @public
         *
         * @param {number} opacity  0.5
         * @param {number} zIndex  zIndex  32767
         */
        mask = core.mask = function (opacity, zIndex) {
            //__gzip_original__body
            var i = 0,
                body = DOCUMENT.body,
                o = getView(),
                // 22
                // IE
                top = MAX(o.top - o.height * 2, 0),
                left = MAX(o.left - o.width * 2, 0),
                text = ';top:' + top + 'px;left:' + left +
                    'px;width:' + MIN(o.width * 5, o.pageWidth - left) +
                    'px;height:' + MIN(o.height * 5, o.pageHeight - top) + 'px;display:';

            if ('boolean' == typeof opacity) {
                text += opacity ? 'block' : 'none'; 
                for (; o = maskElements[i++]; ) {
                    o.style.cssText += text;
                }
            }
            else if (opacity === undefined) {
                removeDom(maskElements.pop());
                if (!maskElements.length) {
                    removeClass(body, 'ecui-mask');
                }
            }
            else {
                if (!maskElements.length) {
                    addClass(body, 'ecui-mask');
                }
                maskElements.push(o = body.appendChild(createDom(
                    '',
                    'position:absolute;background-color:#000;z-index:' + (zIndex || 32767)
                )));
                setStyle(o, 'opacity', opacity);
                o.style.cssText += text + 'block';
            }
        };

        /**
         *  class 
         * @public
         *
         * @return {boolean}  class 
         */
        needInitClass = core.needInitClass = function () {
            return !structural;
        };

        /**
         * 
         * query condition
         * type   {Function} 
         * parent {ecui.ui.Control} 
         * custom {Function} query  this 
         * @public
         *
         * @param {Object} condition 
         * @return {Array} 
         */
        query = core.query = function (condition) {
            condition = condition || {};

            //__gzip_original__parent
            for (
                var i = 0,
                    result = [],
                    parent = condition.parent,
                    custom = condition.custom,
                    o;
                o = independentControls[i++];
            ) {
                if ((!condition.type || (o instanceof condition.type)) &&
                        (parent === undefined || (o.getParent() === parent)) &&
                        (!custom || custom.call(this, o))) {
                    result.push(o);
                }
            }

            return result;
        };

        /**
         * 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 
         * @param {string} name 
         * @param {Function} caller 
         */
        core.removeEventListener = function (control, name, caller) {
            if (name = eventListeners[control.getUID() + name]) {
                remove(name, caller);
            }
        };

        /**
         * 
         * restore  dragintercept  zoom 
         * @public
         */
        restore = core.restore = function () {
            if (ieVersion) {
                if (currEnv.type == 'drag' || currEnv.type == 'zoom') {
                    // IE
                    DOCUMENT.body.releaseCapture();
                }
            }
            setHandler(currEnv, true);
            setHandler(currEnv = envStack.pop());
        };

        /**
         *  ECUI  
         * setFocused  loseFocus  setFocused  onblur 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 
         */
        setFocused = core.setFocused = function (control) {
            if (control && control.isDisabled()) {
                // 
                control = null;
            }

            var parent = getCommonParent(focusedControl, control);

            bubble(focusedControl, 'blur', null, parent);
            bubble(focusedControl = control, 'focus', null, parent);
        };

        /**
         * 
         * triggerEvent  event 
         * @public
         *
         * @param {ecui.ui.Control} control 
         * @param {string} name 
         * @param {ecui.ui.Event} event  false 
         * @param {Array} args 
         * @return {boolean} 
         */
        triggerEvent = core.triggerEvent = function (control, name, event, args) {
            if (args && event) {
                args.splice(0, 0, event);
            }
            else if (event) {
                args = [event];
            }
            else {
                event = {returnValue: event, preventDefault: UI_EVENT_CLASS.preventDefault};
                args = args || [];
            }

            if (listeners = eventListeners[control.getUID() + name]) {
                for (var i = 0, listeners, o; o = listeners[i++]; ) {
                    o.apply(control, args);
                }
            }

            if ((control['on' + name] && control['on' + name].apply(control, args) === false) ||
                    event.returnValue === false ||
                    (control['$' + name] && control['$' + name].apply(control, args) === false)) {
                event.preventDefault();
            }

            return event.returnValue !== false;
        };

        /**
         * 
         * event  ECUI 
         * pageX           {number} X
         * pageY           {number} Y
         * which           {number} 
         * target          {HTMLElement}  Element 
         * returnValue     {boolean}  
         * cancelBubble    {boolean}  
         * exit            {Function} 
         * getControl      {Function}  ECUI  
         * getNative       {Function} 
         * preventDefault  {Function} 
         * stopPropagation {Function} 
         * @public
         *
         * @param {Event} event 
         * @return {ecui.ui.Event} 
         */
        wrapEvent = core.wrapEvent = function (event) {
            if (event instanceof UI_EVENT) {
                // 
                return event;
            }

            var body = DOCUMENT.body,
                html = getParent(body);

            if (ieVersion) {
                event = WINDOW.event;
                event.pageX = html.scrollLeft + body.scrollLeft - html.clientLeft + event.clientX - body.clientLeft;
                event.pageY = html.scrollTop + body.scrollTop - html.clientTop + event.clientY - body.clientTop;
                event.target = event.srcElement;
                event.which = event.keyCode;
            }

            if (event.type == 'mousemove') {
                lastClick = null;
            }
            mouseX = event.pageX;
            mouseY = event.pageY;

            return new UI_EVENT(event.type, event);
        };

        /**
         *  ECUI  
         * zoom  onzoomstart  zoom  onzoom  onzoomend range 
         * minWidth  {number}  
         * maxWidth  {number}  
         * minHeight {number}  
         * maxHeight {number}  
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 
         * @param {ecui.ui.Event} event 
         * @param {Object} range 
         */
        core.zoom = function (control, event, range) {
            if (event.type == 'mousedown') {
                // 
                if (range) {
                    extend(zoomEnv, range);
                }
                zoomEnv.top = control.getY();
                zoomEnv.left = control.getX();
                zoomEnv.width = control.getWidth();
                zoomEnv.height = control.getHeight();

                initDragAndZoom(control, event, zoomEnv, 'zoom');
            }
        };

        /**
         * 
         * @private
         *
         * @param {Event} event 
         */
        currEnv.keydown = currEnv.keypress = currEnv.keyup = function (event) {
            event = wrapEvent(event);

            //__gzip_original__type
            //__gzip_original__which
            var type = event.type,
                which = event.which;

            if (type == 'keydown') {
                keyCode = which;
            }
            bubble(focusedControl, type, event);
            if (type == 'keyup' && keyCode == which) {
                // 
                keyCode = 0;
            }
        };

        /**
         * 
         * @private
         *
         * @param {Event} event 
         */
        if (ieVersion) {
            // IE mousedown  mouseup 
            currEnv.dblclick = function (event) {
                currEnv.mousedown(event);
                currEnv.mouseup(event);
            };

            // IE mousedown 
            currEnv.selectstart = function (event) {
                event = wrapEvent(event);
                onselectstart(findControl(event.target), event);
            };
        }

        /**
         * 
         * @private
         *
         * @param {Event} event 
         */
        currEnv[firefoxVersion ? 'DOMMouseScroll' : 'mousewheel'] = function (event) {
            event = wrapEvent(event);
            
            event.detail =
                event._oNative.wheelDelta !== undefined ? event._oNative.wheelDelta / -40 : event._oNative.detail;

            // 
            if (currEnv.type == 'drag') {
                event.preventDefault();
            }
            else {
                bubble(hoveredControl, 'mousewheel', event);
                if (!event.cancelBubble) {
                    bubble(focusedControl, 'mousewheel', event);
                }
            }
        };

        /**
         *  ECUI  
         * @public
         *
         * @return {ecui.ui.Control} 
         */
        UI_EVENT_CLASS.getControl = function () {
            var o = findControl(this.target);
            if (o && !o.isDisabled()) {
                for (; o; o = o.getParent()) {
                    if (o.isCapturable()) {
                        return o;
                    }
                }
            }
            return null;
        };

        /**
         * 
         * @public
         *
         * @return {Object} 
         */
        UI_EVENT_CLASS.getNative = function () {
            return this._oNative;
        };

        /**
         * 
         * @public
         */
        UI_EVENT_CLASS.preventDefault = function () {
            this.returnValue = false;
            if (this._oNative) {
                if (ieVersion) {
                    this._oNative.returnValue = false;
                }
                else {
                    this._oNative.preventDefault();
                }
            }
        };

        /**
         * 
         * @public
         */
        UI_EVENT_CLASS.stopPropagation = function () {
            this.cancelBubble = true;
            if (this._oNative) {
                if (ieVersion) {
                    this._oNative.cancelBubble = false;
                }
                else {
                    this._oNative.stopPropagation();
                }
            }
        };

        /**
         * 
         * @public
         */
        UI_EVENT_CLASS.exit = function () {
            this.preventDefault();
            this.stopPropagation();
        };

        /**
         * 
         * @private
         *
         * @param {ecui.ui.Control} start 
         * @param {string} type 
         * @param {ecui.ui.Event} 
         * @param {ecui.ui.Control} end 
         */
        function bubble(start, type, event, end) {
            event = event || new UI_EVENT(type);
            event.cancelBubble = false;
            for (; start != end; start = start.getParent()) {
                event.returnValue = undefined;
                triggerEvent(start, type, event);
                if (event.cancelBubble) {
                    return;
                }
            }
        }

        /**
         * 
         * @private
         *
         * @param {ecui.ui.Control} control1 1
         * @param {ecui.ui.Control} control2 2
         * @return {ecui.ui.Control}  null
         */
        function getCommonParent(control1, control2) {
            if (control1 != control2) {
                var i = 0,
                    list1 = [],
                    list2 = [];

                for (; control1; control1 = control1.getParent()) {
                    list1.push(control1);
                }
                for (; control2; control2 = control2.getParent()) {
                    list2.push(control2);
                }

                list1.reverse();
                list2.reverse();

                // 
                for (; list1[i] == list2[i]; i++) {}
                control1 = list1[i - 1];
            }

            return control1 || null;
        }

        /**
         *  Element  ECUI 
         *  Element ( init  $bind  create$fastCreate ) getControl  ECUI  get
         * @private
         *
         * @return {ecui.ui.Control}  Element  ECUI 
         */
        function getControlByElement() {
            return this._cControl;
        }

        /**
         * 
         * @private
         *
         * @param {ecui.ui.Control} control 
         * @param {ecui.ui.Event} event 
         * @param {Object} env 
         * @return {string} type dragzoom
         */
        function initDragAndZoom(control, event, env, type) {
            var currStyle = control.getOuter().style,
                // reflow
                x = control.getX(),
                y = control.getY();

            currStyle.left = x + 'px';
            currStyle.top = y + 'px';
            currStyle.position = 'absolute';

            env.target = control;
            env.actived = activedControl;
            setEnv(env);

            // drag
            activedControl = null;

            triggerEvent(control, type + 'start', event);

            if (ieVersion) {
                // IE
                DOCUMENT.body.setCapture();
            }
        }

        /**
         * ECUI
         * @private
         *
         * @return {boolean} 
         */
        function initEnvironment() {
            if (!namedControls) {
                status = LOADING;

                // 
                for (o in ext) {
                    plugins[o] = ext[o];
                }

                // 
                for (o in currEnv) {
                    attachEvent(DOCUMENT, o, currEnv[o]);
                }

                namedControls = {};

                var o = getOptions(DOCUMENT.body, 'data-ecui');

                ecuiName = o.name || ecuiName;
                isGlobalId = o.globalId;
                structural = indexOf(['class', 'all'], o.structural) + 1;

                insertHTML(
                    DOCUMENT.body,
                    'BEFOREEND',
                    '<div style="position:absolute;overflow:scroll;top:-90px;left:-90px;width:80px;height:80px;' +
                        'border:1px solid"><div style="position:absolute;top:0px;height:90px"></div></div>'
                );
                // Element
                o = DOCUMENT.body.lastChild;
                flgContentBox = o.offsetWidth > 80;
                flgFixedOffset = o.lastChild.offsetTop;
                scrollNarrow = o.offsetWidth - o.clientWidth - 2;
                removeDom(o);

                attachEvent(WINDOW, 'resize', repaint);
                attachEvent(WINDOW, 'unload', function () {
                    for (var i = 0; o = allControls[i++]; ) {
                        o.$dispose();
                    }

                    //  Element 
                    DOCUMENT = maskElements = null;
                });
                attachEvent(WINDOW, 'scroll', onscroll);

                init(DOCUMENT.body);
                addClass(DOCUMENT.body, 'ecui-loaded');

                status = NORMAL;
                return true;
            }
        }

        /**
         * 
         * @private
         *
         * @return {boolean} 
         */
        function isDblClick() {
            return lastClick.time > new DATE().getTime() - 200;
        }

        /**
         * 
         * @private
         *
         * @param {ecui.ui.Event} event 
         * @return {boolean} 
         */
        function isScrollClick(event) {
            var target = event.target,
                pos = getPosition(target),
                style = getStyle(target);
            return event.pageX - pos.left - toNumber(style.borderLeftWidth) >= target.clientWidth !=
                event.pageY - pos.top - toNumber(style.borderTopWidth) >= target.clientHeight;
        }

        /**
         * 
         * @private
         *
         * @param {ecui.ui.Control} control 
         * @param {ecui.ui.Event} event 
         */
        function mousedown(control, event) {
            bubble(activedControl = control, 'activate', event);
            bubble(control, 'mousedown', event);
            onselectstart(control, event);
        }

        /**
         * 
         * @private
         *
         * @param {ecui.ui.Control} control 
         * @param {Object} options 
         */
        function oncreate(control, options) {
            if (control.oncreate) {
                control.oncreate(options);
            }
            allControls.push(control);

            if (options.id) {
                namedControls[options.id] = control;
                if (isGlobalId) {
                    WINDOW[options.id] = control;
                }
            }

            if (options.ext) {
                for (var o in options.ext) {
                    if (plugins[o]) {
                        plugins[o](control, options.ext[o], options);
                        if (o = control['$init' + o.charAt(0).toUpperCase() + toCamelCase(o.slice(1))]) {
                            o.call(control, options);
                        }
                    }
                }
            }
        }

        /**
         * 
         * @private
         */
        function onscroll(event) {
            event = wrapEvent(event);
            for (var i = 0, o; o = independentControls[i++]; ) {
                triggerEvent(o, 'pagescroll', event);
            }
            mask(true);
        }

        /**
         * 
         * @private
         *
         * @param {ecui.ui.Control} control 
         * @param {ecui.ui.Event} event 
         */
        function onselectstart(control, event) {
            for (; control; control = control.getParent()) {
                if (!control.isUserSelect()) {
                    event.preventDefault();
                    return;
                }
            }
        }

        /**
         *  ecui 
         * @private
         *
         * @param {Object} env 
         */
        function setEnv(env) {
            var o = {};
            setHandler(currEnv, true);

            extend(o, currEnv);
            extend(o, env);
            o.x = mouseX;
            o.y = mouseY;
            setHandler(o);

            envStack.push(currEnv);
            currEnv = o;
        }

        /**
         * document
         * @private
         *
         * @param {Object} env document
         * @param {boolean} remove truedata
         */
        function setHandler(env, remove) {
            for (var i = 0, func = remove ? detachEvent : attachEvent, o; i < 5; ) {
                if (env[o = eventNames[i++]]) {
                    func(DOCUMENT, o, env[o]);
                }
            }
        }

        ready(init);
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Control - ECUI 
 ECUI  DOM  Element ()()(focus)(hover)(active)(disabled) DOM 

HTMLidecui.get(id):
<div ecui="type:control;id:demo">
  <!--  -->
  ...
</div>


_bCapturable        - 
_bUserSelect        - 
_bFocusable         - 
_bDisabled          - true
_bCached            - 
_bCreated           - 
_sUID               - ID
_sPrimary           - 
_sClass             - 
_sWidth             - 
_sHeight            - 
_sDisplay           - hideshow
_eMain              - 
_eBody              - $setBody
_cParent            - 
_aStatus            - 
$$width             - 
$$height            - 
$$bodyWidthRevise   - 
$$bodyHeightRevise  - 
$$borderTopWidth    - 
$$borderLeftWidth   - 
$$borderRightWidth  - 
$$borderBottomWidth - 
$$paddingTop        - 
$$paddingLeft       - 
$$paddingRight      - 
$$paddingBottom     - 
$$position          - 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        REGEXP = RegExp,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        remove = array.remove,
        addClass = dom.addClass,
        getParent = dom.getParent,
        getStyle = dom.getStyle,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        blank = util.blank,
        timer = util.timer,
        toNumber = util.toNumber,

        REPAINT = core.REPAINT,

        $bind = core.$bind,
        $clearState = core.$clearState,
        calcLeftRevise = core.calcLeftRevise,
        calcTopRevise = core.calcTopRevise,
        disposeControl = core.dispose,
        findControl = core.findControl,
        getActived = core.getActived,
        getFocused = core.getFocused,
        getHovered = core.getHovered,
        getStatus = core.getStatus,
        inheritsControl = core.inherits,
        isContentBox = core.isContentBox,
        loseFocus = core.loseFocus,
        query = core.query,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ];
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_CONTROL
    ///__gzip_original__UI_CONTROL_CLASS
    /**
     * 
     * options 
     * type       
     * primary    
     * current    
     * capturable 
     * userSelect 
     * focusable  
     * resizable  
     * disabled   
     * @public
     *
     * @param {Object} options 
     */
    var UI_CONTROL = ui.Control =
        inheritsControl(
            null,
            null,
            null,
            function (el, options) {
                $bind(el, this);

                this._bDisabled = !!options.disabled;
                this._sUID = options.uid;
                this._sPrimary = options.primary || '';
                this._sClass = options.current || this._sPrimary;
                this._eMain = this._eBody = el;
                this._cParent = null;

                this._bCapturable = options.capturable !== false;
                this._bUserSelect = options.userSelect !== false;
                this._bFocusable = options.focusable !== false;
                if (options.resizable !== false) {
                    this._bResizable = true;
                    el = el.style;
                    this._sWidth = el.width;
                    this._sHeight = el.height;
                }
                else {
                    this._bResizable = false;
                }

                this._aStatus = ['', ' '];
            }
        ),
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_CONTROL_READY_LIST,
        UI_CONTROL_QUERY_SHOW = {custom: function (control) {
            return this != control && this.contain(control) && control.isShow();
        }};
//{else}//
    /**
     * 
     * @private
     *
     * @param {ecui.ui.Control} control 
     * @param {HTMLElement} parent 
     * @param {HTMLElement} parentElement  Element 
     */
    function UI_CONTROL_ALTER_PARENT(control, parent, parentElement) {
        var oldParent = control._cParent,
            el = control.getOuter(),
            flag = control._bCreated && control.isShow();

        // 
        if (parent != oldParent) {
            if (oldParent) {
                if (!triggerEvent(oldParent, 'remove', null, [control])) {
                    return;
                }
            }
            if (parent) {
                if (!triggerEvent(parent, 'append', null, [control])) {
                    parent = parentElement = null;
                }
            }
        }

        if (parentElement != getParent(el)) {
            if (parentElement) {
                parentElement.appendChild(el);
            }
            else {
                removeDom(el);
            }
            //  DOM $setParent
            control.$setParent(parent);
        }

        if (flag != (control._bCreated && control.isShow())) {
            triggerEvent(control, flag ? 'hide' : 'show', false);
        }
    }

    /**
     * 
     *  -active
     * @protected
     *
     * @param {ecui.ui.Event} event 
     */
    UI_CONTROL_CLASS.$activate = function () {
        this.alterClass('+active');
    };

    /**
     * 
     *  -focus
     * @protected
     *
     * @param {ecui.ui.Event} event 
     */
    UI_CONTROL_CLASS.$blur = function () {
        this.alterClass('-focus');
    };

    /**
     * 
     * $cache  Element  clearCache 
     * @protected
     *
     * @param {CssStyle} style  Css 
     * @param {boolean} cacheSize 
     */
    UI_CONTROL_CLASS.$cache = function (style, cacheSize) {
        if (ieVersion < 8) {
            o = style.borderWidth;
            if (o.indexOf(' ') > 0) {
                o = o.split(' ');
                this.$$borderTopWidth = toNumber(o[0]);
                this.$$borderRightWidth = toNumber(o[1]);
                this.$$borderBottomWidth = o[2] ? toNumber(o[2]) : this.$$borderTopWidth;
                this.$$borderLeftWidth = o[3] ? toNumber(o[3]) : this.$$borderRightWidth = toNumber(o[1]);
            }
            else {
                this.$$borderTopWidth = this.$$borderLeftWidth = this.$$borderRightWidth = this.$$borderBottomWidth =
                    toNumber(o);
            }
            o = style.padding;
            if (o.indexOf(' ') > 0) {
                o = o.split(' ');
                this.$$paddingTop = toNumber(o[0]);
                this.$$paddingRight = toNumber(o[1]);
                this.$$paddingBottom = o[2] ? toNumber(o[2]) : this.$$paddingTop;
                this.$$paddingLeft = o[3] ? toNumber(o[3]) : this.$$paddingRight;
            }
            else {
                this.$$paddingTop = this.$$paddingLeft = this.$$paddingRight = this.$$paddingBottom = toNumber(o);
            }
        }
        else {
            for (
                var i = 0,
                    list = [
                        'borderTopWidth', 'borderLeftWidth', 'borderRightWidth', 'borderBottomWidth',
                        'paddingTop', 'paddingLeft', 'paddingRight', 'paddingBottom'
                    ],
                    o;
                o = list[i++];
            ) {
                this['$$' + o] = toNumber(style[o]);
            }
        }

        this.$$position = style.position;

        if (cacheSize !== false) {
            o = isContentBox();
            this.$$width = this._eMain.offsetWidth || toNumber(style.width) + (o ? this.$getBasicWidth() : 0);
            this.$$height = this._eMain.offsetHeight || toNumber(style.height) + (o ? this.$getBasicHeight() : 0);
        }
    };

    /**
     * 
     *  -active
     * @protected
     *
     * @param {ecui.ui.Event} event 
     */
    UI_CONTROL_CLASS.$deactivate = function () {
        this.alterClass('-active');
    };

    /**
     * 
     *  IE $dispose  ondispose 
     * @protected
     */
    UI_CONTROL_CLASS.$dispose = function () {
        try {
            triggerEvent(this, 'dispose', false);
        }
        catch (e) {
        }
        this._eMain.getControl = undefined;
        this._eMain = this._eBody = null;
        //  $ready  onload  dispose $ready 
        this.$ready = blank;
    };

    /**
     * 
     *  -focus
     * @protected
     *
     * @param {ecui.ui.Event} event 
     */
    UI_CONTROL_CLASS.$focus = function () {
        this.alterClass('+focus');
    };

    /**
     * 
     * ()(border-width)(padding)
     * @public
     *
     * @return {number} 
     */
    UI_CONTROL_CLASS.$getBasicHeight = function () {
        return this.$$borderTopWidth + this.$$borderBottomWidth + this.$$paddingTop + this.$$paddingBottom;
    };

    /**
     * 
     * ()(border-width)(padding)
     * @public
     *
     * @return {number} 
     */
    UI_CONTROL_CLASS.$getBasicWidth = function () {
        return this.$$borderLeftWidth + this.$$borderRightWidth + this.$$paddingLeft + this.$$paddingRight;
    };

    /**
     * 
     * $getSection  ECUI 
     * @protected
     *
     * @param {string} name 
     * @return {ecui.ui.Control} 
     */
    UI_CONTROL_CLASS.$getSection = function (name) {
        return this['_u' + name];
    };

    /**
     * 
     * $hide 
     * @protected
     */
    UI_CONTROL_CLASS.$hide = function () {
        if (this._sDisplay === undefined) {
            if (this._bCreated) {
                for (var i = 0, list = query.call(this, UI_CONTROL_QUERY_SHOW), o; o = list[i++]; ) {
                    triggerEvent(o, 'hide', false);
                }
            }

            o = this.getOuter().style;

            //  display 
            this._sDisplay = o.display;
            o.display = 'none';
            // 
            $clearState(this);
        }
    };

    /**
     * 
     * $locate  Element  offsetParent ( getMain )
     * @protected
     */
    UI_CONTROL_CLASS.$locate = function () {
        if (this.$$position == 'static') {
            this._eMain.style.position = this.$$position = 'relative';
        }
    };

    /**
     * 
     *  -hover
     * @protected
     *
     * @param {ecui.ui.Event} event 
     */
    UI_CONTROL_CLASS.$mouseout = function () {
        this.alterClass('-hover');
    };

    /**
     * 
     *  -hover
     * @protected
     *
     * @param {ecui.ui.Event} event 
     */
    UI_CONTROL_CLASS.$mouseover = function () {
        this.alterClass('+hover');
    };

    /**
     * 
     * @protected
     */
    UI_CONTROL_CLASS.$resize = function () {
        //__gzip_original__el
        //__gzip_original__currStyle
        var el = this._eMain,
            currStyle = el.style;

        currStyle.width = this._sWidth;
        if (ieVersion < 8 && getStatus() != REPAINT) {
            // ie6/7
            var style = getStyle(el);
            if (style.width == 'auto' && style.display == 'block') {
                currStyle.width = '100%';
                currStyle.width = el.offsetWidth - (isContentBox() ? this.$getBasicWidth() * 2 : 0) + 'px';
            }
        }
        currStyle.height = this._sHeight;
    };

    /**
     * 
     * ECUI   Element  Element 
     * @protected
     *
     * @param {HTMLElement} el Element 
     */
    UI_CONTROL_CLASS.$setBody = function (el) {
        this._eBody = el;
    };

    /**
     * 
     *  setParent $setParent  $setParent 
     * @protected
     *
     * @param {ecui.ui.Control} parent ECUI 
     */
    UI_CONTROL_CLASS.$setParent = function (parent) {
        this._cParent = parent;
    };

    /**
     * 
     * @protected
     *
     * @param {number} width 
     * @param {number} height 
     */
    UI_CONTROL_CLASS.$setSize = function (width, height) {
        //__gzip_original__style
        var style = this._eMain.style,
            o = this._eMain.tagName,
            fixedSize = isContentBox() && o != 'BUTTON' && o != 'INPUT';

        // IE
        if (width && (o = width - (fixedSize ? this.$getBasicWidth() : 0)) > 0) {
            style.width = o + 'px';
            this.$$width = width;
        }

        // IE
        if (height && (o = height - (fixedSize ? this.$getBasicHeight() : 0)) > 0) {
            style.height = o + 'px';
            this.$$height = height;
        }
    };

    /**
     * 
     * $show 
     * @protected
     */
    UI_CONTROL_CLASS.$show = function () {
        this.getOuter().style.display = this._sDisplay || '';
        this._sDisplay = undefined;

        if (this._bCreated) {
            for (var i = 0, list = query.call(this, UI_CONTROL_QUERY_SHOW), o; o = list[i++]; ) {
                triggerEvent(o, 'show', false);
            }
        }
    };

    /**
     * /
     * ( getTypes  getClass )- ui-control demo hover  ui-controldemoui-control-hover  demo-hover
     * @public
     *
     * @param {string} className +-
     */
    UI_CONTROL_CLASS.alterClass = function (className) {
        var flag = className.charAt(0) == '+';

        if (flag) {
            className = '-' + className.slice(1) + ' ';
        }
        else {
            className += ' ';
        }

        (flag ? addClass : removeClass)(this._eMain, this.getTypes().concat([this._sClass, '']).join(className));

        if (flag) {
            this._aStatus.push(className);
        }
        else {
            remove(this._aStatus, className);
        }
    };

    /**
     * 
     * appendTo  findControl (onremove)(onappend) false parentElement 
     * @public
     *
     * @param {HTMLElement} parentElement  Element  DOM 
     */
    UI_CONTROL_CLASS.appendTo = function (parentElement) {
        UI_CONTROL_ALTER_PARENT(this, parentElement && findControl(parentElement), parentElement);
    };

    /**
     * 
     * blur  loseFocus 
     * @public
     */
    UI_CONTROL_CLASS.blur = function () {
        loseFocus(this);
    };

    /**
     * 
     * cache  $cache  Element  clearCache 
     * @public
     *
     * @param {boolean} cacheSize 
     * @param {boolean} force  clearCache 
     */
    UI_CONTROL_CLASS.cache = function (cacheSize, force) {
        if (force || !this._bCached) {
            this._bCached = true;
            this.$cache(getStyle(this._eMain), cacheSize);
        }
    };

    /**
     * 
     *  Element  clearCache 
     * @public
     */
    UI_CONTROL_CLASS.clearCache = function () {
        this._bCached = false;
    };

    /**
     * 
     * contain 
     * @public
     *
     * @param {ecui.ui.Control} control ECUI 
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.contain = function (control) {
        for (; control; control = control._cParent) {
            if (control == this) {
                return true;
            }
        }
        return false;
    };

    /**
     * 
     *  -disabled( alterClass )disable  isDisabled  true
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.disable = function () {
        if (!this._bDisabled) {
            this.alterClass('+disabled');
            this._bDisabled = true;
            $clearState(this);
            return true;
        }
        return false;
    };

    /**
     * 
     * dispose  ecui.dispose(this) 
     * @public
     */
    UI_CONTROL_CLASS.dispose = function () {
        disposeControl(this);
    };

    /**
     * 
     *  -disabled( alterClass )enable isDisabled  true
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.enable = function () {
        if (this._bDisabled) {
            this.alterClass('-disabled');
            this._bDisabled = false;
            return true;
        }
        return false;
    };

    /**
     * 
     * focus  isFocused  setFocused 
     * @public
     */
    UI_CONTROL_CLASS.focus = function () {
        if (!this.isFocused()) {
            setFocused(this);
        }
    };

    /**
     * 
     * getBody 
     * @public
     *
     * @return {HTMLElement} Element 
     */
    UI_CONTROL_CLASS.getBody = function () {
        return this._eBody;
    };

    /**
     * 
     * getBodyHeight  content 
     * @public
     *
     * @return {number} 
     */
    UI_CONTROL_CLASS.getBodyHeight = function () {
        return this.getHeight() - this.getMinimumHeight();
    };

    /**
     * 
     * getBodyWidth  content 
     * @public
     *
     * @return {number} 
     */
    UI_CONTROL_CLASS.getBodyWidth = function () {
        return this.getWidth() - this.getMinimumWidth();
    };

    /**
     * 
     * getClass  alterClass  getPrimary setClass 
     * @public
     *
     * @return {string} 
     */
    UI_CONTROL_CLASS.getClass = function () {
        return this._sClass;
    };

    /**
     * 
     * @public
     *
     * @return {string} HTML 
     */
    UI_CONTROL_CLASS.getContent = function () {
        return this._eBody.innerHTML;
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    UI_CONTROL_CLASS.getHeight = function () {
        this.cache();
        return this.$$height;
    };

    /**
     * 
     * getMain  Element ( create )
     * @public
     *
     * @return {HTMLElement} Element 
     */
    UI_CONTROL_CLASS.getMain = function () {
        return this._eMain;
    };

    /**
     * 
     * setSize  getMinimumHeight 
     * @public
     *
     * @return {number} 
     */
    UI_CONTROL_CLASS.getMinimumHeight = function () {
        this.cache();
        return this.$getBasicHeight() + (this.$$bodyHeightRevise || 0);
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    UI_CONTROL_CLASS.getMinimumWidth = function () {
        this.cache();
        return this.$getBasicWidth() + (this.$$bodyWidthRevise || 0);
    };

    /**
     * 
     * getOuter 
     * @public
     *
     * @return {HTMLElement} Element 
     */
    UI_CONTROL_CLASS.getOuter = function () {
        return this._eMain;
    };

    /**
     * 
     * getParent  ECUI  DOM 
     * @public
     *
     * @return {ecui.ui.Control} 
     */
    UI_CONTROL_CLASS.getParent = function () {
        return this._cParent || null;
    };

    /**
     * 
     * getPrimary  primary ( create ) getClass setClass 
     * @public
     *
     * @return {string} 
     */
    UI_CONTROL_CLASS.getPrimary = function () {
        return this._sPrimary;
    };

    /**
     * 
     * @public
     *
     * @return {string} 
     */
    UI_CONTROL_CLASS.getType = function () {
        return this.constructor.agent.types[0];
    };

    /**
     * 
     * getTypes 
     * @public
     *
     * @return {Array} 
     */
    UI_CONTROL_CLASS.getTypes = function () {
        return this.constructor.agent.types.slice();
    };

    /**
     * 
     * getUID  ID  id
     * @public
     *
     * @return {string}  ID
     */
    UI_CONTROL_CLASS.getUID = function () {
        return this._sUID;
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    UI_CONTROL_CLASS.getWidth = function () {
        this.cache();
        return this.$$width;
    };

    /**
     * X
     * getX  offsetLeft X getOuter  DOM ( ecui.dom.getPosition)
     * @public
     *
     * @return {number} X
     */
    UI_CONTROL_CLASS.getX = function () {
        var el = this.getOuter();

        return this.isShow() ? el.offsetLeft - calcLeftRevise(el) : 0;
    };

    /**
     * Y
     * getY  offsetTop Y getOuter  DOM ( ecui.dom.getPosition)
     * @public
     *
     * @return {number} Y
     */
    UI_CONTROL_CLASS.getY = function () {
        var el = this.getOuter();

        return this.isShow() ? el.offsetTop - calcTopRevise(el) : 0;
    };

    /**
     * 
     *  hide  onhide 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.hide = function () {
        if (this.isShow()) {
            triggerEvent(this, 'hide');
        }
    };

    /**
     * 
     * init  
     * @public
     */
    UI_CONTROL_CLASS.init = function () {
        if (!this._bCreated) {
            if (this._bDisabled) {
                this.alterClass('+disabled');
            }
            this.$setSize(this.getWidth(), this.getHeight());

            if (UI_CONTROL_READY_LIST === null) {
                //  $ready 
                this.$ready();
            }
            else {
                if (!UI_CONTROL_READY_LIST) {
                    //  $ready 
                    //  ie  input  onload 
                    // ECUI  ecui.get(xxx)  onload 
                    UI_CONTROL_READY_LIST = [];
                    timer(function () {
                        for (var i = 0, o; o = UI_CONTROL_READY_LIST[i++]; ) {
                            o.$ready();
                        }
                        UI_CONTROL_READY_LIST = null;
                    });
                }
                if (this.$ready != blank) {
                    UI_CONTROL_READY_LIST.push(this);
                }
            }
            this._bCreated = true;
        }
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isActived = function () {
        return this.contain(getActived());
    };

    /**
     * 
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isCapturable = function () {
        return this._bCapturable;
    };

    /**
     * 
     *  enable  disable 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isDisabled = function () {
        return this._bDisabled || (!!this._cParent && this._cParent.isDisabled());
    };

    /**
     * 
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isFocusable = function () {
        return this._bFocusable;
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isFocused = function () {
        return this.contain(getFocused());
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isHovered = function () {
        return this.contain(getHovered());
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isResizable = function () {
        return this._bResizable;
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isShow = function () {
        return !!this.getOuter().offsetWidth;
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CONTROL_CLASS.isUserSelect = function () {
        return this._bUserSelect;
    };

    /**
     * 
     * render 
     * @public
     */
    UI_CONTROL_CLASS.render = function () {
        this.resize();
    };

    /**
     * 
     * repaint  DOM  repaint 
     * @public
     */
    UI_CONTROL_CLASS.repaint = function () {
        this.cache(true, true);
        this.$setSize(this.getWidth(), this.getHeight());
    };

    /**
     * 
     * resize  resize 
     */
    UI_CONTROL_CLASS.resize = function () {
        if (this._bResizable) {
            this.$resize();
            this.repaint();
        }
    };

    /**
     * 
     * @public
     *
     * @param {number} width 
     * @param {number} height 
     */
    UI_CONTROL_CLASS.setBodySize = function (width, height) {
        this.setSize(width && width + this.getMinimumWidth(), height && height + this.getMinimumHeight());
    };

    /**
     * 
     * setClass  alterClass  getClass 
     * @public
     *
     * @param {string} currClass 
     */
    UI_CONTROL_CLASS.setClass = function (currClass) {
        var i = 0,
            oldClass = this._sClass,
            classes = this.getTypes(),
            list = [];

        currClass = currClass || this._sPrimary;

        // 
        if (currClass != oldClass) {
            classes.splice(0, 0, this._sClass = currClass);
            for (; classes[i]; ) {
                list[i] = this._aStatus.join(classes[i++]);
            }
            classes[0] = oldClass;
            this._eMain.className =
                list.join('') +
                    this._eMain.className.split(/\s+/).join('  ').replace(
                        new REGEXP('(^| )(' + classes.join('|') + ')(-[^ ]+)?( |$)', 'g'),
                        ''
                    );
        }
    };

    /**
     * 
     * @public
     *
     * @param {string} html HTML 
     */
    UI_CONTROL_CLASS.setContent = function (html) {
        this._eBody.innerHTML = html;
    };

    /**
     * 
     * setParent (onremove)(onappend) false parent 
     * @public
     *
     * @param {ecui.ui.Control} parent  DOM 
     */
    UI_CONTROL_CLASS.setParent = function (parent) {
        UI_CONTROL_ALTER_PARENT(this, parent, parent && parent._eBody);
    };

    /**
     * 
     * setPosition  left  top  position 
     * @public
     *
     * @param {number} x X
     * @param {number} y Y
     */
    UI_CONTROL_CLASS.setPosition = function (x, y) {
        var style = this.getOuter().style;
        style.left = x + 'px';
        style.top = y + 'px';
    };

    /**
     * 
     * 
     * @public
     *
     * @param {number} width 
     * @param {number} height 
     */
    UI_CONTROL_CLASS.setSize = function (width, height) {
        if (this._bResizable) {
            this.cache();

            //__gzip_original__style
            var style = this._eMain.style;

            // 
            if (width < this.getMinimumWidth()) {
                width = 0;
            }
            if (height < this.getMinimumHeight()) {
                height = 0;
            }

            this.$setSize(width, height);

            if (width) {
                this._sWidth = style.width;
            }
            if (height) {
                this._sHeight = style.height;
            }
        }
    };

    /**
     * 
     *  show  onshow 
     * @public
     */
    UI_CONTROL_CLASS.show = function () {
        if (!this.isShow()) {
            triggerEvent(this, 'show');
            return true;
        }
        return false;
    };

    (function () {
        // //$
        for (var i = 0, o; o = eventNames[i++]; ) {
            UI_CONTROL_CLASS['$' + o] = UI_CONTROL_CLASS['$' + o] || blank;
        }

        // 
        UI_CONTROL_CLASS.$intercept = UI_CONTROL_CLASS.$append = UI_CONTROL_CLASS.$remove =
            UI_CONTROL_CLASS.$zoomstart = UI_CONTROL_CLASS.$zoom = UI_CONTROL_CLASS.$zoomend =
            UI_CONTROL_CLASS.$dragstart = UI_CONTROL_CLASS.$dragmove = UI_CONTROL_CLASS.$dragend =
            UI_CONTROL_CLASS.$ready = UI_CONTROL_CLASS.$pagescroll = blank;
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Decorate - 
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ext = core.ext,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        REGEXP = RegExp,
        FLOOR = MATH.floor,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        
        addClass = dom.addClass,
        createDom = dom.create,
        getStyle = dom.getStyle,
        insertBefore = dom.insertBefore,
        insertHTML = dom.insertHTML,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        toCamelCase = string.toCamelCase,
        inherits = util.inherits,

        $bind = core.$bind,
        isContentBox = core.isContentBox,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {ecui.ui.Control} control 
     * @param {string} value 
     */
    var EXT_DECORATE = ext.decorate = function (control, value) {
        value.replace(/([A-Za-z0-9\-]+)\s*\(\s*([^)]+)\)/g, function ($0, $1, $2) {
            // 
            $1 = EXT_DECORATE[toCamelCase($1.charAt(0).toUpperCase() + $1.slice(1))];

            // 
            $2 = $2.split(/\s+/);
            //  el 
            for (var i = 0; $0 = $2[i++]; ) {
                new $1(control, $0);
            }
        });
    };

    /**
     * 
     * @public
     *
     * @param {ecui.ui.Control|ecui.ext.decorate.Decorator} control 
     * @param {string} primary 
     * @param {Array} list 
     */
    var DECORATOR = EXT_DECORATE.Decorator = function (control, primary, list) {
            //__transform__id_i
            var id = control.getUID(),
                o = (this._oInner = DECORATOR[id] || control).getOuter();

            insertBefore(this._eMain = createDom(this._sPrimary = primary), o).appendChild(o);
            $bind(this._eMain, control);
            control.clearCache();

            DECORATOR[id] = this;

            if (!DECORATOR_OLD_METHODS[id]) {
                // 
                id = DECORATOR_OLD_METHODS[id] = {};
                for (o in DECORATOR_PROXY) {
                    id[o] = control[o];
                    control[o] = DECORATOR_PROXY[o];
                }
            }

            if (list) {
                for (id = 0; o = list[id]; ) {
                    list[id++] =
                        '<div class="' + primary + '-' + o +
                            '" style="position:absolute;top:0px;left:0px"></div>';
                }

                insertHTML(this._eMain, 'BEFOREEND', list.join(''));
            }
        },
        DECORATOR_CLASS = DECORATOR.prototype,

        DECORATOR_PROXY = {},
        DECORATOR_OLD_METHODS = {};
//{else}//
    /**
     * 
     * @public
     *
     * @param {ecui.ui.Control} control ECUI 
     */
    DECORATOR.clear = function (control) {
        var id = control.getUID(),
            o;

        // 
        for (o in DECORATOR_PROXY) {
            delete control[o];

            // 
            if (control[o] != DECORATOR_OLD_METHODS[id][o]) {
                control[o] = DECORATOR_OLD_METHODS[id][o];
            }
        }

        o = DECORATOR[id];

        insertBefore(control.getOuter(), o._eMain);
        removeDom(o._eMain);
        for (; o != control; o = o._oInner) {
            o.$dispose();
        }
        delete DECORATOR[id];
        delete DECORATOR_OLD_METHODS[id];
    };

    /**
     * 
     * @protected
     *
     * @param {CssStyle} style  Css 
     * @param {boolean} cacheSize 
     */
    DECORATOR_CLASS.$cache = function (style, cacheSize) {
        this._oInner.$cache(style, cacheSize, true);
        UI_CONTROL_CLASS.$cache.call(this, getStyle(this._eMain), false);
        this._oInner.$$position = 'relative';
        this.$$position = style.position == 'absolute' ? 'absolute' : 'relative';
        this.$$layout =
            ';top:' + style.top + ';left:' + style.left + ';display:' + style.display +
                (ieVersion ? ';zoom:' + style.zoom : '');
    };

    /**
     * 
     * @protected
     */
    DECORATOR_CLASS.$dispose = function () {
        this._eMain = null;
    };

    /**
     * 
     * @protected
     */
    DECORATOR_CLASS.$resize = function () {
        //__gzip_original__style
        var style = this._eMain.style;

        style.width = '';
        if (!ieVersion) {
            style.height = '';
        }
        this._oInner.$resize(true);
    };

    /**
     * 
     * @protected
     *
     * @param {number} width 
     * @param {number} height 
     */
    DECORATOR_CLASS.$setSize = function (width, height) {
        //__gzip_original__style
        //__gzip_original__inner
        var style = this._eMain.style,
            inner = this._oInner,
            invalidWidth = UI_CONTROL_CLASS.$getBasicWidth.call(this),
            invalidHeight = UI_CONTROL_CLASS.$getBasicHeight.call(this),
            fixedSize = isContentBox();

        inner.$setSize(width && width - invalidWidth, height && height - invalidHeight, true);

        style.width = inner.getWidth(true) + (fixedSize ? 0 : invalidWidth) + 'px';
        style.height = inner.getHeight(true) + (fixedSize ? 0 : invalidHeight) + 'px';
    };

    /**
     * /
     * @public
     *
     * @param {string} className +-
     */
    DECORATOR_CLASS.alterClass = function (className) {
        var flag = className.charAt(0) == '+';

        this._oInner.alterClass(className, true);

        if (flag) {
            className = '-' + className.slice(1);
        }

        (flag ? addClass : removeClass)(this._eMain, this._sPrimary + className);
    };

    /**
     * 
     * @public
     *
     * @return {string} 
     */
    DECORATOR_CLASS.getClass = function () {
        return this._sPrimary;
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    DECORATOR_CLASS.getHeight = function () {
        return this._oInner.getHeight(true) + UI_CONTROL_CLASS.$getBasicHeight.call(this);
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    DECORATOR_CLASS.getMinimumHeight = function () {
        return this._oInner.getMinimumHeight(true) + UI_CONTROL_CLASS.$getBasicHeight.call(this);
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    DECORATOR_CLASS.getMinimumWidth = function () {
        return this._oInner.getMinimumWidth(true) + UI_CONTROL_CLASS.$getBasicWidth.call(this);
    };

    /**
     * 
     * @public
     *
     * @return {HTMLElement} Element 
     */
    DECORATOR_CLASS.getOuter = function () {
        return this._eMain;
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    DECORATOR_CLASS.getWidth = function () {
        return this._oInner.getWidth(true) + UI_CONTROL_CLASS.$getBasicWidth.call(this);
    };

    /**
     * 
     * @public
     */
    DECORATOR_CLASS.init = function () {
        this._eMain.style.cssText = 'position:' + this.$$position + this.$$layout;
        this._oInner.getOuter(true).style.cssText += ';position:relative;top:auto;left:auto;display:block';
        this._oInner.init(true);
    };

    /**
     * 
     * 
     * @protected
     */
    DECORATOR_PROXY.$dispose = function () {
        DECORATOR.clear(this);
        this.$dispose();
    };

    (function () {
        function build(name, index) {
            DECORATOR_PROXY[name] = function () {
                var id = this.getUID(),
                    o = DECORATOR[id],
                    args = arguments;

                return args[index] ? DECORATOR_OLD_METHODS[id][name].apply(this, args) : o[name].apply(o, args);
            };
        }

        // 
        for (
            var i = 0, names = [
                ['$cache', 2], ['$resize', 0], ['$setSize', 2],
                ['alterClass', 1], ['getOuter', 0],
                ['getMinimumWidth', 0], ['getMinimumHeight', 0],
                ['getWidth', 0], ['getHeight', 0], ['init', 0]
            ];
            i < 10;
        ) {
            // 
            build(names[i][0], names[i++][1]);
        }
    })();
//{/if}//
/*
LRDecorator - "--"paddingLeftpaddingRight
*/
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {Control} control 
     * @param {string} primary 
     */
    var LR_DECORATOR = EXT_DECORATE.LRDecorator = function (control, primary) {
            DECORATOR.call(this, control, primary, ['left', 'right']);
        };
//{else}//
    /**
     * 
     * @public
     *
     * @param {number} width 
     * @param {number} height 
     */
    inherits(LR_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            text = ';top:' + this.$$paddingTop + 'px;height:' + this._oInner.getHeight(true) + 'px;width:';

        o.style.cssText +=
            text + this.$$paddingRight + 'px;left:' + (this.$$paddingLeft + this._oInner.getWidth(true)) + 'px';
        o.previousSibling.style.cssText += text + this.$$paddingLeft + 'px';
    };
//{/if}//
/*
TBDecorator - "--"paddingToppaddingBottom
*/
//{if $phase == "define"}//
        /**
         * 
         * @public
         *
         * @param {Control} control 
         * @param {string} primary 
         */
    var TB_DECORATOR = EXT_DECORATE.TBDecorator = function (control, primary) {
            DECORATOR.call(this, control, primary, ['top', 'bottom']);
        };
//{else}//
    /**
     * 
     * @public
     *
     * @param {number} width 
     * @param {number} height 
     */
    inherits(TB_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            text = ';left:' + this.$$paddingLeft + 'px;width:' + this._oInner.getWidth(true) + 'px;height:';

        o.style.cssText +=
            text + this.$$paddingBottom + 'px;top:' + (this.$$paddingTop + this._oInner.getHeight(true)) + 'px';
        o.previousSibling.style.cssText += text + this.$$paddingTop + 'px';
    };
//{/if}//
/*
MagicDecorator - "--------"padding
*/
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {Control} control 
     * @param {string} primary 
     */
    var MAGIC_DECORATOR = EXT_DECORATE.MagicDecorator = function (control, primary) {
            DECORATOR.call(
                this,
                control,
                primary,
                ['widget0', 'widget1', 'widget2', 'widget3', 'widget5', 'widget6', 'widget7', 'widget8']
            );
        };
//{else}//
    /**
     * 
     * @public
     *
     * @param {number} width 
     * @param {number} height 
     */
    inherits(MAGIC_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            i = 9,
            paddingTop = this.$$paddingTop,
            paddingLeft = this.$$paddingLeft,
            widthList = this._oInner.getWidth(true),
            heightList = this._oInner.getHeight(true),
            topList = [0, paddingTop, paddingTop + heightList],
            leftList = [0, paddingLeft, paddingLeft + widthList];

        widthList = [paddingLeft, widthList, this.$$paddingRight];
        heightList = [paddingTop, heightList, this.$$paddingBottom];

        for (; i--; ) {
            if (i != 4) {
                o.style.cssText +=
                    ';top:' + topList[FLOOR(i / 3)] + 'px;left:' + leftList[i % 3] + 'px;width:' + widthList[i % 3] +
                        'px;height:' + heightList[FLOOR(i / 3)] + 'px';
                o = o.previousSibling;
            }
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Combine - 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        ext = core.ext,
        util = core.util,

        REGEXP = RegExp,

        indexOf = array.indexOf,
        remove = array.remove,
        blank = util.blank,

        $connect = core.$connect,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'mousewheel', 'keydown', 'keypress', 'keyup',
            'focus', 'blur', 'activate', 'deactivate'
        ];
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * 
     * @public
     *
     * @param {Array} controls 
     * @param {Array} names  * 
     */
    var COMBINE = function (controls, names) {
            this._aControls = [];
            if (!names) {
                names = ['disable', 'enable'];
            }
            else if ((i = indexOf(names, '*')) >= 0) {
                names.splice(i, 1, 'disable', 'enable');
                names = eventNames.concat(names);
            }
            names.splice(0, 0, '$dispose');
            this._aNames = names;
            for (var i = 0, o; o = controls[i++]; ) {
                if ('string' == typeof o) {
                    $connect(this, EXT_COMBINE_BIND, o);
                }
                else {
                    EXT_COMBINE_BIND.call(this, o);
                }
            }
        },
        EXT_COMBINE_CLASS = COMBINE.prototype,
        EXT_COMBINE_PROXY = {};
//{else}//
    /**
     * 
     * 
     * @public
     *
     * @param {string} name 
     * @return {Function} 
     */
    function EXT_COMBINE_BUILD(name) {
        if (!EXT_COMBINE_PROXY[name]) {
            EXT_COMBINE_CLASS[name] = function () {
                var i = 0,
                    uid = this.getUID(),
                    combine = COMBINE[uid],
                    o;

                combine[name] = blank;
                for (; o = combine._aControls[i++]; ) {
                    if (indexOf(eventNames, name) < 0) {
                        COMBINE[uid + name].apply(o, arguments);
                    }
                    else if (o != this) {
                        triggerEvent(o, name, arguments[0]);
                    }
                }
                delete combine[name];
            };

            EXT_COMBINE_PROXY[name] = function () {
                COMBINE[this.getUID()][name].apply(this, arguments);
            };
        }

        return EXT_COMBINE_PROXY[name];
    }

    /**
     * 
     * @public
     *
     * @param {ecui.ui.Control} control 
     */
    function EXT_COMBINE_BIND(control) {
        for (var i = 0, uid = control.getUID(), o; o = this._aNames[i++]; ) {
            if (indexOf(eventNames, o) < 0) {
                COMBINE[uid + o] = control[o];
                control[o] = EXT_COMBINE_BUILD(o);
            }
            else {
                core.addEventListener(control, o, EXT_COMBINE_BUILD(o));
            }
        }
        this._aControls.push(control);
        COMBINE[uid] = this;
    }

    /**
     * 
     * @protected
     */
    EXT_COMBINE_PROXY.$dispose = function () {
        var i = 0,
            uid = this.getUID(),
            combine = COMBINE[uid],
            el = this.getMain(),
            o = [this.getClass()].concat(this.getTypes());

        COMBINE[uid + '$dispose'].call(this);
        el.className = o.join(' ');
        remove(combine._aControls, this);
        for (; o = combine._aNames[i++]; ) {
            delete COMBINE[uid + o];
        }
    };

    /**
     * 
     * @public
     *
     * @param {ecui.ui.Control} control 
     * @param {string} value 
     */
    ext.combine = function (control, value) {
        if (/(^[^(]+)(\(([^)]+)\))?$/.test(value)) {
            value = REGEXP.$3;
            new COMBINE(
                [control].concat(REGEXP.$1.split(/\s+/)),
                value.split(/\s+/)
            );
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//
// FIXME
// 
$getNamespaceBase().ecui = ecui;

/*
Button - 
(active)

HTML:
<div ecui="type:button">
  <!--  -->
  ...
</div>

<button ecui="type:button">
  <!--  -->
  ...
</button>

<input ecui="type:button" value="" type="button">


*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        setText = dom.setText,
        setDefault = util.setDefault,

        inheritsControl = core.inherits,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_BUTTON
    ///__gzip_original__UI_BUTTON_CLASS
    /**
     * 
     * options 
     * text 
     * @public
     *
     * @param {Object} options 
     */
    var UI_BUTTON = ui.Button =
        inheritsControl(
            UI_CONTROL,
            'ui-button',
            function (el, options) {
                setDefault(options, 'userSelect', false);
                if (options.text) {
                    setText(el, options.text);
                }
            }
        ),
        UI_BUTTON_CLASS = UI_BUTTON.prototype;
//{else}//
    /**
     * 
     * @override
     */
    UI_BUTTON_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        event.stopPropagation();
    };

    /**
     *  -active
     * @override
     */
    UI_BUTTON_CLASS.$mouseout = function (event) {
        UI_CONTROL_CLASS.$mouseout.call(this, event);
        if (this.isActived()) {
            this.alterClass('-active');
        }
    };

    /**
     *  -active
     * @override
     */
    UI_BUTTON_CLASS.$mouseover = function (event) {
        UI_CONTROL_CLASS.$mouseover.call(this, event);
        if (this.isActived()) {
            this.alterClass('+active');
        }
    };

    /**
     * 
     * @public
     *
     * @param {string} text 
     */
    UI_BUTTON_CLASS.setText = function (text) {
        setText(this.getBody(), text);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Form - 
 iframe  window.open  z-index 40964096 z-index 

HTML:
<div ecui="type:form;hide:true">
  <label></label>
  <!--  -->
  ...
</div>


_bFlag          - /showModal
_bAutoTitle     - 
_bAutoHeight    - 
_bAutoCenter    - 
_uTitle         - 
_uClose         - 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        string = core.string,
        util = core.util,

        undefined,
        MATH = Math,
        MAX = MATH.max,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getStyle = dom.getStyle,
        moveElements = dom.moveElements,
        encodeHTML = string.encodeHTML,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        calcHeightRevise = core.calcHeightRevise,
        calcWidthRevise = core.calcWidthRevise,
        drag = core.drag,
        inheritsControl = core.inherits,
        loseFocus = core.loseFocus,
        mask = core.mask,
        setFocused = core.setFocused,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = ui.Control.prototype,
        UI_BUTTON = ui.Button;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_FORM
    ///__gzip_original__UI_FORM_CLASS
    /**
     * 
     * options 
     * hide         
     * autoTitle    title
     * autoCenter   
     * @public
     *
     * @param {Object} options 
     */
    var UI_FORM = ui.Form =
        inheritsControl(
            UI_CONTROL,
            'ui-form',
            function (el, options) {
                // Element
                var type = this.getType(),
                    o = createDom(type + '-body', 'position:relative;overflow:auto'),
                    titleEl = first(el);

                moveElements(el, o, true);

                if (titleEl && titleEl.tagName == 'LABEL') {
                    el.innerHTML =
                        '<div class="' + type + '-close' + this.Close.TYPES + '" style="position:absolute"></div>';
                    el.insertBefore(titleEl, el.firstChild);
                    titleEl.className = type + '-title' + this.Title.TYPES;
                    titleEl.style.position = 'absolute';
                }
                else {
                    el.innerHTML =
                        '<label class="' + type + '-title' + this.Title.TYPES +
                            '" style="position:absolute">'+ (options.title ? encodeHTML(options.title) : '') +'</label><div class="' + type + '-close' + this.Close.TYPES +
                            '" style="position:absolute"></div>';
                    titleEl = el.firstChild;
                }

                el.style.overflow = 'hidden';
                el.appendChild(o);
            },
            function (el, options) {
                this._bAutoHeight = !el.style.height;
                el = children(el);

                this._bFlag = options.hide;
                this._bAutoTitle = options.autoTitle !== false;
                this._bAutoCenter = options.autoCenter === true;

                // 
                this._uTitle = $fastCreate(this.Title, el[0], this, {userSelect: false});

                // 
                this._uClose = $fastCreate(this.Close, el[1], this);
                if (options.closeButton === false) {
                    this._uClose.$hide();
                }

                this.$setBody(el[2]);
            }
        ),
        UI_FORM_CLASS = UI_FORM.prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_FORM_TITLE_CLASS = (UI_FORM_CLASS.Title = inheritsControl(UI_CONTROL)).prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_FORM_CLOSE_CLASS = (UI_FORM_CLASS.Close = inheritsControl(UI_BUTTON)).prototype,

        UI_FORM_ALL = [],   // 
        UI_FORM_MODAL = 0;  // showModal
//{else}//
    /**
     * zIndex
     * @protected
     *
     * @param {ecui.ui.Form} form 
     */
    function UI_FORM_FLUSH_ZINDEX(form) {
        UI_FORM_ALL.push(UI_FORM_ALL.splice(indexOf(UI_FORM_ALL, form), 1)[0]);

        // z
        for (var i = 0, j = UI_FORM_ALL.length - UI_FORM_MODAL, o; o = UI_FORM_ALL[i++]; ) {
            o.getOuter().style.zIndex = i > j ? 32767 + (i - j) * 2 : 4095 + i;
        }
    }

    /**
     * 
     * @override
     */
    UI_FORM_TITLE_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        drag(this.getParent(), event);
    };

    /**
     * 
     * @override
     */
    UI_FORM_CLOSE_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);
        this.getParent().hide();
    };

    /**
     * @override
     */
    UI_FORM_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        style = getStyle(this.getMain().lastChild);
        this.$$bodyWidthRevise = calcWidthRevise(style);
        this.$$bodyHeightRevise = calcHeightRevise(style);
        this._uTitle.cache(true, true);
        this._uClose.cache(true, true);
    };

    /**
     * 
     * @override
     */
    UI_FORM_CLASS.$dispose = function () {
        if (indexOf(UI_FORM_ALL, this) >= 0) {
            // 
            // unloaddisposegetOuter
            try {
                this.$hide();
            }
            catch(e) {}
        }
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 
     * @override
     */
    UI_FORM_CLASS.$focus = function () {
        UI_CONTROL_CLASS.$focus.call(this);
        UI_FORM_FLUSH_ZINDEX(this);
    };

    /**
     *  showModal 
     * @override
     */
    UI_FORM_CLASS.$hide = function () {
        // showModal
        var i = indexOf(UI_FORM_ALL, this);
        if (i >= 0) {
            UI_FORM_ALL.splice(i, 1);
        }

        if (i > UI_FORM_ALL.length - UI_FORM_MODAL) {
            if (this._bFlag) {
                if (i == UI_FORM_ALL.length) {
                    mask();
                }
                else {
                    // 
                    UI_FORM_ALL[i]._bFlag = true;
                }
                this._bFlag = false;
            }
            UI_FORM_MODAL--;
        }

        UI_CONTROL_CLASS.$hide.call(this);
        loseFocus(this);
    };

    /**
     * @override
     */
    UI_FORM_CLASS.$setSize = function (width, height) {
        if (this._bAutoHeight) {
            height = null;
        }
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();

        var style = this.getMain().lastChild.style;

        style.width = this.getBodyWidth() + 'px';
        if (!this._bAutoHeight) {
            style.height = this.getBodyHeight() + 'px';
        }
        if (this._bAutoTitle) {
            this._uTitle.$setSize(this.getWidth() - this.$getBasicWidth());
        }
    };

    /**
     * 
     * @override
     */
    UI_FORM_CLASS.$show = function () {
        UI_FORM_ALL.push(this);
        UI_CONTROL_CLASS.$show.call(this);
        setFocused(this);
    };

    /**
     * 
     * @public
     */
    UI_FORM_CLASS.center = function () {
        o = this.getOuter();
        o.style.position = this.$$position = 'absolute';
        o = o.offsetParent;

        if (!o || o.tagName == 'BODY' || o.tagName == 'HTML') {
            var o = getView(),
                x = o.right + o.left,
                y = o.bottom + o.top;
        }
        else {
            x = o.offsetWidth;
            y = o.offsetHeight;
        }

        this.setPosition(MAX((x - this.getWidth()) / 2, 0), MAX((y - this.getHeight()) / 2, 0));
    };

    /**
     *  showModal 
     * @override
     */
    UI_FORM_CLASS.hide = function () {
        for (var i = indexOf(UI_FORM_ALL, this), o; o = UI_FORM_ALL[++i]; ) {
            if (o._bFlag) {
                return false;
            }
        }
        return UI_CONTROL_CLASS.hide.call(this);
    };

    /**
     * @override
     */
    UI_FORM_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uTitle.init();
        this._uClose.init();
        if (this._bFlag) {
            this._bFlag = false;
            this.$hide();
        }
        else {
            this.$show();
        }
    };

    /**
     * 
     * @public
     *
     * @param {string} text 
     */
    UI_FORM_CLASS.setTitle = function (text) {
        this._uTitle.setContent(text || '');
    };

    /**
     * @override
     */
    UI_FORM_CLASS.show = function () {
        if (UI_FORM_MODAL && indexOf(UI_FORM_ALL, this) < UI_FORM_ALL.length - UI_FORM_MODAL) {
            // showModalshowModal
            UI_FORM_MODAL++;
        }

        var result = UI_CONTROL_CLASS.show.call(this);
        if (!result) {
            UI_FORM_FLUSH_ZINDEX(this);
        }
        else if (this._bAutoCenter) {
            this.center();
        }

        return result;
    };

    /*
     * @override
     */
    UI_FORM_CLASS.$resize = function () {
        var style = this.getMain().lastChild.style; 

        UI_CONTROL_CLASS.$resize.call(this);
        style.width = '';
        style.height = '';
    };

    /**
     * override
     * getHeight
     */
    UI_FORM_CLASS.getHeight = function () {
        if (this._bAutoHeight) {
            this.cache(true, true);
        }
        return UI_CONTROL_CLASS.getHeight.call(this);
    }

    /**
     * 
     * showModal 
     * @public
     *
     * @param {number} opacity 0.05
     */
    UI_FORM_CLASS.showModal = function (opacity) {
        if (!this._bFlag) {
            if (indexOf(UI_FORM_ALL, this) < UI_FORM_ALL.length - UI_FORM_MODAL) {
                UI_FORM_MODAL++;
            }

            mask(opacity !== undefined ? opacity : 0.05, 32766 + UI_FORM_MODAL * 2);

            this._bFlag = true;
            if (!UI_CONTROL_CLASS.show.call(this)) {
                UI_FORM_FLUSH_ZINDEX(this);
            }
            else if (this._bAutoCenter) {
                this.center(); 
            }
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
InputControl - 
 InputElement () IE 
** IE6Input3pxoverflow:hidden **

HTML:
<input ecui="type:input-control" type="password" name="passwd" value="1111">
:
<div ecui="type:input-control;name:passwd;value:1111;inputType:password"></div>
:
<div ecui="type:input-control">
  <input type="password" name="passwd" value="1111">
</div>


_bHidden - 
_eInput  - INPUT
_aValidateRules - 
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        REGEXP = RegExp,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        createDom = dom.create,
        insertBefore = dom.insertBefore,
        setInput = dom.setInput,
        setStyle = dom.setStyle,
        encodeHTML = string.encodeHTML,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        timer = util.timer,

        $bind = core.$bind,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        wrapEvent = core.wrapEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_INPUT_CONTROL
    ///__gzip_original__UI_INPUT_CONTROL_CLASS
    /**
     * 
     * options 
     * name         
     * value        
     * checked      (radio/checkbox)
     * inputType     text
     * hidden       
     * @public
     *
     * @param {Object} options 
     */
    var UI_INPUT_CONTROL = ui.InputControl =
        inheritsControl(
            UI_CONTROL,
            null,
            function (el, options) {
                if (el.tagName == 'INPUT' || el.tagName == 'TEXTAREA') {
                    // 
                    var input = el;

                    insertBefore(el = createDom(input.className, input.style.cssText, 'span'), input).appendChild(input);
                    input.className = '';
                }
                else {
                    input = el.getElementsByTagName('INPUT')[0] || el.getElementsByTagName('TEXTAREA')[0];

                    if (!input) {
                        input = setInput(null, options.name, options.inputType);
                        input.defaultValue = input.value =
                            options.value === undefined ? '' : options.value.toString();
                        el.appendChild(input);
                    }
                }

                setStyle(el, 'display', 'inline-block');

                input.style.border = '0px';
                if (options.hidden) {
                    input.style.display = 'none';
                }
                if (options.checked) {
                    input.defaultChecked = input.checked = true;
                }

                return el;
            },
            function (el, options) {
                this._bHidden = options.hidden;
                this._eInput = el.getElementsByTagName('INPUT')[0] || el.getElementsByTagName('TEXTAREA')[0];

                if (util.validator) {
                    this._aValidateRules = util.validator.collectRules(options);
                }

                UI_INPUT_CONTROL_BIND_EVENT(this);
            }
        ),
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_INPUT_CONTROL_INPUT = {};
//{else}//

    /**
     * 
     * @private
     *
     * @param {Event} event 
     */
    function UI_INPUT_CONTROL_FORM_SUBMIT(event) {
        event = wrapEvent(event);

        //__transform__elements_list
        //__transform__el_o
        for (var i = 0, elements = event.target.elements, el; el = elements[i++]; ) {
            if (el.getControl) {
                triggerEvent(el.getControl(), 'submit', event);
            }
        }
    }

    /**
     *  INPUT 
     * @private
     *
     * @param {ecui.ui.Edit} control 
     */
    function UI_INPUT_CONTROL_BIND_EVENT(control) {
        $bind(control._eInput, control);
        if (!control._bHidden) {
            // IEtextarea
            for (var name in UI_INPUT_CONTROL_INPUT) {
                attachEvent(control._eInput, name, UI_INPUT_CONTROL_INPUT[name]);
            }
        }
    }

    /**
     * /
     * @private
     *
     * @param {Event} event 
     */
    UI_INPUT_CONTROL_INPUT.blur = UI_INPUT_CONTROL_INPUT.focus = function (event) {
        //__gzip_original__type
        var type = event.type;

        event = wrapEvent(event).target.getControl();

        // blur/focus
        event['$' + type] = UI_CONTROL_CLASS['$' + type];
        event[type]();

        delete event['$' + type];
    };

    /**
     * 
     * [todo] firefox
     * @private
     *
     * @param {Event} event 
     */
    UI_INPUT_CONTROL_INPUT.dragover = UI_INPUT_CONTROL_INPUT.drop = function (event) {
        wrapEvent(event).exit();
    };

    /**
     * 
     * @private
     *
     * @param {Event} event 
     */
    if (ieVersion) {
        UI_INPUT_CONTROL_INPUT.propertychange = function (event) {
            if (event.propertyName == 'value') {
                triggerEvent(wrapEvent(event).target.getControl(), 'change');
            }
        };
    }
    else {
        UI_INPUT_CONTROL_INPUT.input = function (event) {
            triggerEvent(this.getControl(), 'change');
        };
    }

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$dispose = function () {
        this._eInput.getControl = undefined;
        this._eInput = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 
     * @protected
     *
     * @param {Event} event 
     */
    UI_INPUT_CONTROL_CLASS.$reset = function () {
        this.$ready();
    };

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$setParent = function (parent) {
        UI_CONTROL_CLASS.$setParent.call(this, parent);
        if (parent = this._eInput.form) {
            if (parent.getControl) {
                parent.getControl().addItem(this.getName(), this);
            }
        }
    };

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this._eInput.style.width = this.getBodyWidth() + 'px';
        this._eInput.style.height = this.getBodyHeight() + 'px';
    };

    /**
     * 
     * @protected
     *
     * @param {Event} event 
     */
    UI_INPUT_CONTROL_CLASS.$submit = blank;

    /**
     * 
     * @override
     */
    UI_INPUT_CONTROL_CLASS.disable = function () {
        if (UI_CONTROL_CLASS.disable.call(this)) {
            var body = this.getBody();

            if (this._bHidden) {
                this._eInput.disabled = true;
            }
            else {
                body.removeChild(this._eInput);
                if (this._eInput.type != 'password') {
                    // 
                    body.innerHTML = encodeHTML(this._eInput.value);
                }
            }

            return true;
        }
        return false;
    };

    /**
     * 
     * @override
     */
    UI_INPUT_CONTROL_CLASS.enable = function () {
        if (UI_CONTROL_CLASS.enable.call(this)) {
            var body = this.getBody();

            if (this._bHidden) {
                this._eInput.disabled = false;
            }
            else {
                body.innerHTML = '';
                body.appendChild(this._eInput);
            }

            return true;
        }
        return false;
    };

    /**
     * 
     * @public
     *
     * @return {HTMLElement} InputElement 
     */
    UI_INPUT_CONTROL_CLASS.getInput = function () {
        return this._eInput;
    };

    /**
     * 
     * getName  setName 
     * @public
     *
     * @return {string} INPUT 
     */
    UI_INPUT_CONTROL_CLASS.getName = function () {
        return this._eInput.name;
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    UI_INPUT_CONTROL_CLASS.getSelectionEnd = ieVersion ? function () {
        var range = DOCUMENT.selection.createRange().duplicate();

        range.moveStart('character', -this._eInput.value.length);
        return range.text.length;
    } : function () {
        return this._eInput.selectionEnd;
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    UI_INPUT_CONTROL_CLASS.getSelectionStart = ieVersion ? function () {
        //__gzip_original__length
        var range = DOCUMENT.selection.createRange().duplicate(),
            length = this._eInput.value.length;

        range.moveEnd('character', length);
        return length - range.text.length;
    } : function () {
        return this._eInput.selectionStart;
    };

    /**
     * 
     * getValue  setValue 
     * @public
     *
     * @return {string} 
     */
    UI_INPUT_CONTROL_CLASS.getValue = function () {
        return this._eInput.value;
    };

    /**
     * 
     * @public
     *
     * @param {number} pos 
     */
    UI_INPUT_CONTROL_CLASS.setCaret = ieVersion ? function (pos) {
        var range = this._eInput.createTextRange();
        range.collapse();
        range.select();
        range.moveStart('character', pos);
        range.collapse();
        range.select();
    } : function (pos) {
        this._eInput.setSelectionRange(pos, pos);
    };

    /**
     * 
     * setName  getName 
     * @public
     *
     * @param {string} name 
     */
    UI_INPUT_CONTROL_CLASS.setName = function (name) {
        var el = setInput(this._eInput, name || '');
        if (this._eInput != el) {
            UI_INPUT_CONTROL_BIND_EVENT(this);
            this._eInput = el;
        }
    };

    /**
     * 
     * setValue  getValue 
     * @public
     *
     * @param {string} value 
     */
    UI_INPUT_CONTROL_CLASS.setValue = function (value) {
        //__gzip_original__input
        var input = this._eInput,
            func = UI_INPUT_CONTROL_INPUT.propertychange;

        // 
        if (func) {
            detachEvent(input, 'propertychange', func);
        }
        input.value = value;
        if (this._bDisabled 
            && !this._bHidden 
            && this._eInput.type != 'password'
        ) {
            this.getBody().innerHTML = encodeHTML(value);
        }
        if (func) {
            attachEvent(input, 'propertychange', func);
        }
    };

    /**
     * 
     *
     * @return {Boolean} 
     */
    UI_INPUT_CONTROL_CLASS.validate = function() {
       return true; 
    };

    /**
     * 
     */
    UI_INPUT_CONTROL_CLASS.setDefaultValue = function () {
        var value = this.getValue();
        this._eInput.defaultValue = value;
    };

    (function () {
        function build(name) {
            UI_INPUT_CONTROL_CLASS['$' + name] = function () {
                UI_CONTROL_CLASS['$' + name].call(this);

                //__gzip_original__input
                var input = this._eInput;

                detachEvent(input, name, UI_INPUT_CONTROL_INPUT[name]);
                try {
                    input[name]();
                }
                catch (e) {
                }
                attachEvent(input, name, UI_INPUT_CONTROL_INPUT[name]);
            };
        }

        build('blur');
        build('focus');
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Scrollbar - 



_nTotal         - 
_nStep          - 
_nValue         - 
_oStop          - 
_uPrev          - 
_uNext          - 
_uThumb         - 


_oRange         - 
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        FLOOR = MATH.floor,
        MAX = MATH.max,
        MIN = MATH.min,

        children = dom.children,
        blank = util.blank,
        setDefault = util.setDefault,
        timer = util.timer,

        $fastCreate = core.$fastCreate,
        drag = core.drag,
        getActived = core.getActived,
        getMouseX = core.getMouseX,
        getMouseY = core.getMouseY,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SCROLLBAR
    ///__gzip_original__UI_SCROLLBAR_CLASS
    ///__gzip_original__UI_VSCROLLBAR
    ///__gzip_original__UI_VSCROLLBAR_CLASS
    ///__gzip_original__UI_HSCROLLBAR
    ///__gzip_original__UI_HSCROLLBAR_CLASS
    /**
     * 
     * @protected
     *
     * @param {Object} options 
     */
    var UI_SCROLLBAR = ui.Scrollbar =
        inheritsControl(
            UI_CONTROL,
            'ui-scrollbar',
            function (el, options) {
                setDefault(options, 'userSelect', false);
                setDefault(options, 'focusable', false);

                var type = this.getType();

                el.innerHTML =
                    '<div class="' +
                        type + '-prev' + this.Button.TYPES +
                        '" style="position:absolute;top:0px;left:0px"></div><div class="' +
                        type + '-next' + this.Button.TYPES +
                        '" style="position:absolute;top:0px;left:0px"></div><div class="' +
                        this.Thumb.TYPES + '" style="position:absolute"></div>';
            },
            function (el, options) {
                //  el  children
                el = children(el);

                // 
                this._nValue = this._nTotal = 0;
                this._nStep = 1;

                // /
                this._uPrev = $fastCreate(this.Button, el[0], this, {focusable: false});
                this._uNext = $fastCreate(this.Button, el[1], this, {focusable: false});
                this._uThumb = $fastCreate(this.Thumb, el[2], this, {focusable: false});

                this._oStop = blank;
            }
        ),
        UI_SCROLLBAR_CLASS = UI_SCROLLBAR.prototype,

        /**
         * 
         * @protected
         *
         * @param {Object} options 
         */
        UI_SCROLLBAR_THUMB_CLASS =
            (UI_SCROLLBAR_CLASS.Thumb = inheritsControl(UI_BUTTON, 'ui-scrollbar-thumb')).prototype,

        /**
         * 
         * @protected
         *
         * @param {Object} options 
         */
        UI_SCROLLBAR_BUTTON_CLASS =
            (UI_SCROLLBAR_CLASS.Button = inheritsControl(UI_BUTTON, 'ui-scrollbar-button')).prototype;
//{else}//
    /**
     * 
     * @private
     *
     * @param {ecui.ui.Scrollbar} scrollbar 
     * @param {number} step 
     * @param {number} interval 40ms
     */
    function UI_SCROLLBAR_AUTO_SCROLL(scrollbar, step, interval) {
        var value = scrollbar._nValue,
            direction = scrollbar.getMouseDirection();

        // 
        scrollbar._oStop();

        if (direction == -1 && step < 0 || direction == 1 && step > 0) {
            scrollbar.setValue(value + step);
        }
        else {
            // 
            value = -1;
        }

        // 
        scrollbar._oStop = scrollbar._nValue != value ?
            timer(UI_SCROLLBAR_AUTO_SCROLL, interval || 200, null, scrollbar, step, 40) : blank;
    }

    /**
     * 
     *  onscroll  false $scroll 
     * @private
     *
     * @param {ecui.ui.Scrollbar} scrollbar 
     */
    function UI_SCROLLBAR_CHANGE(scrollbar) {
        var parent = scrollbar.getParent(),
            uid;

        if (parent) {
            parent.$scroll();
            if (!UI_SCROLLBAR[uid = parent.getUID()]) {
                // onscroll
                timer(function () {
                    delete UI_SCROLLBAR[uid];
                    triggerEvent(parent, 'scroll', false);
                });
                UI_SCROLLBAR[uid] = true;
            }
        }
    }

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_THUMB_CLASS.$activate = function (event) {
        UI_BUTTON_CLASS.$activate.call(this, event);

        drag(this, event, this._oRange);
    };

    /**
     * @override
     */
    UI_SCROLLBAR_THUMB_CLASS.$dragmove = function (event, x, y) {
        UI_BUTTON_CLASS.$dragmove.call(this, event, x, y);

        var parent = this.getParent(),
            value = parent.$calculateValue(x, y);

        // step
        parent.$setValue(value == parent._nTotal ? value : value - value % parent._nStep);
        UI_SCROLLBAR_CHANGE(parent);
    };

    /**
     * 
     * @public
     *
     * @param {number} top 
     * @param {number} right 
     * @param {number} bottom 
     * @param {number} left 
     */
    UI_SCROLLBAR_THUMB_CLASS.setRange = function (top, right, bottom, left) {
        this._oRange = {
            top: top,
            right: right,
            bottom: bottom,
            left: left
        };
    };

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$activate = function (event) {
        UI_BUTTON_CLASS.$activate.call(this, event);

        var parent = this.getParent();
        UI_SCROLLBAR_AUTO_SCROLL(parent, parent.getMouseDirection() * MAX(parent._nStep, 5));
    };

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$deactivate = function (event) {
        UI_BUTTON_CLASS.$deactivate.call(this, event);
        this.getParent()._oStop();
    };

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$mouseout = function (event) {
        UI_BUTTON_CLASS.$mouseout.call(this, event);
        if (getActived() == this) {
            this.getParent()._oStop(true);
        }
    };

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$mouseover = function (event) {
        UI_BUTTON_CLASS.$mouseover.call(this, event);
        if (getActived() == this) {
            this.getParent()._oStop(true);
        }
    };

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        UI_SCROLLBAR_AUTO_SCROLL(this, this.getMouseDirection() * this.$getPageStep());
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        this._uPrev.cache(true, true);
        this._uNext.cache(true, true);
        this._uThumb.cache(true, true);
    };

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_CLASS.$deactivate = function (event) {
        UI_CONTROL_CLASS.$deactivate.call(this, event);
        this._oStop();
    };

    /**
     * 0 setValue 
     * @override
     */
    UI_SCROLLBAR_CLASS.$hide = function () {
        UI_CONTROL_CLASS.$hide.call(this);
        UI_SCROLLBAR_CLASS.setValue.call(this, 0);
    };

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_CLASS.$mouseout = function (event) {
        UI_CONTROL_CLASS.$mouseout.call(this, event);
        if (getActived() == this) {
            this._oStop(true);
        }
    };

    /**
     * 
     * @override
     */
    UI_SCROLLBAR_CLASS.$mouseover = function (event) {
        UI_CONTROL_CLASS.$mouseover.call(this, event);
        if (getActived() == this) {
            this._oStop(true);
        }
    };

    /**
     * 
     * ()()
     * @protected
     *
     * @param {number} step 
     */
    UI_SCROLLBAR_CLASS.$setPageStep = function (step) {
        this._nPageStep = step;
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
    };

    /**
     * 
     * $setValue 
     * @protected
     *
     * @param {number} value 
     */
    UI_SCROLLBAR_CLASS.$setValue = function (value) {
        this._nValue = value;
    };

    /**
     * 
     * getStep  setStep 
     * @public
     *
     * @return {number} 
     */
    UI_SCROLLBAR_CLASS.getStep = function () {
        return this._nStep;
    };

    /**
     * 
     * getTotal  setTotal 
     * @public
     *
     * @return {number} 
     */
    UI_SCROLLBAR_CLASS.getTotal = function () {
        return this._nTotal;
    };

    /**
     * 
     * getValue  setValue 
     * @public
     *
     * @return {number} 
     */
    UI_SCROLLBAR_CLASS.getValue = function () {
        return this._nValue;
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uPrev.init();
        this._uNext.init();
        this._uThumb.init();
    };

    /**
     * 
     * setStep 0
     * @public
     *
     * @param {number} value 
     */
    UI_SCROLLBAR_CLASS.setStep = function (value) {
        if (value > 0) {
            this._nStep = value;
        }
    };

    /**
     * 
     * setTotal 
     * @public
     *
     * @param {number} value 
     */
    UI_SCROLLBAR_CLASS.setTotal = function (value) {
        if (value >= 0 && this._nTotal != value) {
            this._nTotal = value;
            // 
            if (this._nValue > value) {
                // 
                this._nValue = value;
                UI_SCROLLBAR_CHANGE(this);
            }
            this.$flushThumb();
        }
    };

    /**
     * 
     * setValue  setTotal 
     * @public
     *
     * @param {number} value 
     */
    UI_SCROLLBAR_CLASS.setValue = function (value) {
        value = MIN(MAX(0, value), this._nTotal);
        if (this._nValue != value) {
            // 
            this._nValue = value;
            UI_SCROLLBAR_CHANGE(this);
            this.$flushThumb();
        }
    };

    /**
     * 
     *  value , 00- setStepsetTotal  setValue 
     * @public
     *
     * @param {number} n 
     */
    UI_SCROLLBAR_CLASS.skip = function (n) {
        this.setValue(this._nValue + n * this._nStep);
    };
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {Object} options 
     */
    var UI_VSCROLLBAR = ui.VScrollbar = inheritsControl(UI_SCROLLBAR, 'ui-vscrollbar'),
        UI_VSCROLLBAR_CLASS = UI_VSCROLLBAR.prototype;
//{else}//
    /**
     * 
     *  $setValue 
     * @protected
     *
     * @param {number} x X
     * @param {number} y Y
     */
    UI_VSCROLLBAR_CLASS.$calculateValue = function (x, y) {
        //__gzip_original__range
        var thumb = this._uThumb,
            range = thumb._oRange;
        return (y - range.top) / (range.bottom - this._uPrev.getHeight() - thumb.getHeight()) * this._nTotal;
    };

    /**
     * 
     * / setSizesetValue  setTotal 
     * @protected
     */
    UI_VSCROLLBAR_CLASS.$flushThumb = function () {
        // 
        var thumb = this._uThumb,
            total = this._nTotal,
            height = this.getHeight(),
            prevHeight = this._uPrev.getHeight(),
            bodyHeight = this.getBodyHeight(),
            thumbHeight = MAX(FLOOR(bodyHeight * height / (height + total)), thumb.getMinimumHeight() + 5);

        if (total) {
            thumb.$setSize(0, thumbHeight);
            thumb.setPosition(0, prevHeight + FLOOR((this._nValue / total) * (bodyHeight - thumbHeight)));
            thumb.setRange(prevHeight, 0, bodyHeight + prevHeight, 0);
        }
    };

    /**
     * 
     *  $setPageStep $getPageStep  $getPageStep 
     * @protected
     *
     * @return {number} 
     */
    UI_VSCROLLBAR_CLASS.$getPageStep = function () {
        var height = this.getHeight();
        return this._nPageStep || height - height % this._nStep;
    };

    /**
     * @override
     */
    UI_VSCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_SCROLLBAR_CLASS.$setSize.call(this, width, height);

        //__gzip_original__next
        var bodyWidth = this.getBodyWidth(),
            prevHeight = this.$$paddingTop,
            next = this._uNext;

        // 
        this._uPrev.$setSize(bodyWidth, prevHeight);
        next.$setSize(bodyWidth, this.$$paddingBottom);
        this._uThumb.$setSize(bodyWidth);
        next.setPosition(0, this.getBodyHeight() + prevHeight);

        this.$flushThumb();
    };

    /**
     * 
     *  -1 1 0
     * @protected
     *
     * @return {number} 
     */
    UI_VSCROLLBAR_CLASS.getMouseDirection = function () {
        return getMouseY(this) < this._uThumb.getY() ?
            -1 : getMouseY(this) > this._uThumb.getY() + this._uThumb.getHeight() ? 1 : 0;
    };
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {Object} options 
     */
    var UI_HSCROLLBAR = ui.HScrollbar = inheritsControl(UI_SCROLLBAR, 'ui-hscrollbar'),
        UI_HSCROLLBAR_CLASS = UI_HSCROLLBAR.prototype;
//{else}//
    /**
     * 
     *  $setValue 
     * @protected
     *
     * @param {number} x X
     * @param {number} y Y
     */
    UI_HSCROLLBAR_CLASS.$calculateValue = function (x, y) {
        //__gzip_original__range
        var thumb = this._uThumb,
            range = thumb._oRange;
        return (x - range.left) / (range.right - this._uPrev.getWidth() - thumb.getWidth()) * this._nTotal;
    };

    /**
     * 
     * / setSizesetValue  setTotal 
     * @protected
     */
    UI_HSCROLLBAR_CLASS.$flushThumb = function () {
        // 
        var thumb = this._uThumb,
            total = this._nTotal,
            width = this.getWidth(),
            prevWidth = this._uPrev.getWidth(),
            bodyWidth = this.getBodyWidth(),
            thumbWidth = MAX(FLOOR(bodyWidth * width / (width + total)), thumb.getMinimumWidth() + 5);

        if (total) {
            thumb.$setSize(thumbWidth);
            thumb.setPosition(prevWidth + FLOOR((this._nValue / total) * (bodyWidth - thumbWidth)), 0);
            thumb.setRange(0, bodyWidth + prevWidth, 0, prevWidth);
        }
    };

    /**
     * 
     *  $setPageStep $getPageStep  $getPageStep 
     * @protected
     *
     * @return {number} 
     */
    UI_HSCROLLBAR_CLASS.$getPageStep = function () {
        var width = this.getWidth();
        return width - width % this._nStep;
    };

    /**
     * @override
     */
    UI_HSCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_SCROLLBAR_CLASS.$setSize.call(this, width, height);

        //__gzip_original__next
        var bodyHeight = this.getBodyHeight(),
            prevWidth = this.$$paddingLeft,
            next = this._uNext;

        // 
        this._uPrev.$setSize(prevWidth, bodyHeight);
        next.$setSize(this.$$paddingRight, bodyHeight);
        this._uThumb.$setSize(0, bodyHeight);
        next.setPosition(this.getBodyWidth() + prevWidth, 0);

        this.$flushThumb();
    };

    /**
     * 
     *  -1 1 0
     * @protected
     *
     * @return {number} 
     */
    UI_HSCROLLBAR_CLASS.getMouseDirection = function () {
        return getMouseX(this) < this._uThumb.getX() ?
            -1 : getMouseX(this) > this._uThumb.getX() + this._uThumb.getWidth() ? 1 : 0;
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Panel - 
///()

HTML:
<div ecui="type:panel">
  <!--  -->
  ...
</div>


_bAbsolute           - Element
_nWheelDelta         - 
_eBrowser            - Element
_uVScrollbar         - 
_uHScrollbar         - 
_uCorner             - 
$$mainWidth          - layout
$$mainHeight         - layout
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,
        FLOOR = MATH.floor,

        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getStyle = dom.getStyle,
        moveElements = dom.moveElements,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        calcHeightRevise = core.calcHeightRevise,
        calcWidthRevise = core.calcWidthRevise,
        findControl = core.findControl,
        getKey = core.getKey,
        getScrollNarrow = core.getScrollNarrow,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        wrapEvent = core.wrapEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_VSCROLLBAR = ui.VScrollbar,
        UI_HSCROLLBAR = ui.HScrollbar;
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * @protected
     *
     * @param {Object} options 
     */
    ///__gzip_original__UI_BROWSER_SCROLLBAR
    ///__gzip_original__UI_BROWSER_SCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_VSCROLLBAR
    ///__gzip_original__UI_BROWSER_VSCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_HSCROLLBAR
    ///__gzip_original__UI_BROWSER_HSCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_CORNER
    ///__gzip_original__UI_BROWSER_CORNER_CLASS
    ///__gzip_original__UI_PANEL
    ///__gzip_original__UI_PANEL_CLASS
    var UI_BROWSER_SCROLLBAR =
        inheritsControl(
            UI_CONTROL,
            null,
            null,
            function (el, options) {
                detachEvent(el, 'scroll', UI_BROWSER_SCROLLBAR_SCROLL);
                attachEvent(el, 'scroll', UI_BROWSER_SCROLLBAR_SCROLL);
            }
        ),
        UI_BROWSER_SCROLLBAR_CLASS = UI_BROWSER_SCROLLBAR.prototype;
//{else}//
    /**
     * 
     *  onscroll  false $scroll 
     * @private
     *
     * @param {ecui.ui.Event} event 
     */
    function UI_BROWSER_SCROLLBAR_SCROLL(event) {
        triggerEvent(findControl(getParent(wrapEvent(event).target)), 'scroll');
    }

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.$hide = UI_BROWSER_SCROLLBAR_CLASS.hide = function () {
        this.getMain().style[this._aProperty[0]] = 'hidden';
        UI_BROWSER_SCROLLBAR_CLASS.setValue.call(this, 0);
    };

    /**
     * 
     * @protected
     *
     * @param {number} value 
     */
    UI_BROWSER_SCROLLBAR_CLASS.$setValue = function (value) {
        this.getMain()[this._aProperty[1]] = MIN(MAX(0, value), this.getTotal());
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.$show = UI_BROWSER_SCROLLBAR_CLASS.show = function () {
        this.getMain().style[this._aProperty[0]] = 'scroll';
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.getHeight = function () {
        return this._aProperty[4] ? this.getMain()[this._aProperty[4]] : getScrollNarrow();
    };

    /**
     * 
     * getTotal  setTotal 
     * @public
     *
     * @return {number} 
     */
    UI_BROWSER_SCROLLBAR_CLASS.getTotal = function () {
        return toNumber(this.getMain().lastChild.style[this._aProperty[2]]);
    };

    /**
     * 
     * getValue  setValue 
     * @public
     *
     * @return {number} 
     */
    UI_BROWSER_SCROLLBAR_CLASS.getValue = function () {
        return this.getMain()[this._aProperty[1]];
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.getWidth = function () {
        return this._aProperty[3] ? this.getMain()[this._aProperty[3]] : getScrollNarrow();
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.isShow = function () {
        return this.getMain().style[this._aProperty[0]] != 'hidden';
    };

    /**
     * 
     * setTotal 
     * @public
     *
     * @param {number} value 
     */
    UI_BROWSER_SCROLLBAR_CLASS.setTotal = function (value) {
        this.getMain().lastChild.style[this._aProperty[2]] = value + 'px';
    };

    /**
     * 
     * @public
     *
     * @param {number} value 
     */
    UI_BROWSER_SCROLLBAR_CLASS.setValue = function (value) {
        this.$setValue(value);
        triggerEvent(this.getParent(), 'scroll');
    };

    UI_BROWSER_SCROLLBAR_CLASS.$cache =
        UI_BROWSER_SCROLLBAR_CLASS.$getPageStep = UI_BROWSER_SCROLLBAR_CLASS.$setPageStep =
        UI_BROWSER_SCROLLBAR_CLASS.$setSize = UI_BROWSER_SCROLLBAR_CLASS.alterClass =
        UI_BROWSER_SCROLLBAR_CLASS.cache = UI_BROWSER_SCROLLBAR_CLASS.getStep =
        UI_BROWSER_SCROLLBAR_CLASS.init = UI_BROWSER_SCROLLBAR_CLASS.setPosition =
        UI_BROWSER_SCROLLBAR_CLASS.setStep = UI_BROWSER_SCROLLBAR_CLASS.skip = blank;
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {Object} options 
     */
    var UI_BROWSER_VSCROLLBAR =
        inheritsControl(
            UI_BROWSER_SCROLLBAR,
            null,
            null,
            function (el, options) {
                this._aProperty = ['overflowY', 'scrollTop', 'height', null, 'offsetHeight'];
            }
        );
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {Object} options 
     */
    var UI_BROWSER_HSCROLLBAR =
        inheritsControl(
            UI_BROWSER_SCROLLBAR,
            null,
            null,
            function (el, options) {
                this._aProperty = ['overflowX', 'scrollLeft', 'width', 'offsetWidth', null];
            }
        );
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {Object} options 
     */
    var UI_BROWSER_CORNER = inheritsControl(UI_CONTROL),
        UI_BROWSER_CORNER_CLASS = UI_BROWSER_CORNER.prototype;
//{else}//
    (function () {
        for (var name in UI_CONTROL_CLASS) {
            UI_BROWSER_CORNER_CLASS[name] = blank;
        }
    })();
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * options 
     * vScroll    
     * hScroll    
     * browser    
     * absolute   Element
     * wheelDelta (*)20
     * @public
     *
     * @param {Object} options 
     */
    var UI_PANEL = ui.Panel =
        inheritsControl(
            UI_CONTROL,
            'ui-panel',
            function (el, options) {
                var vscroll = options.vScroll !== false,
                    hscroll = options.hScroll !== false,
                    type = this.getType(),
                    o = createDom(
                        type + '-body',
                        'position:absolute;top:0px;left:0px' + (hscroll ? ';white-space:nowrap' : '')
                    );

                el.style.overflow = 'hidden';
                moveElements(el, o, true);

                el.innerHTML =
                    (options.browser ?
                        '<div style="position:absolute;top:0px;left:0px;overflow:auto;padding:0px;border:0px">' +
                            '<div style="width:1px;height:1px;padding:0px;border:0px"></div></div>'
                        : (vscroll ?
                            '<div class="' + type + '-vscrollbar' + this.VScrollbar.TYPES +
                                '" style="position:absolute"></div>' : '') +
                                (hscroll ?
                                    '<div class="' + type + '-hscrollbar' + this.HScrollbar.TYPES +
                                        '" style="position:absolute"></div>' : '') +
                                (vscroll && hscroll ?
                                    '<div class="' + type + '-corner' + UI_CONTROL.TYPES +
                                        '" style="position:absolute"></div>' : '')
                    ) + '<div class="' + type +
                            '-layout" style="position:relative;overflow:hidden;padding:0px"></div>';

                el.lastChild.appendChild(o);
            },
            function (el, options) {
                var i = 0,
                    browser = options.browser,
                    vscroll = options.vScroll !== false,
                    hscroll = options.hScroll !== false,
                    list = [
                        [vscroll, '_uVScrollbar', browser ? UI_BROWSER_VSCROLLBAR : this.VScrollbar],
                        [hscroll, '_uHScrollbar', browser ? UI_BROWSER_HSCROLLBAR : this.HScrollbar],
                        [vscroll && hscroll, '_uCorner', browser ? UI_BROWSER_CORNER : UI_CONTROL]
                    ],
                    o;

                this.$setBody(el.lastChild.lastChild);

                this._bAbsolute = options.absolute;
                this._nWheelDelta = options.wheelDelta;

                el = el.firstChild;
                if (browser) {
                    this._eBrowser = el;
                }

                // Elementlefttop
                for (; o = list[i++]; ) {
                    if (o[0]) {
                        this[o[1]] = $fastCreate(o[2], el, this);
                        if (!browser) {
                            el = el.nextSibling;
                        }
                    }
                }
            }
        ),
        UI_PANEL_CLASS = UI_PANEL.prototype;
//{else}//

    UI_PANEL_CLASS.VScrollbar = UI_VSCROLLBAR;
    UI_PANEL_CLASS.HScrollbar = UI_HSCROLLBAR;

    /**
     * @override
     */
    UI_PANEL_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        var body = this.getBody(),
            mainWidth = body.offsetWidth,
            mainHeight = body.offsetHeight;

        style = getStyle(getParent(body));
        this.$$bodyWidthRevise = calcWidthRevise(style);
        this.$$bodyHeightRevise = calcHeightRevise(style);

        // Element
        if (this._bAbsolute) {
            for (
                var i = 0,
                    list = body.all || body.getElementsByTagName('*'),
                    pos = getPosition(body);
                //  body  DOM 
                body = list[i++];
            ) {
                if (body.offsetWidth && getStyle(body, 'position') == 'absolute') {
                    style = getPosition(body);
                    mainWidth = MAX(mainWidth, style.left - pos.left + body.offsetWidth);
                    mainHeight = MAX(mainHeight, style.top - pos.top + body.offsetHeight);
                }
            }
        }

        this.$$mainWidth = mainWidth;
        this.$$mainHeight = mainHeight;

        if (this._uVScrollbar) {
             this._uVScrollbar.cache(true, true);
        }
        if (this._uHScrollbar) {
             this._uHScrollbar.cache(true, true);
        }
        if (this._uCorner) {
            this._uCorner.cache(true, true);
        }
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.$dispose = function () {
        this._eBrowser = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 
     * @override
     */
    UI_PANEL_CLASS.$keydown = UI_PANEL_CLASS.$keypress = function (event) {
        var which = getKey(),
            o = which % 2 ? this._uHScrollbar : this._uVScrollbar;

        if (which >= 37 && which <= 40 && !event.target.value) {
            if (o) {
                o.skip(which + which % 2 - 39);
            }
            return false;
        }
    };

    /**
     * 
     * @override
     */
    UI_PANEL_CLASS.$mousewheel = function (event) {
        if (this.isHovered()) {
            o = this._uVScrollbar;

            if (o && o.isShow()) {
                // 
                var value = o.getValue(),
                    delta = this._nWheelDelta || FLOOR(20 / o.getStep()) || 1,
                    o;

                o.skip(event.detail > 0 ? delta : -delta);
                event.stopPropagation();
                // 
                return value == o.getValue();
            }
        }
    };

    /**
     * 
     *  onscroll  false $scroll 
     * @protected
     */
    UI_PANEL_CLASS.$scroll = function () {
        var style = this.getBody().style;
        style.left = -MAX(this.getScrollLeft(), 0) + 'px';
        style.top = -MAX(this.getScrollTop(), 0) + 'px';
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();

        var basicWidth = this.$getBasicWidth(),
            basicHeight = this.$getBasicHeight(),
            paddingWidth = this.$$paddingLeft + this.$$paddingRight,
            paddingHeight = this.$$paddingTop + this.$$paddingBottom,
            bodyWidth = this.getWidth() - basicWidth,
            bodyHeight = this.getHeight() - basicHeight,
            mainWidth = this.$$mainWidth,
            mainHeight = this.$$mainHeight,
            browser = this._eBrowser,
            vscroll = this._uVScrollbar,
            hscroll = this._uHScrollbar,
            corner = this._uCorner,
            vsWidth = vscroll ? vscroll.getWidth() : 0,
            hsHeight = hscroll ? hscroll.getHeight() : 0, 
            innerWidth = bodyWidth - vsWidth,
            innerHeight = bodyHeight - hsHeight,
            hsWidth = innerWidth + paddingWidth,
            vsHeight = innerHeight + paddingHeight;

        // 
        if (vscroll) {
            vscroll.setPosition(hsWidth, 0);
        }
        if (hscroll) {
            hscroll.setPosition(0, vsHeight);
        }
        if (corner) {
            corner.setPosition(hsWidth, vsHeight);
        }

        if (mainWidth <= bodyWidth && mainHeight <= bodyHeight) {
            // 
            if (vscroll) {
                vscroll.$hide();
            }
            if (hscroll) {
                hscroll.$hide();
            }
            if (corner) {
                corner.$hide();
            }
            innerWidth = bodyWidth;
            innerHeight = bodyHeight;
        }
        else {
            while (true) {
                if (corner) {
                    // 
                    if (mainWidth > innerWidth && mainHeight > innerHeight) {
                        hscroll.$setSize(hsWidth);
                        hscroll.setTotal(browser ? mainWidth + basicWidth : mainWidth - innerWidth);
                        hscroll.$show();
                        vscroll.$setSize(0, vsHeight);
                        vscroll.setTotal(browser ? mainHeight + basicHeight : mainHeight - innerHeight);
                        vscroll.$show();
                        corner.$setSize(vsWidth, hsHeight);
                        corner.$show();
                        break;
                    }
                    corner.$hide();
                }
                if (hscroll) {
                    if (mainWidth > bodyWidth) {
                        // 
                        hscroll.$setSize(bodyWidth + paddingWidth);
                        hscroll.setTotal(browser ? mainWidth + basicWidth : mainWidth - bodyWidth);
                        hscroll.$show();
                        if (vscroll) {
                            vscroll.$hide();
                        }
                        innerWidth = bodyWidth;
                    }
                    else {
                        hscroll.$hide();
                    }
                }
                if (vscroll) {
                    if (mainHeight > bodyHeight) {
                        // 
                        vscroll.$setSize(0, bodyHeight + paddingHeight);
                        vscroll.setTotal(browser ? mainHeight + basicHeight : mainHeight - bodyHeight);
                        vscroll.$show();
                        if (hscroll) {
                            hscroll.$hide();
                        }
                        innerHeight = bodyHeight;
                    }
                    else {
                        vscroll.$hide();
                    }
                }
                break;
            }
        }

        innerWidth -= this.$$bodyWidthRevise;
        innerHeight -= this.$$bodyHeightRevise;
        (innerWidth < 0) && (innerWidth = 0);
        (innerHeight < 0) && (innerHeight = 0);

        if (vscroll) {
            vscroll.$setPageStep(innerHeight);
        }
        if (hscroll) {
            hscroll.$setPageStep(innerWidth);
        }
    
        //  corner  style
        if (browser) {
            corner = browser.style;
            corner.width = bodyWidth + paddingWidth + 'px';
            corner.height = bodyHeight + paddingHeight + 'px';
        }

        corner = getParent(this.getBody()).style;
        corner.width = innerWidth + 'px';
        corner.height = innerHeight + 'px';
    };

    /**
     * 
     * getScrollLeft  getValue
     * @public
     *
     * @return {number}  -1
     */
    UI_PANEL_CLASS.getScrollLeft = function () {
        var o = this._uHScrollbar;
        return o ? o.getValue() : -1;
    };

    /**
     * 
     * getScrollTop  getValue
     * @public
     *
     * @return {number}  -1
     */
    UI_PANEL_CLASS.getScrollTop = function () {
        var o = this._uVScrollbar;
        return o ? o.getValue() : -1;
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        if (this._uVScrollbar) {
            this._uVScrollbar.init();
        }
        if (this._uHScrollbar) {
            this._uHScrollbar.init();
        }
        if (this._uCorner) {
            this._uCorner.init();
        }
    };

    /**
     * 
     * reset  0
     * @public
     */
    UI_PANEL_CLASS.reset = function () {
        if (this._uVScrollbar) {
            this._uVScrollbar.setValue(0);
        }
        if (this._uHScrollbar) {
            this._uHScrollbar.setValue(0);
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Item/Items - 
(Items)
/ ecui.ui.Items  prototype  $initItems 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,

        indexOf = array.indexOf,
        remove = array.remove,
        children = dom.children,
        createDom = dom.create,
        insertBefore = dom.insertBefore,
        trim = string.trim,
        blank = util.blank,
        callSuper = util.callSuper,

        $fastCreate = core.$fastCreate,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_ITEM
    ///__gzip_original__UI_ITEMS
    /**
     * 
     * @public
     *
     * @param {string|Object} options 
     */
    var UI_ITEM = ui.Item =
        inheritsControl(
            UI_CONTROL,
            'ui-item',
            function (el, options) {
                el.style.overflow = 'hidden';
                if (options.prompt != null) {
                    el.title = options.prompt;
                }
            }
        ),
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items = {};
//{else}//
    /**
     *  onitemclick 
     * @override
     */
    UI_ITEM_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);

        var parent = this.getParent();
        if (parent) {
            triggerEvent(parent, 'itemclick', event, [indexOf(UI_ITEMS[parent.getUID()], this)]);
        }
    };

    /**
     *  $alterItems 
     * @override
     */
    UI_ITEMS.$append = function (child) {
        // 
        if (!(child instanceof (this.Item || UI_ITEM)) || callSuper(this, '$append') === false) {
            return false;
        }
        UI_ITEMS[this.getUID()].push(child);
        this.$alterItems();
    };

    /**
     * @override
     */
    UI_ITEMS.$cache = function (style, cacheSize) {
        callSuper(this, '$cache');

        for (var i = 0, list = UI_ITEMS[this.getUID()], o; o = list[i++]; ) {
            o.cache(true, true);
        }
    };

    /**
     * @override
     */
    UI_ITEMS.$dispose = function () {
        delete UI_ITEMS[this.getUID()];
        callSuper(this, '$dispose');
    };

    /**
     * 
     *  Items  $initItems $initItems 
     * @protected
     */
    UI_ITEMS.$initItems = function () {
        // 
        this.$alterItems = this.$initItems = blank;

        UI_ITEMS[this.getUID()] = [];

        // 
        for (var i = 0, list = children(this.getBody()), o; o = list[i++]; ) {
            this.add(o);
        }

        delete this.$alterItems;
    };

    /**
     *  $alterItems 
     * @override
     */
    UI_ITEMS.$remove = function (child) {
        callSuper(this, '$remove');
        remove(UI_ITEMS[this.getUID()], child);
        this.$alterItems();
    };

    /**
     * 
     * add 
     * @public
     *
     * @param {string|HTMLElement|ecui.ui.Item} item  html //
     * @param {number} index 
     * @param {Object} options 
     * @return {ecui.ui.Item} 
     */
    UI_ITEMS.add = function (item, index, options) {
        var list = UI_ITEMS[this.getUID()],
            o;

        if (item instanceof UI_ITEM) {
            // 
            item.setParent(this);
        }
        else {
            // Element
            if ('string' == typeof item) {
                this.getBody().appendChild(o = createDom());
                o.innerHTML = item;
                item = o;
            }

            o = this.Item || UI_ITEM;
            item.className = trim(item.className) + ' ' + this.getType() + '-item' + o.TYPES;

            options = options || getOptions(item);
            options.parent = this;
            options.select = false;
            list.push(item = $fastCreate(o, item, this, options));
            this.$alterItems();
        }

        // 
        if (item.getParent() && (o = list[index]) && o != item) {
            insertBefore(item.getOuter(), o.getOuter());
            list.splice(index, 0, list.pop());
        }

        return item;
    };

    /**
     * 
     * append  add  index 
     * @public
     *
     * @param {string|Element|ecui.ui.Item} item  html //
     * @param {Object} 
     * @return {ecui.ui.Item} 
     */
    UI_ITEMS.append = function (item, options) {
        this.add(item, undefined, options);
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_ITEMS.getItems = function () {
        return UI_ITEMS[this.getUID()].slice();
    };

    /**
     * @override
     */
    UI_ITEMS.init = function () {
        callSuper(this, 'init');
        this.$alterItems();
    };

    /**
     * 
     * @public
     *
     * @param {number|ecui.ui.Item} item /
     * @return {ecui.ui.Item} 
     */
    UI_ITEMS.remove = function (item) {
        if ('number' == typeof item) {
            item = UI_ITEMS[this.getUID()][item];
        }
        if (item) {
            item.setParent();
        }
        return item || null;
    };

    /**
     * 
     * @public
     *
     * @param {number} itemWidth 
     * @param {number} itemHeight 
     */
    UI_ITEMS.setItemSize = function (itemWidth, itemHeight) {
        for (var i = 0, list = UI_ITEMS[this.getUID()], o; o = list[i++]; ) {
            o.$setSize(itemWidth, itemHeight);
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Checkbox - 
 InputElement ()

HTML:
<input ecui="type:checkbox;subject:china" name="city" value="beijing" checked="checked" type="checkbox">

<div ecui="type:checkbox;name:city;value:beijing;checked:true;subject:china"></div>

<div ecui="type:checkbox;subject:china">
  <input name="city" value="beijing" checked="checked" type="checkbox">
</div>


_bDefault        - 
_nStatus         - 0--1--2--
_cSubject        - 
_aDependents     - 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        ui = core.ui,
        util = core.util,

        undefined,

        remove = array.remove,
        setDefault = util.setDefault,

        $connect = core.$connect,
        getKey = core.getKey,
        inheritsControl = core.inherits,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_CHECKBOX
    ///__gzip_original__UI_CHECKBOX_CLASS
    /**
     * 
     * options 
     * subject  ID
     * @public
     *
     * @param {Object} options 
     */
    var UI_CHECKBOX = ui.Checkbox =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-checkbox',
            function (el, options) {
                setDefault(options, 'hidden', true);
                setDefault(options, 'inputType', 'checkbox');
            },
            function (el, options) {
                // IE6/7DOM
                this._bDefault = this.getInput().defaultChecked;
                this._aDependents = [];

                $connect(this, this.setSubject, options.subject);
            }
        ),
        UI_CHECKBOX_CLASS = UI_CHECKBOX.prototype;
//{else}//
    /**
     * 
     * @private
     *
     * @param {ecui.ui.Checkbox} control 
     * @param {number} status 0--1--2--
     */
    function UI_CHECKBOX_CHANGE(control, status) {
        if (status !== control._nStatus) {
            // 
            control.setClass(control.getPrimary() + ['-checked', '', '-part'][status]);

            control._nStatus = status;

            var el = control.getInput();
            el.defaultChecked = el.checked = !status;

            // 
            if (control._cSubject) {
                UI_CHECKBOX_FLUSH(control._cSubject);
            }
        }
    }

    /**
     * 
     * @private
     *
     * @param {ecui.ui.Checkbox} control 
     */
    function UI_CHECKBOX_FLUSH(control) {
        for (var i = 0, status, o; o = control._aDependents[i++]; ) {
            if (status !== undefined && status != o._nStatus) {
                status = 2;
                break;
            }
            status = o._nStatus;
        }

        if (status !== undefined) {
            UI_CHECKBOX_CHANGE(control, status);
        }
    }

    /**
     * 
     * @override
     */
    UI_CHECKBOX_CLASS.$click = function (event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this, event);
        this.setChecked(!!this._nStatus);
    };

    /**
     * @override
     */
    UI_CHECKBOX_CLASS.$dispose = function () {
        var arr = this._aDependents.slice(0),
            i, o;

        this.setSubject();
        for (i = 0; o = arr[i]; i++) {
            o.setSubject();
        }
        UI_INPUT_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 
     * @override
     */
    UI_CHECKBOX_CLASS.$keydown = UI_CHECKBOX_CLASS.$keypress = UI_CHECKBOX_CLASS.$keyup = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type].call(this, event);
        if (getKey() == 32) {
            // 
            if (event.type == 'keyup') {
                this.setChecked(!!this._nStatus);
            }
            event.preventDefault();
        }
    };

    /**
     * @override
     */
    UI_CHECKBOX_CLASS.$ready = function () {
        if (!this._aDependents.length) {
            // 
            UI_CHECKBOX_CHANGE(this, this.getInput().checked ? 0 : 1);
        }
    };

    /**
     * @override
     */
    UI_CHECKBOX_CLASS.$reset = function (event) {
        // IE6/7DOM
        this.getInput().checked = this._bDefault;
        UI_INPUT_CONTROL_CLASS.$reset.call(this, event);
    };

    /**
     * 
     *  setSubject 
     * @public
     *
     * @return {Array} 
     */
    UI_CHECKBOX_CLASS.getDependents = function () {
        return this._aDependents.slice();
    };

    /**
     * 
     * getSubject  setSubject 
     * @public
     *
     * @return {ecui.ui.Checkbox} 
     */
    UI_CHECKBOX_CLASS.getSubject = function () {
        return this._cSubject || null;
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CHECKBOX_CLASS.isChecked = function () {
        return !this._nStatus;
    };

    /**
     * 
     * @public
     *
     * @param {boolean} checked 
     */
    UI_CHECKBOX_CLASS.setChecked = function (checked) {
        UI_CHECKBOX_CHANGE(this, checked ? 0 : 1);
        // 
        for (var i = 0, o; o = this._aDependents[i++]; ) {
            o.setChecked(checked);
        }
    };

    /**
     * override
     */
    UI_CHECKBOX_CLASS.setDefaultValue = function () {
        this._bDefault = this.isChecked();
    };

    /**
     * 
     * setSubject  getDependents  DOM  setSubject 
     * @public
     *
     * @param {ecui.ui.Checkbox} checkbox 
     */
    UI_CHECKBOX_CLASS.setSubject = function (checkbox) {
        var oldSubject = this._cSubject;
        if (oldSubject != checkbox) {
            this._cSubject = checkbox;

            if (oldSubject) {
                // 
                remove(oldSubject._aDependents, this);
                UI_CHECKBOX_FLUSH(oldSubject);
            }

            if (checkbox) {
                checkbox._aDependents.push(this);
                UI_CHECKBOX_FLUSH(checkbox);
            }
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Radio - 
 InputElement ()

HTML:
<input ecui="type:radio" name="city" value="beijing" checked="checked" type="radio">

<div ecui="type:radio;name:city;value:beijing;checked:true"></div>

<div ecui="type:radio">
  <input name="city" value="beijing" checked="checked" type="radio">
</div>


_bDefault  - 
*/
//{if 0}//
(function () {

    var core = ecui,
        ui = core.ui,
        util = core.util,

        undefined,

        setDefault = util.setDefault,

        getKey = core.getKey,
        inheritsControl = core.inherits,
        query = core.query,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_RADIO
    ///__gzip_original__UI_RADIO_CLASS
    /**
     * 
     * options 
     * @public
     *
     * @param {Object} options 
     */
    var UI_RADIO = ui.Radio =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-radio',
            function (el, options) {
                setDefault(options, 'hidden', true);
                setDefault(options, 'inputType', 'radio');
            },
            function (el, options) {
                // IE6/7DOM
                this._bDefault = this.getInput().defaultChecked;
            }
        ),
        UI_RADIO_CLASS = UI_RADIO.prototype;
//{else}//
    /**
     * 
     * @private
     *
     * @param {ecui.ui.Radio} control 
     * @param {boolean|undefined} checked 
     */
    function UI_RADIO_FLUSH(control, checked) {
        if (checked !== undefined) {
            var el = control.getInput();
            el.defaultChecked = el.checked = checked;
        }
        control.setClass(control.getPrimary() + (control.isChecked() ? '-checked' : ''));
    }

    /**
     * 
     * @override
     */
    UI_RADIO_CLASS.$click = function (event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this, event);
        this.setChecked(true);
    };

    /**
     * 
     * @override
     */
    UI_RADIO_CLASS.$keydown = UI_RADIO_CLASS.$keypress = UI_RADIO_CLASS.$keyup = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type].call(this, event);
        if (event.which == 32) {
            if (event.type == 'keyup' && getKey() == 32) {
                this.setChecked(true);
            }
            event.preventDefault();
        }
    };

    /**
     * @override
     */
    UI_RADIO_CLASS.$ready = function () {
        UI_RADIO_FLUSH(this);
    };

    /**
     * @override
     */
    UI_RADIO_CLASS.$reset = function (event) {
        // IE6/7DOM
        this.getInput().checked = this._bDefault;
        UI_INPUT_CONTROL_CLASS.$reset.call(this, event);
    };

    /**
     * 
     * getItems 
     * @public
     *
     * @return {Array} 
     */
    UI_RADIO_CLASS.getItems = function () {
        //__gzip_original__form
        var i = 0,
            list = this.getInput(),
            form = list.form,
            o = list.name,
            result = [];

        if (!o) {
            return [this];
        }
        else if (form) {
            //  name  form[o] 
            for (list = form[o]; o = list[i++]; ) {
                if (o.getControl) {
                    result.push(o.getControl());
                }
            }
            return result;
        }
        else {
            return query({type: UI_RADIO, custom: function (control) {
                return !control.getInput().form && control.getName() == o;
            }});
        }
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_RADIO_CLASS.isChecked = function () {
        return this.getInput().checked;
    };

    /**
     * 
     * 
     * @public
     *
     * @param {boolean} checked 
     */
    UI_RADIO_CLASS.setChecked = function (checked) {
        if (this.isChecked() != checked) {
            if (checked) {
                for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
                    UI_RADIO_FLUSH(o, o == this);
                }
            }
            else {
                UI_RADIO_FLUSH(this, false);
            }
        }
    };

    /**
     * override
     */
    UI_RADIO_CLASS.setDefaultValue = function () {
        this._bDefault = this.isChecked();
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Select - 
 SelectElement 

HTML:
<select ecui="type:select" name="sex">
  <option value="male" selected="selected"></option>
  <option value="female"></option>
</select>

<div ecui="type:select;name:sex;value:male">
  <div ecui="value:male"></div>
  <div ecui="value:female"></div>
</div>


_nOptionSize  - 
_cSelected    - 
_uText        - 
_uButton      - 
_uOptions     - 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getText = dom.getText,
        insertAfter = dom.insertAfter,
        insertBefore = dom.insertBefore,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        encodeHTML = string.encodeHTML,
        extend = util.extend,
        getView = util.getView,
        setDefault = util.setDefault,

        $fastCreate = core.$fastCreate,
        getAttributeName = core.getAttributeName,
        getFocused = core.getFocused,
        inheritsControl = core.inherits,
        intercept = core.intercept,
        mask = core.mask,
        restore = core.restore,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_SCROLLBAR = ui.Scrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SELECT
    ///__gzip_original__UI_SELECT_CLASS
    /**
     * 
     * options 
     * browser        
     * optionSize     5
     * optionsElement 
     * @public
     *
     * @param {Object} options 
     */
    var UI_SELECT = ui.Select =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-select',
            function (el, options) {
                var name = el.name || options.name || '',
                    type = this.getType(),

                    id = options.id || 'id_notset',
                    optionsEl = createDom(
                        type + '-options' + this.Options.TYPES,
                        'position:absolute;z-index:65535;display:none'
                    );

                optionsEl.setAttribute('ecui_id', id);
                   
                setDefault(options, 'hidden', true);

                if (el.tagName == 'SELECT') {
                    var i = 0,
                        list = [],
                        elements = el.options,
                        o = el;

                    options.value = el.value;

                    // select
                    el = insertBefore(createDom(el.className, el.style.cssText, 'span'), el);
                    removeDom(o);

                    // select
                    for (; o = elements[i]; ) {
                        // text
                        list[i++] =
                            '<div ' + getAttributeName() + '="value:' + encodeHTML(o.value) + '">' +
                                o.text + '</div>';
                    }
                    optionsEl.innerHTML = list.join('');
                }
                else {
                    moveElements(el, optionsEl);
                }

                el.innerHTML =
                    '<span class="' + type + '-text' + UI_ITEM.TYPES + '"></span><span class="' + type + '-button' +
                        UI_BUTTON.TYPES + '" style="position:absolute"></span><input name="' + name + '" value="' +
                        encodeHTML(options.value || '') + '">';

                el.appendChild(optionsEl);

                return el;
            },
            function (el, options) {
                el = children(el);

                this._uText = $fastCreate(UI_ITEM, el[0], this, {capturable: false});
                this._uButton = $fastCreate(UI_BUTTON, el[1], this, {capturable: false});

                this._uOptions = $fastCreate(
                    this.Options,
                    removeDom(el[3]),
                    this,
                    {hScroll: false, browser: options.browser}
                );

                this.$setBody(this._uOptions.getBody());
                // 
                this._nOptionSize = options.optionSize || 5;

                this.$initItems();
            }
        ),
        UI_SELECT_CLASS = UI_SELECT.prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_SELECT_OPTIONS_CLASS = (UI_SELECT_CLASS.Options = inheritsControl(UI_PANEL)).prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_SELECT_ITEM_CLASS =
            (UI_SELECT_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    this._sValue = options.value === undefined ? getText(el) : '' + options.value;
                }
            )).prototype;
//{else}//
    /**
     * 
     * @private
     *
     * @param {ecui.ui.Select} control 
     */
    function UI_SELECT_FLUSH(control) {
        var options = control._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            el = options.getOuter(),
            pos = getPosition(control.getOuter()),
            selected = control._cSelected,
            optionTop = pos.top + control.getHeight();

        if (!getParent(el)) {
            //  DOM 
            DOCUMENT.body.appendChild(el);
            control.cache(false, true);
            control.$alterItems();
        }

        if (options.isShow()) {
            if (selected) {
                setFocused(selected);
            }
            scrollbar.setValue(scrollbar.getStep() * indexOf(control.getItems(), selected));

            // controloptionHeight
            control = options.getHeight();

            // 
            options.setPosition(
                pos.left,
                optionTop + control <= getView().bottom ? optionTop : pos.top - control
            );
        }
    }

    /**
     * 
     * @private
     *
     * @param {ecui.ui.Select} control 
     * @param {ecui.ui.Select.Item} item 
     */
    function UI_SELECT_CHANGE_SELECTED(control, item) {
        if (item !== control._cSelected) {
            control._uText.setContent(item ? item.getBody().innerHTML : '');
            UI_INPUT_CONTROL_CLASS.setValue.call(control, item ? item._sValue : '');
            control._cSelected = item;
            if (control._uOptions.isShow()) {
                setFocused(item);
            }
        }
    }

    extend(UI_SELECT_CLASS, UI_ITEMS);

    /**
     * 
     * @override
     */
    UI_SELECT_OPTIONS_CLASS.$dispose = function () {
        this.hide();
        UI_PANEL_CLASS.$dispose.call(this);
    };

    /**
     * 
     * @override
     */
    UI_SELECT_OPTIONS_CLASS.$hide = function () {
        UI_PANEL_CLASS.$hide.call(this);
        mask();
        restore();
    };

    /**
     * 
     * @override
     */
    UI_SELECT_ITEM_CLASS.$mouseover = function (event) {
        UI_ITEM_CLASS.$mouseover.call(this, event);
        setFocused(this);
    };

    /**
     * 
     * getValue 
     * @public
     *
     * @return {string} 
     */
    UI_SELECT_ITEM_CLASS.getValue = function () {
        return this._sValue;
    };

    /**
     * 
     * setValue 
     * @public
     *
     * @param {string} value 
     */
    UI_SELECT_ITEM_CLASS.setValue = function (value) {
        var parent = this.getParent();
        this._sValue = value;
        if (parent && this == parent._cSelected) {
            // 
            UI_INPUT_CONTROL_CLASS.setValue.call(parent, value);
        }
    };

    /**
     *  DOM 
     * @override
     */
    UI_SELECT_CLASS.$activate = function (event) {
        if (!(event.getControl() instanceof UI_SCROLLBAR)) {
            UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
            this._uOptions.show();
            // 
            intercept(this);
            mask(0, 65534);
            UI_SELECT_FLUSH(this);
            event.stopPropagation();
        }
    };

    /**
     * 
     *   /
     * @protected
     */
    UI_SELECT_CLASS.$alterItems = function () {
        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            step = this.getBodyHeight(),
            width = this.getWidth(),
            itemLength = this.getItems().length;

        if (getParent(options.getOuter())) {
            // 
            scrollbar.setStep(step);

            // , 
            this.setItemSize(
                width - options.getMinimumWidth() - (itemLength > optionSize ? scrollbar.getWidth() : 0),
                step
            );

            // options
            options.$$mainHeight = itemLength * step + options.$$bodyHeightRevise;
            options.$setSize(width, (MIN(itemLength, optionSize) || 1) * step + options.getMinimumHeight());
        }
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$cache = function (style, cacheSize) {
        (getParent(this._uOptions.getOuter()) ? UI_ITEMS : UI_INPUT_CONTROL_CLASS)
            .$cache.call(this, style, cacheSize);
        this._uText.cache(false, true);
        this._uButton.cache(false, true);
        this._uOptions.cache(false, true);
    };

    /**
     * 
     * @override
     */
    UI_SELECT_CLASS.$intercept = function (event) {
        //__transform__control_o
        this._uOptions.hide();
        for (var control = event.getControl(); control; control = control.getParent()) {
            if (control instanceof this.Item) {
                if (control != this._cSelected) {
                    // 
                    UI_SELECT_CHANGE_SELECTED(this, control);
                    triggerEvent(this, 'change');
                }
                break;
            }
        }
        event.exit();
    };

    /**
     * /ESC
     * @override
     */
    UI_SELECT_CLASS.$keydown = UI_SELECT_CLASS.$keypress = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type](event);

        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            which = event.which,
            list = this.getItems(),
            length = list.length,
            focus = getFocused();

        if (this.isFocused()) {
            // 
            if (which == 40 || which == 38) {
                if (length) {
                    if (options.isShow()) {
                        setFocused(list[which = MIN(MAX(0, indexOf(list, focus) + which - 39), length - 1)]);
                        which -= scrollbar.getValue() / scrollbar.getStep();
                        scrollbar.skip(which < 0 ? which : which >= optionSize ? which - optionSize + 1 : 0);
                    }
                    else {
                        this.setSelectedIndex(MIN(MAX(0, indexOf(list, this._cSelected) + which - 39), length - 1));
                    }
                }
                return false;
            }
            else if (which == 27 || which == 13 && options.isShow()) {
                // ESC
                options.hide();
                if (which == 13) {
                    UI_SELECT_CHANGE_SELECTED(this, focus);
                    //change
                    triggerEvent(this, 'change');
                }
                return false;
            }
        }
    };

    /**
     * 
     * @override
     */
    UI_SELECT_CLASS.$mousewheel = function (event) {
        if (this.isFocused()) {
            var options = this._uOptions,
                list = this.getItems(),
                length = list.length;

            if (options.isShow()) {
                options.$mousewheel(event);
            }
            else {
                //optionsindex
                options = indexOf(list, this._cSelected) + (event.detail > 0 ? 1 : -1)
                this.setSelectedIndex(
                    length ?
                        MIN(MAX(0, options), length - 1) : null
                );
                if (options >= 0 && options < length) {
                    //change
                    triggerEvent(this, 'change');
                }
            }

            event.exit();
        }
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$ready = function () {
        this.setValue(this.getValue());
    };

    /**
     * 
     * @override
     */
    UI_SELECT_CLASS.remove = function (item) {
        if ('number' == typeof item) {
            item = this.getItems()[item];
        }
        if (item == this._cSelected) {
            UI_SELECT_CHANGE_SELECTED(this);
        }
        return UI_ITEMS.remove.call(this, item);
    };

    /**
     * cache
     * @override
     */
    UI_SELECT_CLASS.add = function (item, index, options) {
        item = UI_ITEMS.add.call(this, item, index, options);
        if (getParent(this._uOptions.getOuter())) {
            item.cache(true, true);
        }
        return item;
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$setSize = function (width, height) {
        UI_INPUT_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
        height = this.getBodyHeight();

        // 
        this._uText.$setSize(width = this.getBodyWidth() - height, height);

        // 
        this._uButton.$setSize(height, height);
        this._uButton.setPosition(width, 0);
    };

    /**
     * 
     * @public
     *
     * @return {ecui.ui.Item} 
     */
    UI_SELECT_CLASS.getSelected = function () {
        return this._cSelected || null;
    };

    /**
     * 
     * 
     * @public
     *
     * @param {number} value  1
     */
    UI_SELECT_CLASS.setOptionSize = function (value) {
        this._nOptionSize = value;
        this.$alterItems();
        UI_SELECT_FLUSH(this);
    };

    /**
     * 
     * @public
     *
     * @param {number} index 
     */
    UI_SELECT_CLASS.setSelectedIndex = function (index) {
        UI_SELECT_CHANGE_SELECTED(this, this.getItems()[index]);
    };

    /**
     * 
     * setValue  getValue 
     * @public
     *
     * @param {string} value 
     */
    UI_SELECT_CLASS.setValue = function (value) {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            if (o._sValue == value) {
                UI_SELECT_CHANGE_SELECTED(this, o);
                return;
            }
        }

        // 
        UI_SELECT_CHANGE_SELECTED(this);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
TreeView - 


HTML:
<div ecui="type:tree-view;">
  <!-- label -->
  <label></label>
  <!--  -->
  <div></div>
  <div></div>
  <div>
    <label></label>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
  </div>
</div>


_bCollapsed    - 
_eChildren     - Element
_aChildren     - 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        indexOf = array.indexOf,
        remove = array.remove,
        addClass = dom.addClass,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getStyle = dom.getStyle,
        insertAfter = dom.insertAfter,
        removeClass = dom.removeClass,
        trim = string.trim,
        extend = util.extend,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        getMouseX = core.getMouseX,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_TREE_VIEW
    ///__gzip_original__UI_TREE_VIEW_CLASS
    /**
     * 
     * options 
     * collapsed      
     * expandSelected 
     * @public
     *
     * @param {Object} options 
     */
    var UI_TREE_VIEW = ui.TreeView =
        inheritsControl(
            UI_CONTROL,
            'ui-treeview',
            function (el, options) {
                options.resizable = false;

                var o = first(el);

                // label
                if (o && o.tagName == 'LABEL') {
                    // 
                    for (
                        var i = 0,
                            list = children(el).slice(1),
                            childItems = UI_TREE_VIEW_SETITEMS(this, el.appendChild(createDom()));
                        o = list[i++];
                    ) {
                        childItems.appendChild(o);
                    }

                    addClass(
                        el,
                        options.current = options.primary + (options.collapsed ? '-collapsed' : '-expanded')
                    );

                    if (options.collapsed) {
                        childItems.style.display = 'none';
                    }
                }
            },
            function (el, options) {
                var childTrees = this._aChildren = [];

                this._bCollapsed = options.collapsed || false;
                this._bExpandSelected = options.expandSelected !== false;

                // 
                for (
                    var i = 0,
                        list = children(el.lastChild),
                        o;
                    o = list[i];
                ) {
                    delete options.current;
                    (childTrees[i++] = UI_TREE_VIEW_CREATE_CHILD(o, this, options)).$setParent(this);
                }
            }
        ),
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype;
//{else}//
    /**
     *  Element 
     * @private
     *
     * @param {ecui.ui.TreeView} tree 
     * @param {HTMLElement} items  Element 
     * @return {HTMLElement} items  Element 
     */
    function UI_TREE_VIEW_SETITEMS(tree, items) {
        tree._eChildren = items;
        items.className = tree.getType() + '-children';
        items.style.cssText = '';
        return items;
    }

    /**
     * 
     * @private
     *
     * @param {ecui.ui.TreeView} control 
     */
    function UI_TREE_VIEW_FLUSH(control) {
        control.setClass(
            control.getPrimary() + (control._aChildren.length ? control._bCollapsed ? '-collapsed' : '-expanded' : '')
        );
    }

    /**
     * 
     * @private
     *
     * @param {HTMLElement} el  Element 
     * @param {ecui.ui.TreeView} parent 
     * @param {Object} options  create 
     * @return {ecui.ui.TreeView} 
     */
    function UI_TREE_VIEW_CREATE_CHILD(el, parent, options) {
        el.className = (trim(el.className) || parent.getPrimary()) + parent.constructor.agent.TYPES;
        return $fastCreate(parent.constructor, el, null, extend(extend({}, options), getOptions(el)));
    }

    /**
     * /
     * @private
     *
     * @param {ecui.ui.TreeView} control 
     * @param {boolean} status 
     * @return {boolean} 
     */
    function UI_TREE_VIEW_SET_COLLAPSE(control, status) {
        if (control._eChildren && control._bCollapsed != status) {
            control._eChildren.style.display = (control._bCollapsed = status) ? 'none' : '';
            UI_TREE_VIEW_FLUSH(control);
        }
    }

    /**
     * /
     * @override
     */
    UI_TREE_VIEW_CLASS.$click = function (event) {
        if (event.getControl() == this) {
            UI_CONTROL_CLASS.$click.call(this, event);

            if (getMouseX(this) <= toNumber(getStyle(this.getBody(), 'paddingLeft'))) {
                //  event  name
                this[event = this.isCollapsed() ? 'expand' : 'collapse']();
                triggerEvent(this, event);
            }
            else {
                this.select();
            }
        }
    };

    /**
     * @override
     */
    UI_TREE_VIEW_CLASS.$dispose = function () {
        this._eChildren = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 
     * @override
     */
    UI_TREE_VIEW_CLASS.$hide = function () {
        UI_CONTROL_CLASS.$hide.call(this);

        if (this._eChildren) {
            this._eChildren.style.display = 'none';
        }
    };

    /**
     * 
     * @override
     */
    UI_TREE_VIEW_CLASS.$setParent = function (parent) {
        var root = this.getRoot(),
            o = this.getParent();

        if (this == root._cSelected || this == root) {
            // 
            // 
            if (root._cSelected) {
                root._cSelected.alterClass('-selected');
            }
            root._cSelected = null;
        }
        else {
            remove(o._aChildren, this);
            UI_TREE_VIEW_FLUSH(o);
        }

        UI_CONTROL_CLASS.$setParent.call(this, parent);

        // 
        if (this._eChildren) {
            insertAfter(this._eChildren, this.getOuter());
        }
    };

    /**
     * 
     * @override
     */
    UI_TREE_VIEW_CLASS.$show = function () {
        UI_CONTROL_CLASS.$show.call(this);

        if (this._eChildren && !this._bCollapsed) {
            this._eChildren.style.display = '';
        }
    };

    /**
     * 
     * @public
     *
     * @param {string|ecui.ui.TreeView} item  html /
     * @param {number} index 
     * @param {Object} options 
     * @return {ecui.ui.TreeView} 
     */
    UI_TREE_VIEW_CLASS.add = function (item, index, options) {
        var list = this._aChildren,
            o;

        if (!this._eChildren) {
            UI_TREE_VIEW_SETITEMS(this, createDom());
            insertAfter(this._eChildren, this.getOuter());
            this._eChildren.style.display = this._bCollapsed ? 'none' : '';
        }

        if (o = list[index]) {
            o = o.getOuter();
        }
        else {
            index = list.length;
            o = null;
        }

        if ('string' == typeof item) {
            o = this._eChildren.insertBefore(createDom(), o);
            o.innerHTML = item;
            item = UI_TREE_VIEW_CREATE_CHILD(o, this, options);
        }
        else {
            this._eChildren.insertBefore(item.getOuter(), o);
        }

        //  setParent getRoot 
        item.$setParent(this);
        list.splice(index, 0, item);

        UI_TREE_VIEW_FLUSH(this);

        return item;
    };

    /**
     * 
     * @public
     */
    UI_TREE_VIEW_CLASS.collapse = function () {
        UI_TREE_VIEW_SET_COLLAPSE(this, true);
    };

    /**
     * 
     * @public
     */
    UI_TREE_VIEW_CLASS.expand = function () {
        UI_TREE_VIEW_SET_COLLAPSE(this, false);
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_TREE_VIEW_CLASS.getChildren = function () {
        return this._aChildren.slice();
    };

    /**
     * 
     * @public
     *
     * @return {ecui.ui.TreeView}  null
     */
    UI_TREE_VIEW_CLASS.getFirst = function () {
        return this._aChildren[0] || null;
    };

    /**
     * 
     * @public
     *
     * @return {ecui.ui.TreeView}  null
     */
    UI_TREE_VIEW_CLASS.getLast = function () {
        return this._aChildren[this._aChildren.length - 1] || null;
    };

    /**
     * 
     * @public
     *
     * @return {ecui.ui.TreeView}  null
     */
    UI_TREE_VIEW_CLASS.getNext = function () {
        var parent = this.getParent();
        return parent instanceof UI_TREE_VIEW && parent._aChildren[indexOf(parent._aChildren, this) + 1] || null;
    };

    /**
     * 
     * @public
     *
     * @return {ecui.ui.TreeView}  null
     */
    UI_TREE_VIEW_CLASS.getPrev = function () {
        var parent = this.getParent();
        return parent instanceof UI_TREE_VIEW && parent._aChildren[indexOf(parent._aChildren, this) - 1] || null;
    };

    /**
     * 
     * @public
     *
     * @return {ecui.ui.TreeView} 
     */
    UI_TREE_VIEW_CLASS.getRoot = function () {
        for (
            var o = this, parent;
            // TreeTree
            (parent = o.getParent()) instanceof UI_TREE_VIEW && indexOf(parent._aChildren, o) >= 0;
            o = parent
        ) {}
        return o;
    };

    /**
     * 
     * @public
     *
     * @return {ecui.ui.TreeView} 
     */
    UI_TREE_VIEW_CLASS.getSelected = function () {
        return this.getRoot()._cSelected || null;
    };

    /**
     * @override
     */
    UI_TREE_VIEW_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        for (var i = 0, list = this._aChildren, o; o = list[i++]; ) {
            o.init();
        }
    };

    /**
     * 
     * @public
     *
     * @return {boolean} true false 
     */
    UI_TREE_VIEW_CLASS.isCollapsed = function () {
        return !this._eChildren || this._bCollapsed;
    };

    /**
     * 
     * @public
     */
    UI_TREE_VIEW_CLASS.select = function () {
        var root = this.getRoot();

        if (root._cSelected != this) {
            if (root._cSelected) {
                root._cSelected.alterClass('-selected');
            }
            this.alterClass('+selected');
            root._cSelected = this;
        }

        if (this._bExpandSelected) {
            this.expand();
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
MonthView - 
//()()

HTML:
<div ecui="type:month-view;year:2009;month:11"></div>


_nYear      - 
_nMonth     - (0-11)
_aCells     - 0-6
_oRange     - 
_oCurRange  - setRange_oCurRange  _oRange,
              


_nDay       - 1
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        DATE = Date,

        extend = util.extend,
        indexOf = array.indexOf,
        addClass = dom.addClass,
        getParent = dom.getParent,
        removeClass = dom.removeClass,
        setText = dom.setText,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_MONTH_VIEW
    ///__gzip_original__UI_MONTH_VIEW_CLASS
    /**
     * 
     * options 
     * year    
     * month   (1-12)
     * @public
     *
     * @param {Object} options 
     */
    var UI_MONTH_VIEW = ui.MonthView =
        inheritsControl(
            UI_CONTROL,
            'ui-monthview',
            null,
            function (el, options) {
                var i = 0,
                    type = this.getType(),
                    list = [],
                    o;

                el.style.overflow = 'auto';

                for (; i < 7; ) {
                    list[i] =
                        '<td class="' + type + '-title' + this.Cell.TYPES + (i == 6 ? type + '-title-last' : '') + '">' +
                            UI_MONTH_VIEW.WEEKNAMES[i++] + '</td>';
                }
                list[i] = '</tr></thead><tbody><tr>';
                for (; ++i < 50; ) {
                    list[i] =
                        '<td class="' + type + '-item' + this.Cell.TYPES +  (i % 7 ? '' : type + '-item-last') + '"></td>' +
                            (i % 7 ? '' : '</tr><tr>');
                }

                el.innerHTML =
                    '<table cellspacing="0" cellpadding="0"><thead><tr>' + list.join('') + '</tr></tbody></table>';

                this._aCells = [];
                list = el.getElementsByTagName('TD');
                for (i = 0; o = list[i]; ) {
                    // 
                    this._aCells[i++] = $fastCreate(this.Cell, o, this, {resizable: false});
                }

                this._oRange = options.range || {};
                this._oCurRange = extend({}, this._oRange);

                this.setDate(options.year, options.month);
                this.setDay(options.day);
            }
        ),
        UI_MONTH_VIEW_CLASS = UI_MONTH_VIEW.prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_MONTH_VIEW_CELL_CLASS = (UI_MONTH_VIEW_CLASS.Cell = inheritsControl(UI_CONTROL)).prototype;
//{else}//
    UI_MONTH_VIEW.WEEKNAMES = ['', '', '', '', '', '', ''];

    function UI_MONTH_VIEW_COMPARE(a, b) {
        a = new Date(a.getFullYear(), a.getMonth(), a.getDate());
        b = new Date(b.getFullYear(), b.getMonth(), b.getDate());
        return a >= b;
    }
    
    UI_MONTH_VIEW_CLASS.$setSelected = function (cell) {
        if (this._uCellSel) {
            this._uCellSel.alterClass('-selected');
        }
        if (cell) {
            cell.alterClass('+selected');
            this._uCellSel = cell;
        }
    };

    /**
     * 
     * @override
     */
    UI_MONTH_VIEW_CELL_CLASS.$click = function (event) {
        var parent = this.getParent(),
            index = indexOf(parent._aCells, this);

        if (triggerEvent(
            parent,
            index < 7 ? 'titleclick' : 'dateclick',
            event,
            index < 7 ? [index] : [new DATE(parent._nYear, parent._nMonth, this._nDay)]
        ) !== false) {
            parent.$setSelected(this);
        }
    };

    /**
     * 
     * @public
     *
     * @return {number} (1-12)
     */
    UI_MONTH_VIEW_CLASS.getMonth = function () {
        return this._nMonth + 1;
    };

    /**
     * 
     * @public
     *
     * @return {number} (19xx-20xx)
     */
    UI_MONTH_VIEW_CLASS.getYear = function () {
        return this._nYear;
    };

    /**
     * 
     * 
     * @public
     *
     * @param {number} offsetMonth 
     */
    UI_MONTH_VIEW_CLASS.move = function (offsetMonth) {
        var time = new DATE(this._nYear, this._nMonth + offsetMonth, 1);
        this.setDate(time.getFullYear(), time.getMonth() + 1);
    };

    UI_MONTH_VIEW_CLASS.setDay = function (day) {
        var list = this._aCells, i, o;
        if (!day) {
            this.$setSelected();
            return;
        }
        for (i = 0; o = list[i]; i++) {
            if (!o.isDisabled() && o._nDay == day) {
                this.$setSelected(o);
                break;
            }
        }
    };

    UI_MONTH_VIEW_CLASS.getDay = function () {
        var res;
        if (this._uCellSel) {
            res = this._uCellSel._nDay;
        }
        return res;
    };

    /**
     * 
     * @public
     *
     * @param {number} year (19xx-20xx)
     * @param {number} month (1-12)
     */
    UI_MONTH_VIEW_CLASS.setDate = function (year, month) {
        //__gzip_original__date
        var i = 7,
            today = new DATE(),
            year = year || today.getFullYear(),
            month = month ? month - 1 : today.getMonth(),
            // 
            o = new DATE(year, month, 0),
            day = 1 - o.getDay(),
            lastDayOfLastMonth = o.getDate(),
            // 
            lastDayOfCurrMonth = new DATE(year, month + 1, 0).getDate(),
            rangeBegin = this._oCurRange.begin,
            rangeEnd = this._oCurRange.end, currDate, cellDay;

        if (this._nYear != year || this._nMonth != month) {
            this._nYear = year;
            this._nMonth = month;

            currDate = new DATE(year, month, 1);

            for (; o = this._aCells[i++]; ) {
                if (month = day > 0 && day <= lastDayOfCurrMonth) {
                    currDate.setDate(day);
                    if ((!rangeBegin || rangeBegin <= currDate) 
                        && (!rangeEnd || rangeEnd >= currDate)) {
                        o.enable();
                    }
                    else {
                        o.disable();
                    }
                }
                else {
                    o.disable();
                }

                if (i == 36 || i == 43) {
                    (o.isDisabled() ? addClass : removeClass)(getParent(o.getOuter()), this.getType() + '-extra');
                }
                
                cellDay = month ? day : day > lastDayOfCurrMonth ? day - lastDayOfCurrMonth : lastDayOfLastMonth + day;
                this.setCellHTML && (this.setCellHTML(o, cellDay, day) !== false) || setText(o.getBody(), cellDay);
                o._nDay = day++;
            }
        }
    };

    UI_MONTH_VIEW_CLASS.setRange = function(begin, end, overrideOrg) {
        var o, i, range, 
            currDate = new DATE(this._nYear, this._nMonth, 1), 
            lastDayOfCurrMonth = new DATE(this._nYear, this._nMonth + 1, 0).getDate();

        if(overrideOrg === true) {
            this._oRange.begin = begin;
            this._oRange.end = end;
        }

        if(begin) {
            if(this._oRange.begin) {
                begin = UI_MONTH_VIEW_COMPARE(begin, this._oRange.begin) ? begin : this._oRange.begin;
            }
        } 
        else {
            begin = this._oRange.begin;
        }
        if(end) {
            if(this._oRange.end) {
                end = UI_MONTH_VIEW_COMPARE(this._oRange.end, end) ? end : this._oRange.end;
            }
        } 
        else {
            end = this._oRange.end;
        }

        for( i = 0; o = this._aCells[i ++]; ) {
            if(o._nDay > 0 && o._nDay <= lastDayOfCurrMonth) {
                currDate.setDate(o._nDay);
                if(( !begin || UI_MONTH_VIEW_COMPARE(currDate, begin)) 
                && ( !end || UI_MONTH_VIEW_COMPARE(end, currDate))) {
                    o.enable();
                } else {
                    o.disable();
                }
            }
        }

        this._oCurRange.begin = begin;
        this._oCurRange.end = end;
    };


//{/if}//
//{if 0}//
})();
//{/if}//

/*
Table - 
 TableElement //

HTML:
<div ecui="type:table">
  <table>
    <!--  -->
    <thead>
      <tr>
        <th style="width:200px;"></th>
        <th style="width:200px;">url</th>
        <th style="width:250px;"></th>
        <th style="width:100px;"></th>
      </tr>
    </thead>
    <!--  -->
    <tbody>
      <tr>
        <td></td>
        <td>www.baidu.com</td>
        <td></td>
        <td>1999</td>
      </tr>
    </tbody>
  </table>
</div>


_aHCells     - 
_aRows       - 
_uHead       - 


$$pos        - 


$$pos        - 
_aElements   - Elementnullfalse
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        REGEXP = RegExp,
        MAX = MATH.max,
        MIN = MATH.min,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getPosition = dom.getPosition,
        getAttribute = dom.getAttribute,
        getParent = dom.getParent,
        insertBefore = dom.insertBefore,
        insertHTML = dom.insertHTML,
        next = dom.next,
        removeDom = dom.remove,
        trim = string.trim,
        extend = util.extend,
        toNumber = util.toNumber,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        disposeControl = core.dispose,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ],

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_SCROLLBAR_CLASS = ui.Scrollbar.prototype,
        UI_VSCROLLBAR = ui.VScrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_TABLE
    ///__gzip_original__UI_TABLE_CLASS
    /**
     * 
     * @public
     *
     * @param {Object} options 
     */
    var UI_TABLE = ui.Table =
        inheritsControl(
            UI_PANEL,
            'ui-table',
            function (el, options) {
                var list, o,
                    type = this.getType();

                options.wheelDelta = 1;
                if (el.tagName == 'TABLE') {
                    var table = el;
                    insertBefore(el = createDom(table.className), table).appendChild(table);
                    if (options.width) {
                        el.style.width = options.width;
                    }
                    if (options.height) {
                        el.style.height = options.height;
                    }
                    table.className = '';
                }

                o = el.getElementsByTagName('TABLE')[0];
                list = children(o);

                o.setAttribute('cellSpacing', '0');

                if (list[0].tagName != 'THEAD') {
                    insertBefore(createDom('', '', 'thead'), list[0])
                        .appendChild(children(list[0])[0]);
                }
                
                return el;
            },
            function (el, options) {
                var i = 0,
                    type = this.getType(),
                    rows = this._aRows = [],
                    cols = this._aHCells = [],
                    colspans = [],
                    o = el.getElementsByTagName('TABLE')[0],
                    list = children(o),
                    j = list[0],
                    headRowCount = 1;

                o = children(list[0]);
                headRowCount = o.length;
                list = o.concat(children(list[1]));

                // 
                if (o = this.$getSection('VScrollbar')) {
                    o.setValue = UI_TABLE_SCROLL_SETVALUE;
                }
                if (o = this.$getSection('HScrollbar')) {
                    o.setValue = UI_TABLE_SCROLL_SETVALUE;
                }

                // 
                o = createDom(type + '-head' + UI_CONTROL.TYPES, 'position:absolute;top:0px;overflow:hidden');
                o.innerHTML =
                    '<div style="white-space:nowrap;position:absolute"><table cellspacing="0"><tbody>' +
                        '</tbody></table></div>';
                (this._uHead = $fastCreate(UI_CONTROL, this.getMain().appendChild(o), this)).$setBody(j);

                // 
                for (; o = list[i]; i++) {
                    o.className = trim(o.className) + this.Row.TYPES;
                    // list[i] 
                    list[i] = first(o);
                    colspans[i] = 1;
                    (rows[i] = $fastCreate(this.Row, o, this))._aElements = [];
                }

                for (j = 0; ; j++) {
                    for (i = 0; o = rows[i]; i++) {
                        if (colspans[i]-- > 1) {
                            continue;
                        }
                        if (el = list[i]) {
                            if (o._aElements[j] === undefined) {
                                o._aElements[j] = el;
                                // list[i]
                                list[i] = next(el);

                                var rowspan = +getAttribute(el, 'rowSpan') || 1,
                                    colspan = colspans[i] = +getAttribute(el, 'colSpan') || 1;

                                while (rowspan--) {
                                    if (!rowspan) {
                                        colspan--;
                                    }
                                    for (o = colspan; o--; ) {
                                        rows[i + rowspan]._aElements.push(rowspan ? false : null);
                                    }
                                }
                            }
                        }
                        //
                        else if (o._aElements[j] === false) {
                            continue;
                        }
                        else {
                            // list[i]
                            for (j = 0; ; j++) {
                                //  type 
                                type = {};
                                for (i = 0; o = rows[i]; i++) {
                                    el = o._aElements[j];
                                    if (el === undefined) {
                                        this._aHeadRows = this._aRows.splice(0, headRowCount);
                                        return;
                                    }
                                    else if (el) {
                                        if (i < headRowCount) {
                                            extend(type, getOptions(el));
                                            el.className = trim(el.className) + this.HCell.TYPES;
                                            cols[j] = $fastCreate(this.HCell, el, this, { colIndex: j });
                                            cols[j]._oOptions = extend({}, type); //options
                                        }
                                        else {
                                            el.className =
                                                (trim(el.className) || type.primary || '') + this.Cell.TYPES;
                                            el.getControl = UI_TABLE_GETCONTROL();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        ),
        UI_TABLE_CLASS = UI_TABLE.prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_TABLE_ROW_CLASS = (UI_TABLE_CLASS.Row = inheritsControl(UI_CONTROL, 'ui-table-row')).prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_TABLE_HCELL_CLASS = (UI_TABLE_CLASS.HCell = inheritsControl(
            UI_CONTROL, 
            'ui-table-hcell',
            function (el, options) {
                this.$$colIndex = options.colIndex;
            }
        )).prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_TABLE_CELL_CLASS = (UI_TABLE_CLASS.Cell = inheritsControl(
            UI_CONTROL,
            'ui-table-cell',
            function (el, options) {
                // 
                options.resizable = false;
                this.$$colIndex = options.colIndex;
            }
        )).prototype,

        /**
         * 
         *  getControl 
         * @private
         *
         * @return {Function} 
         */
        UI_TABLE_GETCONTROL = ieVersion == 8 ? function (colIndex) {
            // getControlreflow
            var control;
            return function () {
                return (control = control || UI_TABLE_CREATE_CELL(this, colIndex));
            };
        } : function () {
            return UI_TABLE_INIT_CELL;
        };
//{else}//
    /**
     * 
     * @private
     *
     * @return {ecui.ui.Table.Cell} 
     */
    function UI_TABLE_INIT_CELL(colIndex) {
        this.getControl = null;
        return UI_TABLE_CREATE_CELL(this, colIndex);
    }

    /**
     * 
     * @private
     *
     * @param {HTMLElement} main 
     * @return {ecui.ui.Table.Cell} 
     */
    function UI_TABLE_CREATE_CELL(main, colIndex) {
        // 
        var row = getParent(main).getControl(),
            table = row.getParent();

        return $fastCreate(
            table.Cell,
            main,
            row,
            extend(
                {colIndex: colIndex}, 
                table._aHCells[indexOf(row._aElements, main)]._oOptions
            )
        );
    }

    /**
     * 
     * @private
     *
     * @param {ecui.ui.Table.Row} row 
     */
    function UI_TABLE_INIT_ROW(row) {
        for (var i = 0, list = row.getParent()._aHCells, el, o; o = list[i]; ) {
            if ((el = row._aElements[i++]) && el != o.getMain()) {
                o = o.getWidth() - o.getMinimumWidth();
                while (row._aElements[i] === null) {
                    o += list[i++].getWidth();
                }
                el.style.width = o + 'px';
            }
        }
    }

    /**
     * 
     * 
     * @private
     *
     * @param {number} value 
     */
    function UI_TABLE_SCROLL_SETVALUE(value) {
        //__gzip_original__length
        var i = 1,
            list = this.getParent()[this instanceof UI_VSCROLLBAR ? '_aRows' : '_aHCells'],
            length = list.length,
            oldValue = this.getValue();

        value = MIN(MAX(0, value), this.getTotal());

        if (value == oldValue) {
            return;
        }

        if (value > oldValue) {
            if (length == 1) {
                UI_SCROLLBAR_CLASS.setValue.call(this, this.getTotal());
                return;
            }
            for (; ; i++) {
                // 
                if (value <= list[i].$$pos) {
                    if (oldValue < list[i - 1].$$pos) {
                        i--;
                    }
                    break;
                }
            }
        }
        else {
            for (i = length; i--; ) {
                // 
                if (value >= list[i].$$pos) {
                    if (i < length - 1 && oldValue > list[i + 1].$$pos) {
                        i++;
                    }
                    break;
                }
            }
        }

        UI_SCROLLBAR_CLASS.setValue.call(this, list[i].$$pos);
    }

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$dispose = function () {
        this._aElements = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 
     * $getElement  false/null 
     * @protected
     *
     * @return {Array} 
     */
    UI_TABLE_ROW_CLASS.$getElements = function () {
        return this._aElements.slice();
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$hide = function () {
        var i = 0,
            table = this.getParent(),
            index = indexOf(table._aRows, this),
            nextRow = table._aRows[index + 1],
            j,
            cell,
            o;

        for (; table._aHCells[i]; i++) {
            o = this._aElements[i];
            if (o === false) {
                o = table.$getElement(index - 1, i);
                // cell == o
                if (cell != o) {
                    o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') - 1);
                    cell = o;
                }
            }
            else if (o && (j = +getAttribute(o, 'rowSpan')) > 1) {
                // rowSpan
                o.setAttribute('rowSpan', j - 1);
                for (j = i + 1; ; ) {
                    cell = nextRow._aElements[j++];
                    if (cell || cell === undefined) {
                        break;
                    }
                }

                o.getControl().$setParent(nextRow);
                nextRow.getBody().insertBefore(o, cell || null);
            }
        }

        UI_CONTROL_CLASS.$hide.call(this);
        table.repaint();
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$show = function () {
        var i = 0,
            table = this.getParent(),
            index = indexOf(table._aRows, this),
            nextRow = table._aRows[index + 1],
            j,
            cell,
            o;

        for (; table._aHCells[i]; i++) {
            o = this._aElements[i];
            if (o === false) {
                o = table.$getElement(index - 1, i);
                // cell == o
                if (cell != o) {
                    o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') + 1);
                    cell = o;
                }
            }
            else if (o && nextRow && nextRow._aElements[i] === false) {
                // rowSpan
                o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') + 1);
                for (j = i + 1; ; ) {
                    cell = this._aElements[j++];
                    if (cell || cell === undefined) {
                        break;
                    }
                }

                o.getControl().$setParent(this);
                this.getBody().insertBefore(o, cell || null);
            }
        }

        UI_CONTROL_CLASS.$show.call(this);
        table.resize();
    };

    /**
     * 
     * @public
     *
     * @param {number} colIndex 0
     * @return {ecui.ui.Table.Cell} 
     */
    UI_TABLE_ROW_CLASS.getCell = function (colIndex) {
        return this._aElements[colIndex] ? this._aElements[colIndex].getControl(colIndex) : null;
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_TABLE_ROW_CLASS.getCells = function () {
        for (var i = this._aElements.length, result = []; i--; ) {
            result[i] = this.getCell(i);
        }
        return result;
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        // 
        // if (ieVersion < 8) {
            // for fakeDom...
            // for (var i = 0, c; c = this.getCell(i); i ++) {
                // c.cache(style, cacheSize);
            // }
        // }
    };    

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.setSize = function (width, height) {
        for (var i = this._aElements.length, oldHeight = this.getHeight(); i--; ) {
            if (this._aElements[i]) {
                this._aElements[i].getControl().$setSize(null, height);
            }
        }
        this.getParent()[height > oldHeight ? 'resize' : 'repaint']();
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.$hide = function () {
        this.$setStyles('display', 'none', -this.getWidth());
    };

    /**
     * 
     * $setStyles 
     * @protected
     *
     * @param {string} name 
     * @param {string} value 
     * @param {number} widthRevise 
     */
    UI_TABLE_HCELL_CLASS.$setStyles = function (name, value, widthRevise) {
        //__gzip_original__cols
        var i = 0,
            table = this.getParent(),
            rows = table._aHeadRows.concat(table._aRows),
            body = this.getBody(),
            cols = table._aHCells,
            index = indexOf(cols, this),
            o = getParent(getParent(getParent(body))).style,
            j;

        body.style[name] = value;
        if (widthRevise) {
            o.width = first(table.getBody()).style.width = toNumber(o.width) + widthRevise + 'px';
        }

        for (; o = rows[i++]; ) {
            //  body 
            body = o._aElements;
            o = body[index];
            if (o) {
                o.style[name] = value;
            }
            if (widthRevise && o !== false) {
                for (j = index; !(o = body[j]); j--) {}

                var width = -cols[j].getMinimumWidth(),
                    colspan = 0;

                do {
                    if (!cols[j].getOuter().style.display) {
                        width += cols[j].getWidth();
                        colspan++;
                    }
                }
                while (body[++j] === null);

                if (width > 0) {
                    o.style.display = '';
                    o.style.width = width + 'px';
                    o.setAttribute('colSpan', colspan);
                }
                else {
                    o.style.display = 'none';
                }
            }
        }
        if (widthRevise > 0) {
            table.resize();
        }
        else {
            table.repaint();
        }
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.$show = function () {
        this.$setStyles('display', '', this.getWidth());
    };

    /**
     * 
     * @public
     *
     * @param {number} rowIndex 0
     * @return {ecui.ui.Table.Cell} 
     */
    UI_TABLE_HCELL_CLASS.getCell = function (rowIndex) {
        return this.getParent().getCell(rowIndex, indexOf(this._aHCells, this));
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_TABLE_HCELL_CLASS.getCells = function () {
        for (var i = 0, index = indexOf(this.getParent()._aHCells, this), o, result = []; o = this.getParent()._aRows[i]; ) {
            result[i++] = o.getCell(index);
        }
        return result;
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        this.getParent().$cacheByFakeColMaxWidth(this);
    };    

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.setSize = function (width) {
        var oldWidth = this.getWidth();
        // 
        this.$setSize(width);
        this.$setStyles('width', width - this.$getBasicWidth() + 'px', width - oldWidth);
    };

    /**
     * @override
     */
    UI_TABLE_CELL_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        this.getParent().getParent().$cacheByFakeColMaxWidth(this);    
    };    

    /**
     * @override
     */
    UI_TABLE_CELL_CLASS.getHeight = function () {
        return this.getOuter().offsetHeight;
    };

    /**
     * @override
     */
    UI_TABLE_CELL_CLASS.getWidth = function () {
        return this.getOuter().offsetWidth;
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$cache = function (style, cacheSize) {
        UI_PANEL_CLASS.$cache.call(this, style, cacheSize);

        this._uHead.cache(false, true);

        //  style  o
        this.$$paddingTop = this._uHead.getBody().offsetHeight;

        for (var i = 0, pos = 0; style = this._aRows[i++]; ) {
            style.$$pos = pos;
            style.cache(true, true);
            if (!style.getOuter().style.display) {
                pos += style.getHeight();
            }
        }
        for (i = 0, pos = 0; style = this._aHCells[i++]; ) {
            style.$$pos = pos;
            style.cache(true, true);
            if (!style.getOuter().style.display) {
                pos += style.getWidth();
            }
        }
        this.$$mainWidth = pos;

        // for (i = 0, pos = 0; style = this._aHCells[i++]; ) {
            // style.getOuter().width = style.$$width + 'px';
        // }
        // 
        // UI_PANEL_CLASS.$cache.call(this, style, cacheSize);
        // this._uHead.cache(false, true);        
    };

    /**
     * 
     * $getElement  Element  Element 
     * @protected
     *
     * @param {number} rowIndex 0
     * @param {number} colIndex 0
     * @return {HTMLElement} 
     */
    UI_TABLE_CLASS.$getElement = function (rowIndex, colIndex) {
        //__gzip_original__rows
        var rows = this._aRows,
            cols = rows[rowIndex] && rows[rowIndex]._aElements,
            col = cols && cols[colIndex];

        if (col === undefined) {
            col = null;
        }
        else if (!col) {
            for (; col === false; col = (cols = rows[--rowIndex]._aElements)[colIndex]) {}
            for (; !col; col = cols[--colIndex]) {}
        }
        return col;
    };

    /**
     * 
     * @protected
     */
    UI_TABLE_CLASS.$pagescroll = function () {
        UI_PANEL_CLASS.$pagescroll.call(this);
        if (!this._uVScrollbar) {
            this._uHead.getOuter().style.top =
                MAX(getView().top - getPosition(this.getOuter()).top, 0) + 'px';
        }
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$scroll = function () {
        UI_PANEL_CLASS.$scroll.call(this);
        this._uHead.getMain().lastChild.style.left = this.getBody().style.left;
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$setSize = function (width, height) {
        var body = this.getBody(),
            vscroll = this.$getSection('VScrollbar'),
            hscroll = this.$getSection('HScrollbar'),
            mainWidth = this.$$mainWidth,
            mainHeight = this.$$mainHeight,
            vsWidth = vscroll && vscroll.getWidth(),
            hsHeight = hscroll && hscroll.getHeight(),
            basicWidth = this.$getBasicWidth(),
            basicHeight = this.$getBasicHeight(),
            mainWidthRevise = mainWidth + basicWidth,
            mainHeightRevise = mainHeight + basicHeight,
            bodyWidth = width - basicWidth,
            bodyHeight = height - basicHeight,
            o;

        this.getMain().style.paddingTop = this.$$paddingTop + 'px';
        first(body).style.width = this._uHead.getMain().lastChild.lastChild.style.width = mainWidth + 'px';

        // 
        if (mainWidth <= bodyWidth && mainHeight <= bodyHeight) {
            width = mainWidthRevise;
            height = mainHeightRevise;
        }
        else if (!(vscroll && hscroll &&
            mainWidth > bodyWidth - vsWidth && mainHeight > bodyHeight - hsHeight)
        ) {
            o = mainWidthRevise + (!vscroll || bodyHeight >= mainHeight ? 0 : vsWidth);
            width = hscroll ? MIN(width, o) : o;
            o = mainHeightRevise + (!hscroll || bodyWidth >= mainWidth ? 0 : hsHeight);
            height = vscroll ? MIN(height, o) : o;
        }

        UI_PANEL_CLASS.$setSize.call(this, width, height);

        this._uHead.$setSize(toNumber(getParent(body).style.width) + this._uHead.$getBasicWidth(), this.$$paddingTop);
    };

    /**
     * 
     * options 
     * width   {number} 
     * primary {string} 
     * title   {string} 
     * @public
     *
     * @param {Object} options 
     * @param {number} index 
     * @return {ecui.ui.Table.HCell} 
     */
    UI_TABLE_CLASS.addColumn = function (options, index) {
        var i = 0,
            headRowCount = this._aHeadRows.length,
            rows = this._aHeadRows.concat(this._aRows),
            primary = options.primary || '',
            el = createDom(primary + this.HCell.TYPES, '', 'td'),
            col = $fastCreate(this.HCell, el, this),
            row,
            o;

        el.innerHTML = options.title || '';

        primary += this.Cell.TYPES;
        for (; row = rows[i]; i++) {
            o = row._aElements[index];
            if (o !== null) {
                // 
                for (j = index; !o; ) {
                    o = row._aElements[++j];
                    if (o === undefined) {
                        break;
                    }
                }
                if (i < headRowCount) {
                    row._aElements.splice(index, 0, row.getBody().insertBefore(el, o));
                    el.setAttribute('rowSpan', headRowCount - i);
                    this._aHCells.splice(index, 0, col);
                    i = headRowCount - 1;
                }
                else {
                    row._aElements.splice(index, 0, o = row.getBody().insertBefore(createDom(primary, '', 'td'), o));
                    o.getControl = UI_TABLE_GETCONTROL();
                }
            }
            else {
                // colspan
                var cell = this.$getElement(i - headRowCount, index),
                    j = +getAttribute(cell, 'rowspan') || 1;

                cell.setAttribute('colSpan', +getAttribute(cell, 'colSpan') + 1);
                row._aElements.splice(index, 0, o);
                for (; --j; ) {
                    rows[++i]._aElements.splice(index, 0, false);
                }
            }
        }

        col.cache();
        col.$setSize(options.width);
        col.$setStyles('width', el.style.width, options.width);
        col._oOptions = extend({}, options);

        return col;
    };

    /**
     * 
     * @public
     *
     * @param {Array} data ()
     * @param {number} index 
     * @return {ecui.ui.Table.Row} 
     */
    UI_TABLE_CLASS.addRow = function (data, index) {
        var i = 0,
            j = 1,
            body = this.getBody().lastChild.lastChild,
            el = createDom(),
            html = ['<table><tbody><tr class="' + this.Row.TYPES + '">'],
            rowCols = [],
            row = this._aRows[index],
            col;

        if (!row) {
            index = this._aRows.length;
        }

        for (; col = this._aHCells[i]; ) {
            if (row && row._aElements[i] === false || data[i] === false) {
                rowCols[i++] = false;
            }
            else {
                // colspan/width 
                rowCols[i] = true;
                html[j++] = '<td class="' + this.Cell.TYPES + '" style="';
                for (
                    var o = i,
                        colspan = col.isShow() ? 1 : 0,
                        width = col.getWidth() - col.getMinimumWidth();
                    (col = this._aHCells[++i]) && data[i] === null;
                ) {
                    rowCols[i] = null;
                    if (col.isShow()) {
                        colspan++;
                        width += col.getWidth();
                    }
                }
                rowCols[o] = true;
                html[j++] = (colspan ? 'width:' + width + 'px" colSpan="' + colspan : 'display:none') + '">' +
                    (data[o] || '') + '</td>';
            }
        }

        html[j] = '</tr></tbody></table>';
        el.innerHTML = html.join('');
        el = el.lastChild.lastChild.lastChild;

        body.insertBefore(el, row ? row.getOuter() : null);
        row = $fastCreate(this.Row, el, this);
        this._aRows.splice(index--, 0, row);

        //  col rowspan++
        for (i = 0, el = el.firstChild, col = null; this._aHCells[i]; i++) {
            if (o = rowCols[i]) {
                rowCols[i] = el;
                el.getControl = UI_TABLE_GETCONTROL();
                el = el.nextSibling;
            }
            else if (o === false) {
                o = this.$getElement(index, i);
                if (o != col) {
                    o.setAttribute('rowSpan', (+getAttribute(o, 'rowSpan') || 1) + 1);
                    col = o;
                }
            }
        }

        row._aElements = rowCols;
        this.resize();
        return row;
    };

    /**
     * 
     * @public
     *
     * @param {number} rowIndex 0
     * @param {number} colIndex 0
     * @return {ecui.ui.Table.Cell} 
     */
    UI_TABLE_CLASS.getCell = function (rowIndex, colIndex) {
        rowIndex = this._aRows[rowIndex];
        return rowIndex && rowIndex.getCell(colIndex) || null;
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    UI_TABLE_CLASS.getColumnCount = function () {
        return this._aHCells.length;
    };

    /**
     * 
     *  hidesetSize()  show 
     * @public
     *
     * @param {number} index 0
     * @return {ecui.ui.Table.HCell} 
     */
    UI_TABLE_CLASS.getHCell = function (index) {
        return this._aHCells[index] || null;
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_TABLE_CLASS.getHCells = function () {
        return this._aHCells.slice();
    };

    /**
     * 
     * @public
     *
     * @param {number} index 0
     * @return {ecui.ui.Table.Row} 
     */
    UI_TABLE_CLASS.getRow = function (index) {
        return this._aRows[index] || null;
    };

    /**
     * 
     * @public
     *
     * @return {number} 
     */
    UI_TABLE_CLASS.getRowCount = function () {
        return this._aRows.length;
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_TABLE_CLASS.getRows = function () {
        return this._aRows.slice();
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.init = function () {
        insertBefore(this._uHead.getBody(), this._uHead.getMain().lastChild.lastChild.firstChild);
        this.$$mainHeight -= this.$$paddingTop;

        UI_PANEL_CLASS.init.call(this);

        for (var i = 0, o; o = this._aHCells[i++]; ) {
            o.$setSize(o.getWidth());
        }
        for (i = 0; o = this._aHeadRows[i++]; ) {
            UI_TABLE_INIT_ROW(o);
        }
        for (i = 0; o = this._aRows[i++]; ) {
            UI_TABLE_INIT_ROW(o);
        }
    };

    /**
     * 
     * @public
     *
     * @param {number} index 0
     */
    UI_TABLE_CLASS.removeColumn = function (index) {
        var i = 0,
            cols = this._aHCells,
            o = cols[index];

        if (o) {
            o.hide();

            removeDom(o.getOuter());
            disposeControl(o);
            cols.splice(index, 1);

            for (; o = this._aRows[i++]; ) {
                cols = o._aElements;
                if (o = cols[index]) {
                    if (cols[index + 1] === null) {
                        // 
                        cols.splice(index + 1, 1);
                        continue;
                    }
                    removeDom(o);
                    if (o.getControl != UI_TABLE_GETCONTROL()) {
                        disposeControl(o.getControl());
                    }
                }
                cols.splice(index, 1);
            }
        }
    };

    /**
     * 
     * @public
     *
     * @param {number} index 0
     */
    UI_TABLE_CLASS.removeRow = function (index) {
        var i = 0,
            row = this._aRows[index],
            rowNext = this._aRows[index + 1],
            body = row.getBody(),
            o;

        if (row) {
            row.hide();
            for (; this._aHCells[i]; i++) {
                if (o = row._aElements[i]) {
                    if (getParent(o) != body) {
                        rowNext._aElements[i] = o;
                        for (; row._aElements[++i] === null; ) {
                            rowNext._aElements[i] = null;
                        }
                        i--;
                    }
                }
            }

            removeDom(row.getOuter());
            disposeControl(row);
            this._aRows.splice(index, 1);

            this.repaint();
        }
    };

    /**
     * @private
     *
     * hack
     * 
     * ie67
     * 
     * 
     * fakedom
     */    
    UI_TABLE_CLASS.$getFakeDom = function () {
        var me = this;

        var fakeDom = this.$$fakeDom;
        var style;
        if (!fakeDom) {
            fakeDom = this.$$fakeDom = document.createElement('div');
            style = fakeDom.style;
            style.position = 'absolute';
            style.top = '0';
            style.left = '-10000px';
            style.visibility = 'hidden';
            document.body.appendChild(fakeDom);
        }

        // 
        if (!this.$$remover) {
            this.$$remover = setTimeout(function () {
                document.body.removeChild(fakeDom);
                fakeDom = me.$$fakeDom = style = me.$$remover = null;
            }, 0);
        }
        return fakeDom;
    };

    /**
     *  $getFakeDom
     *
     * @private     
     * @param {Object} cell cachecell
     */    
    UI_TABLE_CLASS.$cacheByFakeColMaxWidth = function (cell) {
        if (ieVersion < 8) {

            var map = this.$$fakeColMaxWidthMap;
            if (!map) {
                map = this.$$fakeColMaxWidthMap = {};
            }
            var colIndex = cell.$$colIndex;

            var fakeDom = this.$getFakeDom();
            fakeDom.innerHTML = cell.getOuter().innerHTML;

            var width = fakeDom.offsetWidth 
                + (core.isContentBox() ? cell.$getBasicWidth() : 0); 

            var maxWidth;
            if (!isFakeColIgnoreCell(cell)) { 
                // cell
                maxWidth = map[colIndex];
                if (!maxWidth || width > maxWidth) {
                    map[colIndex] = maxWidth = width;
                }
            }
            else {
                maxWidth = width;
            }

            // cell$$width
            if (!isFakeColIgnoreCell(cell)) {
                for (var i = 0, row; row = this._aRows[i]; i ++) {
                    var c = row.getCell(colIndex);
                    if (c && !isFakeColIgnoreCell(c)) {
                        c.$$width = maxWidth;
                    }                
                }
                for (var i = 0, row; row = this._aHeadRows[i]; i ++) {
                    var c = row.getCell(colIndex);
                    if (c && !isFakeColIgnoreCell(c)) {
                       c.$$width = maxWidth;
                    }
                }
            }
        }
    };

    function isFakeColIgnoreCell(cell) {
        var colspan = cell.__$$colspan; // 
        if (colspan == null) {
            colspan = cell.__$$colspan = cell._eMain.getAttribute('colspan');
        }
        return colspan > 1;
    }

    // 
    (function () {
        function build(name) {
            var type = name.replace('mouse', '');

            name = '$' + name;

            UI_TABLE_ROW_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                triggerEvent(this.getParent(), 'row' + type, event);
            };

            UI_TABLE_CELL_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                triggerEvent(this.getParent().getParent(), 'cell' + type, event);
            };
        }

        for (var i = 0; i < 7; ) {
            build(eventNames[i++]);
        }
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Tab - 



<div ecui="type:tab;selected:1">
    <!--  -->
    <div>
        <label>1</label>
        <!--  -->
        ...
    </div>
    <!-- selected -->
    <label ecui="selected:true">2</label>
</div>


_bButton         - 
_oSelected       - 
_aPosition       - 
_cSelected       - 
_uPrev           - 
_uNext           - 
$$titleWidth     - 

Item
_sContainer      -  DOM 
_eContainer      -  DOM 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        createDom = dom.create,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        first = dom.first,
        setStyle = dom.setStyle,
        extend = util.extend,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * options 
     * selected 0
     * @protected
     *
     * @param {Object} options 
     */
    ///__gzip_original__UI_TAB
    ///__gzip_original__UI_TAB_BUTTON
    ///__gzip_original__UI_TAB_ITEM
    var UI_TAB = ui.Tab =
        inheritsControl(
            UI_CONTROL,
            'ui-tab',
            null,
            function (el, options) {
                //__gzip_original__buttonParams
                var type = this.getType(),
                    o = createDom(type + '-title', 'position:relative;overflow:hidden');

                this._oSelected = options.selected || 0;

                // DOM
                o.innerHTML = '<div class="' + type + '-prev' + this.Button.TYPES +
                    '" style="position:absolute;display:none;left:0px"></div><div class="' +
                    type + '-next' + this.Button.TYPES +
                    '" style="position:absolute;display:none"></div><div class="' +
                    type + '-items" style="position:absolute;white-space:nowrap"></div>';

                moveElements(el, options = o.lastChild);
                el.appendChild(o);
                this.$setBody(options);

                this.$initItems();

                // 
                this._uNext = $fastCreate(this.Button, options = options.previousSibling, this);
                this._uPrev = $fastCreate(this.Button, options.previousSibling, this);
            }
        ),
        UI_TAB_CLASS = UI_TAB.prototype,

        /**
         * 
         * @protected
         *
         * @param {Object} options 
         */
        UI_TAB_BUTTON_CLASS = (UI_TAB_CLASS.Button = inheritsControl(UI_BUTTON, 'ui-tab-button')).prototype,

        /**
         * 
         * options 
         * selected 
         * @protected
         *
         * @param {Object} options 
         */
        UI_TAB_ITEM_CLASS =
            (UI_TAB_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    //__gzip_original__parent
                    var parent = options.parent;

                    if (el.tagName != 'LABEL') {
                        var o = first(el),
                            tmpEl;

                        moveElements(el, tmpEl = createDom(options.primary + '-container'), true);
                        el.appendChild(o);
                        this.setContainer(tmpEl);
                    }

                    setStyle(el, 'display', 'inline-block');

                    if (parent && options.selected) {
                        parent._oSelected = this;
                    }
                }
            )).prototype;
//{else}//
    /**
     * 
     * @private
     *
     * @param {ecui.ui.Tab} control Tab 
     */
    function UI_TAB_FLUSH_BUTTON(control) {
        var left = toNumber(control.getBody().style.left);

        control._uPrev[left < control._uPrev.getWidth() ? 'enable' : 'disable']();
        control._uNext[
            left > control.getBodyWidth() - control.$$titleWidth - control._uNext.getWidth() ? 'enable' : 'disable'
        ]();
    }

    extend(UI_TAB_CLASS, UI_ITEMS);

    /**
     * @override
     */
    UI_TAB_BUTTON_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);

        //__gzip_original__pos
        var parent = this.getParent(),
            style = parent.getBody().style,
            pos = parent._aPosition,
            index = parent.$getLeftMostIndex();

        index = MIN(
            MAX(0, index + (parent._uPrev == this ? toNumber(style.left) != pos[index] ? 0 : -1 : 1)),
            pos.length - 1
        );

        style.left = MAX(pos[index], parent.getBodyWidth() - parent.$$titleWidth - parent._uNext.getWidth()) + 'px';
        UI_TAB_FLUSH_BUTTON(parent);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$cache = function (style, cacheSize) {
        UI_ITEM_CLASS.$cache.call(this, style, cacheSize);

        this.$$marginLeft = toNumber(style.marginLeft);
        this.$$marginRight = toNumber(style.marginRight);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$click = function (event) {
        UI_ITEM_CLASS.$click.call(this, event);
        this.getParent().setSelected(this);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$dispose = function () {
        this._eContainer = null;
        UI_ITEM_CLASS.$dispose.call(this);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$setParent = function (parent) {
        //__gzip_original__el
        var el = this._eContainer;

        UI_ITEM_CLASS.$setParent.call(this, parent);
        if (el) {
            if (parent) {
                parent.getMain().appendChild(el);
            }
            else {
                removeDom(el);
            }
        }
    };

    /**
     * 
     * @public
     *
     * @return {HTMLElement} 
     */
    UI_TAB_ITEM_CLASS.getContainer = function () {
        return this._eContainer;
    };

    /**
     * 
     * @public
     *
     * @param {HTMLElement} el 
     */
    UI_TAB_ITEM_CLASS.setContainer = function (el) {
        var parent = this.getParent();

        if (this._eContainer) {
            removeDom(this._eContainer);
        }
        if (this._eContainer = el) {
            if ((this._sContainer = el.style.display) == 'none') {
                this._sContainer = '';
            }

            if (parent) {
                parent.getMain().appendChild(el);

                // 
                el.style.display = parent._cSelected == this ? this._sContainer : 'none';
            }
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$alterItems = function () {
        // $setSize
        if (this._aPosition) {
            this.$setSize(this.getWidth());
        }

        for (
            var i = 0,
                list = this.getItems(),
                pos = this._aPosition = [this._uPrev.getWidth()],
                lastItem = {$$marginRight: 0},
                o;
            o = list[i++];
            lastItem = o
        ) {
            pos[i] = pos[i - 1] - MAX(lastItem.$$marginRight, o.$$marginLeft) - o.getWidth();
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$cache = function (style, cacheSize) {
        UI_ITEMS.$cache.call(this, style, cacheSize);

        this._uPrev.cache(true, true);
        this._uNext.cache(true, true);

        this.$$titleWidth = this.getBody().offsetWidth;
    };

    /**
     * 
     * @protected
     *
     * @return {number} 
     */
    UI_TAB_CLASS.$getLeftMostIndex = function () {
        for (var left = toNumber(this.getBody().style.left), pos = this._aPosition, i = pos.length; i--; ) {
            if (left <= pos[i]) {
                return i;
            }
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$remove = function (child) {
        if (this._cSelected == child) {
            var list = this.getItems(),
                index = indexOf(list, child);

            // 
            this.setSelected(index == list.length - 1 ? index - 1 : index + 1);
        }

        UI_ITEMS.$remove.call(this, child);
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);

        //__gzip_original__prev
        //__gzip_original__next
        var prev = this._uPrev,
            next = this._uNext,
            style = this.getBody().style;

        width = this.getBodyWidth();
        if (this.$$titleWidth > width) {
            width -= next.getWidth();
            next.getOuter().style.left = width + 'px';

            if (this._bButton) {
                // 
                width -= this.$$titleWidth;
                if (toNumber(style.left) < width) {
                    style.left = width + 'px';
                }
            }
            else {
                prev.$show();
                next.$show();
                style.left = prev.getWidth() + 'px';
                this._bButton = true;
            }

            UI_TAB_FLUSH_BUTTON(this);
        }
        else if (this._bButton) {
            prev.$hide();
            next.$hide();
            style.left = '0px';
            this._bButton = false;
        }
    };

    /**
     * 
     *
     * @return {ecui.ui.Tab.Item} 
     */
    UI_TAB_CLASS.getSelected = function () {
        return this._cSelected;
    };

    /**
     * @override
     */
    UI_TAB_CLASS.init = function () {
        this._uPrev.init();
        this._uNext.init();
        UI_ITEMS.init.call(this);
        for (var i = 0, list = this.getItems(), o; o = list[i++];) {
            o.$setSize(o.getWidth(), o.getHeight());
        }
        this.setSelected(this._oSelected);
    };

    /**
     * 
     * @public
     *
     * @param {number|ecui.ui.Tab.Item} /
     */
    UI_TAB_CLASS.setSelected = function (item) {
        //__gzip_original__prev
        var i = 0,
            list = this.getItems(),
            prev = this._uPrev,
            style = this.getBody().style,
            left = toNumber(style.left),
            o;

        if ('number' == typeof item) {
            item = list[item];
        }
        if (this._cSelected != item) {
            for (; o = list[i++]; ) {
                if (o._eContainer) {
                    o._eContainer.style.display = o == item ? o._sContainer : 'none';
                }
            }

            if (this._cSelected) {
                this._cSelected.alterClass('-selected');
            }

            if (item) {
                item.alterClass('+selected');
                o = this._aPosition[indexOf(list, item)] - (prev.isShow() ? 0 : prev.getWidth());

                // ()
                if (left < o) {
                    style.left = o + 'px';
                }
                else {
                    o -= item.getWidth() 
                        + (prev.isShow() ? prev.getWidth() : 0) 
                        // + prev.getWidth()
                        + (this._uNext.isShow() ? this._uNext.getWidth() : 0)
                        // + this._uNext.getWidth()
                        - this.getBodyWidth();
                    if (left > o) {
                        style.left = o + 'px';
                    }
                }
                UI_TAB_FLUSH_BUTTON(this);
            }

            this._cSelected = item;
            triggerEvent(this, 'change');
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//
/*
Listbox - 


HTML:
<div ecui="type:listbox;name:test">
    <!--  -->
    <li></li>
    ...
</div>


_sName  - input


_eInput - inputform
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        undefined,

        getText = dom.getText,
        setInput = dom.setInput,
        extend = util.extend,

        inheritsControl = core.inherits,

        UI_PANEL = ui.Panel,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * @public
     *
     * @param {Object} options 
     */
    ///__gzip_original__UI_LISTBOX
    ///__gzip_original__UI_LISTBOX_ITEM
    var UI_LISTBOX = ui.Listbox =
        inheritsControl(
            UI_PANEL,
            'ui-listbox',
            function (el, options) {
                options.hScroll = false;
            },
            function (el, options) {
                this._sName = options.name || '';
                this.$initItems();
            }
        ),
        UI_LISTBOX_CLASS = UI_LISTBOX.prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_LISTBOX_ITEM_CLASS = (UI_LISTBOX_CLASS.Item = inheritsControl(
            UI_ITEM,
            null,
            null,
            function (el, options) {
                el.appendChild(this._eInput = setInput(null, options.parent._sName, 'hidden')).value =
                    options.value === undefined ? getText(el) : options.value;
                this.setSelected(!!options.selected);
            }
        )).prototype;
//{else}//
    extend(UI_LISTBOX_CLASS, UI_ITEMS);

    /**
     * @override
     */
    UI_LISTBOX_ITEM_CLASS.$click = function (event) {
        UI_ITEM_CLASS.$click.call(this, event);
        this.setSelected(!this.isSelected());
    };

    /**
     * @override
     */
    UI_LISTBOX_ITEM_CLASS.$dispose = function () {
        this._eInput = null;
        UI_ITEM_CLASS.$dispose.call(this);
    };

    /**
     * @override
     */
    UI_LISTBOX_ITEM_CLASS.$setParent = function (parent) {
        UI_ITEM_CLASS.$setParent.call(this, parent);

        if (parent instanceof UI_LISTBOX) {
            this._eInput = setInput(this._eInput, parent._sName);
        }
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_LISTBOX_ITEM_CLASS.isSelected = function () {
        return !this._eInput.disabled;
    };

    /**
     * 
     * @public
     *
     * @param {boolean} status 
     */
    UI_LISTBOX_ITEM_CLASS.setSelected = function (status) {
        this.alterClass('selected', this._eInput.disabled = status === false);
    };

    /**
     * @override
     */
    UI_LISTBOX_CLASS.$alterItems = function () {
        //__transform__items_list
        var items = this.getItems(),
            vscroll = this.$getSection('VScrollbar'),
            step = items.length && items[0].getHeight();

        if (step) {
            vscroll.setStep(step);
            this.setItemSize(
                this.getBodyWidth() - (items.length * step > this.getBodyHeight() ? vscroll.getWidth() : 0),
                step
            );
            this.$setSize(0, this.getHeight());
        }
    };

    /**
     * 
     * getName  setName 
     * @public
     *
     * @return {string} 
     */
    UI_LISTBOX_CLASS.getName = function () {
        return this._sName;
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_LISTBOX_CLASS.getSelected = function () {
        for (var i = 0, list = this.getItems(), o, result = []; o = list[i++]; ) {
            if (o.isSelected()) {
                result.push(o);
            }
        }
        return result;
    };

    /**
     * 
     *  onsubmit  selectAll 
     * @public
     */
    UI_LISTBOX_CLASS.selectAll = function () {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            o.setSelected();
        }
    };

    /**
     * 
     * setName  getName 
     * @public
     *
     * @param {string} name 
     */
    UI_LISTBOX_CLASS.setName = function (name) {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            // 
            o._eInput = setInput(o._eInput, name);
        }
        this._sName = name;
    };
//{/if}//
//{if 0}//
})();
//{/if}//
/*
Label - 
 RadioCheckbox 

HTML:
<div ecui="type:label;for:checkbox"></div>


_cFor - 
*/
//{if 0}//
(function () {

    var core = ecui,
        ui = core.ui,
        util = core.util,

        inheritsControl = core.inherits,
        $connect = core.$connect,
        triggerEvent = core.triggerEvent,
        blank = util.blank,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,

        AGENT_EVENT = ['click', 'mouseover', 'mouseout', 'mouseup', 'mousedown'];
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * options 
     * for  id
     * @public
     *
     * @param {Object} options 
     */
    //__gzip_original__UI_LABEL
    var UI_LABEL = ui.Label = inheritsControl(
            UI_CONTROL,
            'ui-label',
            null,
            function (el, options) {
                this._bResizable = false;
                $connect(this, this.setFor, options['for']);
            }
        ),
        UI_LABEL_CLASS = UI_LABEL.prototype;
//{else}//
    /**
     * 
     * setFor 
     * @public
     *
     * @param {ecui.ui.Control} control 
     */
    UI_LABEL_CLASS.setFor = function (control) {
        this._cFor = control;
    };


    UI_LABEL_CLASS.$setSize = blank;

    // 
    (function () {
        var i, name;
        
        for (i = 0; name = AGENT_EVENT[i]; i++) {
            UI_LABEL_CLASS['$' + name]  = (function (name) {
                return function (event) {
                    UI_CONTROL_CLASS['$' + name].call(this, event);

                    var control = this._cFor;
                    if (control && !control.isDisabled()) {
                        triggerEvent(control, name, event);
                    }
                };
            })(name);
        }
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
CheckTree - 



HTML:
<div ecui="type:check-tree;fold:true;id:parent;name:part">
    <!--  -->
    <label></label>
    <!-- foldstyle="display:none" -->
    <li ecui="superior:other"></li>
    <li>()</li>
    ...
</div>


_oSuperior - ID
_uCheckbox - 
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        inheritsControl = core.inherits,
        createDom = dom.create,

        $connect = core.$connect,
        $fastCreate = core.$fastCreate,

        UI_CHECKBOX = ui.Checkbox,

        UI_TREE_VIEW = ui.TreeView,
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * options 
     * name 
     * value 
     * superior truefalse
     * @public
     *
     * @param {Object} options 
     */
    //__gzip_original__UI_CHECK_TREE
    var UI_CHECK_TREE = ui.CheckTree = 
        inheritsControl(
            UI_TREE_VIEW,
            'ui-check-tree',
            function (el, options) {
                this._oSuperior = options.superior;

                for (
                    var i = 0,
                        checkbox = this._uCheckbox = $fastCreate(
                            UI_CHECKBOX,
                            el.insertBefore(createDom(UI_CHECKBOX.types[0]), el.firstChild),
                            this,
                            {name: options.name, value: options.value, disabled: options.disabled}
                        ),
                        list = this.getChildren();
                    el = list[i++];
                ) {
                    options = el._oSuperior
                    if (options !== false) {
                        el = el._uCheckbox;
                        if (!options) {
                            el.setSubject(checkbox);
                        }
                        else {
                            $connect(el, el.setSubject, options);
                        }
                    }
                }
            }
        ),
        UI_CHECK_TREE_CLASS = UI_CHECK_TREE.prototype;
//{else}//
    /**
     * 
     * (setSizealterClass ) Element  clearCache 
     * @protected
     *
     * @param {CssStyle} style  Element  Css 
     * @param {boolean} cacheSize 
     */
    UI_CHECK_TREE_CLASS.$cache = function (style, cacheSize) {
        UI_TREE_VIEW_CLASS.$cache.call(this, style, cacheSize);
        this._uCheckbox.cache(true, true);
    };

    /**
     * 
     * $init  create  init 
     * @protected
     */
    UI_CHECK_TREE_CLASS.init = function () {
        UI_TREE_VIEW_CLASS.init.call(this);
        this._uCheckbox.init();
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_CHECK_TREE_CLASS.getChecked = function () {
        for (var i = 0, list = this.getChildren(), result = this.isChecked() ? [this] : [], o; o = list[i++]; ) {
            result = result.concat(o.getChecked());    
        }
        return result;
    };

    /**
     * 
     * @public
     *
     * @return {string} 
     */
    UI_CHECK_TREE_CLASS.getValue = function () {
        return this._uCheckbox.getValue();
    };

    /**
     * 
     * @public
     *
     * @return {boolean} 
     */
    UI_CHECK_TREE_CLASS.isChecked = function () {
        return this._uCheckbox.isChecked();
    };

    /**
     * 
     * @public
     *
     * @param {boolean} 
     */
    UI_CHECK_TREE_CLASS.setChecked = function (status) {
        this._uCheckbox.setChecked(status);    
    };

    UI_CHECK_TREE_CLASS.disable = function () {
        this._uCheckbox.disable();
        UI_TREE_VIEW_CLASS.disable.call(this);
    };

    UI_CHECK_TREE_CLASS.enable = function () {
        this._uCheckbox.enable();
        UI_CHECK_TREE_CLASS.enable.call(this);
    };

    UI_CHECK_TREE_CLASS.add = function (item, index, options) {
        var con = UI_TREE_VIEW_CLASS.add.call(this, item, index, options);
        if (con._oSuperior !== false) {
            if (!con._oSuperior) {
                con._uCheckbox.setSubject(this._uCheckbox);
            }
            else {
                con._uCheckbox.setSubject(con._oSuperior);
            }
        }
        return con;
    };

    UI_CHECK_TREE_CLASS.$ready = function () {
        this._uCheckbox.$ready();
    }
//{/if}//
//{if 0}//
})();
//{/if}//

/*
MessageBox - 
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,

        createDom = dom.create,

        createControl = core.create,
        disposeControl = core.dispose;
//{/if}//
//{if $phase == "define"}//
    var ECUI_MESSAGEBOX,
        ECUI_MESSAGEBOX_BUTTONS = [];
//{else}//
    /**
     * 
     * @private
     * 
     * @param {Event} event 
     */
    function ECUI_MESSAGEBOX_ONCLICK(event) {
        ECUI_MESSAGEBOX.hide();
        if (this._fAction) {
            this._fAction.call(null, event);
        }
    }

    /**
     * 
     * @protected
     * 
     * @param {string} text 
     * @param {Array} buttonTexts 
     * @param {Array} 
     *          {String} text 
     *          {String} className 
     *          {Function} action 
     * @param {Number} opacity 
     */
    core.$messagebox = function (text, title, buttons, opacity) {
        if (!ECUI_MESSAGEBOX) {
            ECUI_MESSAGEBOX = createControl(
                'Form',
                {
                    main: createDom('ui-form ui-messagebox'),
                    hide: true,
                    parent: document.body,
                    autoCenter: true,
                    closeButton: false
                }
            );

            body = ECUI_MESSAGEBOX.getBody();
            body.innerHTML =
                '<div class="ui-messagebox-text"></div>' +
                '<div class="ui-messagebox-bottom"></div>';
        }

        var i = 0,
            length = buttons.length,
            body = ECUI_MESSAGEBOX.getBody(),
            bottom = body.lastChild,
            o;

        if (!ECUI_MESSAGEBOX.isShow()) {
            while (length > ECUI_MESSAGEBOX_BUTTONS.length) {
                ECUI_MESSAGEBOX_BUTTONS.push(
                    createControl('Button', {element: createDom('ui-button', '', 'span'), parent: bottom})
                );
            }

            disposeControl(body = body.firstChild);
            body.innerHTML = text;

            for (; o = ECUI_MESSAGEBOX_BUTTONS[i]; i++) {
                if (i < length) {
                    o.setContent(buttons[i].text);
                    o.$show();
                    o._fAction = buttons[i].action;
                    o.onclick = ECUI_MESSAGEBOX_ONCLICK;
                    if (buttons[i].className) {
                        o.setClass(buttons[i].className);
                    }
                    else {
                        o.setClass(o.getPrimary());
                    }
                }
                else {
                    o.$hide();
                }
            }

            ECUI_MESSAGEBOX.setTitle(title || '');
            ECUI_MESSAGEBOX.showModal(opacity);
        }
    };

    /**
     * 
     * @public
     * 
     * @param {string} text 
     * @param {Function} onok 
     */
    core.alert = function (text, onok) {
        core.$messagebox(text, '', [
            {text: '', className: 'ui-button-g', action: onok}
        ]);
    };

    /**
     * /
     * @public
     * 
     * @param {string} text 
     * @param {Function} onok 
     * @param {Function} oncancel 
     */
    core.confirm = function (text, onok, oncancel) {
        core.$messagebox(text, '', [
            {text: '', className: 'ui-button-g', action: onok},
            {text: '', action: oncancel}
        ]);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
LockedTableSlowLockedTable

LockedTable - 
()()

HTML:
<div ecui="type:locked-table;left-lock:2;right-lock:1">
    <table>
        <!-- width -->
        <thead>
            <tr>
                <th></th>
                ...
            </tr>
        </thead>
        <tbody>
            <!--  -->
            <tr>
                <td></td>
                ...
            </tr>
            ...
        </tbody>
    </table>
</div>


_nLeft       - 
_nRight      - +1
_aLockedRow  - 
_uLockedHead - 
_uLockedMain - 


_eFill       - 
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        REGEXP = RegExp,
        USER_AGENT = navigator.userAgent,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getAttribute = dom.getAttribute,
        insertBefore = dom.insertBefore,
        removeDom = dom.remove,
        blank = util.blank,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        disposeControl = core.dispose,
        $bind = core.$bind,
        inheritsControl = core.inherits,

        firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ],

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_TABLE = ui.Table,
        UI_TABLE_CLASS = UI_TABLE.prototype,
        UI_TABLE_ROW = UI_TABLE_CLASS.Row,
        UI_TABLE_ROW_CLASS = UI_TABLE_ROW.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * options 
     * left-lock  
     * right-lock 
     * @public
     *
     * @param {Object} options 
     */
    //__gzip_original__UI_LOCKED_TABLE
    //__gzip_original__UI_LOCKED_TABLE_ROW
    var UI_LOCKED_TABLE = ui.SlowLockedTable =
        inheritsControl(
            UI_TABLE,
            '*locked-table',
            null,
            function (el, options) {

                // ==========================
                // var ddd = new Date();                
                
                var i = 0,
                    type = this.getType(),
                    headRows = this._aHeadRows,
                    rows = headRows.concat(this._aRows),
                    lockedEl = createDom('', 'position:absolute;top:0px;left:0px;overflow:hidden'),
                    list = [],
                    lockedRows = this._aLockedRow = [],
                    lockedHeadRows = this._aLockedHeadRow = [],
                    o;

                this._nLeft = options.leftLock || 0;
                this._nRight = this.getColumnCount() - (options.rightLock || 0);

                //  options  rows
                for (; el = rows[i]; ) {
                    el = el.getMain();
                    list[i++] =
                        '<tr class="' + el.className + '" style="' + el.style.cssText +
                            '"><td style="padding:0px;border:0px"></td></tr>';
                }

                lockedEl.innerHTML =
                    '<div class="' + type + '-locked-head" style="position:absolute;top:0px;left:0px"><div style="white-space:nowrap;position:absolute"><table cellspacing="0"><thead>' + list.splice(0, headRows.length).join('') + '</thead></table></div></div><div class="' + type + '-locked-layout" style="position:absolute;left:0px;overflow:hidden"><div style="white-space:nowrap;position:absolute;top:0px;left:0px"><table cellspacing="0"><tbody>' + list.join('') + '</tbody></table></div></div>';
                //  list 
                o = this._uLockedHead = $fastCreate(UI_CONTROL, lockedEl.firstChild, this);
                o.$setBody(el = o.getMain().lastChild.lastChild.firstChild);

                for (i = 0, list = children(el); o = list[i]; ) {
                    lockedHeadRows[i] = UI_LOCKED_TABLE_CREATE_LOCKEDROW(o, headRows[i++]);
                }

                o = this._uLockedMain = $fastCreate(UI_CONTROL, el = lockedEl.lastChild, this);
                o.$setBody(el = el.lastChild);

                for (i = 0, list = children(el.lastChild.lastChild); o = list[i]; ) {
                    lockedRows[i] = UI_LOCKED_TABLE_CREATE_LOCKEDROW(o, this._aRows[i++]);
                }
                insertBefore(lockedEl.firstChild, this._uHead.getOuter());
                insertBefore(lockedEl.firstChild, getParent(this.getBody()));

                // console.log('=================== locked-table constructor] ' + ((new Date()).getTime() - ddd));
                // ddd = new Date();                
            }
        );
        UI_LOCKED_TABLE_CLASS = UI_LOCKED_TABLE.prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_LOCKED_TABLE_ROW_CLASS = (UI_LOCKED_TABLE_CLASS.Row = inheritsControl(UI_TABLE_CLASS.Row)).prototype;
//{else}//
    /**
     * 
     * @private
     *
     * @param {HTMLElement} el  Element 
     * @param {ecui.ui.Table.Row} row 
     */
    function UI_LOCKED_TABLE_CREATE_LOCKEDROW(el, row) {
        $bind(el, row);
        row._eFill = el.lastChild;

        return row;
    }
    
    /**
     * 
     * @private
     *
     * @param {ecui.ui.LockedTable.LockedHead|ecui.ui.LockedTable.LockedRow} locked 
     */
    function UI_LOCKED_TABLE_ROW_SPLIT(locked) {
        var i = 0,
            table = locked.getParent(),
            cols = table.getHCells(),
            list = locked.$getElements(),
            baseBody = locked.getBody(),
            lockedBody = getParent(locked._eFill),
            el = lockedBody.firstChild,
            o;

        for (; cols[i]; ) {
            if (i == table._nLeft) {
                el = baseBody.firstChild;
            }
            if (o = list[i++]) {
                if (el != o) {
                    (i <= table._nLeft || i > table._nRight ? lockedBody : baseBody).insertBefore(o, el);
                }
                else {
                    el = el.nextSibling;
                }
            }
            if (i == table._nRight) {
                el = locked._eFill.nextSibling;
            }
        }
    }

    /**
     * 
     * @private
     *
     * @param {ecui.ui.LockedTable} table 
     */
    function UI_LOCKED_TABLE_ALL_SPLIT(table) {
        for (var i = 0, o; o = table._aLockedHeadRow[i++]; ) {
            UI_LOCKED_TABLE_ROW_SPLIT(o);
        }
        for (var i = 0, o; o = table._aLockedRow[i++]; ) {
            UI_LOCKED_TABLE_ROW_SPLIT(o);
        }
    }

    /**
     * @override
     */
    UI_LOCKED_TABLE_ROW_CLASS.$dispose = function () {
        this._eFill = null;
        UI_TABLE_ROW_CLASS.$dispose.call(this);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$cache = function (style, cacheSize) {

        // ==========================
        // var ttt = new Date();
        // var ddd = ttt;

        UI_TABLE_CLASS.$cache.call(this, style, cacheSize);

        // console.log('=================== locked-table $cache super class cache] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        var i = 0,
            rows = this.getRows(),
            cols = this.getHCells(),
            pos = cols[this._nLeft].$$pos;

        this.$$paddingTop = MAX(this.$$paddingTop, this._uLockedHead.getBody().offsetHeight);
        this.$$mainWidth -=
            (this.$$paddingLeft = pos) +
                (this.$$paddingRight =
                    this._nRight < cols.length ? this.$$mainWidth - cols[this._nRight].$$pos : 0);

        // console.log('=================== locked-table $cache 1] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        //  style  o
        for (; style = cols[i++]; ) {
            style.$$pos -= pos;
        }

        // console.log('=================== locked-table $cache 2 (col)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        for (i = 0, pos = 0; style = rows[i++]; ) {
            style.getCell(this._nLeft).cache(false, true);
            style.$$pos = pos;
            pos += MAX(style.getHeight(), style._eFill.offsetHeight);
        }

        // ======================== ch 35
        // console.log('=================== locked-table $cache 3 (row)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        if (pos) {
            this.$$mainHeight = pos;
            if (!this._bCreated) {
                this.$$mainHeight += this.$$paddingTop;
            }
        }

        this._uLockedHead.cache(false, true);
        this._uLockedMain.cache(false, true);

        // console.log('=================== locked-table $cache 4 (locked)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        // console.log('=================== locked-table $cache] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$pagescroll = function () {
        UI_TABLE_CLASS.$pagescroll.call(this);
        if (!this._uVScrollbar) {
            this._uLockedHead.getOuter().style.top = this._uHead.getOuter().style.top
        }
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$resize = function () {
        // ==========================
        // var ddd = new Date();

        var o = this.getMain().style;
        o.paddingLeft = o.paddingRight = '';
        this.$$paddingLeft = this.$$paddingRight = 0;

        // console.log('=================== locked-table $resize start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        UI_TABLE_CLASS.$resize.call(this);

        // console.log('=================== locked-table $resize superclass resize] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$scroll = function () {
        UI_TABLE_CLASS.$scroll.call(this);
        this._uLockedMain.getBody().style.top = this.getBody().style.top;
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$setSize = function (width, height) {
        // ====================================
        // var ddd = new Date();
        // var ttt = new Date();

        var o = this.getMain().style,
            i = 0,
            layout = getParent(this.getBody()),
            lockedHead = this._uLockedHead,
            lockedMain = this._uLockedMain,
            style = getParent(getParent(lockedHead.getBody())).style;

        // console.log('=================== locked-table $setSize start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        o.paddingLeft = this.$$paddingLeft + 'px';
        o.paddingRight = this.$$paddingRight + 'px';

        // console.log('=================== locked-table $setSize 1] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        UI_TABLE_CLASS.$setSize.call(this, width, height);

        // console.log('=================== locked-table $setSize 2] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        o = this._uHead.getWidth() + this.$$paddingLeft + this.$$paddingRight;
        (o < 0 || isNaN(o)) && (o = 0);

        // console.log('=================== locked-table $setSize 3] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        lockedHead.$setSize(o, this.$$paddingTop);

        // console.log('=================== locked-table $setSize 4] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        style.height = this.$$paddingTop + 'px';
        this._uLockedMain.$setSize(o, toNumber(layout.style.height));

        // console.log('=================== locked-table $setSize 5] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        style.width = this._uLockedMain.getBody().lastChild.style.width = o + 'px';
        this._uLockedMain.getOuter().style.top = this.$$paddingTop + 'px';
        
        // bugfix: paddingleft
        this._uHead.getOuter().style.left = this.$$paddingLeft + 'px';

        width = layout.style.width;

        // 
        // 
        var rows = this._aLockedHeadRow,
            minHeight;

        // console.log('=================== locked-table $setSize 6] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();


        //  
        height = this.$$paddingTop / rows.length; 
        for (i = 0; o = rows[i]; i++) {
            o._eFill.style.width = width;
            o._eFill.style.height = height + 'px';
            o = o.getCell(this._nLeft);
            if (o) {
                minHeight = firefoxVersion ? 0 : o.$getBasicHeight();
                isNaN(minHeight) && (minHeight = 0);
                o = o.getOuter();
                style = getAttribute(o, 'rowSpan') || 0;
                if (style) {
                    style = parseInt(style, 10);
                }
                o.style.height = MAX(style * height - minHeight, 0) + 'px';
            }
        }

        // console.log('=================== locked-table $setSize 7] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();


        // 
        rows = this._aLockedRow;
        for (i = 0; o = rows[i]; i++) {
            // ==================================
            // ddd1 = new Date();

            // ================================== ch sometimes 1
            o._eFill.style.width = width;

            //==================================  ch 1205 olap-table.resize315
            // _eFillgetCell(this._nLeft)
            // css

            /*
            console.log('=================== locked-table $setSize hot_0] ' + ((new Date()).getTime() - ddd1));
            ddd1 = new Date();

            // ================================== ch 4 ()
            style = MAX(height = o.getCell(this._nLeft).getOuter().offsetHeight, o._eFill.offsetHeight);

            console.log('=================== locked-table $setSize hot_1] ' + ((new Date()).getTime() - ddd1));
            
            // ==================================
            ddd1 = new Date();

            // ================================== 
            if (style > o._eFill.offsetHeight) {
                o._eFill.style.height = style + 'px';
            }
            else if (height < style) {
                minHeight = firefoxVersion ? 0 : o.getCell(this._nLeft).$getBasicHeight();
                o.getCell(this._nLeft).getOuter().style.height = MAX(style - minHeight, 0) + 'px';
            }

            console.log('=================== locked-table $setSize hot_2] ' + ((new Date()).getTime() - ddd1));
            */
        }

        // console.log('=================== locked-table $setSize end (hot!!) (into)] ' + ((new Date()).getTime() - ddd));
        // console.log('=================== locked-table $setSize total] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.addColumn = function (options, index) {
        if (index >= 0) {
            if (index < this._nLeft) {
                this._nLeft++;
            }
            if (index < this._nRight) {
                this._nRight++;
            }
        }
        return UI_TABLE_CLASS.addColumn.call(this, options, index);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.removeRow = function (index) {
        var i = 0,  row = this._aRows[index], o,
            lockedTR = row._eFill.parentNode;

        if (row) {
            row.hide();
            o = row.getOuter();
            disposeControl(row);
            removeDom(o, true);
            removeDom(lockedTR, true);
            this._aRows.splice(index, 1);
            this._aLockedRow.splice(index, 1);
            this.repaint();
        }
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.addRow = function (data, index) {

        //__gzip_original__lockedRow
        var row = UI_TABLE_CLASS.addRow.call(this, data, index),
            index = indexOf(this.getRows(), row),
            lockedRow = this._aLockedRow[index],
            el = row.getMain(),
            o = createDom();

        o.innerHTML = '<table cellspacing="0"><tbody><tr class="' + el.className + '" style="' + el.style.cssText +
            '"><td style="padding:0px;border:0px"></td></tr></tbody></table>';

        o = UI_LOCKED_TABLE_CREATE_LOCKEDROW(el = o.lastChild.lastChild.lastChild, row);
        lockedRow = lockedRow ? lockedRow._eFill.parentNode : null;
        this._uLockedMain.getBody().lastChild.lastChild.insertBefore(el, lockedRow);
        this._aLockedRow.splice(index, 0, o);
        UI_LOCKED_TABLE_ROW_SPLIT(o);

        this.repaint();

        return row;
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.init = function () {
        // ==========================
        // var ddd = new Date();

        // ========================== ch 25
        UI_LOCKED_TABLE_ALL_SPLIT(this);

        // console.log('=================== locked-table init (locked-table split)] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        UI_TABLE_CLASS.init.call(this);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.removeColumn = function (index) {
        UI_TABLE_CLASS.removeColumn.call(this, index);
        if (index >= 0) {
            if (index < this._nLeft) {
                this._nLeft--;
            }
            if (index < this._nRight) {
                this._nRight--;
            }
        }
    };

    /**
     * 
     * 
     * @protected
     */
    (function () {
        function build(name) {
            UI_LOCKED_TABLE_ROW_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                getParent(this._eFill).className = this.getMain().className;
            };
        }

        for (var i = 0; i < 11; ) {
            build('$' + eventNames[i++]);
        }
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        string = core.string,
        util = core.util,

        DATE = Date,
        REGEXP = RegExp,
        DOCUMENT = document,

        pushArray = array.push,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        moveElements = dom.moveElements,
        setText = dom.setText,
        formatDate = string.formatDate,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        setFocused = core.setFocused,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_SELECT = ui.Select,
        UI_MONTH_VIEW = ui.MonthView,
        UI_MONTH_VIEW_CELL = UI_MONTH_VIEW.Cell;

    /**
     * 
     * options 
     * year    
     * month   (1-12)
     * @public
     *
     * @param {Object} options 
     */
    var UI_CALENDAR = ui.Calendar =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-calendar',
            function (el, options) {
                options.hidden = true;
            },
            function (el, options) {
                var o = createDom(), child,
                    date, range,
                    type = this.getTypes()[0];

                o.innerHTML = '<div class="'+ type +'-text"></div><div class="'+ type +'-cancel"></div><div class="'+ type +'-button"></div>'
                    + '<div class="'+ type +'-layer" style="position:absolute;display:none"></div>';

                child = children(o);

                this._bTip = options.tip !== false;

                if (options.date) {
                    date = options.date.split('-');
                    this._oDate = new Date(date[0], parseInt(date[1], 10) - 1, date[2]);
                }
                else if (options.date === false) {
                    this._oDate = null
                }
                else {
                    this._oDate = new Date();
                }
                range = UI_CALENDAR_PARSE_RANGE(options.start, options.end);

                this._eText = child[0];

                this._uCancel = $fastCreate(this.Cancel, child[1], this);
                this._uButton = $fastCreate(UI_CONTROL, child[2], this);
                DOCUMENT.body.appendChild(child[3]);
                this._uLayer = $fastCreate(this.Layer, child[3], this, {date: this._oDate, range: range});

                moveElements(o, el, true);
            }
        ),

        UI_CALENDAR_CLASS = UI_CALENDAR.prototype,
        UI_CALENDAR_CANCEL_CLASS = (UI_CALENDAR_CLASS.Cancel = inheritsControl(UI_CONTROL)).prototype,

        UI_CALENDAR_LAYER = UI_CALENDAR_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-calendar-layer',
            null,
            function (el, options) {
                var html = [], o, i,
                    type = this.getTypes()[0],
                    buttonClass = this.Button,
                    selectClass = this.Select,
                    monthViewClass = this.MonthView,
                    date = options.date,
                    year = (new Date()).getFullYear();

                html.push('<div class="'+ type +'-buttons"><div class="'+ type +'-btn-prv'+ UI_BUTTON.TYPES +'"></div><select class="'+ type +'-slt-year'+ UI_SELECT.TYPES +'">');
                for ( i = year - 5; i < year + 5; i ++) {
                    html.push('<option value="'+ i +'">'+ i +'</option>');
                }
                html.push('</select><select class="'+ type +'-slt-month'+ UI_SELECT.TYPES +'">');
                for (i = 1; i <= 12; i++) {
                    html.push('<option value="'+ i +'">'+ (i < 10 ? '0' : '') + i +'</option>');
                }
                html.push('</select><div class="'+ type +'-btn-nxt'+ UI_BUTTON.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-month-view'+ UI_MONTH_VIEW.TYPES +'"></div>');
                el.innerHTML = html.join('');
                
                el = children(el);
                o = children(el[0]);

                this._uPrvBtn = $fastCreate(buttonClass, o[0], this);
                this._uPrvBtn._nStep = -1;
                this._uYearSlt = $fastCreate(selectClass, o[1], this);
                this._uMonthSlt = $fastCreate(selectClass, o[2], this);
                this._uNxtBtn = $fastCreate(buttonClass, o[3], this);
                this._uNxtBtn._nStep = 1;

                el = el[1];
                this._sMode = options.mode;
                this._uMonthView = $fastCreate(
                    monthViewClass, 
                    el, 
                    this, 
                    {
                        range : options.range, 
                        mode: options.mode
                    }
                );
            }
        ),

        UI_CALENDAR_LAYER_CLASS = UI_CALENDAR_LAYER.prototype,
        UI_CALENDAR_LAYER_BUTTON_CLASS = (UI_CALENDAR_LAYER_CLASS.Button = inheritsControl(UI_BUTTON, null)).prototype,
        UI_CALENDAR_LAYER_SELECT_CLASS = (UI_CALENDAR_LAYER_CLASS.Select = inheritsControl(UI_SELECT, null)).prototype,
        UI_CALENDAR_LAYER_MONTHVIEW_CLASS = (UI_CALENDAR_LAYER_CLASS.MonthView = inheritsControl(UI_MONTH_VIEW, null)).prototype,

        UI_CALENDAR_STR_DEFAULT = '<span class="ui-calendar-default"></span>',
        UI_CALENDAR_STR_PATTERN = 'yyyy-MM-dd';


    function UI_CALENDAR_PARSE_RANGE(begin, end) {
        var now = new Date(), res = null,
            o = [now.getFullYear(), now.getMonth(), now.getDate()], t,
            p = {y:0, M:1, d:2};
        if (/^(\d+)([yMd])$/.test(begin)) {
            res = res || {};
            t = o.slice();
            t[p[REGEXP.$2]] -= parseInt(REGEXP.$1, 10);
            res.begin = new Date(t[0], t[1], t[2]);
        }
        else if ('[object String]' == Object.prototype.toString.call(begin)) {
            res = res || {};
            res.begin = new Date(begin);
        }

        if (/^(\d+)([yMd])$/.test(end)) {
            res = res || {};
            t = o.slice();
            t[p[REGEXP.$2]] += parseInt(REGEXP.$1, 10);
            res.end = new Date(t[0], t[1], t[2]);
        }
        else if ('[object String]' == Object.prototype.toString.call(end)) {
            res = res || {};
            res.end = new Date(end);
        }

        return res;
    }

    function UI_CALENDAR_TEXT_FLUSH(con) {
        var el = con._eText;
        if (el.innerHTML == '') {
            con._uCancel.hide();
            if (con._bTip) {
                el.innerHTML = UI_CALENDAR_STR_DEFAULT;
            }
        }
        else {
            con._uCancel.show();
        }
    }

    function UI_CALENDAR_MONTHVIEW_FLUSH(con, day) {
        var cal = con._uMonthView,
            month = con._uMonthSlt.getValue(),
            year = con._uYearSlt.getValue();

        if (cal.getMonth() != month || cal.getYear() != year) {
            cal.setDate(year, month);
        }
        if (con._oDateSel && 
                cal.getMonth() == con._oDateSel.getMonth() + 1 && 
                cal.getYear() == con._oDateSel.getFullYear()) {
            day = con._oDateSel.getDate();
        }
        cal.setDay(day);
    }

    UI_CALENDAR_CLASS.getDate = function () {
        return this._oDate;
    };

    UI_CALENDAR_CLASS.setDate = function (date) {
        var layer = this._uLayer,
            ntxt = date != null ? formatDate(date, UI_CALENDAR_STR_PATTERN) : '';

        if (this._uLayer.isShow()) {
            this._uLayer.hide();
        }

        this._eText.innerHTML = ntxt;
        this.setValue(ntxt);
        this._oDate = date;
        UI_CALENDAR_TEXT_FLUSH(this);
    };

    UI_CALENDAR_CLASS.$activate = function (event) {
        var layer = this._uLayer, con,
            pos = getPosition(this.getOuter()),
            posTop = pos.top + this.getHeight();

        UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
        if (!layer.isShow()) {
            layer.setDate(this.getDate());
            layer.show();
            con = layer.getHeight();
            layer.setPosition(
                pos.left,
                posTop + con <= getView().bottom ? posTop : pos.top - con
            );
            setFocused(layer);
        }
    };

    UI_CALENDAR_CLASS.$cache = function (style, cacheSize) {
        UI_INPUT_CONTROL_CLASS.$cache.call(this, style, cacheSize);
        this._uButton.cache(false, true);
        this._uLayer.cache(true, true);
    };

    UI_CALENDAR_CLASS.init = function () {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this.setDate(this._oDate);
        this._uLayer.init();
    };

    UI_CALENDAR_CLASS.clear = function () {
        this.setDate(null);
    };

    UI_CALENDAR_CANCEL_CLASS.$click = function () {
        var par = this.getParent(),
            layer = par._uLayer;

        UI_CONTROL_CLASS.$click.call(this);
        par.setDate(null);
    };

    UI_CALENDAR_CANCEL_CLASS.$activate = UI_BUTTON_CLASS.$activate;

    UI_CALENDAR_LAYER_CLASS.$blur = function () {
        this.hide();
    };

    UI_CALENDAR_LAYER_CLASS.setDate = function (date, notDay) {
        var monthSlt = this._uMonthSlt,
            yearSlt = this._uYearSlt,
            year = date != null ? date.getFullYear() : (new Date()).getFullYear(),
            month = date != null ? date.getMonth() + 1 : (new Date()).getMonth() + 1;

        if (!notDay) {
            this._oDateSel = date;
        }   
        monthSlt.setValue(month);
        yearSlt.setValue(year);
        UI_CALENDAR_MONTHVIEW_FLUSH(this, notDay ? null : date ? date.getDate() : null);
    };

    UI_CALENDAR_LAYER_CLASS.getDate = function () {
        var cal = this._uMonthView;
        return new Date(cal.getYear(), cal.getMonth() - 1);
    };

    UI_CALENDAR_LAYER_CLASS.$cache = function (style, cacheSize) {
        this._uPrvBtn.cache(true, true);
        this._uNxtBtn.cache(true, true);
        this._uMonthSlt.cache(true, true);
        this._uYearSlt.cache(true, true);
        this._uMonthView.cache(true, true);
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);
    };

    UI_CALENDAR_LAYER_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uMonthSlt.init();
        this._uYearSlt.init();
        this._uMonthView.init();
    };

    UI_CALENDAR_LAYER_CLASS.ondateclick = function (event, date) {
        var par = this.getParent();
        if ((!par.getDate || par.getDate().getTime() != date.getTime()) 
            && triggerEvent(par, 'change', null, [date])
        ) {
            par.setDate(date);
        }
        this.hide();
    };

    UI_CALENDAR_LAYER_SELECT_CLASS.onchange = function () {
        var layer = this.getParent();
        UI_CALENDAR_MONTHVIEW_FLUSH(layer);
        triggerEvent(layer, 'viewchange', null, [layer.getDate().getFullYear(), layer.getDate().getMonth() + 1]);
    };

    UI_CALENDAR_LAYER_BUTTON_CLASS.$click = function () {
        var step = this._nStep,
            layer = this.getParent(),
            date = layer.getDate(),
            ndate;
        ndate = new Date(date.getFullYear(), date.getMonth() + step, 1);
        layer.setDate(ndate, true);
        triggerEvent(layer, 'viewchange', null, [ndate.getFullYear(), ndate.getMonth() + 1]);
    };

    UI_CALENDAR_LAYER_MONTHVIEW_CLASS.ondateclick = function (event, date) {
        triggerEvent(this.getParent(), 'dateclick', event, [date]);
    };


/**
 * 
 */
    var UI_MULTI_CALENDAR = ui.MultiCalendar = 
        inheritsControl(
            UI_CALENDAR,
            'ui-multi-calendar',
            function (el, options) {
                options.hidden = true;
            },
            function (el, options) {
                var o = createDom(), els;

                o.innerHTML = '<input type="hidden" name="'+ (options.beginname ? options.beginname : 'beginDate') +'" />'
                    + '<input type="hidden" name="'+ (options.endname ? options.endname : 'endDate') +'" />';
                
                if (options.bdate) {
                    els = options.bdate.split('-');
                    this._oBegin = new Date (els[0], parseInt(els[1], 10) - 1, els[2]);
                }
                if (options.edate) {
                    els = options.edate.split('-');
                    this._oEnd = new Date (els[0], parseInt(els[1], 10) - 1, els[2]);
                }
                els = children(o);    
                this._eBeginInput = els[0];
                this._eEndInput = els[1];

                moveElements(o, el, true);
            }
        ),

        UI_MULTI_CALENDAR_CLASS = UI_MULTI_CALENDAR.prototype,

        UI_MULTI_CALENDAR_LAY = UI_MULTI_CALENDAR_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-multi-calendar-layer',
            null,
            function (el, options) {
                var type = this.getTypes()[0],
                    html = [], range = options.range || {};

                html.push('<div class="'+ type +'-cal-area"><div class="'+ type +'-text"><strong></strong><span></span></div><div class="'+ UI_CALENDAR_LAYER.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-cal-area"><div class="'+ type +'-text"><strong></strong><span></span></div><div class="'+ UI_CALENDAR_LAYER.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-buttons"><div class="ui-button-g'+ UI_BUTTON.TYPES +'"></div><div class="'+ UI_BUTTON.TYPES +'"></div></div>');

                el.innerHTML = html.join('');
                el = children(el);

                this._eBeginText = el[0].firstChild.lastChild;
                this._eEndText = el[1].firstChild.lastChild;
                this._uBeginCal = $fastCreate(this.Cal, el[0].lastChild, this, {range: range});
                this._uBeginCal._sType = 'begin';
                this._uEndCal = $fastCreate(this.Cal, el[1].lastChild, this, {range: range});
                this._uEndCal._sType = 'end';
                this._uSubmitBtn = $fastCreate(this.Button, el[2].firstChild, this);
                this._uSubmitBtn._sType = 'submit';
                this._uCancelBtn = $fastCreate(this.Button, el[2].lastChild, this);
                this._uCancelBtn._sType = 'cancel';
            }
        ),

        UI_MULTI_CALENDAR_LAY_CLASS = UI_MULTI_CALENDAR_LAY.prototype;

        UI_MULTI_CALENDAR_LAY_CAL_CLASS = (UI_MULTI_CALENDAR_LAY_CLASS.Cal = inheritsControl(UI_CALENDAR_LAYER)).prototype,

        UI_MULTI_CALENDAR_LAY_BUTTON_CLASS = (UI_MULTI_CALENDAR_LAY_CLASS.Button = inheritsControl(UI_BUTTON)).prototype,
        UI_MULTI_CALENDAR_STR_DEFAULT = '<span class="ui-multi-calendar-default"></span>';
    
    function UI_MULTI_CALENDAR_TEXT_FLUSH(con) {
        var el = con._eText;
        if (el.innerHTML == '') {
            con._uCancel.hide();
            if (con._bTip) {
                el.innerHTML = UI_MULTI_CALENDAR_STR_DEFAULT;
            }
        }
        else {
            con._uCancel.show();
        }
    };

    UI_MULTI_CALENDAR_CLASS.init = function () {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this.setDate({begin: this._oBegin, end: this._oEnd});
        this._uLayer.init();
    };

    UI_MULTI_CALENDAR_CLASS.setDate = function (date) {
        var str = [], beginTxt, endTxt;

        if (date == null) {
            date = {begin: null, end: null};
        }

        beginTxt = date.begin ? formatDate(date.begin, UI_CALENDAR_STR_PATTERN) : '';
        endTxt = date.end ? formatDate(date.end, UI_CALENDAR_STR_PATTERN) : '';

        this._oBegin = date.begin;    
        this._oEnd = date.end;
        this._eBeginInput.value = beginTxt;
        this._eEndInput.value = endTxt;
        if (this._oBegin) {
            str.push(beginTxt);
        }
        if (this._oEnd) {
            str.push(endTxt);
        }
        if (str.length == 1) {
            str.push(this._oEnd ? '' : '');
            str = str.join('');
        }
        else if (str.length == 2) {
            str = str.join('');
        }
        else {
            str = '';
        }
        this._eText.innerHTML = str;
        UI_MULTI_CALENDAR_TEXT_FLUSH(this);
    };

    UI_MULTI_CALENDAR_CLASS.getDate = function () {
        return {begin: this._oBegin, end: this._oEnd};
    };

    UI_MULTI_CALENDAR_LAY_CLASS.setDate = function (date) {
        this._oBeginDate = date.begin;
        this._oEndDate = date.end;

        if (date.begin) {
            this._eBeginText.innerHTML = formatDate(date.begin, UI_CALENDAR_STR_PATTERN);
        }
        else {
            this._eBeginText.innerHTML = '';
        }

        if (date.end) {
            this._eEndText.innerHTML = formatDate(date.end, UI_CALENDAR_STR_PATTERN);
        }
        else {
            this._eEndText.innerHTML = '';
        }

        this._uBeginCal.setDate(date.begin);
        this._uBeginCal.setRange(undefined, date.end);
        this._uEndCal.setDate(date.end);
        this._uEndCal.setRange(date.begin);
    };

    UI_MULTI_CALENDAR_LAY_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
        this.hide();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uBeginCal.init();
        this._uEndCal.init();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.ondateset = function () {
        var par = this.getParent(),
            beginDate = this._oBeginDate,
            endDate = this._oEndDate;

        if (triggerEvent(par, 'dateset', [beginDate, endDate])) {
            par.setDate({begin: beginDate, end: endDate});
        }
        this.hide();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.$setDate = function (date, type) {
        var key = type.charAt(0).toUpperCase() 
                + type.substring(1);

        this['_e' + key + 'Text'].innerHTML = formatDate(date, UI_CALENDAR_STR_PATTERN);
        this['_o' + key + 'Date'] = date;
        if (type == 'begin') {
            this._uEndCal.setRange(date);
        }
        else {
            this._uBeginCal.setRange(undefined, date);
        }
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.ondateclick = function (event, date) {
        var par = this.getParent();

        this._oDateSel = date;
        par.$setDate(date, this._sType);
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.setRange = function (begin, end) {
        this._uMonthView.setRange(begin, end);
    };

    UI_MULTI_CALENDAR_LAY_BUTTON_CLASS.$click = function () {
        var par = this.getParent();
        UI_BUTTON_CLASS.$click.call(this);
        if (this._sType == 'submit') {
            triggerEvent(par, 'dateset');
        }
        else {
            par.hide();
        }
    }

})();

/*
Combox - 


HTML:
<select ecui="type:combox" name="age">
  <option value="20">20</option>
  <option value="21" selected="selected">21</option>
  <option value="22">22</option>
</select>

<div ecui="type:combox;name:age;value:21">
  <div ecui="value:20">20</div>
  <div ecui="value:21">21</div>
  <div ecui="value:22">22</div>
</div>

:
<div ecui="type:combox">
    <!-- ecnameinput -->
    <input name="test" />
    <!--  -->
    <li value=""></li>
    ...
</div>
*/
//{if 0}//
(function () {

    var core = ecui,
        ui = core.ui,

        inheritsControl = core.inherits,

        UI_SELECT = ui.Select,
        UI_SELECT_CLASS = UI_SELECT.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_COMBOX
    ///__gzip_original__UI_COMBOX_CLASS
    /**
     * 
     * options 
     * @public
     *
     * @param {Object} options 
     */
    var UI_COMBOX = ui.Combox =
        inheritsControl(
            UI_SELECT,
            '*ui-combox',
            function (el, options) {
                this.$getSection('Text').getOuter().style.display = 'none';
            },
            function (el, options) {
                options.hidden = false;
            }
        ),
        UI_COMBOX_CLASS = UI_COMBOX.prototype;
//{else}//
    /**
     * 
     * @protected
     *
     * @param {number} width 
     * @param {number} height 
     */
    UI_COMBOX_CLASS.$setSize = function (width, height) {
        UI_SELECT_CLASS.$setSize.call(this, width, height);
        this.getInput().style.width = this.$getSection('Text').getWidth() + 'px';
    };
//{/if}//
//{if 0}//
})();
//{/if}//
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        setFocused = core.setFocused,
        createDom = dom.create,
        children = dom.children,
        moveElements = dom.moveElements,
        getPosition  = dom.getPosition,
        inheritsControl = core.inherits,
        isContentBox = core.isContentBox,
        getStatus = core.getStatus,
        getView = util.getView,
        triggerEvent = core.triggerEvent,
        trim = string.trim,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,

        UI_TIP_TIME_OPEN = 500,
        UI_TIP_TIME_CLOSE = 200,
        REPAINT = core.REPAINT,

        uiPsTipLayer = null;

    var UI_TIP = ui.Tip = 
        inheritsControl(
            UI_CONTROL,
            'ui-tip',
            function(el, options) {
                options.message = trim(el.innerHTML) || options.message;
                el.innerHTML = '';
            },
            function (el, options) {
                this._sTarget = options.target;
                this._sMessage = options.message;
                this._oTimer = null;
            }
        ),

        UI_TIP_CLASS = UI_TIP.prototype,
        UI_TIP_LAYER = UI_TIP_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-tip-layer',
            function (el, options) {
                el.appendChild(createDom(this.getTypes() + '-corner'));
                el.appendChild(createDom());
            },
            function (el, options) {
                el = children(el);
                this._eCorner = el[0];
                this.$setBody(el[1]);
            }
        ),

        UI_TIP_LAYER_CLASS = UI_TIP_LAYER.prototype;


    function UI_TIP_LAYER_GET() {
        var o;
        if (!uiPsTipLayer) {
            o = document.body.appendChild(createDom(UI_TIP_LAYER.TYPES));
            uiPsTipLayer = $fastCreate(UI_TIP_LAYER, o);
            uiPsTipLayer.cache();
            uiPsTipLayer.init();
        }
        return uiPsTipLayer;
    }


    UI_TIP_CLASS.$mouseover = function () {
        var con = this;
        UI_CONTROL_CLASS.$mouseover.call(this);
        clearTimeout(this._oTimer);
        if (!this._bShow) {
            this._oTimer = setTimeout(function () {
                con.open();
            }, UI_TIP_TIME_OPEN);
        }
    }

    UI_TIP_CLASS.$mouseout = function () {
        var con = this;
        UI_CONTROL_CLASS.$mouseout.call(this);
        clearTimeout(this._oTimer);
        if (this._bShow) {
            this._oTimer = setTimeout(function () {
                con.close()
            }, UI_TIP_TIME_CLOSE);
        }
    }

    UI_TIP_CLASS.$getTarget = function (id) {
        return document.getElementById(id);
    }

    UI_TIP_CLASS.setTarget = function (id) {
        this._sTarget = id;
    }

    UI_TIP_CLASS.open = function () {
        var layer = UI_TIP_LAYER_GET();

        if (this._sTarget) {
            o = this.$getTarget(this._sTarget);
            if (o) {
                if ('[object String]' == Object.prototype.toString.call(o)) {
                    layer.getBody().innerHTML = o;
                }
                else {
                    layer.getBody().innerHTML = o.innerHTML;
                }
            }
        }
        else if (this._sMessage) {
            layer.setContent(this._sMessage);
        }

        layer.show(this);
        this._bShow = true;
    }

    UI_TIP_CLASS.close = function () {
        UI_TIP_LAYER_GET().hide();
        this._bShow = false;
    }

    UI_TIP_LAYER_CLASS.show = function (con) {
        var pos = getPosition(con.getOuter()),
            type = this.getTypes()[0],
            view = getView(),
            cornerHeight = 13,
            w = con.getWidth(), h = con.getHeight(),
            wFix = 9, hFix = 13,
            className = [];

        if (con) {
            this._uHost = con;
        }

        UI_CONTROL_CLASS.show.call(this);
        this.resize();
        if (pos.left + this.getWidth() > view.right) {
            pos.left = pos.left + w - this.getWidth() + wFix;
            className.push('-right')
        }
        else {
            pos.left = pos.left - wFix;
            className.push('-left');
        }

        if (pos.top - cornerHeight - this.getHeight() < view.top 
                && pos.top + h + cornerHeight + this.getHeight() < view.bottom) {
            pos.top += h + cornerHeight;
            className.push('-bottom');
        }
        else {
            pos.top -= cornerHeight + this.getHeight();
            className.push('-top');
        }

        this._eCorner.className = type + '-corner ' + type + '-corner' + className.join('');
        this.setPosition(pos.left, pos.top);
    }

    UI_TIP_LAYER_CLASS.$mouseover = function () {
        UI_CONTROL_CLASS.$mouseover.call(this);
        this._uHost.$mouseover();
    }

    UI_TIP_LAYER_CLASS.$mouseout = function () {
        UI_CONTROL_CLASS.$mouseout.call(this);
        this._uHost.$mouseout();
    }

    UI_TIP_LAYER_CLASS.$resize = function () {
         var el = this._eMain,
            currStyle = el.style;

        currStyle.width = this._sWidth;
        currStyle.height = this._sHeight;
        this.repaint();
    }
})();

(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        getMouseX = core.getMouseX,
        triggerEvent = core.triggerEvent,
        disposeControl = core.dispose,
        getOptions = core.getOptions,

        createDom = dom.create,
        getStyle = dom.getStyle,
        first = dom.first,
        moveElements = dom.moveElements,
        getPosition = dom.getPosition,
        setStyle = dom.setStyle,
        addClass = dom.addClass,
        ieVersion = dom.ieVersion,
        toNumber = util.toNumber,
        extend = util.extend,
        blank = util.blank,
        unionBoundBox = xutil.graphic.unionBoundBox,
        indexOf = array.indexOf,
        trim = string.trim,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_TREE_VIEW = ui.TreeView,
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype;

    var UI_PL_FLOAT_MENU = ui.PlFloatMenu = 
        inheritsControl(
            UI_TREE_VIEW,
            'ui-float-menu',
            null,
            function (el, options) {
                var o, type = this.getTypes()[0];
                
                if (options.url) {
                    this._sUrl = options.url;
                    delete options.url;
                    addClass(el, type + '-pointer');    
                }
                
                if (options.value) {
                    this._sValue = options.value;
                    delete options.value;
                }
                if (options.text) {
                    this._sText = options.text;
                }
                if (options.isNew) {
                    el.appendChild(createDom(type + '-icon-new'));
                    delete options.isNew;
                }
                if (options.prompt) {
                    el.setAttribute('title', options.prompt);
                }
                if (options.floatTree) {
                    this._oFloaterDatasource = options.floatTree;
                    el.appendChild(createDom(type + '-icon-arror'));
                    delete options.floatTree;
                }
                options.collapsed = false;
                this._bRootHide = true;
                
                if (!options.notRoot) { // mold fake and floater
                    document.body.appendChild(o = createDom('ui-float-menu-floater', 'display:none'));
                    this._uFloater = $fastCreate(this.Floater, o, this, {});
                    options.notRoot = true;
                }
            }
        ),
        UI_PL_FLOAT_MENU_CLASS = UI_PL_FLOAT_MENU.prototype,
        
        // 
        UI_PL_FLOAT_MENU_FLOATER = UI_PL_FLOAT_MENU_CLASS.Floater = 
            inheritsControl(
                UI_CONTROL,
                'ui-float-menu-floater',
                null,
                function (el, options) {
                    var type = this.getTypes()[0];
                    this._aLineList = [];
                }
            ),
        UI_PL_FLOAT_MENU_FLOATER_CLASS = UI_PL_FLOAT_MENU_FLOATER.prototype,
        
        // 
        UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS = (UI_PL_FLOAT_MENU_FLOATER_CLASS.Line = (
            inheritsControl(UI_CONTROL, 'ui-float-menu-floater-line')
        )).prototype;
        


    function UI_PL_FLOAT_MENU_LOAD_DATA(con, data) {
        var i, item, o;
        for (i = 0; item = data[i]; i++) {
            o = item.text; 
            item = extend({}, item);
            item.notRoot = true;
            o = con.add(o, null, item);
            if (item.children && item.children.length > 0) {
                UI_PL_FLOAT_MENU_LOAD_DATA(o, item.children);
            }
        }
    }
    
    /**
     * 
     * @param {String} value 1101:1119:21, :floatervaluenull
     */
    UI_PL_FLOAT_MENU_CLASS.select = function (value) {
        var con, o, i, item, menuValue, floaterValue, root = this.getRoot();
        
        if (value === null) {
            root.setSelected(null);
            return;
        }
        
        o = (value = String(value)).indexOf(':');
        if (o >=0 ) {
            menuValue = value.slice(0, o);
            floaterValue = value.slice(o + 1, value.length) || null;
        } else {
            menuValue = value;   
        }
        
        if (this._sValue && this._sValue == menuValue) {
            root.setSelected(this);
            con = this;
            while ((con = con.getParent()) && con instanceof UI_PL_FLOAT_MENU) {
                con.expand();
            }
            root._sFloaterValue = floaterValue;
            root._uFloater.select(floaterValue);
        }
        else {
            for (i = 0; item = this._aChildren[i]; i++) {
                item.select(value);
            }
        }
    }

    UI_PL_FLOAT_MENU_CLASS.setSelected = function (node) {
        var con;
        if (this == this.getRoot()) {
            if (this._cSelected != node) {
                if (this._cSelected) {
                    this._cSelected.alterClass('-selected');
                    con = this._cSelected;
                    while((con = con.getParent()) && con instanceof UI_PL_FLOAT_MENU) {
                        con.alterClass('-half-selected');
                    }
                }
                if (node) {
                    node.alterClass('+selected');
                    con = node;
                    while((con = con.getParent()) && con instanceof UI_PL_FLOAT_MENU) {
                        con.alterClass('+half-selected');
                    }
                }
                this._cSelected = node;
            }

            if (node && this._bExpandSelected) {
                node.expand();
            }
        }
    }

    UI_PL_FLOAT_MENU_CLASS.getSelected = function () {
        if (this._cSelected) {
            return this._cSelected.$wrapItemData();
        } 
        else {
            return null;
        }
    }    
    
    UI_PL_FLOAT_MENU_CLASS.getBoundBox = function () {
        return unionBoundBox.apply(this, this.$getAllBounds());
    }
    
    UI_PL_FLOAT_MENU_CLASS.$getAllBounds = function (bounds) {
        var i, node, bound;
        bounds = bounds || [];
        if (this.isShow()) {
            bound = getPosition(this.getOuter());
            bound.width = this.getWidth();
            bound.height = this.getHeight();
            bounds.push(bound);
        }
        if (this._aChildren) {
            for (i = 0; node = this._aChildren[i]; i++) {
                bounds = node.$getAllBounds(bounds);
            }   
        }
        return bounds;
    }
    
    UI_PL_FLOAT_MENU_CLASS.setData = function (data) {
        var item, i;

        // 
        this.select(null);

        if (this.getRoot() !== this) {
            return;
        }
        for (i = 0; item = this._aChildren[i]; i++) {
            disposeControl(item);
        }
        this._aChildren = [];
        this._eChildren.innerHTML = '';

        UI_PL_FLOAT_MENU_LOAD_DATA(this, data);
        this.init();
    }

    UI_PL_FLOAT_MENU_CLASS.init = function () {
        var o, el = this._eMain;

        UI_TREE_VIEW_CLASS.init.call(this);
        
        if (this._aChildren && this._aChildren.length > 0) {
            o = createDom(this.getPrimary() + '-icon');
            el.insertBefore(o, el.firstChild);
        }

        this.collapse();

        if (this.getRoot() == this) {
            if (this._bRootHide) {
                this.getOuter().style.display = 'none';
            }
            this.expand();
        }
    }  

    UI_PL_FLOAT_MENU_CLASS.$wrapItemData = function () {
        return {
            menuId: this._sValue, 
            menuName: this._sText, 
            menuUrl: this._sUrl
        };
    }    

    UI_PL_FLOAT_MENU_CLASS.$floaterselect = function (data, hoveredCon) {
        if (this == this.getRoot()) {
            this.setSelected(hoveredCon || null);
            this._uFloater.hide();
            this._sFloaterValue = data.value;

            triggerEvent(
                this, 
                'change',
                null, 
                [
                    {
                        menuId: data.value,
                        menuName: data.text,
                        menuUrl: data.url
                    }
                ]
            )
        }
    }

    UI_PL_FLOAT_MENU_CLASS.$mousemove = function (event) {
        var root = this.getRoot(), floater = root._uFloater;
        if (this == root) { return; }
        
        // hovered
        if (root._uHoveredMenu != this) {
            root._uHoveredMenu && root._uHoveredMenu.alterClass('-hover');
            this.alterClass('+hover');
            root._uHoveredMenu = this;
        }
        
        // floater, 
        // tree-viewfloatermouseovermouseout
        if (floater.getMenuShowMe() != this) {
            if (this._oFloaterDatasource) {
                floater.setData(this, this._oFloaterDatasource, root._sFloaterValue);
                floater.show(this);
            } else {
                floater.getMenuShowMe() && floater.hide();
            }
        }
        event.exit();
    }

    UI_PL_FLOAT_MENU_CLASS.$mouseover = function (event) {
        // hover
        event.exit();
    }
    
    UI_PL_FLOAT_MENU_CLASS.$mouseout = function (event) {
        if (this.getRoot() == this) {
            if (this.getRoot()._uHoveredMenu) {
                this.getRoot()._uHoveredMenu.alterClass('-hover');
                this.getRoot()._uHoveredMenu = null;
            }
            if (this.getRoot()._uFloater) {
                this.getRoot()._uFloater.hide();
            }
        }
    }
    
    UI_PL_FLOAT_MENU_CLASS.$click = function (event) {
        if (event.getControl() == this) {
            UI_CONTROL_CLASS.$click.call(this, event);

            var root = this.getRoot();
            var doExpand = false;

            if (this._aChildren.length > 0
                && (!this._sUrl
                    || getMouseX(this) 
                        <= toNumber(getStyle(this.getBody(), 'paddingLeft'))
                )
            ) {
                doExpand = true;
                event.exit();
                this[event = this.isCollapsed() ? 'expand' : 'collapse']();
                triggerEvent(this, event);
            }
            
            if (!doExpand && this._sUrl) {
                root.setSelected(this);
                triggerEvent(root, 'change', this.$wrapItemData());
            }
        }        
    }
        
        
        
    ///////////////////////////////////////////////////
    // UI_PL_FLOAT_MENU_FLOATER
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.setData = function (menuHovered, datasource, floaterValue) {
        var i, item, o, lineType, datasource = datasource || [];
        
        this.hide();
        this.clear();
        
        this._uMenuHovered = menuHovered;
        // floaterLine
        for (i = 0; item = datasource[i]; i++) {
            lineType = item.lineType || UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.DEFAULT_KEY;
            this.getBody().appendChild(o = createDom('ui-float-menu-floater-line'));
            o = UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.create(lineType, o, this, {datasource: item});
            this._aLineList.push(o);
            if (i < datasource.length - 1) {
                o.alterClass('+separater');   
            }
        }
        
        this.select(floaterValue);
    }
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.getMenuShowMe = function () {
        return this._uMenuShowMe;
    }
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.show = function (menuShowMe) {
        this._uMenuShowMe = menuShowMe;
        UI_CONTROL_CLASS.show.call(this);
        this.$layout();
    }
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.hide = function () {
        this._uMenuShowMe = null;
        UI_CONTROL_CLASS.hide.call(this);
    }
    
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.$layout = function () {
        var left, top, 
            menuCon = this.getParent(),
            menuHovered = this._uMenuHovered,
            menuBoundBox = menuCon.getBoundBox(),
            hoveredPos = getPosition(menuHovered.getOuter()),
            hoveredWidth = menuHovered.getWidth(),
            thisHeight = this.getHeight();
            
        left = hoveredPos.left + hoveredWidth;
        top = hoveredPos.top - 2;
        /* if (top + thisHeight > menuBoundBox.top + menuBoundBox.height) {
            top = menuBoundBox.top + menuBoundBox.height - thisHeight;   
        }
        if (top < menuBoundBox.top) {
            top = menuBoundBox.top;
        }*/
        this.setPosition(left - (ieVersion ? 1 : 2), top);
    }
    
    /**
     * 
     * @param {String} value  1:22
     */
    UI_PL_FLOAT_MENU_FLOATER_CLASS.select = function (value) {
        var i, lineCon;
        for (i = 0; lineCon = this._aLineList[i]; i++) {
            lineCon.select(value);
        }
    }
    
    /**
     * floater
     */
    UI_PL_FLOAT_MENU_FLOATER_CLASS.clear = function () {
        var i, lineCon;
        for (i = 0; lineCon = this._aLineList[i]; i++) {
            disposeControl(lineCon);
        }
        this._aLineList = [];
        this._uMenuHovered = null;
        this.getBody().innerHTML = '';
    }
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.$dispose = function () {
        this.getBody().innerHTML = '';
        UI_CONTROL_CLASS.$dispose.call(this);
    }    
    
    /**
     * Event handler of "floaterlineselect"
     */
    UI_PL_FLOAT_MENU_FLOATER_CLASS.$floaterlineselect = function (floaterLineCon, data) {
        var i, floaterLine;
        // floaterLine
        for (i = 0; floaterLine = this._aLineList[i]; i++) {
            if (floaterLine !== floaterLineCon) {
                floaterLine.select(null);   
            }
        }
        triggerEvent(this.getParent(), 'floaterselect', null, [data, this._uMenuHovered]);
    }
  
    ///////////////////////////////////////////////////
    // UI_PL_FLOAT_MENU_FLOATER 
    
    /**
     * Line control class factory
     */
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.lineControlTypeSet = {};
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.DEFAULT_KEY = '';
    
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.registerLineControlType = function (key, controlType) {
        UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.lineControlTypeSet[key] = controlType;
    }
    
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.create = function (key, el, parent, options) {
        return $fastCreate(UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.lineControlTypeSet[key], el, parent, options);
    }
    
    /**
     * @param {String} value null
     */
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.select = function (value) {} // blank
    
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.$dispose = function () {
        this.getBody().innerHTML = '';
        UI_CONTROL_CLASS.$dispose.call(this);
    }    
    
})();

(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        getMouseX = core.getMouseX,
        triggerEvent = core.triggerEvent,
        disposeControl = core.dispose,
        getOptions = core.getOptions,

        createDom = dom.create,
        getStyle = dom.getStyle,
        first = dom.first,
        moveElements = dom.moveElements,
        toNumber = util.toNumber,
        extend = util.extend,
        blank = util.blank,
        indexOf = array.indexOf,
        trim = string.trim,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_PL_FLOAT_MENU_FLOATER_LINE = ui.PlFloatMenu.prototype.Floater.prototype.Line,
        UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS = UI_PL_FLOAT_MENU_FLOATER_LINE.prototype;

    var UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE = 
            inheritsControl(
                UI_PL_FLOAT_MENU_FLOATER_LINE,
                'ui-float-menu-floater-radio-line',
                null,
                function (el, options) {
                    var o, type = this.getTypes()[0], i, item, 
                        datasource = options.datasource, me = this,
                        children = datasource.children || [];
                    
                    this._sUrl = datasource.url;
                    this._sText = datasource.text;
                    this._sValue = datasource.value;

                    this._aBtnList = [];
                    var tmpEl = createDom();

                    for (var i = 0, o; o = children[i]; i ++) {
                        tmpEl.innerHTML = '<div class="ui-button-g ui-button q-btn-table">' + o.text + '</div>';
                        el.appendChild(tmpEl.firstChild);
                        this._aBtnList.push($fastCreate(UI_BUTTON, el.lastChild, this, {}));

                        // 
                        this._aBtnList[this._aBtnList.length - 1].onclick = (function(oo) {
                            return function() {
                                triggerEvent(me, 'itemselect', null, [oo]);
                            }
                        })(extend({},o));
                    }

                    // event handler
                    // this._uRadioList.onclick = function (itemValue) {
                    // }
                }
            ),
            
        UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE_CLASS = UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE.prototype;
        
        // Register to factory as default
        UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.registerLineControlType(
            UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.DEFAULT_KEY, UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE);

    /**
     * @param {String} value  1102:22, null
     */
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.select = function (value) {
        var o, lineValue, itemValue;
        if (value !== null && value !== undefined && (value = trim(value)) !== '') {
            o = value.split(':');
            lineValue = o[0];
            itemValue = o[1];
            if (lineValue != this._sValue) { return; }
            (itemValue === undefined || trim(itemValue) === '') && (itemValue = lineValue); // fake item
            this.selectItem(itemValue);
        } 
        else { // 
            this.selectItem(null);
        }
    }       
        
    UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE_CLASS.selectItem = function (itemValue) {
        // do nothing
    }
    
    UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE_CLASS.$itemselect = function (itemValue) {
        triggerEvent(
            this.getParent(), 
            'floaterlineselect', 
            null, 
            [
                this, 
                {
                    value: this._sValue,
                    text: this._sText,
                    url: itemValue.url
                }
            ]
        );
    }
    
    UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE_CLASS.$dispose = function () {
        this.getBody().innerHTML = '';
        UI_CONTROL_CLASS.$dispose.call(this);
    }    

})();

(function () {
    var core = ecui,
        dom = core.dom,
        ui = core.ui,

        inheritsControl = core.inherits,
        createDom = dom.create,
        moveElements = dom.moveElements,

        UI_BUTTON = ui.Button;

    var UI_PL_BUTTON = ui.PlButton = 
        inheritsControl(
            UI_BUTTON,
            'ui-button',
            function (el, options) {
                var o = createDom(),
                    type = this.getTypes()[0];
            
                moveElements(el, o, true);
                el.innerHTML = '<span class="'+ type +'-inner"></span>';
                moveElements(o, el.firstChild, true);

                if (options.icon) {
                    o = createDom(type + '-icon', '',  'span');
                    el.appendChild(o);
                }
            }
        ),
        UI_PL_BUTTON_CLASS = UI_PL_BUTTON.prototype;
        
    /**
     * 
     * @public
     *
     * @param {any} innerHTML 
     */
    UI_PL_BUTTON_CLASS.setInner = function (innerHTML) {
    	this.getBody().firstChild.innerHTML = innerHTML;
    	this.$resize();
    };
    
    /**
     * 
     * @public
     *
     * @param {any} innerHTML 
     */
    UI_PL_BUTTON_CLASS.hideForce = function () {
    	this.$hide();
    };
    
    /**
     * 
     * @public
     *
     * @param {any} innerHTML 
     */
    UI_PL_BUTTON_CLASS.showForce = function () {
    	this.$show();
    };
    
    

})();

/**
 * ecui.ui.Container
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    
 *          
 * author:  sushuang(sushuang@baidu.com)
 * depend:  ecui
 */

(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        disposeControl = core.dispose,
        blank = util.blank,

        createDom = dom.create,
        getStyle = dom.getStyle,
        extend = util.extend,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;

    var UI_CONTAINER = ui.Container = 
        inheritsControl(
            UI_CONTROL,
            'ui-container',
            function (el, options) {
                var o = createDom(),
                    type = this.getTypes()[0];
                // TODO
            }
        ),
        UI_CONTAINER_CLASS = UI_CONTAINER.prototype;    
     
    UI_CONTAINER_CLASS.setSize = blank; // setSize 
    
    /**
     * 
     * @public
     * 
     * @param {string|ecui.ui.Control|Function} type 
     *          typeFunction
     *          @param {HTMLElement} DOM
     *          @return {ecui.ui.Control} 
     * @return {ecui.ui.Control} 
     */
    UI_CONTAINER_CLASS.createSubControl = function (type, domCreater) {
        var o = createDom();
        
        if (type && type instanceof UI_CONTROL) {
            
        }
        // TODO
    };
    
    /**
     * 
     * @public
     * 
     * @param {ecui.ui.Control} control 
     */
    UI_CONTAINER_CLASS.removeSubControl = function (control) {
        // TODO
    };

    /**
     * DOM
     * getBody()appendChild
     * @protected
     * 
     * @return {HTMLElement} DOM
     */
    UI_CONTAINER_CLASS.createSubDom = function () {
        var o = createDom();
        this.getBody().appendChild(o);
        return o;
    };
    
})();

/**
 * ecui.ui.TabContainer
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    TAB
 * author:  sushuang(sushuang@baidu.com)
 * depend:  ecui
 */

(function() {

    var array = ecui.array;
    var dom = ecui.dom;
    var ui = ecui.ui;
    var util = ecui.util;
    var string = ecui.string;
    var MAX = Math.max;

    var indexOf = array.indexOf;
    var $fastCreate = ecui.$fastCreate;
    var inheritsControl = ecui.inherits;
    var triggerEvent = ecui.triggerEvent;
    var disposeControl = ecui.dispose;
    var moveElements = dom.moveElements;
    var removeDom = dom.remove;
    var encodeHTML = string.encodeHTML;
    // 
    var template = xutil.string.template;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var blank = util.blank;
    var q = xutil.dom.q;

    var createDom = dom.create;
    var getStyle = dom.getStyle;
    var extend = util.extend;

    var UI_CONTROL = ui.Control;
    var UI_TAB = ui.Tab;
    var UI_TAB_CLASS = UI_TAB.prototype;
    var UI_ITEMS = ui.Items;
    var UI_BUTTON = ui.Button;

    /**
     * tab
     * 
     * @class
     * @param {Object} options 
     */
    var UI_TAB_CONTAINER = ui.TabContainer = inheritsControl(UI_TAB);
    var UI_TAB_CONTAINER_CLASS = UI_TAB_CONTAINER.prototype;
        
    var UI_TAB_ITEM_EXT_CLASS = (UI_TAB_CONTAINER_CLASS.Item = inheritsControl(
            UI_TAB_CLASS.Item, 
            null, 
            null,
            function(el, options) {
                var type = this.getType();

                el.innerHTML = template(TPL_ITEM, {   
                    currClass: this._sClass, 
                    content: el.innerHTML, 
                    close: options.canClose ? TPL_CLOSE_BTN : ''
                });
                    
                this._oMemo = options.memo;
                if (options.canClose) {
                    this._uCloseBtn = $fastCreate(
                        this.CloseBtn, 
                        q('q-close-btn', el)[0], 
                        this, 
                        { primary:'ui-tab-close-btn' }
                    );
                }
            }
        )).prototype;
        
    var UI_TAB_CLOSE_BTN_CLASS = (UI_TAB_ITEM_EXT_CLASS.CloseBtn = 
            inheritsControl(UI_BUTTON)).prototype;

    var UI_TAB_BUTTON_CLASS = (
            UI_TAB_CONTAINER_CLASS.Button = inheritsControl(
                UI_TAB_CLASS.Button,
                null,
                function(el, options) {
                    var type = this.getType();
                    el.appendChild(createDom(type + '-icon'));
                }
            )
        ).prototype;
    
    /**/
    var TPL_ITEM = [
            '<div class="#{currClass}-ledge"></div>',
            '<div class="#{currClass}-lledge"></div>',
            '<div class="#{currClass}-inner">',
                '<span class="#{currClass}-text">#{content}</span>',
                '#{close}',
            '</div>',
            '<div class="#{currClass}-lledge"></div>',
            '<div class="#{currClass}-ledge"></div>'
        ].join('');
    var TPL_CLOSE_BTN = [
            '<span class="ui-tab-close-btn q-close-btn">',
                '<span class="ui-tab-close-btn-icon"></span>',
            '</span>'
        ].join('');
                    
    /**
     * @override
     */
    UI_TAB_CONTAINER_CLASS.$dispose = function() {
        UI_TAB_CONTAINER.superClass.$dispose.call(this);
    };        
        
    /**
     * @override
     */
    UI_TAB_CONTAINER_CLASS.$alterItems = function() {
        this.cache(true, true);
        UI_TAB_CONTAINER.superClass.$alterItems.call(this);
    };

    /**
     *  tab
     * @public 
     * 
     * @param {ecui.ui.Control|Function} tabContent tab
     *          
     *          
     *              {HTMLElement} tabEl itemcontainer
     *              {ecui.ui.Tab} tabCtrl 
     *              {ecui.ui.Item} tabItem
     *          
     *              {ecui.ui.Control} 
     * @param {Object} options 
     * @param {number} options.index 
     * @param {string} options.title 
     * @param {boolean} options.canClose 
     * @param {HTMLElement=} options.tabEl tab el
     * @param {HTMLElement=} options.contentEl content el
     * @param {Any} options.memo 
     * @return {Object}
     *          {ecui.ui.Item} tabItem 
     *          {(ecui.ui.Control|HTMLElement)} tabContent 
     */    
    UI_TAB_CONTAINER_CLASS.addTab = function(tabContent, options) {
        options = options || {};
        options.canClose = options.canClose || false; 

        var el = options.tabEl;
        if (!el) {
            el = createDom();
            this.getBody().appendChild(el);
        }
        if (el.tagName != 'LABEL') {
            el.innerHTML = '<label>' + options.title + '</label>';
        }
        
        var tabItem = this.add(el, options.index, options);

        if (options.contentEl) {
            tabItem.setContainer(options.contentEl);
        }
        
        if (Object.prototype.toString.call(tabContent) 
                == '[object Function]'
        ) {
            tabContent = tabContent(
                tabItem.getContainer(),
                this,
                tabItem,
                options
            );
        }

        // tabContent && tabContent.$setParent(this);

        return { tabItem: tabItem, tabContent: tabContent };
    };
        
    /**
     * tab
     * @public
     * 
     * @param {ecui.ui.Item} tabItem 
     */
    UI_TAB_CONTAINER_CLASS.selectTab = function(tabItem) {
        this.setSelected(tabItem);
    };
    
    /**
     * tab
     * @public
     * 
     * @param {string} tabId tab
     */
    UI_TAB_CONTAINER_CLASS.$closeTab = function(item) {
        this.remove(item);
    };
    
    //----------------------------------------
    // UI_TAB_ITEM_EXT
    //----------------------------------------
    
    /**
     * 
     * @public
     * 
     * @return {Any} 
     */
    UI_TAB_ITEM_EXT_CLASS.getMemo = function() {
        return this._oMemo;
    };

    /**
     * 
     * @public
     * 
     * @param {string} title 
     */
    UI_TAB_ITEM_EXT_CLASS.setTitle = function(title) {
        var titleEl = q(this._sClass + '-text', this.getOuter())[0];
        var parent = this.getParent();

        if (titleEl) {
            var fullTitle = encodeHTML(title);
            var shortTitle;
            if (textLength(title) > 36) {
                shortTitle = encodeHTML(textSubstr(title, 0, 36) + '...');
            } 
            else {
                shortTitle = fullTitle;
            }
            titleEl.innerHTML = '<label title="' + fullTitle + '">' 
                + shortTitle + '</label>';   

            parent.$alterItems();
            // 
            // TODO
            // 
            var style = parent.getBody().style;
            var left = parseInt(style.left);
            var itemIndex = indexOf(parent.getItems(), this);
            var itemLeft = parent._aPosition[itemIndex] 
                - (parent._uPrev.isShow() ? 0 : parent._uPrev.getWidth());

            if (left + parent.getBodyWidth() + itemLeft - this.getWidth() < 0) {
                style.left = 
                    MAX(
                        parent._aPosition[itemIndex], 
                        parent.getBodyWidth() - parent.$$titleWidth 
                            - parent._uNext.getWidth()
                    ) 
                    + 'px';
            }
        }
    };

    /**
     * 
     * parenteMain
     *
     * @public
     * @override
     * @param {HTMLElement} el 
     */
    UI_TAB_ITEM_EXT_CLASS.setContainer = function (el) {
        var parent = this.getParent();

        if (this._eContainer) {
            removeDom(this._eContainer);
        }
        if (this._eContainer = el) {
            if ((this._sContainer = el.style.display) == 'none') {
                this._sContainer = '';
            }

            if (parent) {
                // 
                el.style.display = parent._cSelected == this 
                    ? this._sContainer : 'none';
            }
        }
    };
        
    /**
     * @override
     */
    UI_TAB_ITEM_EXT_CLASS.$click = function(event) {
        // tab
        var par = this.getParent();
        var selected = par.getSelected();

        if (triggerEvent(par, 'beforechange', null, [this, selected]) !== false) {
            UI_TAB_CONTAINER_CLASS.Item.superClass.$click.apply(this, arguments);
            triggerEvent(par, 'afterchange', null, [this, selected]);
        }        
    };

    //----------------------------------------
    // UI_TAB_CLOSE_BTN
    //----------------------------------------
            
    /**
     * @override
     */
    UI_TAB_CLOSE_BTN_CLASS.$click = function(event) {
        // tab
        var item = this.getParent();
        var tabContainer = item.getParent();
        if (triggerEvent(tabContainer, 'tabclose', null, [item]) !== false) {
            tabContainer.$closeTab(item);
            tabContainer.$alterItems();
        }
        event.stopPropagation();
    };
    
})();


/**
 * ecui.ui.IstCalendar
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    IST
 *          
 * @author:  sushuang(sushuang@baidu.com) 
 *          (
 *              Pulseecui
 *              (pl-calendar.js by cxl(chenxinle@baidu.com))
 *              
 *          )
 * @depend:  ecui
 */

(function() {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;

    var DATE = Date;
    var REGEXP = RegExp;
    var DOCUMENT = document;

    var children = dom.children;
    var createDom = dom.create;
    var getParent = dom.getParent;
    var getPosition = dom.getPosition;
    var moveElements = dom.moveElements;
    var setText = dom.setText;
    var addClass = dom.addClass;
    var formatDate = string.formatDate;
    var getByteLength = string.getByteLength;
    var encodeHTML = string.encodeHTML;
    var sliceByte = string.sliceByte;
    var indexOf = array.indexOf;
    var getView = util.getView;
    var blank = util.blank;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var setFocused = core.setFocused;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_INPUT_CONTROL = ui.InputControl;
    var UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
    var UI_PANEL = ui.Panel;
    var UI_PANEL_CLASS = UI_PANEL.prototype;
    var UI_CALENDAR_CLASS = ui.Calendar.prototype;
    var UI_CALENDAR_LAYER_CLASS = UI_CALENDAR_CLASS.Layer.prototype;
    var UI_CALENDAR_LAYER_SELECT_CLASS = UI_CALENDAR_LAYER_CLASS.Select.prototype;
    var UI_BUTTON = ui.Button;
    var UI_MONTH_VIEW_CLASS = ui.MonthView.prototype;

    //-------------------------------------------------
    // 
    //-------------------------------------------------

    /**
     * 
     *
     * @class
     * @param {Object} options 
     * @param {string} options.start 
     * @param {end} options.end 
     * @param {string} optoins.date 2012-12-12
     * @param {string} options.dateEnd RANGE2012-12-12
     * @param {number} optoins.now 
     * @param {string} options.mode 
     *      'DAY'(), 'WEEK', 'RANGE'
     * @param {string} options.viewMode 
     *      'POP'(), 'FIX' 
     * @param {boolean} options.shiftBtnDisabled buttonfalse
     */
    var UI_IST_CALENDAR = ui.IstCalendar =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-calendar',
            function(el, options) {
                options.hidden = true;
            },
            function(el, options) {
                var o = createDom();
                var child;
                var date;
                var type = this.getTypes()[0];

                this._sMode = options.mode || 'DAY';
                if (this._sMode == 'WEEK' || this._sMode == 'RANGE') {
                    addClass(el, type + '-range-mode');
                }

                this._sViewMode = options.viewMode || 'POP';
                if (this._sViewMode == 'FIX') {
                    addClass(el, type + '-fix-view');
                }

                o.innerHTML = [
                    '<span class="'+ type +'-btn-prv '+ type +'-btn"></span>',
                    '<span class="'+ type +'-text"></span>',
                    '<span class="'+ type +'-btn-nxt '+ type +'-btn"></span>',
                    '<span class="'+ type +'-btn-cal '+ type +'-btn"></span>',
                    '<div class="'+ type +'-layer" style="position:absolute;display:none"></div>'
                ].join('');

                child = children(o);

                this._oDate = PARSE_INPUT_DATE(options.date);
                if (this._sMode == 'RANGE') {
                    this._oDateEnd = PARSE_INPUT_DATE(options.dateEnd);
                }

                this._oRange = UI_CALENDAR_PARSE_RANGE(
                    options.start, 
                    options.end,
                    options.now
                );

                this._eText = child[1];
                
                // 
                if (options.shiftBtnDisabled) {
                    child[0].style.display = 'none';
                }
                this._uBtnPrv = $fastCreate(
                    this.Button, 
                    child[0], 
                    this, 
                    { command: 'prv', icon: true }
                );

                // 
                if (options.shiftBtnDisabled) {
                    child[2].style.display = 'none';
                }
                this._uBtnNxt = $fastCreate(
                    this.Button, 
                    child[2], 
                    this, 
                    { command: 'nxt', icon: true }
                );

                // 
                if (this._sViewMode == 'FIX') {
                    // FIX
                    child[3].style.display = 'none'; 
                }
                this._uBtnCal = $fastCreate(
                    this.Button, 
                    child[3], 
                    this, 
                    { command: 'cal', icon: true }
                );

                if (this._sViewMode == 'POP') {
                    DOCUMENT.body.appendChild(child[4]);
                }

                this._uLayer = $fastCreate(
                    this.Layer, 
                    child[4], 
                    this, 
                    {
                        date: this._oDate, 
                        range: this._oRange,
                        mode: this._sMode
                    }
                );

                moveElements(o, el, true);

                if (this._sViewMode == 'FIX') {
                    this.$showLayer();
                }
            }
        );

    var UI_IST_CALENDAR_CLASS = UI_IST_CALENDAR.prototype;

    var UI_IST_CALENDAR_BUTTON_CLASS = (
            UI_IST_CALENDAR_CLASS.Button = inheritsControl(
                UI_BUTTON, 
                null, 
                function(el, options){
                    var o = createDom();
                    var type = this.getType();
                
                    moveElements(el, o, true);
                    el.innerHTML = '<span class="'+ type +'-inner"></span>';
                    moveElements(o, el.firstChild, true);

                    if (options.icon) {
                        o = createDom(type + '-icon', '',  'span');
                        el.appendChild(o);
                    }

                    this._sCommand = options.command;
                }
            )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_CLASS = (
            UI_IST_CALENDAR_CLASS.Layer = 
                inheritsControl(UI_CALENDAR_CLASS.Layer)
        ).prototype;

    var UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS = (
            UI_IST_CALENDAR_LAYER_CLASS.MonthView = 
                inheritsControl(
                    UI_CALENDAR_CLASS.Layer.prototype.MonthView,
                    null,
                    function(el, options) {
                        this._sMode = options.mode;
                        this._oCellSelSet = {};
                        this._oCellHoverSet = {};
                    }
                )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS = (
            UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.Cell = inheritsControl(
                UI_CALENDAR_CLASS.Layer.prototype.MonthView.prototype.Cell
            )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_SELECT_OPTIONS_CLASS = (
            UI_CALENDAR_LAYER_SELECT_CLASS.Options = inheritsControl(
                UI_CALENDAR_LAYER_SELECT_CLASS.Options, 
                null, 
                null, 
                function(el, options) { 
                    addClass(el, 'ui-calendar-select-options'); 
                }
            )
        ).prototype;

    //-------------------------------------------------
    // 
    //-------------------------------------------------

    var UI_IST_CALENDAR_STR_PATTERN = 'yyyy-MM-dd';
    var UI_IST_CALENDAR_STR_PATTERN_SHOW = 'yyyy-MM-dd';

    var TIME_TYPE_WEEK = 1;
    var TIME_TYPE_MONTH = 2;
    var TIME_TYPE_QUARTER = 3;
    var DAY_MILLISECOND = 24*60*60*1000;
    var DATE_ZERO = new Date(0);

    //-------------------------------------------------
    // 
    //-------------------------------------------------
        
    function UI_CALENDAR_PARSE_RANGE(begin, end, now) {
        now = now != null ? new Date(now) : new Date();
        var res = {};
        var o = [now.getFullYear(), now.getMonth(), now.getDate()];
        var t;
        var p = {y:0, M:1, d:2};

        if (/^([-+]?)(\d+)([yMd])$/.test(begin)) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.begin = new Date(t[0], t[1], t[2]);
        }
        else if (
            Object.prototype.toString.call(begin) in {
                '[object String]': 1, '[object Date]': 1
            }
        ) {
            res.begin = new Date(begin);
        }

        if (/^([-+]?)(\d+)([yMd])$/.test(end)) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.end = new Date(t[0], t[1], t[2]);
        }
        else if (
            Object.prototype.toString.call(end) in {
                '[object String]': 1, '[object Date]': 1
            }
        ) {
            res.end = new Date(end);
        }

        return res ? res : {};
    }
    
    function UI_CALENDAR_WEEK_INFO(date) {
        var weekDay = date.getDay();
        var pre = -((weekDay + 6) % 7), next = (7 - weekDay) % 7;
        return {
            monday: new Date(date.getTime() + pre * DAY_MILLISECOND), 
            sunday: new Date(date.getTime() + next * DAY_MILLISECOND)
        };
    }

    function COMPARE_DATE(year1, month1, date1, year2, month2, date2) {
        if (year1 == year2) {
            if (month1 == month2) {
                if (date1 == date2) {
                    return 0;
                }
                else {
                    return date1 > date2 ? 1 : -1;
                }
            }
            else {
                return month1 > month2 ? 1 : -1;
            }
        }
        else {
            return year1 > year2 ? 1 : -1;
        }
    }

    function COMPARE_DATE_OBJ(date1, date2) {
        return COMPARE_DATE(
            date1.getFullYear(), date1.getMonth(), date1.getDate(),
            date2.getFullYear(), date2.getMonth(), date2.getDate()
        );        
    }

    function PARSE_INPUT_DATE(input) {
        var ret;
        if (input === false) {
            ret = null
        }
        else if (Object.prototype.toString.call(input) == '[object Date]') {
            ret = input;
        }
        else if (Object.prototype.toString.call(input) == '[object String]') {
            ret = input.split('-');
            ret = new Date(
                ret[0], 
                parseInt(ret[1], 10) - 1, 
                ret[2]
            );
        }
        return ret;
    }

    //----------------------------------------------
    // UI_IST_CALENDAR_BUTTON_CLASS 
    //----------------------------------------------

    UI_IST_CALENDAR_BUTTON_CLASS.$click = function(event) {
        var par = this.getParent();
        switch(this._sCommand) {
            case 'prv':
                par.go(-1, -1);
                break;
            case 'nxt':
                par.go(1, 1);
                break;
            case 'cal':
                par.$showLayer();
                break;
        }
        event.exit();
    };

    //----------------------------------------------
    // UI_IST_CALENDAR_CLASS 
    //----------------------------------------------

    UI_IST_CALENDAR_CLASS.$setSize = new Function();

    UI_IST_CALENDAR_CLASS.$showLayer = function() {
        var layer = this._uLayer;
        var pos = getPosition(this.getOuter());
        var posTop = pos.top + this.getHeight();

        if (!layer.isShow()) {

            layer.setDate(this.getDate());
            layer.show();
            setFocused(layer);

            if (this._sViewMode == 'POP') {
                var height = layer.getHeight();
                layer.setPosition(
                    pos.left,
                    posTop + height <= getView().bottom 
                        ? posTop : pos.top - height
                );
            }
        }
    }

    UI_IST_CALENDAR_CLASS.getMode = function() {
        return this._sMode;
    }    

    UI_IST_CALENDAR_CLASS.$flush = function() {
        var curDate = this._oDate;
        var range = this._oRange;

        if (range.begin && range.begin.getTime() == curDate.getTime()) {
            this._uBtnPrv.disable();
        }
        else {
            this._uBtnPrv.enable();
        }
        
        if (range.end && range.end.getTime() == curDate.getTime()) {
            this._uBtnNxt.disable();
        }
        else {
            this._uBtnNxt.enable();
        }
    }

    UI_IST_CALENDAR_CLASS.$click = function(event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this);
        if (event.target == this._eText) {
            this.$showLayer();
        }
    };

    UI_IST_CALENDAR_CLASS.$activate = function (event) {
        var layer = this._uLayer;
        var con;
        var pos = getPosition(this.getOuter());
        var posTop = pos.top + this.getHeight();

        UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
        if (!layer.isShow()) {
            layer.setDate(this.getDate(), this.getDateEnd(), null, true);
            layer.show();
            con = layer.getHeight();
            layer.setPosition(
                pos.left,
                posTop + con <= getView().bottom ? posTop : pos.top - con
            );
            setFocused(layer);
        }
    };

    UI_IST_CALENDAR_CLASS.go = function(offset, offsetEnd) {
        var newDate = new Date(
                this._oDate.getFullYear(), 
                this._oDate.getMonth(), 
                this._oDate.getDate() + offset
            );

        var newDateEnd;
        if (this._sMode == 'RANGE') {
            newDateEnd = new Date(
                this._oDateEnd.getFullYear(), 
                this._oDateEnd.getMonth(), 
                this._oDateEnd.getDate() + offsetEnd
            );
        }

        this.setDate(newDate, newDateEnd, null, true);
        triggerEvent(this, 'change', null, [newDate, newDateEnd]);
    };

    UI_IST_CALENDAR_CLASS.getDate = function() {
        return this._oDate;
    };
    
    UI_IST_CALENDAR_CLASS.getDateEnd = function() {
        return this._oDateEnd;
    };
    
    UI_IST_CALENDAR_CLASS.getWeekInfo = function() {
        return UI_CALENDAR_WEEK_INFO(this._oDate);
    };

    UI_IST_CALENDAR_CLASS.setDate = function(
        date, dateEnd, remainLayer, remainRangeSelStatus
    ) {
        var layer = this._uLayer;
        var range = this._oRange;
        var ntxt; 
        var weekInfo;

        if ((range.begin && range.begin.getTime() > date.getTime()) 
            || (range.end && range.end.getTime() < date.getTime())
        ) {
            return;
        }

        if (this._sViewMode == 'POP' && this._uLayer.isShow() && !remainLayer) {
            this._uLayer.hide();
        }
        
        if (date != null) {
            // 
            if (this._sMode == 'WEEK') {
                weekInfo = UI_CALENDAR_WEEK_INFO(date);
                ntxt = formatDate(
                        maxDate(weekInfo.monday, range.begin), 
                        UI_IST_CALENDAR_STR_PATTERN_SHOW
                    )
                    + '  ' 
                    + formatDate(
                        minDate(weekInfo.sunday, range.end), 
                        UI_IST_CALENDAR_STR_PATTERN_SHOW
                    );
            } 
            // 
            else if (this._sMode == 'RANGE') {
                if (!remainRangeSelStatus || !this._sRangeSelStatus) {
                    this._sRangeSelStatus = 'END';
                }
                ntxt = formatDate(date, UI_IST_CALENDAR_STR_PATTERN_SHOW);
                if (dateEnd) {
                    ntxt += '  ' + formatDate(dateEnd, UI_IST_CALENDAR_STR_PATTERN_SHOW);
                }
                else {
                    if (this._sViewMode == 'POP') {
                        // fake
                        ntxt += [
                            '<span class="', this.getType(), '-fake-text">',
                            '  ' + formatDate(DATE_ZERO, UI_IST_CALENDAR_STR_PATTERN_SHOW),
                            '</span>',
                        ].join('');
                    }
                }
            }
            // 
            else {
                ntxt = formatDate(date, UI_IST_CALENDAR_STR_PATTERN_SHOW);
            }
        } else {
            ntxt = '';
        }

        this._eText.innerHTML = ntxt;
        this.setValue(ntxt.replace(/\//g, '-'));

        this._oDate = date;
        if (this._sMode == 'RANGE') {
            this._oDateEnd = dateEnd;
        }

        if (this._sViewMode == 'FIX') {
            this._uLayer.setDate(date);
        }

        this.$flush();
    };

    UI_IST_CALENDAR_CLASS.init = function() {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this._uLayer.init();
        this.setDate(this.getDate(), this.getDateEnd());
    };

    UI_IST_CALENDAR_CLASS.$cache = function(style, cacheSize) {
        UI_INPUT_CONTROL_CLASS.$cache.call(this, style, cacheSize);
        this._uLayer.cache(true, true);
    };

    UI_IST_CALENDAR_CLASS.setRange = function(begin, end) {
        var cal = this._uLayer._uMonthView;
        cal.setRange(begin, end, true);
    };

    function minDate(date1, date2) {
        if (!date2) { return date1; }
        if (!date1) { return date2; }
        return date1.getTime() > date2.getTime() ? date2 : date1;
    }

    function maxDate(date1, date2) {
        if (!date2) { return date1; }
        if (!date1) { return date2; }
        return date1.getTime() > date2.getTime() ? date1 : date2;        
    }
    
    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_CLASS 
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_CLASS.ondateclick = function(event, date) {
        var par = this.getParent();

        // RANGE
        if (this._sMode != 'RANGE' 
            && (!par.getDate() 
                || par.getDate().getTime() != date.getTime()
            )
        ) {
            par.setDate(date, null, null, true);
            /**
             * @event
             * @param {Date} selected date
             */
            triggerEvent(par, 'change', null, [date])
        }

        // RANGE
        else if (this._sMode == 'RANGE') {
            this._oDateSel = null;
            if (par._sRangeSelStatus == 'BEGIN') {
                par._sRangeSelStatus = 'END';
                var start = par.getDate();
                var end = date;
                if (start && end && COMPARE_DATE_OBJ(start, end) > 0) {
                    var tmp = end;
                    end = start;
                    start = tmp;
                }
                par.setDate(start, end, false, true);

                /**
                 * @event
                 * @param {string} ragneSelStatus 'BEGIN''END'
                 * @param {Date} begin date
                 * @param {Date} end date
                 */
                triggerEvent(
                    par,
                    'change',
                    null,
                    [par.getDate(), date]
                )
            }
            else {
                par._sRangeSelStatus = 'BEGIN';
                // layer
                par.setDate(date, null, true, true);
            }

        }

        // 
        else {
            this.hide();
        }
    };    

    UI_IST_CALENDAR_LAYER_CLASS.hide = function() {
        if (this.getParent()._sViewMode == 'FIX') {
            return;
        }

        if (this.isShow()) {
            var calCon = this.getParent();
            calCon && triggerEvent(calCon, 'layerhide');
        }
        UI_IST_CALENDAR_CLASS.Layer.superClass.hide.apply(this, arguments);
    };

    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS 
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$setSelected = function(cell) {

        function removeStyle(c) { c.alterClass('-selected'); }
        function addStyle(c) { c.alterClass('+selected'); }
        var me = this;

        if (this._uCellSel) {
            // select
            if (this._sMode == 'WEEK') {
                this.$travelWeek(this._uCellSel, removeStyle);
            }
            // select
            else if (this._sMode == 'DAY') {
                removeStyle(this._uCellSel);
            }
        }

        if (cell) {
            // select
            if (this._sMode == 'WEEK') {
                this.$travelWeek(cell, addStyle);
            }
            // select
            else if (this._sMode == 'DAY') {
                addStyle(cell);
            }
            this._uCellSel = cell;
        }

        // select
        if (this._sMode == 'RANGE') {
            var calCon = this.getParent() 
                    ? this.getParent().getParent() : null;

            // 
            if (calCon && calCon._sRangeSelStatus == 'BEGIN') {
                for (var i in this._oCellSelSet) {
                    removeStyle(this._oCellSelSet[i]);
                    delete this._oCellSelSet[i];
                }
                var cellWrap = this.$getCellByDate(calCon.getDate());
                if (cellWrap) {
                    this._oCellSelSet[cellWrap.index] = cellWrap.cell;
                    addStyle(cellWrap.cell);
                }
            }
            // 
            else if (calCon && calCon._sRangeSelStatus == 'END') {
                this.$travelMonth(
                    function(c, i, isThisMonth) {

                        var isInRange;
                        if (isThisMonth) {
                            isInRange = me.$isCellInRange(
                                c, calCon.getDate(), calCon.getDateEnd()
                            );
                        }

                        if (isThisMonth 
                            && isInRange 
                            && !(i in me._oCellSelSet)
                        ) {
                            me._oCellSelSet[i] = c;
                            addStyle(c);
                        }
                        else if (
                            (!isInRange || !isThisMonth) 
                            && (i in me._oCellSelSet)
                        ) {
                            delete me._oCellSelSet[i];
                            removeStyle(c);
                        }
                    }
                );
            }
            // 
            else {
                for (var i in this._oCellSelSet) {
                    delete this._oCellSelSet[i];
                    removeStyle(this._oCellSelSet[i]);
                }
            }
        }
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$setHovered = function(
        cell, hovered
    ) {
        function addStyle(c) { c.alterClass('+hover'); }
        function removeStyle(c) { c.alterClass('-hover'); }
        var cellIndex = indexOf(this._aCells, cell);
        var me = this;

        if (cell) {
            // hover
            if (this._sMode == 'WEEK') {
                this.$travelWeek(cell, (hovered ? addStyle : removeStyle));
            }

            // hover
            else if (this._sMode == 'DAY') {
                hovered ? addStyle(cell) : removeStyle(cell);
            }

            // hover
            else if (this._sMode == 'RANGE') {
                var calCon = this.getParent().getParent();
                var start = calCon.getDate();
                var end = new Date(this._nYear, this._nMonth, cell._nDay);
                if (start && end && COMPARE_DATE_OBJ(start, end) > 0) {
                    var tmp = end;
                    end = start;
                    start = tmp;
                }

                // 
                if (calCon._sRangeSelStatus == 'BEGIN') {
                    this.$travelMonth(
                        function(c, i, isThisMonth) {
                            var isInRange;
                            if (isThisMonth) {
                                isInRange = me.$isCellInRange(c, start, end);
                            }
                            if (hovered
                                && isThisMonth 
                                && isInRange 
                                && !(i in me._oCellHoverSet)
                            ) {
                                me._oCellHoverSet[i] = c;
                                addStyle(c);
                            }
                            else if (
                                (!hovered || !isThisMonth || !isInRange)
                                && (i in me._oCellHoverSet)
                            ) {
                                delete me._oCellHoverSet[i];
                                removeStyle(c);
                            }
                        }
                    );
                }
                // 
                else {
                    this.$travelMonth(
                        function(c, i, isThisMonth) {
                            if ((!hovered || !isThisMonth)
                                && (i in me._oCellHoverSet)
                            ) {
                                delete me._oCellHoverSet[i];
                                removeStyle(c);
                            }
                        }
                    );
                    if (hovered) {
                        this._oCellHoverSet[cellIndex] = cell;
                        addStyle(cell);
                    }
                }
            }

        }
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$travelWeek = function(
        cell, callback
    ) {
        if (cell) {
            var currDate = new DATE(this._nYear, this._nMonth, cell._nDay);
            var index = indexOf(this._aCells, cell);
            index -= ((currDate.getDay() + 6) % 7);
            for (var i = 0; i < 7; i++) {
                callback.call(this, this._aCells[index + i]);    
            } 
        }  
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$travelMonth = function(callback) {
        var lastDateOfThisMonth = 
                new Date(this._nYear, this._nMonth + 1, 0).getDate();
        for (var i = 7, cell, isThisMonth; cell = this._aCells[i]; i ++) {
            isThisMonth = cell._nDay > 0 && cell._nDay <= lastDateOfThisMonth;
            callback(cell, i, isThisMonth);
        }
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$getCellByDate = function(date) {
        if (!date 
            || this._nYear != date.getFullYear() 
            || this._nMonth != date.getMonth()
        ) {
            return null;
        }
        var day = date.getDate();
        for (var i = 0, cell; cell = this._aCells[i]; i ++) {
            if (cell._nDay == day) { 
                return {cell: cell, index: i};
            }
        }
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$isCellInRange = function(
        cell, beginDate, endDate
    ) {
        if (!cell || !beginDate || !endDate) {
            return false;
        }

        var beginY = beginDate && beginDate.getFullYear();
        var beginM = beginDate && beginDate.getMonth();
        var beginD = beginDate && beginDate.getDate();
        var endY = endDate && endDate.getFullYear(); 
        var endM = endDate && endDate.getMonth();
        var endD = endDate && endDate.getDate();

        if ((   
                COMPARE_DATE(
                    beginY, beginM, beginD,
                    this._nYear, this._nMonth, cell._nDay
                ) <= 0
            )
            && (
                COMPARE_DATE(
                    this._nYear, this._nMonth, cell._nDay,
                    endY, endM, endD
                ) <= 0
            )
        ) {
            return true;
        }

        return false; 
    };
    
    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS 
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS.$mouseover = function() {
        var parent = this.getParent();
        var index = indexOf(parent._aCells, this);
        // celldisabledmouseover
        (index >= 7) && parent.$setHovered(this, true);  
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS.$mouseout = function() {
        var parent = this.getParent();
        var index = indexOf(parent._aCells, this);
        // celldisabledmouseout
        (index >= 7) && parent.$setHovered(this, false);   
    };

    UI_CALENDAR_LAYER_SELECT_CLASS.$mousewheel = blank;

})();


/**
 * data tree
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    data-tree.js
 * desc:    
 *          
 * author:  cxl(chenxinle@baidu.com)
 * date:    2012/03/12
 */
(function () {
    var core = ecui,
        array = core.array,
        ui = core.ui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        util = core.util,

        $fastCreate = core.$fastCreate,
        getMouseX = core.getMouseX,
        inheritsControl = core.inherits,
        getOptions = core.getOptions,
        disposeControl = core.dispose,
        triggerEvent = core.triggerEvent,
        extend = util.extend,
        indexOf = array.indexOf,
        extend = util.extend,
        toNumber = util.toNumber,
        getStyle = dom.getStyle,
        first = dom.first,
        insertAfter = dom.insertAfter,
        trim = string.trim,
        blank = util.blank,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_TREE_VIEW = ui.TreeView,
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype,

        UI_DATA_TREE = ui.DataTree = 
        inheritsControl(
            UI_TREE_VIEW,
            'ui-data-tree',
            function (el, options) {
                options.expandSelected = options.expandSelected === true;

                if (first(el) && 'divlabel'.indexOf(first(el).tagName.toLowerCase()) >= 0) {
                    extend(options, getOptions(first(el)));
                }

                if (options.value) {
                    options.value += '';
                }

                options.resizable = false;
            },
            function (el, options) {
                this._aSelected = [];
                this._sValue = options.value;
                this._bHideRoot = options.hideRoot === true; //
                this._bSelectAble = options.selectable !== false;
                this._bMultiSelect = options.multi === true;
                this._bAsyn = options.asyn;
                this._bIsLeaf = options.isLeaf;
                if (options.asyn && !options.isLeaf && this._aChildren.length <= 0) {
                    this.add('Loadding', null);
                    this.collapse();
                    this._bNeedAsyn = true;                        
                }
            }
        ),
        
        UI_DATA_TREE_CLASS = UI_DATA_TREE.prototype;

    function UI_DATA_TREE_VIEW_FLUSH(control) {
        control.setClass(
            control.getPrimary() + (control._aChildren.length ? control._bCollapsed ? '-collapsed' : '-expanded' : '')
        );
    }

    UI_DATA_TREE_CLASS.init = function () {
        UI_TREE_VIEW_CLASS.init.call(this);

        if (this._bHideRoot && this == this.getRoot()) {
            this.hide();
            this.expand();
        }
    }

    UI_DATA_TREE_CLASS.$setParent = function (parent) {
        var root = this.getRoot(),
            selected = root._aSelected,
            o = this.getParent(), i;

        // 
        if ((i = indexOf(selected, this)) >= 0) {
            root.$setSelected(this, false);
        }

        if (this !== root) {
            remove(o._aChildren, this);
            UI_DATA_TREE_VIEW_FLUSH(o);
        }

        UI_CONTROL_CLASS.$setParent.call(this, parent);

        // 
        if (this._eChildren) {
            insertAfter(this._eChildren, this.getOuter());
        }
    }

    UI_DATA_TREE_CLASS.getValue = function () {
        return this._sValue;
    }

    UI_DATA_TREE_CLASS.getText = function () {
        return trim(this.getContent().replace(/<[^>]+>/g, ''));
    }

    UI_DATA_TREE_CLASS.getSelected = function () {
        if (this == this.getRoot()) {
            return this._aSelected.slice();
        }
    }

    UI_DATA_TREE_CLASS.getSelectedValues = function () {
        var res = [], i, item;
        if (this == this.getRoot()) {
            for (i = 0; item = this._aSelected[i]; i++) {
                res.push(item.getValue());
            }
            return this._bMultiSelect ? res : res[0];
        }
    }

    UI_DATA_TREE_CLASS.setValues = function (values) {
        var item;
        if (indexOf(values, this._sValue) >= 0) {
            this.getRoot().$setSelected(this, true);
            item = this;
            while((item = item.getParent()) && item instanceof UI_TREE_VIEW) {
                if (item.isCollapsed()) {
                    item.expand()
                }
            }
        }
        for (var i = 0, item; item = this._aChildren[i]; i++) {
            item.setValues(values);
        }
    }

    UI_DATA_TREE_CLASS.getItemByValue = function (value) {
        var res = null;

        if (this._sValue == value) {
            res = this;
        }
        for (var i = 0, item; (item = this._aChildren[i]) && res == null; i++) {
            res = item.getItemByValue(value);
        }
        return res;
    }

    UI_DATA_TREE_CLASS.load = function (datasource) {
        var i, item, text;

        for (i = 0; item = this._aChildren[i]; i++) {
            disposeControl(item);
        }
        this._aChildren = [];
        this._eChildren.innerHTML = '';

        for (i = 0; item = datasource[i]; i++) {
            text = item.text;
            item = extend({asyn: this._bAsyn}, item);
            delete item.text;
            this.add(text, null, item).init();
        }
    }

    UI_DATA_TREE_CLASS.$expand = function (item) {
        var superObj = item.getRoot();
        if (item._bNeedAsyn) {
            triggerEvent(superObj, 'load', null, [item.getValue(), function (data) {item.load(data)}]);
            item._bNeedAsyn = false;
        }
    }

    UI_DATA_TREE_CLASS.$click = function (event) {
        if (event.getControl() == this) {
            UI_CONTROL_CLASS.$click.call(this, event);

            if (getMouseX(this) <= toNumber(getStyle(this.getBody(), 'paddingLeft'))) {
                this.clickEC();
            }
            else {
                this.clickItem();
            }
        }
    }

    // QAapi
    UI_DATA_TREE_CLASS.clickEC = function () {
        var e;
        this[e = this.isCollapsed() ? 'expand' : 'collapse']();
        triggerEvent(this.getRoot(), e, null, [this]);
    }

    // QAapi
    UI_DATA_TREE_CLASS.clickItem = function () {
        var added = null;
        if (indexOf(this.getRoot()._aSelected, this) >= 0) {
            if (this._bMultiSelect) {
                added = false;    
            }
        }
        else {
            added = true;
        }
        this.getRoot().setSelected(this);
        triggerEvent(this.getRoot(), 'select', null, [this, added == true])
        if (added !== null) {
            triggerEvent(this.getRoot(), 'change', null, [this.getValue(), added]);
        }
    }

    UI_DATA_TREE_CLASS.getSelectedText = function () {
        var res = [], i, item;
        if (this == this.getRoot()) {
            for (i = 0; item = this._aSelected[i]; i++) {
                res.push(item.getText());
            }
            return res.join(',');
        }
    }

    UI_DATA_TREE_CLASS.setSelectAble = function (enable) {
        var root = this.getRoot(), i;

        if (!this.enable && (i = indexOf(root._aSelected, this)) >= 0) {
            root.$setSelected(this, false);
        }
        this._bSelectAble = enable;
    }

    UI_DATA_TREE_CLASS.$setSelected = function (node, flag) {
        var selected, i;
        if (this == this.getRoot()) {
            selected = this._aSelected;
            i = indexOf(selected, node);
            if (flag === true) {
                if (i < 0) {
                    selected.push(node);
                    node.alterClass('+selected');
                }
            }
            else if (flag === false) {
                if (i >= 0) {
                    selected.splice(i, 1);
                    node.alterClass('-selected');
                }
            }
        }
    }

    UI_DATA_TREE_CLASS.clearSelected = function () {
        var selected, i, item;
        
        if (this == this.getRoot()) {
            selected = this._aSelected;
            while(item = selected[0]) {
                this.$setSelected(item, false);
            }
        }
    }

    UI_DATA_TREE_CLASS.setSelected = function (node, force) {
        var selected, i;

        if (this == this.getRoot() && node._bSelectAble) {
            selected = this._aSelected;                    
            i = indexOf(selected, this);
            if ((i = indexOf(selected, node)) >= 0) {
                if (!force && this._bMultiSelect) {
                    this.$setSelected(node, false);
                }
            }
            else {
                if (!this._bMultiSelect && selected.length >= 1) {
                    this.$setSelected(selected[0], false);
                }
                this.$setSelected(node, true);
            }

            if (node && this._bExpandSelected) {
                node.expand();
            }
        }
    };

    UI_DATA_TREE_CLASS.$setSize = blank;
})();

/*
MultiSelect - 


HTML:
<select ecui="type:multi-select;option-size:3" name="test">
    <!--  -->
    <option value=""></option>
    ...
    <option value="" selected></option>
    ...
</select>

:
<div ecui="type:multi-select;name:test;option-size:3">
    <!--  -->
    <li ecui="value:"></li>
    ...
</div>

Item
_eInput - INPUT
*/
//{if 0}//
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        indexOf = array.indexOf,
        getText = dom.getText,
        removeDom = dom.remove,
        createDom = dom.create,
        setInput = dom.setInput,
        extend = util.extend,
        inherits = util.inherits,

        getKey = core.getKey,
        mask = core.mask,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_ITEMS = ui.Items,
        UI_SELECT = ui.Select,
        UI_SELECT_CLASS = UI_SELECT.prototype,
        UI_SELECT_ITEM = UI_SELECT_CLASS.Item,
        UI_SELECT_ITEM_CLASS = UI_SELECT_ITEM.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 
     * options 
     * optionSize 5
     * @public
     *
     * @param {Object} options 
     */
    //__gzip_original__UI_MULTI_SELECT
    //__gzip_original__UI_MULTI_SELECT_ITEM
    var UI_MULTI_SELECT = ui.MultiSelect = 
        inheritsControl(
            UI_SELECT,
            'ui-multi-select',
            function (el, options) {
                options.hide = true;
                if (options.value) {
                    options.value = options.value.toString();
                }
            },
            function(el, options) {
                var values;

                if (options.maxlength) {
                    this._nTextLen = options.maxlength;
                }
                if (options.textAll) {
                    this._sTextAll = options.textAll;
                }
                if (options.textNone) {
                    this._sTextNone = options.textNone;
                }
                if (options.maxSelected) {
                    this._nMaxSelected = options.maxSelected;
                }
                else if (options.selectAllButton) {
                    this.add('', 0, {selectAllButton: true});
                    this._bSelectAllBtn = true;
                }
                if (options.tip) {
                    this._bTip = true;
                }
                if (options.value) {
                    this.setValue(options.value);
                }
                if (options.selectAll) {
                    this._bInitSelectAll = true;
                }
                if (options.minSelected) {
                    this._nMinSelected = options.minSelected;
                }

                this._eInput.disabled = true;
            }
        ),
        UI_MULTI_SELECT_CLASS = UI_MULTI_SELECT.prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_MULTI_SELECT_ITEM = UI_MULTI_SELECT_CLASS.Item =
            inheritsControl(
            UI_SELECT_ITEM,
            'ui-multi-select-item',
            function (el, options) {
                var type = this.getTypes()[0],
                    o = createDom(type + '-icon');
                
                this._bSelectAllBtn = options.selectAllButton;
                this._sTip = options.tip ? options.tip : getText(el);

                el.insertBefore(o, el.firstChild);
                el = this._eInput =
                    options.parent.getMain().appendChild(setInput(null, options.parent.getName(), 'checkbox'));

                options.value === undefined ? el.value = '' : el.value = options.value;
                el.style.display = 'none';
            }
        ),
        UI_MULTI_SELECT_ITEM_CLASS = UI_MULTI_SELECT_ITEM.prototype;
//{else}//
    
    /**
     * 
     * @private
     */
    function UI_MULTI_SELECT_FLUSH_SELECTALL(control, status) {
        var items = control.getItems();

        if (!control._bSelectAllBtn) {
            return;
        }

        if (status === undefined) {
            status = control.getSelected().length === items.length - 1;
            items[0].$setSelected(status);
        }
        else {
            for (var i = 0, item; item = items[i]; i++) {
                item.$setSelected(status);
            }
        }
    }

    /**
     * 
     * @private
     *
     * @param {ecui.ui.MultiSelect} control 
     */
    function UI_MULTI_SELECT_FLUSH_TEXT(control) {
        var tip;
        if (control) {
            var btnAllSelected = false;
            for (var i = 0, list = control.getItems(), o, text = []; o = list[i++]; ) {
                if (o.isSelected()) {
                    if (o._bSelectAllBtn) {
                        btnAllSelected = true;
                    }
                    else {
                        text.push(o._sTip);
                    }
                }
            }
            tip = '<span title="'+ text.join(',') +'">';
            if (
                control._sTextAll
                && (text.length != 0 || btnAllSelected)
                && text.length == list.length + (control._bSelectAllBtn ? -1 : 0) 
            ) {
                text = control._sTextAll;
            }
            else if (text.length == 0 && control._sTextNone) {
                text = control._sTextNone;
            }
            else {
                text = text.join(',');
                if (control._nTextLen && text.length > control._nTextLen) {
                    text = text.substring(0, control._nTextLen) + '...';
                }
            }
            if (control._bTip) {
                text = tip + text + '</span>';
            }
            control.$getSection('Text').setContent(text);
        }
    }

    extend(UI_MULTI_SELECT_CLASS, UI_ITEMS);

    /**
     * 
     * ( isEnabled)click  onclick  false $click 
     * @protected
     *
     * @param {Event} event 
     */
    UI_MULTI_SELECT_ITEM_CLASS.$click = function (event) {
        var par = this.getParent(),
            selected = par.getSelected().length;

        UI_SELECT_ITEM_CLASS.$click.call(this, event);
        if (!this.isSelected()) {
            if (!par._nMaxSelected || par._nMaxSelected >= selected + 1) {
                this.setSelected(true);
            }
        }
        else {
            if (!par._nMinSelected || par._nMinSelected <= selected - 1) {
                this.setSelected(false);
            }
        }
    };

    /**
     * 
     *  IE $dispose  ondispose 
     * @protected
     */
    UI_MULTI_SELECT_ITEM_CLASS.$dispose = function () {
        this._eInput = null;
        UI_SELECT_ITEM_CLASS.$dispose.call(this);
    };

    /**
     * 
     * @protected
     *
     * @return {boolean} 
     */
    UI_MULTI_SELECT_ITEM_CLASS.isSelected = function () {
        return this._eInput.checked;
    };

    /**
     *
     */
    UI_MULTI_SELECT_ITEM_CLASS.$setSelected = function (status) {
        this._eInput.checked = status !== false;
        this.setClass(this.getPrimary() + (this._eInput.checked ? '-selected' : ''));
    }

    /**
     * 
     * @protected
     *
     * @param {boolean} status 
     */
    UI_MULTI_SELECT_ITEM_CLASS.setSelected = function (status) {
        this.$setSelected(status);
        UI_MULTI_SELECT_FLUSH_SELECTALL(this.getParent(), this._bSelectAllBtn ? status : undefined);
        UI_MULTI_SELECT_FLUSH_TEXT(this.getParent());
    };

    /**
     * 
     *   /
     * @protected
     */
    UI_MULTI_SELECT_CLASS.$alterItems = function () {
        UI_SELECT_CLASS.$alterItems.call(this);
        UI_MULTI_SELECT_FLUSH_SELECTALL(this);
        UI_MULTI_SELECT_FLUSH_TEXT(this);
    };

    /**
     * 
     * 
     * @protected
     *
     * @param {ecui.ui.Item} child 
     * @return {boolean} 
     */
    UI_MULTI_SELECT_CLASS.$append = function (item) {
        UI_SELECT_CLASS.$append.call(this, item);
        this.getMain().appendChild(setInput(item._eInput, this.getName()));
    };

    /**
     * 
     * (setSizealterClass ) Element  clearCache 
     * @protected
     *
     * @param {CssStyle} style  Element  Css 
     * @param {boolean} cacheSize 
     */
    UI_MULTI_SELECT_CLASS.$cache = UI_SELECT_CLASS.$cache;

    /**
     * 
     * 
     * @protected
     *
     * @param {Event} event 
     */
    UI_MULTI_SELECT_CLASS.$intercept = function (event) {
        for (var control = event.getControl(); control; control = control.getParent()) {
            if (control instanceof UI_MULTI_SELECT_ITEM) {
                //ECUIfixby hades
                event.target = control.getOuter();
                return false;
            }
        }
        this.$getSection('Options').hide();
        triggerEvent(this, 'change');
        event.exit();
    };

    /**
     * /
     * ( isEnabled)keyup  onkeyup  false $keyup 
     * @protected
     *
     * @param {Event} event 
     */
    UI_MULTI_SELECT_CLASS.$keydown = UI_MULTI_SELECT_CLASS.$keypress = UI_MULTI_SELECT_CLASS.$keyup =
        function (event) {
            UI_INPUT_CONTROL_CLASS['$' + event.type].call(this, event);
            if (!this.$getSection('Options').isShow()) {
                return false;
            }

            var key = getKey();
            if (key == 13 || key == 32) {
                if (event.type == 'keyup') {
                    key = this.getActived();
                    key.setSelected(!key.isSelected());
                }
                return false;
            }
        };

    /**
     * 
     * ( isEnabled)mousewheel  onmousewheel  false $mousewheel 
     * @protected
     *
     * @param {Event} event 
     */
    UI_MULTI_SELECT_CLASS.$mousewheel = function (event) {
        var options = this.$getSection('Options');
        if (options.isShow()) {
            options.$mousewheel(event);
        }
        return false;
    };

    /**
     * 
     * @protected
     *
     * @param {Event} event 
     */
    UI_MULTI_SELECT_CLASS.$deactivate = UI_SELECT_CLASS.$deactivate;

    /**
     * 
     * @protected
     *
     * @param {Event} event 
     */
    UI_MULTI_SELECT_CLASS.$activate = function (event) {
        var con = event.getControl();
        if (!(con instanceof UI_MULTI_SELECT_ITEM)) {
            UI_SELECT_CLASS.$activate.call(this, event);
        }
    }

    /**
     * 
     * 
     * @protected
     */
    UI_MULTI_SELECT_CLASS.$ready = function () {
        UI_MULTI_SELECT_FLUSH_SELECTALL(this);
        UI_MULTI_SELECT_FLUSH_TEXT(this);

        if (this._bInitSelectAll) {
            for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
                !o._bSelectAllBtn && o.setSelected(true);
            }
        }
    };

    /**
     * 
     * 
     * @protected
     *
     * @param {ecui.ui.Item} child 
     */
    UI_MULTI_SELECT_CLASS.$remove = function (item) {
        UI_SELECT_CLASS.$remove.call(this, item);
        this.getMain().removeChild(item._eInput);
    };

    /**
     * 
     * @protected
     *
     * @param {number} width 
     * @param {number} height 
     */
    UI_MULTI_SELECT_CLASS.$setSize = UI_SELECT_CLASS.$setSize;

    /**
     * 
     * @protected
     *
     * @return {Array} 
     */
    UI_MULTI_SELECT_CLASS.getSelected = function () {
        for (var i = 0, list = this.getItems(), o, result = []; o = list[i++]; ) {
            if (o.isSelected() && !o._bSelectAllBtn) {
                result.push(o);
            }
        }
        return result;
    };

    UI_MULTI_SELECT_CLASS.getValue = function () {
        var items = this.getSelected(),
            res = [], i, len;
        for (i = 0, len = items.length; i < len; i++) {
            if (!items[i]._bSelectAllBtn) {
                res.push(items[i]._eInput.value);
            }
        }
        return res;
    };

    /**
     * 
     * @return {Array} 
     */
    UI_MULTI_SELECT_CLASS.getAllValue = function() {
        var items = this.getItems();
        var res = [];
        var i = 0;
        for (i = 0; i < items.length; i++) {
            if (!items[i]._bSelectAllBtn) {
                res.push(items[i].getValue());
            }
        }
        return res;
    };

    UI_MULTI_SELECT_CLASS.selectAll = function () {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            !o._bSelectAllBtn && o.setSelected(true);
        }
    };

    UI_MULTI_SELECT_CLASS.isSelectAll = function () {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            if (!o.isSelected()) {
                return false;
            }
        }
        return true;
    };

    /**
     * 
     * 
     * @public
     *
     * @param {number} value  1
     */
    UI_MULTI_SELECT_CLASS.setOptionSize = UI_SELECT_CLASS.setOptionSize;

    /**
     * 
     * @public
     *
     * @param {Array/String} values 
     */
    UI_MULTI_SELECT_CLASS.setValue = function (values) {
        if ('[object Array]' != Object.prototype.toString.call(values)) {
            values = values.toString().split(',');
        }
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            o.setSelected(indexOf(values, o._eInput.value) >= 0);
        }
        UI_MULTI_SELECT_FLUSH_SELECTALL(this);
        UI_MULTI_SELECT_FLUSH_TEXT(this);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * @author quyatong
 */

(function() {
    var core = ecui,
        ui = core.ui,
        dom = core.dom,
        string = core.string,
        util = core.util,
        disposeControl = core.dispose,
        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        findControl = core.findControl,
        first = dom.first,
        last = dom.last,
        children = dom.children,
        createDom = dom.create,
        removeDom = dom.remove,
        addClass = dom.addClass,
        removeClass = dom.removeClass,
        setText = dom.setText,
        moveElements = dom.moveElements,
        blank = util.blank,
        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_INPUT = ui.InputControl, //.Input,
        UI_INPUT_CLASS = UI_INPUT.prototype,
        UI_SELECT = ui.Select,

        attachEvent = util.attachEvent,
        detachEvent = util.detachEvent,
        repaint = core.repaint,
        WINDOW = window,
        UI_IST_CALENDAR = ui.IstCalendar;

    var UI_CALENDAR_PLUS = ui.CalendarPlus = inheritsControl(UI_CONTROL, "ui-calendar-plus", preProcess, process);

    var UI_CALENDAR_PLUS_CLASS = UI_CALENDAR_PLUS.prototype;

    UI_CALENDAR_PLUS_CLASS.Button = inheritsControl(
        UI_BUTTON, 
        null, 
        function(el, options) {
            var o = createDom();
            var type = this.getType();
        
            moveElements(el, o, true);
            el.innerHTML = '<span class="'+ type +'-inner"></span>';
            moveElements(o, el.firstChild, true);

            o = createDom(type + '-icon', '',  'span');
            el.appendChild(o);
        }
    );

    UI_CALENDAR_PLUS_CLASS.$setSize = new Function();
    
    UI_CALENDAR_PLUS_CLASS.setData = function (options) {
        var el = this.getOuter();
        this.$disposeInner();
        el.innerHTML = '';
        this.$setBody(el);

        preProcess.call(this, el, options);
        process.call(this, el, options);
    };

    UI_CALENDAR_PLUS_CLASS.$disposeInner = function (options) {
        // setDate
        // 
        for (var key in this) {
            if (this.hasOwnProperty(key) 
                && key.indexOf('_u') >= 0
                && this[key] instanceof UI_CONTROL
            ) {
                disposeControl(this[key]);
                this[key] = null;
            }
        }
    };

    /**
     * 
     * @param {EcuiElement} ecui
     * @param {Ojbect} options ecui
     *
     */
     function preProcess(el, options) {
        var uiType = this.getType(); 
        setDefaultOptions(options);
        var types = options.types;
        var tagNames = options.tagNames;
        var list = [];
        var listBox = [];
        for (var i = 0, item; item = types[i]; i++) {
            if (item == 'D') {
               list.push('<option value="day">' + tagNames[i] + '</option>' );
            } 
            if (item == 'W') {
               list.push('<option value="week">'  + tagNames[i] +  '</option>' );
            } 
            if (item == 'M') {
               list.push('<option value="month">'   + tagNames[i] + '</option>' );
            }
            if (item == 'Q') {
               list.push('<option value="quarter">'  + tagNames[i] + '</option>' );
            }
        }

        listBox.push('<div style="display:none" class="time-box-day"><div data-id="day-calendar" class="ui-calendar"></div></div>');
        listBox.push('<div style="display:none" class="time-box-week"><div data-id="week-calendar" class="ui-calendar"></div></div>');
        listBox.push('<div style="display:none" class="time-box-month"><div class="ui-select"></div><div class="ui-select ml10"></div></div>');
        listBox.push('<div style="display:none" class="time-box-quarter"><div class="ui-select"></div><div class="ui-select ml10"></div></div>');
        var opts = list.join(''); 
        var boxs = listBox.join('');
        var htmls = [];
        // 
        htmls.push('   <div class="' + uiType + '-box">' 
                    +     '<span class="' + uiType + '-label"></span>'
                    +     '<select class="' + UI_SELECT.TYPES + '">' 
                    +          opts 
                    +     '</select>'
                    + '</div>'
                  );

        var istCalType = UI_IST_CALENDAR.types[0];
        // htmls.push('<span class="' + uiType + '-btnpre" >&nbsp;&lt;&lt;</span>')
        htmls.push('<span class="'+ istCalType +'-btn-prv '+ istCalType +'-btn"></span>');

        htmls.push('  <div class="' + uiType + '-box">' 
                    +      boxs    
                    + '</div>'
                  );
      
        // htmls.push('<span class="' + uiType + '-btnnext">&nbsp;&gt;&gt;</span>')
        htmls.push('<span class="'+ istCalType +'-btn-nxt '+ istCalType +'-btn"></span>');

        el.innerHTML = htmls.join('');
        
    };

    /**
    * ecui
    * @param {EcuiElement} ecui
    * @param {Ojbect} options ecui
    */
    function process(el, options) {
        var parse = parseDate;
        var format = formatDate;
        setDefaultOptions(options);
        var me = this;
        me._oRange = options.range;
    
        me.typeList = {
            'day': null,
            'week': null,
            'month': null,
            'quarter': null 
        }
        // 
        this._nSelectedType = this._getInnerType(options.types[0]);
        var childs = children(el);
        //
        var conBox = childs[0];
        var select = children(conBox)[1];

        //-- 
        // this._uBtnPre = childs[1];
        // this._uBtnNext = childs[3];
        this._uBtnPre = $fastCreate(this.Button, childs[1], this);        
        this._uBtnNext = $fastCreate(this.Button, childs[3], this);

        this._uConditionSelect = $fastCreate(UI_SELECT, select, this, {});
        this._uConditionSelect.$setSize(100, 20);

        //
        this._uConditionSelect.$mouseWheel = function() {};
        //change 
        this._uConditionSelect.$change = conditionChangeHandle(this); 
        
        //
        var timeWrap = childs[2];  
        var timeBoxs = children(timeWrap); 
        var dayBox = me.typeList['day'] = timeBoxs[0];
        var weekBox = me.typeList['week'] = timeBoxs[1]; 
        var monthBox = me.typeList['month'] = timeBoxs[2]; 
        var quarterBox = me.typeList['quarter'] = timeBoxs[3]; 
        // 
        if (hasType('D', options)) { 
            //
            createDayControl(me, options, dayBox);
        }
        //
        if (hasType('W', options)) {
            createWeekControl(me, options, weekBox);
        }
        //
        if (hasType('M', options)) {
            createMonthControl(me, options, monthBox);
        }
        // 
        if (hasType('Q', options)) {
            createQuarterControl(me, options, quarterBox);
        }
        this._uBtnPre.onclick = btnPreNextHandle('pre', this);
        this._uBtnNext.onclick = btnPreNextHandle('next', this);

        setTimeout(function() {
            var type = me._uConditionSelect.getValue();
            //
            me._showCalendarByType(type);
            //btn
            //bug fix 
            me._setBtnStatus();
          //  core.triggerEvent(me._uConditionSelect, 'change', {}, null);
        }, 100); 
    };

    /**
    *  
    *
    * @param {EcuiElement} me 
    * @param {Object} options 
    * @param {htmlElement} eleBox  
    *
    */ 
    function createQuarterControl(me, options, eleBox) {

        var parse = parseDate; 
        //
        var quarterControlYear = me._uQuarterSelectYear 
                               = $fastCreate(UI_SELECT, eleBox.firstChild, me, {});
        var quarterControlQuarter = me._uQuarterSelectQuarter  
                                  = $fastCreate(UI_SELECT, eleBox.lastChild, me, {});
        
        var quarterData = function() {
            var obj = {};
            var range = options.range.quarter;
            var start = parse(range.start, 'quarter');
            var end = parse(range.end, 'quarter');
            var startYear = start.getFullYear();
            var endYear = end.getFullYear();
            var startQ = range.start.split('-')[1];
            var endQ = range.end.split('-')[1];
            var result = [];

            //range
            for (var i = startYear; i <= endYear; i++) {
                result.push({ text: i + '', value: i });
            }
            var q = [
                { text: '', value: 'Q1' }, 
                { text: '', value: 'Q2' }, 
                { text: '', value: 'Q3' }, 
                { text: '', value: 'Q4' } 
            ];
            obj.year = result;
            obj.quarter = q;
            return obj;

        }();

        //
        quarterControlYear.$setSize(100, 20);
        quarterControlQuarter.$setSize(100, 20);
        setSelectData(quarterControlYear,quarterData.year);
        setSelectData(quarterControlQuarter, quarterData.quarter);
        var defaultDate = options.defaults.quarter;
        var  date =  parse(defaultDate, 'quarter');
        var _year = date.getFullYear();
        var _q = defaultDate.split('-')[1];  
        quarterControlYear.setValue(_year);
        quarterControlQuarter.setValue(_q);

        quarterControlYear.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
        quarterControlQuarter.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }

    };
    /**
    *  
    * @param {EcuiElement} me 
    * @param {Object} options 
    * @param {htmlElement} eleBox  
    */ 
    function createMonthControl(me, options, eleBox) {

        var parse = parseDate; 

        var monthControlYear = me._uMonthSelectYear 
        = $fastCreate(UI_SELECT, eleBox.firstChild, me, {});
        var monthControlMonth = me._uMonthSelectMonth 
        = $fastCreate(UI_SELECT, eleBox.lastChild, me, {});     

        // 
        var monData = function(options) {
            var obj = {};
            var range = options.range.month;
            var start = parse(range.start, 'month');
            var end = parse(range.end, 'month');
            var startYear = start.getFullYear();
            var endYear = end.getFullYear();
            var startMonth = start.getMonth();
            var endMonth = end.getMonth();

            var result = [ ];
            var resultMon = [];
            var mon = [ '', '', '', '', '', '',
            '', '', '', '', '', ''
            ];

            //range
            for (var i = startYear; i <= endYear; i++) {
                result.push({ text: i + '', value: i });
            }

            //
            for (var i = 0, item; item = mon[i]; i ++) {
                resultMon.push({ text: item + '' , value: i });
            }

            obj.year = result; 
            obj.month = resultMon; 
            return obj; 
        }(options);

        //
        setSelectData(monthControlYear, monData.year);
        setSelectData(monthControlMonth, monData.month);
        var defaultDate = options.defaults.month;
        var  date =  parse(defaultDate, 'month');
        var _year = date.getFullYear();
        var _month = date.getMonth();
        //
        monthControlYear.$setSize(100, 20);
        monthControlMonth.$setSize(100, 20);
        monthControlYear.setValue(_year);
        monthControlMonth.setValue(_month);

        monthControlYear.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
        monthControlMonth.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
    
    };
    /**
    *  
    * @param {EcuiElement} me 
    * @param {Object} options 
    * @param {htmlElement} eleBox  
    */
    function createWeekControl(me, options, eleBox) {
        var parse = parseDate; 
        //
        var weekControl = me._uWeekCalendar
                        = $fastCreate(  UI_IST_CALENDAR, 
                                        eleBox.firstChild,
                                        me,
                                        { 
                                            mode:'WEEK', 
                                            viewMode:'POP',
                                            shiftBtnDisabled: true 
                                        }
                                    );
        var dft = parse( options.defaults.week, 'day' );
        var range = options.range.week;
        var start = parse( range.start, 'day');
        var end = parse( range.end, 'day');
        //
        //var startMonday = null;
        // 
        var endMonday = getMonday(end);
        var endSunday =  new Date(endMonday.getFullYear(), endMonday.getMonth(), endMonday.getDate() + 6);
        var startMonday = getMonday(start);

        //bug fix: weekrange
        weekControl.setRange(start, end);
        weekControl.setDate(dft);

        weekControl.$setSize(280, 20);
        weekControl.onchange = function() {

            core.triggerEvent(me, 'change', {}, null);
        }
    
    };
    /**
    * 
    * @param {EcuiElement} me 
    * @param {Object} options 
    * @param {htmlElement} eleBox  
    */
    function createDayControl (me, options, eleBox) {
        var parse = parseDate; 
        var dayControl = me._uDayCalendar 
                       = $fastCreate(   UI_IST_CALENDAR, 
                                        eleBox.firstChild,
                                        me,
                                        {   
                                            mode:'DAY', 
                                            viewMode:'POP', 
                                            shiftBtnDisabled: true 
                                        }
                                    );
        var dft = parse( options.defaults.day , 'day');
        var range = options.range.day;
        var start = parse(range.start, 'day'); 
        var end = parse(range.end, 'day'); 

        dayControl.setRange(start, end);

        dayControl.setDate(dft);
        //
        dayControl.$setSize(280, 20);
        dayControl.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        } 
    
    };

    /**
    * @param {EcuiElement} ele 
    * @return {Function} onchange
    */
    function conditionChangeHandle(ele) {
        var me = ele;
        return function() {
            var value = this.getValue();
            me._showCalendarByType(value);
            
            core.triggerEvent(me, 'change', {}, null);
        };
    } 
    
    /**
    * select
    * @inner
    * @param {ECUIElement} select ecui
    * @param {Array[Object]} select ecui
    */
    function setSelectData(select, data) {
        data = data || [];
        for (var i = 0, len = data.length; i < len; i++) {
            var item = data[i]; 
            select.add(item.text, i, { value: item.value });
        }
    };

    /**
    *     D M W Q
    * @param {string} type
    * @return {boolean} 
    */
    function hasType(type, options) {
        var types = options.types;
        var result = false;
        for (var i = 0; i < types.length; i ++) {
            if (types[i] === type) {
                result = true; 
                break;
            } 
        }
        return result;
    }; 
    /**
    * @param {string} op  pre next 
    * @param {HtmlElement} el  
    * @return {Function} 
    */
    function btnPreNextHandle(op, el) {
        var me = el;
        return function() {
            var type = me._getDateType();
            var today = new Date()
            var cName = this.className || '';

            //  
            if (cName.match(/disable/)) {
                return ; 
            }
            if (type === 'day') {

                var cal = me._uDayCalendar;
                var d = cal.getDate();       
                if (op === 'pre') {
                    d.setDate(d.getDate() - 1); 
                }
                else {
                    d.setDate(d.getDate() + 1); 
                }
                cal.setDate(d);
                //XXX:  setDateonchage
                //   onchange
                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'week') {
                var cal = me._uWeekCalendar;
                var d = cal.getDate();       
                //bugfix: rangeend
                if (op === 'pre') {
                    d.setDate(d.getDate() - 7); 
                    //
                    d = getMonday(d);
                    d.setDate(d.getDate() + 6);
                }
                else {
                    d.setDate(d.getDate() + 7); 
                    //
                    d = getMonday(d);
                }
                cal.setDate(d);

                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'month') {
                //{type: 'M', date:''}
                var date = me.getDate().date; 
                date = parseDate(date, 'month');
                var cha = (op == 'pre' ? -1 : 1);
                var newDate = new Date(date.getFullYear(), date.getMonth() + cha); 
                newDate = formatDate(newDate, 'month');
                me.setDate({ type: 'M', date: newDate});

                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'quarter') {
                var date = me.getDate().date; 
                date = parseDate(date, 'quarter');
                var cha = (op == 'pre' ? -3 : 3);
                var newDate = new Date(date.getFullYear(), date.getMonth() + cha); 
                newDate = formatDate(newDate, 'quarter');
                me.setDate({ type: 'Q', date: newDate});

                core.triggerEvent(me, 'change', {}, null);
            }
        
        } 
    
    };
    // options
    // @inner
    function  setDefaultOptions(options) {
        var parse = parseDate;
        var format = formatDate;
        var today = new Date();
        var tmp = '';
        //types dom
        if (Object.prototype.toString.call(options.types) == '[object String]') {
            options.types = options.types.split(',');  
        }
        if (!options.types) {
            options.types = ['D', 'W', 'M', 'Q']
        }
        if (!options.tagNames) {
            options.tagNames = ['', '', '', '']; 
        }
        //range
        if (!options.range) {
            options.range = {}; 
        }
        var range = options.range;
        if (!range.day) {
            tmp = format(today, 'day');
            range.day = { start: '2008-01-01', end: tmp };

        }
        if (!range.week) {
            tmp = format(today, 'week');
            range.week = { start: '2008-01-01', end: tmp };
        }
        if (!range.month) {
            var end = new Date();
            var month = end.getFullYear();
            if (month > 2011) {
                end = format(end, 'month'); 
            }
            else {
                end = '2012-01'; 
            }
            range.month = { start: '2008-01', end: end }; 
        }
        if (!range.quarter) {

            var end = new Date();
            var q = end.getFullYear();
            if (q > 2011) {
                end = format(end, 'quarter'); 
            }
            else {
                end = '2012-Q1' 
            }
            range.quarter = { start: '2008-01', end: end };
        }
        //
        if (!options.defaults) {
            options.defaults = {};
        }

        var date = new Date();
        var dft = options.defaults;
        dft.day = dft.day || format(date, 'day');
        dft.week = dft.week || format(date, 'week');
        dft.month = dft.month || format(date, 'month');
        dft.quarter = dft.quarter || format(date, 'quarter');

    };
    /**
    * @param {string}  strTime
    * @param {string_opt}  type : day or week, 
    * @return {Date}  
    */
    function parseDate(strTime, type) {
        var date = null;
        var tmp = [];
        if (strTime == null || strTime == '') {
            return null; 
        }
        if (type === 'day' || type === 'week') {
            tmp = strTime.split('-');
            date = new Date(tmp[0], +tmp[1] - 1, tmp[2]); 
        } 
        else if (type === 'month') {
            tmp = strTime.split('-');
            date = new Date(tmp[0], +tmp[1] - 1, 1); 
        }
        else if (type === 'quarter') {
            tmp = strTime.split('-');
            q = strTime.slice(-1);
            date = new Date(tmp[0], q * 3 - 3, 1); 
        }
        return date;
    };

    /**
    * Date 2012-01-12
    * @param {Date} date
    * @param {Date} type  : day or week, month, quarter
    * @return {string}  
    */
    function formatDate(date, type) {
        if (!date || '[object Date]' != Object.prototype.toString.call(date)) {
            return ''; 
        }
        type = type || 'day'; 
        var year = date.getFullYear();
        var month = date.getMonth() + 1;
        var day = date.getDate();
        var str = [];
        if (type === 'day' || type === 'week') {
            str.push(year);
            str.push(month < 10 ? '0' + month : month);
            str.push(day < 10 ? '0' + day : day);
        } 
        else if (type === 'month') {
            str.push(year);
            str.push(month < 10 ? '0' + month : month);
        }
        else if (type === 'quarter') {
            str.push(year);
            var q = Math.ceil(month / 3);
            str.push('Q' + q);
        }
        return str.join('-');
    };


    /**
    *  
    *  @inner
    */
    function setBtnStatus()  {
        var me = this;
        var gran = me._getDateType();
        var range = me._oRange;
        var today = range;
        var btnPre = me._uBtnPre;
        var btnNext = me._uBtnNext;
        //today = new Date(today.getFullYear(), today.getMonth(), today.getDate())
        var cName = this.getType() + '-btn-disable';
            //
        if (gran == 'day') {
            var d = me.getDate();       
            today = parseDate(range.day.end, 'day');
            var start = parseDate(range.day.start, 'day');

            d = parseDate(d.date, 'day');
            if (d.getTime() >= today.getTime()) {
                btnNext.disable();
                // addClass(btnNext, cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            //
            if (d.getTime() <= start.getTime()) {
                btnPre.disable();
                // addClass(btnPre, cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            } 
        }
        //
        else if (gran == 'week') {
            var d = me.getDate();       
            d = parseDate(d.date, 'day');
            today = parseDate(range.week.end, 'week');
            var monday = getMonday(today);
            var start = parseDate(range.week.start, 'week');
            if (d.getTime() >= monday.getTime()) {
                btnNext.disable();
                // addClass(btnNext , cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            monday = getMonday(start);
            if (d.getTime() <= monday.getTime()) {
                btnPre.disable();
                // addClass(btnPre , cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            }
        }
        //
        else if (gran == 'month') {
            var year = me._uMonthSelectYear.getValue();
            var month = me._uMonthSelectMonth.getValue();
            var d = parseDate(range.month.end, 'month');
            //
            var ds = parseDate(range.month.start, 'month');
            var ds_month =  ds.getMonth();
            var ds_year =  ds.getFullYear();

            var d_year = d.getFullYear();
            var d_month = d.getMonth();
            var big = false;
            if (   year > d_year 
                || ((year == d_year) && (month >= d_month)) 

                //bugfix:  +1
                || ((year == ds_year) && (month + 1 < ds_month))
            ) {
                big = true;
            }
            if (big) {
                btnNext.disable();
                // addClass(btnNext , cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            d = parseDate(range.month.start, 'month');

            var de = parseDate(range.month.end, 'month');
            de_month = de.getMonth();
            de_year = de.getFullYear();
            d_year = d.getFullYear();
            d_month = d.getMonth();
            var small = false;
            if (
                    year < d_year 
                || ((year == d_year) && (month <= d_month))

                //bugfix:  -1
                || ((year == de_year) && (month - 1 > de_month))
            ) {
                small = true;
            }
            if (small) {
                btnPre.disable();
                // addClass(btnPre , cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            }
        }
        //
        else if (gran == 'quarter') {
            var year = me._uQuarterSelectYear.getValue();
            var month = me._uQuarterSelectQuarter.getValue();
            //range
            var d = parseDate(range.quarter.end, 'quarter');
            //range
            var ds = parseDate(range.quarter.start, 'quarter');
            var ds_year = ds.getFullYear();
            var ds_q = _getQ(ds.getMonth() + 1 );

            var d_year = d.getFullYear();
            var d_q = _getQ(d.getMonth() + 1 );
            var big = false;
            if (   year > d_year 
                || ((year == d_year) && month >= d_q)

                //bugfix: q -1
                || ((year == ds_year) && +(month.slice(1)) + 1 < ds_q.slice(1)) 
            ) {
                big = true;
            }
            if (big) {
                btnNext.disable();
                // addClass(btnNext ,cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            d = parseDate(range.quarter.start, 'quarter');
            d_year = d.getFullYear();
            d_q = _getQ(d.getMonth() + 1 );

            var de = parseDate(range.quarter.end, 'quarter');
            de_year = de.getFullYear();
            de_q = _getQ(de.getMonth() + 1 );

            var small = false;
            if (   year < d_year 
                || ((year == d_year) && month <= d_q)
                //bugfix: q -1
                || ((year == de_year) && +month.slice(1) - 1 > de_q.slice(1))
            
            ) {
                small = true;
            }
            if (small) {
                btnPre.disable();
                // addClass(btnPre, cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPe, cName); 
            }
        }
        /**
        * @param {number} month  1
        * @return {String}  
        */
        function _getQ(month) {
            var q = '';
            if (month >= 1 && month <= 3) {
                q = 'Q1'; 
            }
            else if (month >= 4 && month <= 6) {
                q = 'Q2'; 
            }
            else if (month >= 7 && month <= 9) {
                q = 'Q3'; 
            }
            else if (month >= 10 && month <= 12) {
                q = 'Q4'; 
            }
            return q;
        }

    };

    /**
    * 
    * @param {Date} date 
    */
    function getMonday(date) {
        var day = date.getDay();
        var dd = date.getDate();
        var yyyy = date.getFullYear();
        var mm = date.getMonth();
        var monday = null;
        var distance = 0;
        if (day >= 1) {
            dd -= day - 1; 
        }
        else {
            dd -= 6; 
        }
        monday =  new Date(yyyy, mm, dd); 
        return monday;
    };

  

    /**
    * 
    * @return {Object} obj
    * @return {Object} obj.type 'M' 
    * @return {Object} obj.date '1900-01' 
    */
    function getDate() {
        // day week, month quarter
        var type = this._getDateType();
        var date = null;
        var result = {
            type: 'D',
            date: ''
        };
        if (type === 'day') {
            date = this._uDayCalendar.getDate(); 
            date = formatDate(date);
            result = {
                'type': 'D',
                'date': date
            } 
        }
        else if (type === 'week') {
            date = this._uWeekCalendar.getDate(); 
            date = getMonday(date);
            date = formatDate(date);
            result = {
                type: 'W',
                date: date 
            }
        }
        else if (type === 'month') {
            var year = this._uMonthSelectYear.getValue();
            var month = this._uMonthSelectMonth.getValue();
            date = new Date(year, month, 1); 
            date = formatDate(date, 'month');
            result = {
                type: 'M',
                date: date
            }
        }
        else if (type === 'quarter') {
            var year = this._uQuarterSelectYear.getValue();
            var quarter = this._uQuarterSelectQuarter.getValue();
            if (!year || !quarter) {
                date = '';
            }
            else {
                date = year + '-' + quarter;
                result = {
                    type: 'Q',
                    date: date
                } 
            }
        }
        return result;
    };

    /**
    * @param {string} type  type day week  month year
    * @  prototype
    */
    function showCalendarByType(type) {
        
        this._uConditionSelect.setValue(type);

        var typeList = this.typeList;
        var value = type;
        var preType = this._nSelectedType;
        typeList[preType].style.display = 'none';
        //value == day, week, month , quarter
        typeList[value].style.display = 'block';
        //type
        this._nSelectedType = value;
       
    }
    /**
    *  
    * @param {Object} obj
    * @param {string} obj.type   'M', 'D', 'W', 'Q'
    * @param {string} obj.date  1988-03
    */
    function setDate(obj) {
        var type = obj.type || 'M'; 
        var innerType = this._getInnerType(type);
        var date = obj.date;
        var currentType = this._nSelectedType;
        if (!date) {
            return ; 
        }
        //
        if (type === 'D') {
            var d = parseDate(date, 'day');
            this._uDayCalendar.setDate(d); 
            innerType = 'day';
        } 
        else if (type === 'W') {
            var d = parseDate(date, 'week');
            d = getMonday(d);
            this._uWeekCalendar.setDate(d); 
            innerType = 'week';
        }
        else if (type === 'M') {
            var d = parseDate(date, 'month');
            var year = d.getFullYear();
            var month = d.getMonth();
            this._uMonthSelectYear.setValue(year);
            this._uMonthSelectMonth.setValue(month);
            innerType = 'month';
        }
        else if (type === 'Q') {
            var d = parseDate(date, 'quarter');
            if (date.length == 7) {
                var year = date.slice(0, 4);
                var q = date.slice(-2);
            }
            this._uQuarterSelectYear.setValue(year);
            this._uQuarterSelectQuarter.setValue(q);
            innerType = 'quarter';
        }

        if (innerType != currentType) {
            this._showCalendarByType(innerType);
        }

        //core.triggerEvent(this, 'change', {}, null);
    };

    
    /**
    * @param {Object} options options 
    * @param {Array<String>} types   'D', 'M' ===
    * @param {Object} range options 
    * @param {String} range.type options 
    * @param {String} range.date    1988-01-03
    */
    function render(options) {
        detachEvent(WINDOW, 'resize', repaint); 
        var el = this.getOuter();
        //
        for (key in this) {
            if (/_u\w+/.test(key)) {
                disposeControl(this[key]);
            }
        }
        el.innerHTML = '';
        UI_CALENDAR_PLUS.client.call(this, el, options);
        this.cache(true, true);
        this.init();

        this.$resize();
        //
        attachEvent(WINDOW, 'resize', repaint);
    
    }


    /**
    * @private 
    * @param {String} type   DMW  
    * @return {String}
    */
    UI_CALENDAR_PLUS_CLASS._getInnerType = function(type) {

        // 
        var dic = {
            'D': 'day',
            'W': 'week',
            'M': 'month',
            'Q': 'quarter'
        } 
        return dic[type];
    }
    /**
    * @private   
    * @param {Date=} 
    */
    UI_CALENDAR_PLUS_CLASS._setBtnStatus = setBtnStatus;

    /**
    * @private
    * @param {string} type  day week month year
    */
    UI_CALENDAR_PLUS_CLASS._showCalendarByType = showCalendarByType;

    /**
    * @private    
    * 
    * @return {string}  
    */
    UI_CALENDAR_PLUS_CLASS._getDateType = function() {
        return this._nSelectedType; 
    };

    /**
    * @inner   
    */
    UI_CALENDAR_PLUS_CLASS.$change = function() {
        this._setBtnStatus(); 
    };

    /**
    *   
    * @param {Object} options 
    *
    */
    UI_CALENDAR_PLUS_CLASS.render = render;

    /**
    *  
    * @param {Object} obj
    * @param {string} obj.type   'M', 'D', 'W', 'Q'
    * @param {string} obj.date  1988-03
    */
    UI_CALENDAR_PLUS_CLASS.setDate = setDate;

    /**
    * 
    * @return {Object} obj
    * @return {Object} obj.type 'M' 
    * @return {Object} obj.date '1900-01-02' 
    */
    UI_CALENDAR_PLUS_CLASS.getDate = getDate;

   

    })();

/*
XCalendarMDView / XCalendarMWView - /
//()()


_nYear      - 
_nMonth     - (0-11)
_aCells     - 0-6
_oRange     - 


_nDay       - 1
*/
(function () {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var util = core.util;

    var DATE = Date;
    var objProtoToString = Object.prototype.toString;

    var extend = util.extend;
    var indexOf = array.indexOf;
    var addClass = dom.addClass;
    var getParent = dom.getParent;
    var removeClass = dom.removeClass;
    var setText = dom.setText;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;

    var UI_CONTROL = ui.Control;

    //-------------------------------------------------------------
    // 
    //-------------------------------------------------------------

    var UI_X_CALENDAR_UTIL = ui.XCalendarUtil = {};
    var DAY_MILLISECOND = 24*60*60*1000;

    var compareDate = UI_X_CALENDAR_UTIL.compareDate = function (a, b, timeType) {
        a = formatDateByTimeType(a, timeType, true);
        b = formatDateByTimeType(b, timeType, true);

        return a[0] != b[0]
            ? (a[0] > b[0] ? 1 : -1)
            : (
                a[1] != b[1]
                    ? (a[1] > b[1] ? 1 : -1)
                    : (
                        a[2] != b[2]
                            ? (a[2] > b[2] ? 1 : -1)
                            : 0
                    )
            );
    };

    var formatDateByTimeType = UI_X_CALENDAR_UTIL.formatDateByTimeType = function (
        date, timeType, retArrOrDate
    ) {
        if (!date) { return; }

        if (timeType == 'D') {
            date = date2Arr(date, true);
        }
        else if (timeType == 'W') {
            date = date2Arr(getWorkday(date));
        }
        else if (timeType == 'M') {
            date = date2Arr(date, true);
            date[2] = 1;
        }
        else if (timeType == 'Q') {
            date = getQuarterBegin(date, true);
        }

        return retArrOrDate ? date : new Date(date[0], date[1], date[2]);
    };

    var date2Arr = UI_X_CALENDAR_UTIL.date2Arr = function (d, willCreate) {
        return d == null 
            ? d
            : !isArray(d) 
                ? [d.getFullYear(), d.getMonth(), d.getDate()]
                : willCreate
                    ? [d[0], d[1], d[2]]
                    : d;
    };

    var arr2Date = UI_X_CALENDAR_UTIL.arr2Date = function (d, willCreate) {
        return d == null
            ? d
            : isArray(d) 
                ? new Date(d[0], d[1] || 0, d[2] || 1)
                : willCreate
                    ? new Date(d.getFullYear(), d.getMonth(), d.getDate())
                    : d;
    };

    var getQuarterBegin = UI_X_CALENDAR_UTIL.getQuarterBegin = function (date, retArrOrDate) {
        if (!date) { return null; }
        date = date2Arr(date);
        var quarter = getQuarter(date);
        var mon = [0, 0, 3, 6, 9];
        return retArrOrDate 
            ? [date[0], mon[quarter], 1]
            : new Date(date[0], mon[quarter], 1);
    };

    var getQuarter = UI_X_CALENDAR_UTIL.getQuarter = function (date) {
        if (!date) { return null; }
        date = date2Arr(date);
        return Math.floor(date[1] / 3) + 1 ;
    };

    var getWorkday = UI_X_CALENDAR_UTIL.getWorkday = function (date) {
        date = arr2Date(date, true);
        date.setDate(date.getDate() - (6 + date.getDay()) % 7);
        return date;
    };

    var minDate = UI_X_CALENDAR_UTIL.minDate = function (timeType) {
        var args = arguments;
        var m = args[1];
        for (var i = 1, o; i < args.length; i ++) {
            if ((o = args[i]) && compareDate(m, o, timeType) > 0) {
                m = o;
            }
        }
        return m;
    };

    var maxDate = UI_X_CALENDAR_UTIL.maxDate = function (timeType) {
        var args = arguments;
        var m = args[1];
        for (var i = 1, o; i < args.length; i ++) {
            if ((o = args[i]) && compareDate(m, o, timeType) < 0) {
                m = o;
            }
        }
        return m;
    };

    var initSlt = UI_X_CALENDAR_UTIL.initSlt = function (slt, dataWrap) {
        // 
        slt.setValue(null);
        while(slt.remove(0)) {}
        // 
        for (var i = 0, o; o = dataWrap.list[i]; i++) {
            slt.add(String(o.text), null, { value: o.value });
        }
        slt.setValue(dataWrap.selected);
    };    

    var isDate = UI_X_CALENDAR_UTIL.isDate = function (input) {
        return objProtoToString.call(input) == '[object Date]';
    };

    var isArray = UI_X_CALENDAR_UTIL.isArray = function (input) {
        return objProtoToString.call(input) == '[object Array]';
    };

    var isString = UI_X_CALENDAR_UTIL.isString = function (input) {
        return objProtoToString.call(input) == '[object String]';
    };

    var isNumber = UI_X_CALENDAR_UTIL.isNumber = function (input) {
        return objProtoToString.call(input) == '[object Number]';
    };

    var setSltValue = UI_X_CALENDAR_UTIL.setSltValue = function (sltCtrl, value) {
        sltCtrl && sltCtrl.setValue(value);
    };

    var getSltValue = UI_X_CALENDAR_UTIL.getSltValue = function (sltCtrl) {
        return sltCtrl ? sltCtrl.getValue() : void 0;
    };

    var getWeekInfo = UI_X_CALENDAR_UTIL.getWeekInfo = function (date) {
        var weekDay = date.getDay();
        var pre = -((weekDay + 6) % 7), next = (7 - weekDay) % 7;
        var weekInfo = {
            monday: new Date(date.getTime() + pre * DAY_MILLISECOND), 
            sunday: new Date(date.getTime() + next * DAY_MILLISECOND)
        };
        weekInfo.workday = weekInfo.monday;
        weekInfo.weekend = weekInfo.sunday;
        return weekInfo;
    }

    var cloneADate = UI_X_CALENDAR_UTIL.cloneADate = function (aDate) {
        if (!aDate) {
            return;
        }

        var ret = [];
        for (var i = 0, o; i < aDate.length; i ++) {
            if (o = aDate[i]) {
                ret.push(isDate(o) ? new Date(o.getTime()) : o.slice());
            }
        }

        return ret;
    }

    // function pad(value, count) {
    //     value = (value == null || isNaN(value)) ? '' : String(value);
    //     if (value.length < count) {
    //         value = Array(count - value.length + 1).join('0') + value;
    //     }
    //     return value;
    // }

    // function getDateKey(date) {
    //     if (isDate(date)) {
    //         return [
    //             pad(date.getFullYear(), 4), 
    //             pad(date.getMonth(), 2), 
    //             pad(date.getDate(), 2)
    //         ].join('-');
    //     }
    //     else if (isArray(date)) {
    //         return [
    //             pad(date[0], 4), 
    //             pad(date[1], 2), 
    //             pad(date[2], 2)
    //         ].join('-');
    //     }
    // }

    //-------------------------------------------------------------
    // UI_X_CALENDAR_VIEW
    //-------------------------------------------------------------

    /**
     * 
     *
     * @public
     * @param {Object} options 
     */
    var UI_X_CALENDAR_VIEW = 
        inheritsControl(UI_CONTROL, 'ui-x-calendar-view');
    var UI_X_CALENDAR_VIEW_CLASS = UI_X_CALENDAR_VIEW.prototype;

    /**
     * 
     * @public
     *
     * @param {Object} options 
     */
    UI_X_CALENDAR_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_VIEW_CLASS.Cell = inheritsControl(UI_CONTROL)
    ).prototype;
    UI_X_CALENDAR_VIEW_HCELL_CLASS = (
        UI_X_CALENDAR_VIEW_CLASS.HCell = inheritsControl(UI_CONTROL)
    ).prototype;

    UI_X_CALENDAR_VIEW_CLASS.WEEKNAMES = [
        '', '', '', '', '', '', ''
    ];
    UI_X_CALENDAR_VIEW_CLASS.MONTH = [
        '', '', '', '', '', '', '', '', '', '', '', ''
    ];
    UI_X_CALENDAR_VIEW_CLASS.QUARTER = [
        'Q1', 
        'Q2',
        'Q3', 
        'Q4'
    ];

    //-------------------------------------------------------------
    // view 
    //-------------------------------------------------------------

    UI_X_CALENDAR_VIEW_CLASS.$setSize = new Function();

    /**
     * Model
     *
     * @public
     * @return {Object} model
     */
    UI_X_CALENDAR_VIEW_CLASS.getModel = function () {
        return this._oModel;
    };

    UI_X_CALENDAR_VIEW_CLASS.setView = function (date) {
        this.$setView(date);
        this.$flushByRange();
        this.$flushSelected();
        this.$flushHover();
    };

    UI_X_CALENDAR_VIEW_CLASS.$flushByRange = function() {
        var model = this._oModel;
        var range = model.getRange();
        var start = range.start;
        var end = range.end;
        var aDate = this._oModel.getDate();
        var timeType = model.getTimeType();

        // range
        if (timeType == 'W') {
            timeType = 'D';
        }

        this.$forEachCell(
            function (cell, index, inMonth) {
                var currDate = cell.getCellInfo();
                (
                    (!start || compareDate(currDate, start, timeType) >= 0)
                    && (!end || compareDate(end, currDate, timeType) >= 0)
                )
                    ? cell.open()
                    : cell.close();
            }
        )
    };

    UI_X_CALENDAR_VIEW_CLASS.$doFlushSelected = function (getIndexMapFunc, timeType) {
        var model = this._oModel;
        var modelDate = model.getDate();
        var selMode = model.getSelMode();
        var viewInfo = this.getViewInfo();
        var indexMap;
        var range;

        if (selMode == 'RANGE' && modelDate[0] && modelDate[1]) {
            range = modelDate;
        }
        else {
            indexMap = getIndexMapFunc(
                viewInfo, modelDate, this.cellValue2IndexMap
            );
        }

        this.$forEachCell(
            function (cell, index) {
                if (cell._bClosed) { return; }

                var d = cell.getUnitInfo();
                var isIn = range
                    ? (
                        compareDate(d, range[0], timeType) >= 0
                        && compareDate(range[1], d, timeType) >= 0
                    )
                    : index in indexMap;
                var selected;
                var opt;

                isIn
                    ? (selected = true, opt = '+')
                    : (selected = false, opt = '-');

                selected != cell._bSelected && (
                    cell._bSelected = selected,
                    cell.alterClass(opt + 'selected')
                );
            }
        );
    }    

    UI_X_CALENDAR_VIEW_CLASS.$doFlushHover = function (getIndexMapFunc, timeType) {
        var model = this.getModel();
        var selMode = model.getSelMode();
        var modelDate = model.getHoverDate();
        var viewInfo = this.getViewInfo();
        var indexMap;
        var range;

        if (selMode == 'RANGE' && modelDate[0] && modelDate[1]) {
            range = modelDate;
        }
        else {
            indexMap = getIndexMapFunc(
                viewInfo, modelDate, this.cellValue2IndexMap
            );
        }

        this.$forEachCell(
            function (cell, index) {
                if (cell._bClosed) { return; }

                var d = cell.getUnitInfo();
                if (range
                        ? (
                            compareDate(d, range[0], timeType) >= 0
                            && compareDate(range[1], d, timeType) >= 0
                        )
                        : index in indexMap
                ) {

                    !cell._bHover && (
                        cell.alterClass('+hover'),
                        cell._bHover = true
                    );
                } 
                else {
                    cell._bHover && (
                        cell.alterClass('-hover'),
                        cell._bHover = false
                    );
                }
            }
        );
    }

    //-------------------------------------------------------------
    // Cell 
    //-------------------------------------------------------------

    UI_X_CALENDAR_VIEW_CELL_CLASS.close = function () {
        if (this._bSelected) {
            this.alterClass('-selected');
            this._bSelected = false;
        }
        if (this._bHover) {
            this.alterClass('-hover');
            this._bHover = false;
        }
        this._bClosed = true;
        this.disable();
    };

    UI_X_CALENDAR_VIEW_CELL_CLASS.open = function () {
        this._bClosed = false;
        this.enable();
    }

    UI_X_CALENDAR_VIEW_CELL_CLASS.$mouseover = function (event) {
        var par = this.getParent();
        var cc = this.getUnitInfo();
        par.getModel().updateHoverDate(arr2Date(this.getUnitInfo()), true);
        par.$flushHover();
    };

    UI_X_CALENDAR_VIEW_CELL_CLASS.$mouseout = function (event) {
        var par = this.getParent();
        var cc = this.getUnitInfo();
        par.getModel().updateHoverDate(arr2Date(this.getUnitInfo()), false);
        par.$flushHover();
    };

    UI_X_CALENDAR_VIEW_CELL_CLASS.$click = function(event) {
        var par = this.getParent()
        var model = par.getModel();
        if (model.udateDateByClick(arr2Date(this.getUnitInfo()))) {

            // view
            par.$flushSelected();

            /**
             * @event
             */
            triggerEvent(par, 'change', null, [model.getDate()]);
            /**
             * @event
             */
            triggerEvent(par, 'dateclick', null, [arr2Date(this.getUnitInfo())]);
        }
    };

    //-------------------------------------------------------------
    // MD View
    //-------------------------------------------------------------

   /**
     * monthday
     *
     * @public
     * @param {Object} options 
     */
    var UI_X_CALENDAR_MD_VIEW = ui.XCalendarMDView =
        inheritsControl(UI_X_CALENDAR_VIEW, null, null, mConstructor);
    var UI_X_CALENDAR_MD_VIEW_CLASS = UI_X_CALENDAR_MD_VIEW.prototype;

    var UI_X_CALENDAR_MD_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_MD_VIEW_CLASS.Cell = 
            inheritsControl(UI_X_CALENDAR_VIEW_CLASS.Cell)
    ).prototype;

    function mConstructor(el, options) {
        var type = this.getType();
        var list = [];
        var i = 0;
        var o;

        this._oModel = options.model;

        el.style.overflow = 'auto';

        for (; i < 7; ) {
            list[i] =
                '<td class="' + type + '-title' + this.Cell.TYPES + (i == 6 ? type + '-title-last' : '') + '">' +
                    this.WEEKNAMES[i++] + '</td>';
        }
        list[i] = '</tr></thead><tbody><tr>';
        for (; ++i < 50; ) {
            list[i] =
                '<td class="' + type + '-item' + this.Cell.TYPES +  (i % 7 ? '' : type + '-item-last') + '"></td>' +
                    (i % 7 ? '' : '</tr><tr>');
        }

        el.innerHTML =
            '<table cellspacing="0" cellpadding="0"><thead><tr>' + list.join('') + '</tr></tbody></table>';

        this._aCells = [];
        list = el.getElementsByTagName('TD');
        for (i = 0; o = list[i]; i ++) {
            // 
            this._aCells[i] = $fastCreate(
                i < 7 ? this.HCell : this.Cell, 
                o, 
                this, 
                { resizable: false }
            );
        }
    }

    UI_X_CALENDAR_MD_VIEW_CLASS.$flushSelected = function () {
        return this.$doFlushSelected(getIndexMapByDate, 'D');
    };
    
    UI_X_CALENDAR_MD_VIEW_CLASS.$flushHover = function () {
        this.$doFlushHover(getIndexMapByDate, 'D');
    };

    UI_X_CALENDAR_MD_VIEW_CLASS.$forEachCell = function (callback) {
        var lastDayOfCurrMonth = new DATE(this._nYear, this._nMonth + 1, 0).getDate();

        for (var i = 7, cell; cell = this._aCells[i]; i ++) {
            if (cell._nDay > 0 
                && cell._nDay <= lastDayOfCurrMonth
                && callback.call(this, cell, i) === false
            ) {
                break;
            }
        }
    };

    /**
     * view2012420123view
     *
     * @public
     * @param {{Date|Array}} date
     */
    UI_X_CALENDAR_MD_VIEW_CLASS.isCurrView = function (date) {
        date = date2Arr(date);
        return date[0] == this._nYear && date[1] == this._nMonth;
    };

    /**
     * viewdate
     *
     * @public
     * @param {Array} viewInfo
     */
    UI_X_CALENDAR_MD_VIEW_CLASS.getViewInfo = function () {
        return [this._nYear, this._nMonth];
    };

    /**
     * 
     *
     * @public
     * @param {{Date|Array}} date
     */
    UI_X_CALENDAR_MD_VIEW_CLASS.$setView = function (date) {
        date = date2Arr(date);
        var i = 7;
        var year = date[0];
        var month = date[1];
        // ;
        var o = new DATE(year, month, 0);
        var day = 1 - o.getDay();
        var lastDayOfLastMonth = o.getDate();
        // ;
        var lastDayOfCurrMonth = new DATE(year, month + 1, 0).getDate();
        var model = this._oModel;
        var range = model.getRange();
        var rangeStart = range.start;
        var rangeEnd = range.end;
        var currDate;
        var cellDay;

        if (this._nYear != year || this._nMonth != month) {
            this._nYear = year;
            this._nMonth = month;

            // cell_aCell
            this.cellValue2IndexMap = {};

            currDate = new DATE(year, month, 1);

            for (; o = this._aCells[i]; i ++) {
                if (month = day > 0 && day <= lastDayOfCurrMonth) {
                    currDate.setDate(day);
                    if ((!rangeStart || rangeStart <= currDate) 
                        && (!rangeEnd || rangeEnd >= currDate)) {
                        o.open();
                    }
                    else {
                        o.close();
                    }
                }
                else {
                    o.close();
                }

                if (i == 36 || i == 43) {
                    (o.isDisabled() ? addClass : removeClass)(
                        getParent(o.getOuter()), this.getType() + '-extra'
                    );
                }
                
                cellDay = month 
                    ? day 
                    : day > lastDayOfCurrMonth 
                        ? day - lastDayOfCurrMonth 
                        : lastDayOfLastMonth + day;

                this.setCellHTML 
                    && (this.setCellHTML(o, cellDay, day) !== false) 
                    || setText(o.getBody(), cellDay);

                this.cellValue2IndexMap[day] = i;
                o._nDay = day ++;
            }
        }
    };

    UI_X_CALENDAR_MD_VIEW_CELL_CLASS.getUnitInfo = function () {
        var par = this.getParent();
        return [par._nYear, par._nMonth, this._nDay]
    };

    UI_X_CALENDAR_MD_VIEW_CELL_CLASS.getCellInfo = UI_X_CALENDAR_MD_VIEW_CELL_CLASS.getUnitInfo;

    function getIndexMapByDate(viewInfo, dateArr, cellValue2IndexMap) {
        var ret = {};
        for (var i = 0, date; date = date2Arr(dateArr[i]); i ++) {
            if (date[0] == viewInfo[0] && date[1] == viewInfo[1]) { 
                ret[cellValue2IndexMap[date[2]]] = 1;
            }
        }
        return ret;
    }

    //-------------------------------------------------------------
    // MW View
    //-------------------------------------------------------------

    /**
     * monthweek
     *
     * @public
     * @param {Object} options 
     */
    var UI_X_CALENDAR_MW_VIEW = ui.XCalendarMWView =
        inheritsControl(UI_X_CALENDAR_VIEW, null, null, mConstructor);
    var UI_X_CALENDAR_MW_VIEW_CLASS = UI_X_CALENDAR_MW_VIEW.prototype;

    var UI_X_CALENDAR_MW_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_MW_VIEW_CLASS.Cell = 
            inheritsControl(UI_X_CALENDAR_VIEW_CLASS.Cell)
    ).prototype;

    UI_X_CALENDAR_MW_VIEW_CLASS.$flushSelected = function () {
        return this.$doFlushSelected(getIndexMapByWeekDate, 'W');
    };

    UI_X_CALENDAR_MW_VIEW_CLASS.$flushHover = function () {
        this.$doFlushHover(getIndexMapByWeekDate, 'W');
    };

    UI_X_CALENDAR_MW_VIEW_CLASS.$forEachCell = UI_X_CALENDAR_MD_VIEW_CLASS.$forEachCell;

    UI_X_CALENDAR_MW_VIEW_CLASS.isCurrView = UI_X_CALENDAR_MD_VIEW_CLASS.isCurrView;

    UI_X_CALENDAR_MW_VIEW_CLASS.getViewInfo = UI_X_CALENDAR_MD_VIEW_CLASS.getViewInfo;

    UI_X_CALENDAR_MW_VIEW_CLASS.$setView = UI_X_CALENDAR_MD_VIEW_CLASS.$setView;    

    UI_X_CALENDAR_MW_VIEW_CELL_CLASS.getUnitInfo = function () {
        var par = this.getParent();
        return date2Arr(getWorkday([par._nYear, par._nMonth, this._nDay]));
    };

    UI_X_CALENDAR_MW_VIEW_CELL_CLASS.getCellInfo = function () {
        var par = this.getParent();
        return [par._nYear, par._nMonth, this._nDay];
    };

    function getIndexMapByWeekDate(viewInfo, dateArr, cellValue2IndexMap) {
        var ret = {};
        var year = viewInfo[0];
        var month = viewInfo[1];
        for (var i = 0, date, workday, day; date = date2Arr(dateArr[i]); i ++) {
            // 
            workday = getWorkday(date);
            for (var j = 0; j < 7; j ++, workday.setDate(workday.getDate() + 1)) {
                if (workday.getFullYear() == year
                    && workday.getMonth() == month
                ) {
                    ret[cellValue2IndexMap[workday.getDate()]] = 1;
                }
            }
        }
        return ret;
    }

    //-------------------------------------------------------------
    // YM View
    //-------------------------------------------------------------

    /**
     * yearmonth
     *
     * @public
     * @param {Object} options 
     */
    var UI_X_CALENDAR_YM_VIEW = ui.XCalendarYMView =
        inheritsControl(UI_X_CALENDAR_VIEW, null, null, ymConstructor);
    var UI_X_CALENDAR_YM_VIEW_CLASS = UI_X_CALENDAR_YM_VIEW.prototype;

    var UI_X_CALENDAR_YM_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_YM_VIEW_CLASS.Cell = 
            inheritsControl(UI_X_CALENDAR_VIEW_CLASS.Cell)
    ).prototype;
    
    function ymConstructor(el, options) {
        var type = this.getType();
        var list;
        var i;
        var o;

        this._oModel = options.model;
        el.style.overflow = 'auto';

        for (i = 0, list = []; i < 12; i ++) {
            list.push('<td class="' + type + '-item'
                +   this.Cell.TYPES + '">'
                +   this.MONTH[i] + ""
                +   '</td>'
                +   ((i + 1) % 3 ? '' : '</tr><tr>')
            );
        }

        el.innerHTML =
            '<table cellspacing="0"><tbody><tr>'
                +       list.join('')
                +   '</tr></tbody></table>';

        this._aCells = [];
        for (i = 0, list = el.getElementsByTagName('TD'), o;
             o = list[i];
             i ++
        ) {
            // 
            this._aCells[i] = $fastCreate(
                this.Cell, o, this, { resizable: false }
            );
            this._aCells[i]._nMonth = i;
        }
    }    

    UI_X_CALENDAR_YM_VIEW_CLASS.$flushSelected = function () {
        return this.$doFlushSelected(getIndexMapByMonth, 'M');
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.$flushHover = function () {
        this.$doFlushHover(getIndexMapByMonth, 'M');
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.$forEachCell = function (callback) {
        for (var i = 0, cell; cell = this._aCells[i]; i ++) {
            if (callback.call(this, cell, i) === false) {
                break;
            }
        }
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.isCurrView = function (date) {
        date = date2Arr(date);
        return date[0] == this._nYear;
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.getViewInfo = function () {
        return [this._nYear];
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.$setView = function (date) {
        date = date2Arr(date);
        this._nYear = date[0];

        // cell_aCell
        if (!this.cellValue2IndexMap) {
            var cellValue2IndexMap = this.cellValue2IndexMap = {};
            for (var i = 0, cell; cell = this._aCells[i]; i ++) {
                cellValue2IndexMap[cell._nMonth] = i;
            }
        }
    };

    UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getUnitInfo = function () {
        var par = this.getParent();
        return [par._nYear, this._nMonth, 1]
    };

    UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getCellInfo = UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getUnitInfo;

    function getIndexMapByMonth(viewInfo, dateArr, cellValue2IndexMap) {
        var ret = {};
        for (var i = 0, date; date = date2Arr(dateArr[i]); i ++) {
            if (date[0] == viewInfo[0]) { 
                ret[cellValue2IndexMap[date[1]]] = 1;
            }
        }
        return ret;
    }

    //-------------------------------------------------------------
    // YQ View
    //-------------------------------------------------------------

    /**
     * yearquarter
     *
     * @public
     * @param {Object} options 
     */
    var UI_X_CALENDAR_YQ_VIEW = ui.XCalendarYQView =
        inheritsControl(UI_X_CALENDAR_VIEW, null, null, yqConstructor);
    var UI_X_CALENDAR_YQ_VIEW_CLASS = UI_X_CALENDAR_YQ_VIEW.prototype;

    var UI_X_CALENDAR_YQ_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_YQ_VIEW_CLASS.Cell = 
            inheritsControl(UI_X_CALENDAR_VIEW_CLASS.Cell)
    ).prototype;

    function yqConstructor(el, options) {
        var type = this.getType();
        var list;
        var i;
        var o;

        this._oModel = options.model;
        el.style.overflow = 'auto';

        for (i = 0, list = []; i < 4; i ++) {
            list.push('<div class="' + type + '-item'
                +   this.Cell.TYPES + '">'
                +   this.QUARTER[i]
                +   '</div>'
            );
        }

        el.innerHTML = list.join('');

        var quarterMap = [0, 3, 6, 9];
        this._aCells = [];
        for (i = 0, list = el.getElementsByTagName('div'), o;
             o = list[i]; 
             i ++
        ) {
            // 
            this._aCells[i] = $fastCreate(
                this.Cell, o, this, { resizable: false } 
            );
            this._aCells[i]._nMonth = quarterMap[i];
        }
    }

    UI_X_CALENDAR_YQ_VIEW_CLASS.$flushSelected = function () {
        return this.$doFlushSelected(getIndexMapByMonth, 'Q');
    };

    UI_X_CALENDAR_YQ_VIEW_CLASS.$flushHover = function () {
        this.$doFlushHover(getIndexMapByMonth, 'Q');
    };

    UI_X_CALENDAR_YQ_VIEW_CLASS.$forEachCell = UI_X_CALENDAR_YM_VIEW_CLASS.$forEachCell;

    UI_X_CALENDAR_YQ_VIEW_CLASS.isCurrView = UI_X_CALENDAR_YM_VIEW_CLASS.isCurrView;

    UI_X_CALENDAR_YQ_VIEW_CLASS.getViewInfo = UI_X_CALENDAR_YM_VIEW_CLASS.getViewInfo;

    UI_X_CALENDAR_YQ_VIEW_CLASS.$setView = UI_X_CALENDAR_YM_VIEW_CLASS.$setView;

    UI_X_CALENDAR_YQ_VIEW_CELL_CLASS.getUnitInfo = UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getUnitInfo;

    UI_X_CALENDAR_YQ_VIEW_CELL_CLASS.getCellInfo = UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getUnitInfo;

})();

/**
 * ecui.ui.XCalendarLayer
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           
 *           
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  ecui
 */

(function () {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;
    var cutil = ui.XCalendarUtil;

    var DATE = Date;
    var REGEXP = RegExp;
    var DOCUMENT = document;
    var objProtoToString = Object.prototype.toString;

    var pushArray = array.push;
    var children = dom.children;
    var createDom = dom.create;
    var getParent = dom.getParent;
    var getPosition = dom.getPosition;
    var moveElements = dom.moveElements;
    var setText = dom.setText;
    var addClass = dom.addClass;
    var formatDate = string.formatDate;
    var getView = util.getView;
    var encodeHTML = string.encodeHTML;
    var compareDate = cutil.compareDate;
    var date2Arr = cutil.date2Arr;
    var arr2Date = cutil.arr2Date;
    var getWorkday = cutil.getWorkday;
    var minDate = cutil.minDate;
    var maxDate = cutil.maxDate;
    var isDate = cutil.isDate;
    var isArray = cutil.isArray;
    var isString = cutil.isString;
    var isNumber = cutil.isNumber;
    var cloneADate = cutil.cloneADate;
    var setSltValue = cutil.setSltValue;
    var getSltValue = cutil.getSltValue;
    var getWeekInfo = cutil.getWeekInfo;
    var getQuarter = cutil.getQuarter;
    var initSlt = cutil.initSlt;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var setFocused = core.setFocused;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_BUTTON = ui.Button;
    var UI_BUTTON_CLASS = UI_BUTTON.prototype;
    var UI_INPUT_CONTROL = ui.InputControl;
    var UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
    var UI_SELECT = ui.Select;
    var UI_X_CALENDAR_MD_VIEW = ui.XCalendarMDView;
    var UI_X_CALENDAR_MW_VIEW = ui.XCalendarMWView;
    var UI_X_CALENDAR_YM_VIEW = ui.XCalendarYMView;
    var UI_X_CALENDAR_YQ_VIEW = ui.XCalendarYQView;


    /**
     * 
     * 
     * @param {Object} options 
     * @param {(string|Date|number|Array)=} options.date new Date()
     *          string
     *              2012-12-12 D
     *              2012-12-12 W, 
     *              2012-12    M
     *              2012-Q1    Q
     *          ,
     *          
     *          selMode
     *              SINGLE      date2012-12-12Date
     *              MULTIPLE    date[2012-12-12, 2012-03-04, 2012-11-15, ...]Date
     *              RANGE       date[2012-03-04, 2012-11-15]Date2
     * @param {Object} options.range
     * @param {(string|number|Date)=} options.range.offsetBase '+1d'new Date()
     *          
     * @param {(string|number|Date)=} options.range.start 
     *          '+1d', '-2M', '+4y'
     * @param {(string|number|Date)=} options.range.end 
     *          '+1d', '-2M', '+4y'
     * @param {Array.<Object>=} options.selModeList 'SINGLE', 'MULTIPLE', 'RANGE'
     *          { text: 'xxxxxx', value: 'SINGLE', prompt: ',' }valueselMode
     * @param {string=} options.selMode 'SINGLE', 'MULTIPLE', 'RANGE''SINGLE'
     * @param {Object=} options.model modelrender
     * @class
     */
    var UI_X_CALENDAR_LAYER = ui.XCalendarLayer = 
        inheritsControl(
            UI_CONTROL,
            'ui-x-calendar-layer',
            null,
            function (el, options) {
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );

    var UI_X_CALENDAR_LAYER_CLASS = UI_X_CALENDAR_LAYER.prototype;
    var UI_X_CALENDAR_LAYER_STEP_BUTTON_CLASS = (UI_X_CALENDAR_LAYER_CLASS.StepButton = inheritsControl(UI_BUTTON, null)).prototype;
    var UI_X_CALENDAR_LAYER_SELECT_CLASS = (UI_X_CALENDAR_LAYER_CLASS.Select = inheritsControl(UI_SELECT, null)).prototype;
    UI_X_CALENDAR_LAYER_MD_VIEW_CLASS = (UI_X_CALENDAR_LAYER_CLASS.MDView = inheritsControl(UI_X_CALENDAR_MD_VIEW, null)).prototype;
    UI_X_CALENDAR_LAYER_MW_VIEW_CLASS = (UI_X_CALENDAR_LAYER_CLASS.MWView = inheritsControl(UI_X_CALENDAR_MW_VIEW, null)).prototype;
    UI_X_CALENDAR_LAYER_YM_VIEW_CLASS = (UI_X_CALENDAR_LAYER_CLASS.YMView = inheritsControl(UI_X_CALENDAR_YM_VIEW, null)).prototype;
    UI_X_CALENDAR_LAYER_YQ_VIEW_CLASS = (UI_X_CALENDAR_LAYER_CLASS.YQView = inheritsControl(UI_X_CALENDAR_YQ_VIEW, null)).prototype;

    UI_X_CALENDAR_LAYER_SELECT_CLASS.Options = inheritsControl(
        UI_X_CALENDAR_LAYER_SELECT_CLASS.Options, 
        null, 
        null, 
        function(el, options) {
            addClass(el, 'ui-x-calendar-layer-select-options'); 
        }
    );

    UI_X_CALENDAR_LAYER_SEL_MODE_CLASS = (UI_X_CALENDAR_LAYER_CLASS.SelMode = 
        inheritsControl(UI_CONTROL, 'ui-x-calendar-layer-selmode')
    ).prototype;

    /**
     * Model
     *
     * @class
     * @param {Object} options setDatasource
     */
    var UI_X_CALENDAR_MODEL = UI_X_CALENDAR_LAYER_CLASS.Model = modelConstructor;
    var UI_X_CALENDAR_MODEL_CLASS = UI_X_CALENDAR_MODEL.prototype;

    // 
    UI_X_CALENDAR_MODEL_CLASS.DEFAULT = {
        selMode: 'SINGLE',
        timeType: 'D',
        selModeList: [
            { text: '', value: 'SINGLE', prompt: '' },
            { text: '', value: 'RANGE', prompt: '' },
            { text: '', value: 'MULTIPLE', prompt: '' }
        ]
    };

    var DATE_REG = /^(\d+)(\-(\d+)(\-(\d+))?)?$/;
    var QUARTER_REG = /^(\d+)\-Q(\d)/;

    //----------------------------------------------------
    // 
    //----------------------------------------------------

    function parseRange(start, end, offsetBase, cellTimeType) {
        var res = {};
        var o = res.offsetBase = parseInputDate(offsetBase || new Date());

        o = [o.getFullYear(), o.getMonth(), o.getDate()];
        var p = {y: 0, m: 1, d: 2};
        var t;

        if (/^([-+]?)(\d+)([ymd])$/.test((start || '').toLowerCase())) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.start = new Date(t[0], t[1], t[2]);
        }
        else {
            res.start = parseInputDate(start);
        }

        if (/^([-+]?)(\d+)([yMd])$/.test((end || '').toLowerCase())) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.end = new Date(t[0], t[1], t[2]);
        }
        else {
            res.end = parseInputDate(end);
        }

        if (res.start && res.end && compareDate(res.start, res.end, cellTimeType) > 0) {
            var tmp = res.end;
            res.end = res.start;
            res.start = tmp;
        }

        return res ? res : {};
    }

    function parseInputDate(input) {
        var ret;

        if (input == null) {
            ret = null;
        }
        else if (isArray(input)) {
            ret = [];
            for (var i = 0; i < input.length; i ++) {
                ret.push(parseInputDate(input[i]));
            }
        }
        else if (isDate(input)) {
            ret = input;
        }
        else if (isString(input)) {
            ret = parseDateStr(input);
        }
        else if (isNumber(input)){
            ret = new Date(input);
        }

        return ret;
    }

    function parseDateStr(dateStr) {
        if (DATE_REG.test(dateStr)) {
            return new Date(REGEXP.$1, (REGEXP.$3 || 1) - 1, REGEXP.$5 || 1);
        }
        else if (QUARTER_REG.test(dateStr)) {
            var par = [0, 0, 3, 6, 9];
            return new Date(REGEXP.$1, par[REGEXP.$2], 1);
        }
        
        return null;
    };

    function goViewStep(base, step, timeType) {
        step = Number(step);
        base = arr2Date(base, true);
        if (timeType == 'D' || timeType == 'W') {
            base.setMonth(base.getMonth() + step);
        }
        else if (timeType == 'M' || timeType == 'Q') {
            base.setFullYear(base.getFullYear() + step);
        }
        return base;
    }

    function goCellStep(base, step, timeType) {
        base = arr2Date(base, true);
        step = Number(step);
        if (timeType == 'D') {
            base.setDate(base.getDate() + step);
        }
        else if (timeType == 'W') {
            base.setDate(base.getDate() + step * 7);
        }
        else if (timeType == 'M') {
            base.setMonth(base.getMonth() + step);
        }
        else if (timeType == 'Q') {
            base.setMonth(base.getMonth() + step * 3);
        }
        return base;
    }

    //----------------------------------------------------
    // 
    //----------------------------------------------------

    function createModel(el, options) {
        if (options.model) {
            // model
            this._oModel = options.model;
        }
        else {
            // 
            var dft = this._oModel.DEFAULT;
            if (!options.selMode) {
                options.selMode = dft.selMode;
            }
            if (!options.timeType) {
                options.timeType = dft.timeType;
            }
            if (!options.selModeList) {
                options.selModeList = dft.selModeList;
            }
            this._oModel = new this.Model(options);
        }
    }

    function createView(el, options) {
        var type = this.getTypes()[0];
        var me = this;
        var html = [];
        var stepBtnClass = this.StepButton;
        var selectClass = this.Select;

        var model = this._oModel;
        var timeType = model.getTimeType();
        var aDate = model.getDate();
        var range = model.getRange();
        var hasMonthSlt = timeType == 'D' || timeType == 'W';

        var timeTypeDef = {
                D: { clz: this.MDView, st: '-md-view', btns: '-buttons-md' },
                W: { clz: this.MWView, st: '-md-view', btns: '-buttons-md' },
                M: { clz: this.YMView, st: '-ym-view', btns: '-buttons-ym' },
                Q: { clz: this.YQView, st: '-yq-view', btns: '-buttons-yq' }
            }[timeType];

        var o;
        var i;

        html.push('<div class="'+ type +'-buttons ' + type + timeTypeDef.btns + ' ">');

        // 
        html.push('<div class="'+ type +'-btn-prv'+ UI_BUTTON.TYPES +'"></div>');

        // 
        html.push('<select class="'+ type +'-slt-year'+ UI_SELECT.TYPES +'">');
        html.push('</select>');

        // 
        if (hasMonthSlt) {
            html.push('<select class="' + type + '-slt-month' + UI_SELECT.TYPES + '">');
            for (i = 1; i <= 12; i++) {
                html.push('<option value="' + i +'">'+ (i < 10 ? '0' : '') + i + '</option>');
            }
            html.push('</select>');
        }

        // 
        html.push('<div class="' + type + '-btn-nxt' + UI_BUTTON.TYPES + '"></div>');
        
        html.push('</div>');

        // selMode 
        html.push('<div class="' + type + '-selmode"></div>');

        // 
        html.push('<div class="' + type + timeTypeDef.st + ' ' + timeTypeDef.clz.TYPES + '"></div>');

        el.innerHTML = html.join('');
        el = children(el);

        o = children(el[0]);
        i = 0;
        
        this._uPrvBtn = $fastCreate(stepBtnClass, o[i ++], this);
        this._uPrvBtn._nStep = -1;

        this._uYearSlt = $fastCreate(selectClass, o[i ++], this);

        if (hasMonthSlt) {
            this._uMonthSlt = $fastCreate(selectClass, o[i ++], this);
        }

        this._uNxtBtn = $fastCreate(stepBtnClass, o[i ++], this);
        this._uNxtBtn._nStep = 1;

        this._uSelMode = $fastCreate(this.SelMode, el[1], this);

        this._uCalView = $fastCreate(
            timeTypeDef.clz, el[2], this, { model: model }
        );

        this._uCalView.onchange = function (aDate) {
            /**
             * @event
             */
            triggerEvent(me, 'change', null, [aDate]);
        };
        this._uCalView.ondateclick = function (aDate) {
            /**
             * @event
             */
            triggerEvent(me, 'dateclick', null, [aDate]);
        };

        this.render();
    }

    UI_X_CALENDAR_LAYER_CLASS.$setSize = new Function();

    UI_X_CALENDAR_LAYER_CLASS.setDatasource = function (datasource, silent) {
        this._oModel.setDatasource(datasource);
        !silent && this.render();
    };

    UI_X_CALENDAR_LAYER_CLASS.$flushCalView = function (force) {
        var timeType = this._oModel.getTimeType();
        var calView = this._uCalView;
        var d = [];
        (o = Number(getSltValue(this._uYearSlt))) && d.push(o);
        (o = Number(getSltValue(this._uMonthSlt))) && d.push(o - 1);

        calView.setView(d);
    };

    /** 
     * 
     *
     * @public
     * @param {Object} opt
     * @param {Date} viewDate 
     * @param {boolean} remainSlt false
     * @param {boolean} remainSelMode selModefalse
     * @param {boolean} remainTimeView viewfalse
     */  
    UI_X_CALENDAR_LAYER_CLASS.render = function (opt) {
        opt = opt || {};
        var model = this.getModel();

        !opt.remainSlt && this.$resetSltDatasource();
        !opt.remainSelMode && this.$resetSelModeCtrl();
        
        if (!opt.remainTimeView) {
            var aDate = this._oModel.getDate();
            var viewDate = opt.viewDate 
                // 
                || aDate[aDate.length - 1]
                || (
                    opt = new Date(), 
                    opt.setFullYear(
                        Math.min(
                            Math.max(model._nYearRangeStart, opt.getFullYear()), 
                            model._nYearRangeEnd
                        )
                    ),
                    opt
                );

            // monthSlt, yearSlt
            setSltValue(this._uYearSlt, viewDate.getFullYear());
            setSltValue(this._uMonthSlt, viewDate.getMonth() + 1);
            this.$resetStepBtn();
        }

        this.$flushCalView();
    };

    UI_X_CALENDAR_LAYER_CLASS.$resetSelModeCtrl = function () {
        var type = this.getTypes()[0];
        var uSelMode = this._uSelMode;
        var outer = uSelMode.getOuter();
        var model = this.getModel();
        var aSelModeList = model.getSelModeList();
        var selMode = model.getSelMode();

        // 
        outer.innerHTML = '';

        if (!aSelModeList || !aSelModeList.length) {
            outer.style.display = 'none';
        }
        else {
            outer.style.display = '';
        }

        // 
        var html = [];
        var i;
        var o;
        var checked;
        var prompt;
        for (i = 0; o = aSelModeList[i]; i ++) {
            prompt = o.prompt ? (' title="' + encodeHTML(o.prompt) + '" ') : '';
            checked = o.value == selMode ? ' checked="checked" ' : '';
            html.push(
                '<input ' + prompt + ' type="radio" name="' + type + '-selmode-radio-' + this.getUID() 
                + '" class="' + type + '-selmode-radio" ' + checked 
                + ' data-selmode="' + o.value + '"/>'
            );
            html.push('<span ' + prompt + ' class="' + type + '-selmode-text">' + encodeHTML(o.text) + '</span>');
        }
        outer.innerHTML = html.join('');

    };

    UI_X_CALENDAR_LAYER_CLASS.$resetSltDatasource = function () {
        var range = this._oModel.getRange();
        var yearSlt = this._uYearSlt;
        var model = this.getModel();
        if (!yearSlt) { return; }

        var yearBase = (range.offsetBase || new Date()).getFullYear();
        var yearRangeStart = range.start 
            ? range.start.getFullYear() : (yearBase - 5);
        var yearRangeEnd = range.end 
            ? range.end.getFullYear() : (yearBase + 5);

        var oldValue = Number(getSltValue(yearSlt));
        var newValue;

        // 
        yearSlt.setValue(null);
        while(yearSlt.remove(0)) {}

        // 
        for (var i = yearRangeStart; i <= yearRangeEnd; i++) {
            yearSlt.add(String(i), null, { value: Number(i) });
            i == oldValue && (newValue = i);
        }

        model._nYearRangeStart = yearRangeStart;
        model._nYearRangeEnd = yearRangeEnd;

        yearSlt.setValue(newValue != null ? newValue : yearRangeStart);
        this.$resetStepBtn();
    };

    UI_X_CALENDAR_LAYER_CLASS.$resetStepBtn = function () {
        var yearSltValue = Number(getSltValue(this._uYearSlt));
        var monthSltValue = Number(getSltValue(this._uMonthSlt));
        var model = this.getModel();
        var timeType = model.getTimeType();

        // yearSlt
        var d = [yearSltValue, monthSltValue - 1];
        d = goViewStep(d, 1, timeType);
        this._uNxtBtn[
            d.getFullYear() > model._nYearRangeEnd ? 'disable' : 'enable'
        ]();

        d = [yearSltValue, monthSltValue - 1];
        d = goViewStep(d, -1, timeType);
        this._uPrvBtn[
            d.getFullYear() < model._nYearRangeStart ? 'disable' : 'enable'
        ]();
    };

    UI_X_CALENDAR_LAYER_CLASS.getDate = function () {
        return this._oModel.getDate();
    };

    UI_X_CALENDAR_LAYER_CLASS.getModel = function () {
        return this._oModel;
    };

    UI_X_CALENDAR_LAYER_CLASS.getValue = UI_X_CALENDAR_LAYER_CLASS.getDate;

    UI_X_CALENDAR_LAYER_CLASS.getTimeType = function () {
        return this._oModel.getTimeType();
    };

    UI_X_CALENDAR_LAYER_CLASS.init = function () {
        this._uMonthSlt && this._uMonthSlt.init();
        this._uYearSlt && this._uYearSlt.init();
        this._uCalView.init();
        UI_X_CALENDAR_LAYER.superClass.init.call(this);
    };

    //----------------------------------------------------
    // 
    //----------------------------------------------------

    UI_X_CALENDAR_LAYER_SELECT_CLASS.onchange = function () {
        var par = this.getParent()
        par.$resetStepBtn();
        par.$flushCalView();
    };

    //----------------------------------------------------
    //  button
    //----------------------------------------------------

    UI_X_CALENDAR_LAYER_STEP_BUTTON_CLASS.onclick = function () {
        var layer = this.getParent();
        var yearSlt = layer._uYearSlt;
        var monthSlt = layer._uMonthSlt;
        var d = [
            Number(getSltValue(yearSlt)), 
            Number((getSltValue(monthSlt) || 1) - 1), 
            1
        ];

        d = goViewStep(d, this._nStep, layer.getModel().getTimeType());
        setSltValue(yearSlt, d.getFullYear());
        setSltValue(monthSlt, d.getMonth() + 1);
        layer.$resetStepBtn();
        layer.$flushCalView();
    };

    //----------------------------------------------------
    // selmode 
    //----------------------------------------------------

    UI_X_CALENDAR_LAYER_SEL_MODE_CLASS.onclick = function (event) {
        var par = this.getParent();
        var target = event.target;
        if (target.tagName == 'INPUT') {
            var model = par.getModel()
            model.setDatasource({ selMode: target.getAttribute('data-selmode') });
            par.$flushCalView();
            /**
             * @event
             */
            triggerEvent(par, 'change', null, [model.getDate()]);
        }
    };

    //----------------------------------------------------
    // Calendar Model
    //----------------------------------------------------

    function modelConstructor(options) {
        this._aDate = [];
        this._aDefaultDate = [];
        this._oRange = {};
        this._aHoverDate = [];

        this.setDatasource(options);
    };

    /**
     * model
     * 
     * @public
     * @param {Object} datasource 
     * @param {string} datasource.selMode
     * @param {Array.<Object>} datasource.selModeList 
     * @param {string} datasource.timeType
     * @param {Object} datasource.range
     * @param {Date|string} datasource.range.start
     * @param {Date|string} datasource.range.end
     * @param {Date|string} datasource.range.offsetBase
     * @param {Date|string|Array} datasource.date 
     */
    UI_X_CALENDAR_MODEL_CLASS.setDatasource = function (datasource) {
        datasource = datasource || {};

        // forbidEmpty
        if (datasource.forbidEmpty != null) {
            this._bForbidEmpty = datasource.forbidEmpty || false;
        }

        // timeType
        if (datasource.timeType) {
            this._sTimeType = datasource.timeType;
            // cellTimeTypetimeType
            // 
            this._sCellTimeType = datasource.cellTimeType;
            if (this._sCellTimeType == 'W') {
                this._sCellTimeType = 'D';
            }
        }

        // selModelList
        var selModeListChange;
        if (datasource.selModeList) {
            selModeListChange = this._aSelModeList = datasource.selModeList;
        }

        // selMode (selModeselModeList)
        var newSelMode;
        if ((newSelMode = datasource.selMode) || selModeListChange) {
            // selMode
            var oldSelMode = this._sSelMode;
            this._sSelMode = newSelMode || selModeListChange[0].value;
            this.$switchSelMode(oldSelMode, newSelMode);
        }

        // range
        var range = datasource.range;
        if (range) {
            this._oRange = parseRange(
                range.start, 
                range.end, 
                range.offsetBase, 
                this._sCellTimeType
            );
            this.$clipByRange(this._aDate);
        }

        // defaultDate
        var aDefaultDate = datasource.defaultDate;
        if (aDefaultDate) {
            this._aDefaultDate = this.$parseADate(aDefaultDate);
        }

        // _aDate
        var aDate = datasource.date;
        if (aDate) {
            this._aDate = this.$parseADate(aDate);
        }
        
        // 
        if (this._bForbidEmpty && !this._aDate.length) {
            this._aDate = cloneADate(this._aDefaultDate);
        }

        // 
        if (this._sSelMode == 'SINGLE') {
            this._aDate = this._aDate.slice(0, 1);
        }
        else if (this._sSelMode == 'RANGE') {
            this._aDate = this._aDate.slice(0, 2);
        }
    };

    UI_X_CALENDAR_MODEL_CLASS.$parseADate = function (aDate) {
        var aDate = parseInputDate(aDate) || [];
        if (!isArray(aDate)) {
            aDate = [aDate];
        }

        if (this._sSelMode == 'RANGE' 
            && aDate[0]
            && aDate[1] 
            && compareDate(aDate[0], aDate[1], this._sCellTimeType) > 0
        ) {
            var tmp = aDate[1];
            aDate[1] = aDate[0];
            aDate[0] = tmp;
        }
        this.$clipByRange(aDate);

        return aDate;
    };    

    UI_X_CALENDAR_MODEL_CLASS.getDate = function () {
        return this._aDate;
    };

    UI_X_CALENDAR_MODEL_CLASS.getDefaultDate = function () {
        return this._aDefaultDate;
    };

    UI_X_CALENDAR_MODEL_CLASS.getTimeType = function () {
        return this._sTimeType;
    };
    
    UI_X_CALENDAR_MODEL_CLASS.goStep = function (step) {
        for (var i = 0, d; i < this._aDate.length; i ++) {
            if (d = this._aDate[i]) {
                this._aDate[i] = goCellStep(d, step, this._sTimeType);
            }
        }
    };    

    UI_X_CALENDAR_MODEL_CLASS.getHoverDate = function (selMode) {
        return this._aHoverDate || [];
    };

    UI_X_CALENDAR_MODEL_CLASS.getSelMode = function () {
        return this._sSelMode;
    };    

    UI_X_CALENDAR_MODEL_CLASS.getSelModeList = function () {
        return this._aSelModeList;
    };    

    UI_X_CALENDAR_MODEL_CLASS.getRange = function () {
        return this._oRange;
    };

    UI_X_CALENDAR_MODEL_CLASS.$clipByRange = function (aDate) {
        var range = this.getRange();
        var timeType = this._sTimeType;

        for (var i = 0, date; i < aDate.length; ) {
            if ((date = aDate[i])
                && (!range.start || compareDate(date, range.start, timeType) >= 0)
                && (!range.end || compareDate(range.end, date, timeType) >= 0)
            ) {
                i ++;
            }
            else {
                this._sSelMode == 'RANGE'
                    // range
                    ? (aDate = [])
                    : aDate.splice(i, 1);
            }
        }
    };

    UI_X_CALENDAR_MODEL_CLASS.testEdge = function (step) {
        var timeType = this._sTimeType;
        var aDate = this.getDate().slice();
        var range = this.getRange();
        var m;

        var lowerBound = range.start;
        var upperBound = range.end;

        if (!lowerBound) {
            lowerBound = [this._nYearRangeStart, 0, 1];
        }
        if (!upperBound) {
            upperBound = [this._nYearRangeEnd, 11, 31];
        }

        if (!aDate.length) {
            return false;
        }

        if (step < 0 && lowerBound) {
            m = minDate.apply(null, [timeType].concat(aDate));

            return compareDate(
                goCellStep(m, step, timeType),
                lowerBound,
                timeType
            ) >= 0;
        }   
        else if (step > 0 && upperBound) {
            m = maxDate.apply(null, [timeType].concat(aDate));

            return compareDate(
                goCellStep(m, step, timeType),
                upperBound,
                timeType
            ) <= 0;
        }
        else {
            return true;
        }
    };

    UI_X_CALENDAR_MODEL_CLASS.udateDateByClick = function (thisClick) {
        var modelDate = this.getDate();
        var selMode = this.getSelMode();
        var hasChange = true;
        var timeType = this._sTimeType;

        if (selMode == 'RANGE') {
            modelDate[0] && !modelDate[1]
                // 
                ? (modelDate[1] = thisClick)
                // 
                : (modelDate = [thisClick])
        }
        else if (selMode == 'SINGLE') {
            modelDate[0] && compareDate(modelDate[0], thisClick, timeType) == 0 
                ? (hasChange = false)
                : (modelDate[0] = thisClick);
        }
        else if (selMode == 'MULTIPLE') {
            var del = false;
            for (var i = 0, o; o = modelDate[i]; ) {
                if (compareDate(o, thisClick, timeType) == 0) {
                    modelDate.splice(i, 1);
                    del = true;
                }
                else {
                    i ++;
                }
            }
            !del && modelDate.push(thisClick);
        }

        // model
        this.setDatasource({ date: modelDate });

        return hasChange;
    };

    UI_X_CALENDAR_MODEL_CLASS.updateHoverDate = function (refDate, isHover) {
        var dateArr = [];
        var modelDate = this.getDate();

        if (!isHover) {
            this._aHoverDate = [];
        }
        else {
            if (this._sSelMode == 'RANGE' && modelDate[0] && !modelDate[1]) {
                if (compareDate(modelDate[0], refDate, this._sTimeType) > 0) {
                    dateArr = [refDate, modelDate[0]];
                }
                else {
                    dateArr = [modelDate[0], refDate];
                }
            }
            else {
                dateArr = [refDate];
            }   
            this._aHoverDate = dateArr;
        }
    };

    UI_X_CALENDAR_MODEL_CLASS.$switchSelMode = function (oldSelMode, newSelMode) {
        if (oldSelMode == newSelMode || oldSelMode == null || newSelMode == null) {
            return;
        }
        else {
            this._aDate = [];
        }
    }

})();

/**
 * ecui.ui.XCalendar
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           
 *           
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  ecui
 */

/**
 * 
 * {
 *     "forbidEmpty": false,
 *     "disableCancelBtn": false,
 *
 *     // "D""W""M""Q"
 *     // "Day""Week"
 *     "timeTypeList": [
 *         // 
 *         // 
 *         { "value": "D", "text": "" },
 *         { "value": "W", "text": "" },
 *         { "value": "M", "text": "" },
 *         { "value": "Q", "text": "" }
 *     ],
 *
 *     "timeTypeOpt": {
 *         // 
 *         // 
 *         "D": {
 *             "date": ["-31D", "-1D"],
 *             "range": {
 *                  start: "2011-01-01",
 *                  end: "-1D",
 *                  offsetBase: new Date()
 *             },
 *             // selModelList
 *             // value"SINGLE""RANGE""MULTIPLE"
 *             "selModeList": [
 *                 { "text": "", "value": "SINGLE", "prompt": "" }
 *             ],
 *             // selModeList
 *             "selMode": "SINGLE"
 *         },
 *
 *         "W": {
 *             "date": ["-31D", "-1D"],
 *             "range": {
 *                  start: "2011-01-01",
 *                  end: "-1D",
 *                  offsetBase: new Date()
 *             },
 *             "selModeList": [
 *                 { "text": "", "value": "SINGLE", "prompt": "" },
 *                 { "text": "", "value": "RANGE", "prompt": "" }
 *             ],
 *             "selMode": "RANGE"
 *         },
 *
 *         "M": {
 *             "date": ["-31D", "-1D"],
 *             "range": {
 *                  start: "2011-01-01",
 *                  end: "-1D",
 *                  offsetBase: new Date()
 *             },
 *             "selModeList": [
 *                 { "text": "", "value": "SINGLE", "prompt": "" },
 *                 { "text": "", "value": "RANGE", "prompt": "" },
 *                 { "text": "", "value": "MULTIPLE", "prompt": "" }
 *             ],
 *             "selMode": "MULTIPLE"
 *         },
 *
 *         "Q": {
 *             "date": ["-31D", "-1D"],
 *             "range": {
 *                  start: "2011-01-01",
 *                  end: "-1D",
 *                  offsetBase: new Date()
 *             },
 *             "selModeList": [
 *                 { "text": "", "value": "SINGLE", "prompt": "" }
 *             ],
 *             "selMode": "SINGLE"
 *         }
 *     }
 */

(function() {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;
    var cutil = ui.XCalendarUtil;

    var DATE = Date;
    var REGEXP = RegExp;
    var DOCUMENT = document;
    var objProtoToString = Object.prototype.toString;
    var REGEXP = RegExp;

    var children = dom.children;
    var createDom = dom.create;
    var getParent = dom.getParent;
    var getPosition = dom.getPosition;
    var moveElements = dom.moveElements;
    var setText = dom.setText;
    var addClass = dom.addClass;
    var formatDate = string.formatDate;
    var getByteLength = string.getByteLength;
    var encodeHTML = string.encodeHTML;
    var sliceByte = string.sliceByte;
    var indexOf = array.indexOf;
    var getView = util.getView;
    var blank = util.blank;
    var extend = util.extend;
    var getWeekInfo = cutil.getWeekInfo;
    var getQuarter = cutil.getQuarter;
    var minDate = cutil.minDate;
    var maxDate = cutil.maxDate;
    var arrProtoSlice = Array.prototype.slice;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var setFocused = core.setFocused;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_INPUT_CONTROL = ui.InputControl;
    var UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
    var UI_SELECT = ui.Select;
    var UI_BUTTON = ui.Button;
    var UI_LAYER = ui.XCalendarLayer;

    //-------------------------------------------------
    // 
    //-------------------------------------------------

    /**
     * 
     *
     * @class
     * @param {Object} options setDatasource
     * @param {string=} options.headText ''
     * @param {string=} options.rangeLinkStr '  '
     * @param {string=} options.weekLinkStr ' ~ '
     * @param {string=} options.blankText '' 
     */
    var UI_X_CALENDAR = ui.XCalendar =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-x-calendar',
            function(el, options) {
                options.hidden = true;
            },
            function(el, options) {
                var type = this.getTypes()[0];
                var i;
                var item;
                var selected;
                var html = [];
                var domIndex = 0;
                var domIndexTimeType;
                var domIndexInfo;
                var domIndexLayer;
                var shiftBtnDisabled = this._bShiftBtnDisabled = options.shiftBtnDisabled;

                this._oTextOptions = {
                    blankText: options.blankText,
                    rangeLinkStr: options.rangeLinkStr,
                    weekLinkStr: options.weekLinkStr
                };

                // 
                var headText = options.headText;
                if (headText == null) {
                    headText = ''
                    html.push('<span class="' + type + '-head-text">' + encodeHTML(headText) + '</span>');
                    domIndex ++;
                }

                // 
                html.push('<select class="'+ type +'-slt-timetype'+ UI_SELECT.TYPES +'">');
                html.push('</select>');
                domIndexTimeType = domIndex ++;

                // 
                html.push(
                    '<span class="' + type + '-btn-prv ' + type + '-btn"></span>',
                    '<span class="' + type + '-text"></span>',
                    '<span class="' + type + '-btn-cancel ' + type + '-btn"></span>',
                    '<span class="' + type + '-btn-cal ' + type + '-btn"></span>',
                    '<span class="' + type + '-btn-nxt ' + type + '-btn"></span>'
                );
                domIndexInfo = domIndex;
                domIndex += 5;

                // layer
                domIndexLayer = domIndex;
                var tList = ['D', 'W', 'M', 'Q'];
                for (i = 0; item = tList[i]; i ++) {
                    html.push('<div class="'+ type +'-layer" style="position:absolute;display:none"></div>');
                    domIndex ++;
                }

                // 
                var o = createDom();
                o.innerHTML = html.join('');
                var child = children(o);
                var node;

                // 
                if (domIndexTimeType != null) {
                    this._uTimeTypeSlt = $fastCreate(
                        this.Select, child[domIndexTimeType], this
                    );
                }

                // 
                this._eText = child[domIndexInfo + 1];
                
                // prev
                node = child[domIndexInfo];
                if (shiftBtnDisabled) {
                    node.style.display = 'none';
                }
                this._uBtnPrv = $fastCreate(
                    this.Button, node, this, { command: 'prv', icon: true }
                );

                // 
                node = child[domIndexInfo + 2];
                this._uBtnCancel = $fastCreate(
                    this.Button, node, this, { command: 'cancel', icon: true }
                );

                // 
                node = child[domIndexInfo + 3];
                this._uBtnCal = $fastCreate(
                    this.Button, node, this, { command: 'cal', icon: true }
                );

                // next
                node = child[domIndexInfo + 4];
                if (shiftBtnDisabled) {
                    node.style.display = 'none';
                }
                this._uBtnNxt = $fastCreate(
                    this.Button, node, this, { command: 'nxt', icon: true }
                );

                // layers
                var layers = this._oLayers = {};
                i = 0;
                for (i = 0; item = tList[i]; i ++) {
                    node = child[domIndexLayer + i];
                    DOCUMENT.body.appendChild(node);
                    // 
                    layers[item] = node;
                }

                moveElements(o, el, true);

                // 
                this.setDatasource(options);
            }
        );

    var UI_X_CALENDAR_CLASS = UI_X_CALENDAR.prototype;

    var UI_X_CALENDAR_BUTTON_CLASS = (
            UI_X_CALENDAR_CLASS.Button = inheritsControl(
                UI_BUTTON, 
                null, 
                function(el, options){
                    var o = createDom();
                    var type = this.getType();
                
                    moveElements(el, o, true);
                    el.innerHTML = '<span class="'+ type +'-inner"></span>';
                    moveElements(o, el.firstChild, true);

                    if (options.icon) {
                        o = createDom(type + '-icon', '',  'span');
                        el.appendChild(o);
                    }

                    this._sCommand = options.command;
                }
            )
        ).prototype;

    var UI_X_CALENDAR_SELECT_CLASS = (
            UI_X_CALENDAR_CLASS.Select = inheritsControl(UI_SELECT, null)
        ).prototype;

    UI_X_CALENDAR_SELECT_CLASS.Options = inheritsControl(
        UI_X_CALENDAR_SELECT_CLASS.Options, 
        null, 
        null, 
        function(el, options) {
            addClass(el, 'ui-x-calendar-select-options');
        }
    );

    var UI_X_CALENDAR_LAYER_CLASS = (
            UI_X_CALENDAR_CLASS.Layer = inheritsControl(UI_LAYER)
        ).prototype;

    var UI_X_CALENDAR_MODEL = UI_X_CALENDAR_LAYER_CLASS.Model;
    var UI_X_CALENDAR_MODEL_CLASS = UI_X_CALENDAR_MODEL.prototype;

    //-------------------------------------------------
    // 
    //-------------------------------------------------

    var PATTERN_SHOW_DATE = 'yyyy-MM-dd';
    var PATTERN_SHOW_MONTH = 'yyyy-MM';
    var DATE_ZERO = new Date(0);

    //----------------------------------------------
    // UI_X_CALENDAR_CLASS 
    //----------------------------------------------

    /**
     * 
     *
     * @param {Object} datasource 
     * @param {string} datasource.preText
     * @param {string=} datasource.timeType 'D', 'W', 'M', 'Q''D'
     * @param {Array=} datasource.timeTypeList []null
     *      { text: '', value: 'D' }valuetimeTypeOptkey
     * @param {Object=} datasource.timeTypeOpt 
     *      {
     *          D: { ...  },
     *          W: { ...  },
     *          M: { ...  },
     *          Q: { ...  }   
     *      }
     *      ""x-calendar-layer.js
     * @param {boolean} datasource.disableCancelBtn
     * @param {boolean} datasource.disablePreviousBtn
     * @param {boolean} datasource.disableNextBtn
     * @param {boolean=} datasource.forbidEmpty datenotEmptyfalse
     */    
    UI_X_CALENDAR_CLASS.setDatasource = function (datasource, silent, renderOpt) {
        datasource = datasource || {};

        var timeTypeOpt = datasource.timeTypeOpt || {};
        var timeTypeList = this._aTimeTypeList = datasource.timeTypeList 
            || [
                { text: '', value: 'D'},
                { text: '', value: 'W'},
                { text: '', value: 'M'},
                { text: '', value: 'Q'}
            ];
        var models = this._oModels = this._oModels || {};
        var timeType = this._sTimeType = datasource.timeType 
            || (timeTypeList.length ? timeTypeList[0].value : void 0);

        if (datasource.disableCancelBtn) {
            this._uBtnCancel.hide();
        }
        if (datasource.disablePreviousBtn) {
            this._uBtnPrv.hide();
        }
        if (datasource.disableNextBtn) {
            this._uBtnNxt.hide();
        }

        // layermodel
        for (var i = 0, t, opt, dft; t = timeTypeList[i]; i ++) {
            t = t.value;
            opt = 
                timeTypeOpt[t] = 
                extend({ timeType: t }, timeTypeOpt[t]);

            // 
            dft = UI_X_CALENDAR_MODEL_CLASS.DEFAULT;
            if (!opt.selMode) {
                opt.selMode = dft.selMode;
            }
            if (!opt.timeType) {
                opt.timeType = dft.timeType;
            }
            if (!opt.selModeList) {
                opt.selModeList = dft.selModeList;
            }
            if (!opt.defaultDate) {
                opt.defaultDate = opt.date;
            }
            opt.forbidEmpty = datasource.forbidEmpty || false;

            !models[t]
                ? (models[t] = new UI_X_CALENDAR_MODEL(opt))
                : models[t].setDatasource(opt);
        }

        !silent && this.render(renderOpt);
    };

    /** 
     * 
     *
     * @public
     * @param {Object} opt
     * @param {Date} viewDate 
     * @param {boolean} remainSlt 
     * @param {boolean} remainLayer layer
     */  
    UI_X_CALENDAR_CLASS.render = function (opt) {
        opt = opt || {};

        var timeType = this._sTimeType;

        if (!timeType) { return;}

        var models = this._oModels;
        var timeTypeList = this._aTimeTypeList;
        var layers = this._oLayers;

        !opt.remainSlt && this.$resetTimeTypeSlt();

        for (var i = 0, t, layer, isNew; t = timeTypeList[i]; i ++) {
            t = t.value;
            isNew = false;

            // layer
            if (!(layers[t] instanceof UI_CONTROL)) {
                layers[t] = $fastCreate(
                    this.Layer, layers[t], this, { model: models[t] }
                );
                layers[t].init();
                isNew = true;
            }

            layer = layers[t];

            if (t == timeType) {
                if (layer._bLayerShow && !opt.remainLayer) {
                    layer.hide();
                }
            }
            else {
                layers[t].hide();
            }
        }

        this.$flushThis();
    };    

    UI_X_CALENDAR_CLASS.$setSize = new Function();

    UI_X_CALENDAR_CLASS.$resetTimeTypeSlt = function () {
        var timeTypeList = this._aTimeTypeList;
        var slt = this._uTimeTypeSlt;
        if (!slt) { return; }

        // 
        slt.setValue(null);
        while(slt.remove(0)) {}

        // 
        for (var i = 0, t, item; t = timeTypeList[i]; i ++) {
            slt.add(String(t.text), null, { value: t.value });
        }

        slt.setValue(this._sTimeType);
    };

    UI_X_CALENDAR_CLASS.$showLayer = function() {
        var layer = this.getCurrLayer();
        var anchor = this._bShiftBtnDisabled 
            ? this._eText : this._uBtnPrv.getOuter();
        var pos = getPosition(anchor);
        var posTop = pos.top + this.getHeight();

        if (!layer._bLayerShow) {
            layer.render({ remainSlt: true, remainSelMode: true });
            layer.show();
            setFocused(layer);

            var height = layer.getHeight();
            layer.setPosition(
                pos.left,
                posTop + height <= getView().bottom 
                    ? posTop : pos.top - height
            );
        }
    }

    UI_X_CALENDAR_CLASS.$clear = function() {
        var model = this.getModel();
        this.getModel().setDatasource({ date: [] });
        this.$flushThis();
    }

    UI_X_CALENDAR_CLASS.$flushThis = function() {
        var curDate = this._oDate;
        var model = this.getModel();

        var txt = this.$getShowText();
        this._eText.innerHTML = txt.shortHTML;
        txt.fullText && this._eText.setAttribute('title', txt.fullText);
        this._uBtnPrv[model.testEdge(-1) ? 'enable' : 'disable']();
        this._uBtnNxt[model.testEdge(1) ? 'enable' : 'disable']();
    }

    UI_X_CALENDAR_CLASS.$getSingleText = function (date) {
        options = this._oTextOptions || {};
        var model = this.getModel();
        var timeType = this._sTimeType;

        if (!date) { return ''; }

        if (timeType == 'D') {
            return formatDate(date, PATTERN_SHOW_DATE);
        }
        else if (timeType == 'W') {
            var weekInfo = getWeekInfo(date);
            var range = model.getRange();
            // weekrangeweek
            // range
            return formatDate(
                    range.start
                        ? maxDate('D', weekInfo.workday, range.start)
                        : weekInfo.workday,
                    PATTERN_SHOW_DATE
                )
                + (options.weekLinkStr || ' ~ ')
                + formatDate(
                    range.end
                        ? minDate('D', weekInfo.weekend, range.end)
                        : weekInfo.weekend, 
                    PATTERN_SHOW_DATE
                );
        }
        else if (timeType == 'M') {
            return formatDate(date, PATTERN_SHOW_MONTH);
        }
        else if (timeType == 'Q') {
            return date.getFullYear() + '-Q' + getQuarter(date);
        }
    };

    UI_X_CALENDAR_CLASS.$getShowText = function () {
        options = this._oTextOptions || {};
        var type = this.getType();
        var model = this.getModel();
        var aDate = model.getDate();
        var timeType = this._sTimeType;
        var selMode = model.getSelMode();
        var shortText;
        var fullText;
        var rangeLinkStr = options.rangeLinkStr || '  ';
        var tmp;

        if (!aDate[0]) {
            shortHTML = [
                '<span class="', type, '-blank', '">',
                    encodeHTML(options.blankText || ''),
                '</span>'
            ].join('');
            return { shortHTML: shortHTML, fullText: '' };
        }

        if (selMode == 'SINGLE') {
            fullText = shortText = this.$getSingleText(aDate[0], options);
        }
        else if (selMode == 'RANGE') {
            if (timeType == 'W') {
                shortText = this.$getSingleText(aDate[0], options);
                tmp = this.$getSingleText(aDate[1], options);
                fullText = '[' + shortText + ']'
                    + rangeLinkStr + (tmp ? '[' + tmp + ']' : '');
                shortText += ', ...';
            }
            else {
                shortText = fullText = this.$getSingleText(aDate[0], options) 
                    + rangeLinkStr
                    + this.$getSingleText(aDate[1], options);
            }
        }
        else if (selMode == 'MULTIPLE') {
            shortText = this.$getSingleText(aDate[0], options) + ', ...';
            fullText = [];
            for (var i = 0; i < aDate.length; i ++) {
                fullText.push(this.$getSingleText(aDate[i], options));
            }

            fullText = '[' + fullText.join('], [') + ']';
        }

        return { shortHTML: encodeHTML(shortText), fullText: fullText };
    };    

    UI_X_CALENDAR_CLASS.$click = function(event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this);
        if (event.target == this._eText) {
            this.$showLayer();
        }
    };

    UI_X_CALENDAR_CLASS.$activate = function (event) {
        UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
        this.$showLayer();
    };

    UI_X_CALENDAR_CLASS.$goStep = function(step) {
        this.getModel().goStep(step);
        this.getCurrLayer().render({ remainSlt: true, remainSelMode: true });
        this.$flushThis();
    };

    UI_X_CALENDAR_CLASS.getModel = function() {
        return this.getCurrLayer().getModel();
    };
    
    UI_X_CALENDAR_CLASS.getCurrLayer = function() {
        return this._oLayers[this._sTimeType];
    };
    
    UI_X_CALENDAR_CLASS.getDate = function() {
        return this.getModel().getDate();
    };

    UI_X_CALENDAR_CLASS.getValue = UI_X_CALENDAR_CLASS.getDate;

    UI_X_CALENDAR_CLASS.getTimeType = function() {
        return this.getModel().getTimeType();
    };

    UI_X_CALENDAR_CLASS.getSelMode = function() {
        return this.getModel().getSelMode();
    };

    UI_X_CALENDAR_CLASS.init = function() {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this._uBtnCal.init();
        this._uBtnCancel.init();
        this._uBtnNxt.init();
        this._uBtnPrv.init();
        this._uTimeTypeSlt.init();
    };

    //----------------------------------------------
    // UI_X_CALENDAR_BUTTON_CLASS 
    //----------------------------------------------

    UI_X_CALENDAR_BUTTON_CLASS.$click = function (event) {
        var par = this.getParent();
        var changed;
        switch(this._sCommand) {
            case 'prv':
                par.$goStep(-1);
                changed = true;
                break;
            case 'nxt':
                par.$goStep(1);
                changed = true;
                break;
            case 'cal':
                par.$showLayer();
                break;
            case 'cancel': 
                par.$clear();
                changed = true;
                break;
        }

        /**
         * @event
         */
        triggerEvent(
            par, 'change', null, [par.getModel().getDate().slice()]
        );

        event.exit();
    };

    //----------------------------------------------
    // UI_X_CALENDAR_SELECT_CLASS 
    //----------------------------------------------

    UI_X_CALENDAR_SELECT_CLASS.onchange = function () {
        var par = this.getParent();
        par._sTimeType = this.getValue();
        par.$flushThis();

        /**
         * @event
         */
        triggerEvent(
            par, 'change', null, [par.getModel().getDate().slice()]
        );
    };

    //--------------------------------------------------------------
    // UI_X_CALENDAR_LAYER_CLASS 
    //--------------------------------------------------------------

    UI_X_CALENDAR_LAYER_CLASS.$blur = function () {
        this.hide();
    };
    
    UI_X_CALENDAR_LAYER_CLASS.onchange = function() {
        var par = this.getParent();
        par.$flushThis();
        this._bLayerChanged = true;
    };    

    UI_X_CALENDAR_LAYER_CLASS.ondateclick = function() {
        var model = this.getModel();
        var selMode = model.getSelMode();
        var aDate = model.getDate();

        if (selMode == 'SINGLE') {
            this.hide();
        }
    };

    UI_X_CALENDAR_LAYER_CLASS.show = function() {
        this._bLayerShow = true;
        this._bLayerChanged = false;
        UI_X_CALENDAR_CLASS.Layer.superClass.show.apply(this, arguments);
    };

    UI_X_CALENDAR_LAYER_CLASS.hide = function() {
        if (this._bLayerShow) {

            var par = this.getParent();
            var model = this.getModel();
            var selMode = model.getSelMode();
            var aDate = model.getDate();

            // 
            if (selMode == 'RANGE' && aDate[0] && !aDate[1]) {
                aDate[1] = new Date(aDate[0].getTime());
                par.$flushThis();
            }

            par && triggerEvent(par, 'layerhide');

            if (this._bLayerChanged) {
                triggerEvent(
                    par, 'change', null, [this.getModel().getDate().slice()]
                );
                this._bLayerChanged = false;
            }
        }

        this._bLayerShow = false;

        UI_X_CALENDAR_CLASS.Layer.superClass.hide.apply(this, arguments);
    };

})();


// Customized highstock. (any problem, contact sushuang@baidu.com)
// All modifications are marked as [CUSTOMIZED].
// Change log:
// (1) tooltip move: forbiden animation in IE6/7/8
// (2) fix bug: rangeSelector button sometimes does not be set unselect 
//     (this bug is fixed in 1.1.6, but there are another bug in 1.1.6 (#1105), so we still use 1.1.5)
// (3) add quarter format support in dateFormat
// (4) add support of user defined rangeSelector
// (5) fix reflow bug: execute resize (by setTimeout) after chart is destroyed.

// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS

/**
 * @license Highstock JS v1.1.5 (2012-03-15)
 *
 * (c) 2009-2011 Torstein Hnsi
 *
 * License: www.highcharts.com/license
 */

// JSLint options:
/*global Highcharts, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console */

(function () {
// encapsulated variables
var UNDEFINED,
	doc = document,
	win = window,
	math = Math,
	mathRound = math.round,
	mathFloor = math.floor,
	mathCeil = math.ceil,
	mathMax = math.max,
	mathMin = math.min,
	mathAbs = math.abs,
	mathCos = math.cos,
	mathSin = math.sin,
	mathPI = math.PI,
	deg2rad = mathPI * 2 / 360,


	// some variables
	userAgent = navigator.userAgent,
	isIE = /msie/i.test(userAgent) && !win.opera,
	ieVersion = /msie (\d+\.\d+)/i.test(userAgent) ? (document.documentMode || + RegExp['\x241']) : undefined,
	docMode8 = doc.documentMode === 8,
	isWebKit = /AppleWebKit/.test(userAgent),
	isFirefox = /Firefox/.test(userAgent),
	SVG_NS = 'http://www.w3.org/2000/svg',
	hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
	useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
	Renderer,
	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED,
	symbolSizes = {},
	idCounter = 0,
	garbageBin,
	defaultOptions,
	dateFormat, // function
	globalAnimation,
	pathAnim,
	timeUnits,

	// some constants for frequently used strings
	DIV = 'div',
	ABSOLUTE = 'absolute',
	RELATIVE = 'relative',
	HIDDEN = 'hidden',
	PREFIX = 'highcharts-',
	VISIBLE = 'visible',
	PX = 'px',
	NONE = 'none',
	M = 'M',
	L = 'L',
	/*
	 * Empirical lowest possible opacities for TRACKER_FILL
	 * IE6: 0.002
	 * IE7: 0.002
	 * IE8: 0.002
	 * IE9: 0.00000000001 (unlimited)
	 * FF: 0.00000000001 (unlimited)
	 * Chrome: 0.000001
	 * Safari: 0.000001
	 * Opera: 0.00000000001 (unlimited)
	 */
	TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.000001 : 0.002) + ')', // invisible but clickable
	//TRACKER_FILL = 'rgba(192,192,192,0.5)',
	NORMAL_STATE = '',
	HOVER_STATE = 'hover',
	SELECT_STATE = 'select',
	MILLISECOND = 'millisecond',
	SECOND = 'second',
	MINUTE = 'minute',
	HOUR = 'hour',
	DAY = 'day',
	WEEK = 'week',
	MONTH = 'month',
	YEAR = 'year',

	// constants for attributes
	FILL = 'fill',
	LINEAR_GRADIENT = 'linearGradient',
	STOPS = 'stops',
	STROKE = 'stroke',
	STROKE_WIDTH = 'stroke-width',

	// time methods, changed based on whether or not UTC is used
	makeTime,
	getMinutes,
	getHours,
	getDay,
	getDate,
	getMonth,
	getFullYear,
	setMinutes,
	setHours,
	setDate,
	setMonth,
	setFullYear,

	// check for a custom HighchartsAdapter defined prior to this file
	globalAdapter = win.HighchartsAdapter,
	adapter = globalAdapter || {},

	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
	// and all the utility functions will be null. In that case they are populated by the
	// default adapters below.
	getScript = adapter.getScript,
	each = adapter.each,
	grep = adapter.grep,
	offset = adapter.offset,
	map = adapter.map,
	merge = adapter.merge,
	addEvent = adapter.addEvent,
	removeEvent = adapter.removeEvent,
	fireEvent = adapter.fireEvent,
	animate = adapter.animate,
	stop = adapter.stop,

	// lookup over the types and the associated classes
	seriesTypes = {};

// The Highcharts namespace
win.Highcharts = {};

/**
 * Extend an object with the members of another
 * @param {Object} a The object to be extended
 * @param {Object} b The object to add to the first one
 */
function extend(a, b) {
	var n;
	if (!a) {
		a = {};
	}
	for (n in b) {
		a[n] = b[n];
	}
	return a;
}

/**
 * Take an array and turn into a hash with even number arguments as keys and odd numbers as
 * values. Allows creating constants for commonly used style properties, attributes etc.
 * Avoid it in performance critical situations like looping
 */
function hash() {
	var i = 0,
		args = arguments,
		length = args.length,
		obj = {};
	for (; i < length; i++) {
		obj[args[i++]] = args[i];
	}
	return obj;
}

/**
 * Shortcut for parseInt
 * @param {Object} s
 * @param {Number} mag Magnitude
 */
function pInt(s, mag) {
	return parseInt(s, mag || 10);
}

/**
 * Check for string
 * @param {Object} s
 */
function isString(s) {
	return typeof s === 'string';
}

/**
 * Check for object
 * @param {Object} obj
 */
function isObject(obj) {
	return typeof obj === 'object';
}

/**
 * Check for array
 * @param {Object} obj
 */
function isArray(obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
}

/**
 * Check for number
 * @param {Object} n
 */
function isNumber(n) {
	return typeof n === 'number';
}

function log2lin(num) {
	return math.log(num) / math.LN10;
}
function lin2log(num) {
	return math.pow(10, num);
}

/**
 * Remove last occurence of an item from an array
 * @param {Array} arr
 * @param {Mixed} item
 */
function erase(arr, item) {
	var i = arr.length;
	while (i--) {
		if (arr[i] === item) {
			arr.splice(i, 1);
			break;
		}
	}
	//return arr;
}

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== UNDEFINED && obj !== null;
}

/**
 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
 * it attempts to set expando properties on the SVG element, which is not allowed.
 *
 * @param {Object} elem The DOM element to receive the attribute(s)
 * @param {String|Object} prop The property or an abject of key-value pairs
 * @param {String} value The value if a single property is set
 */
function attr(elem, prop, value) {
	var key,
		setAttribute = 'setAttribute',
		ret;

	// if the prop is a string
	if (isString(prop)) {
		// set the value
		if (defined(value)) {

			elem[setAttribute](prop, value);

		// get the value
		} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
			ret = elem.getAttribute(prop);
		}

	// else if prop is defined, it is a hash of key/value pairs
	} else if (defined(prop) && isObject(prop)) {
		for (key in prop) {
			elem[setAttribute](key, prop[key]);
		}
	}
	return ret;
}
/**
 * Check if an element is an array, and if not, make it into an array. Like
 * MooTools' $.splat.
 */
function splat(obj) {
	return isArray(obj) ? obj : [obj];
}


/**
 * Return the first value that is defined. Like MooTools' $.pick.
 */
function pick() {
	var args = arguments,
		i,
		arg,
		length = args.length;
	for (i = 0; i < length; i++) {
		arg = args[i];
		if (typeof arg !== 'undefined' && arg !== null) {
			return arg;
		}
	}
}

/**
 * Set CSS on a given element
 * @param {Object} el
 * @param {Object} styles Style object with camel case property names
 */
function css(el, styles) {
	if (isIE) {
		if (styles && styles.opacity !== UNDEFINED) {
			styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
		}
	}
	extend(el.style, styles);
}

/**
 * Utility function to create element with attributes and styles
 * @param {Object} tag
 * @param {Object} attribs
 * @param {Object} styles
 * @param {Object} parent
 * @param {Object} nopad
 */
function createElement(tag, attribs, styles, parent, nopad) {
	var el = doc.createElement(tag);
	if (attribs) {
		extend(el, attribs);
	}
	if (nopad) {
		css(el, {padding: 0, border: NONE, margin: 0});
	}
	if (styles) {
		css(el, styles);
	}
	if (parent) {
		parent.appendChild(el);
	}
	return el;
}

/**
 * Extend a prototyped class by new members
 * @param {Object} parent
 * @param {Object} members
 */
function extendClass(parent, members) {
	var object = function () {};
	object.prototype = new parent();
	extend(object.prototype, members);
	return object;
}

/**
 * Format a number and return a string based on input settings
 * @param {Number} number The input number to format
 * @param {Number} decimals The amount of decimals
 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
 */
function numberFormat(number, decimals, decPoint, thousandsSep) {
	var lang = defaultOptions.lang,
		// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
		n = number,
		c = isNaN(decimals = mathAbs(decimals)) ? 2 : decimals,
		d = decPoint === undefined ? lang.decimalPoint : decPoint,
		t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
		s = n < 0 ? "-" : "",
		i = String(pInt(n = mathAbs(+n || 0).toFixed(c))),
		j = i.length > 3 ? i.length % 3 : 0;

	return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
		(c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
}

/**
 * Pad a string to a given length by adding 0 to the beginning
 * @param {Number} number
 * @param {Number} length
 */
function pad(number, length) {
	// Create an array of the remaining length +1 and join it with 0's
	return new Array((length || 2) + 1 - String(number).length).join(0) + number;
}

/**
 * Based on http://www.php.net/manual/en/function.strftime.php
 * @param {String} format
 * @param {Number} timestamp
 * @param {Boolean} capitalize
 */
dateFormat = function (format, timestamp, capitalize) {
	if (!defined(timestamp) || isNaN(timestamp)) {
		return 'Invalid date';
	}
	format = pick(format, '%Y-%m-%d %H:%M:%S');

	var date = new Date(timestamp),
		key, // used in for constuct below
		// get the basic time values
		hours = date[getHours](),
		day = date[getDay](),
		dayOfMonth = date[getDate](),
		month = date[getMonth](),
		fullYear = date[getFullYear](),
		lang = defaultOptions.lang,
		langWeekdays = lang.weekdays,
		/* // uncomment this and the 'W' format key below to enable week numbers
		weekNumber = function () {
			var clone = new Date(date.valueOf()),
				day = clone[getDay]() == 0 ? 7 : clone[getDay](),
				dayNumber;
			clone.setDate(clone[getDate]() + 4 - day);
			dayNumber = mathFloor((clone.getTime() - new Date(clone[getFullYear](), 0, 1, -6)) / 86400000);
			return 1 + mathFloor(dayNumber / 7);
		},
		*/

		// list all format keys
		replacements = {

			// Day
			'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
			'A': langWeekdays[day], // Long weekday, like 'Monday'
			'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
			'e': dayOfMonth, // Day of the month, 1 through 31

			// Week (none implemented)
			//'W': weekNumber(),

			// Month
			'b': lang.shortMonths[month], // Short month, like 'Jan'
			'B': lang.months[month], // Long month, like 'January'
			'm': pad(month + 1), // Two digit month number, 01 through 12

            // Quarter
            // [CUSTOMIZED]
            'q': 'Q' + (Math.floor(month / 3) + 1),

			// Year
			'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
			'Y': fullYear, // Four digits year, like 2009

			// Time
			'H': pad(hours), // Two digits hours in 24h format, 00 through 23
			'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
			'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
			'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
			'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
			'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
			'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
			'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
		};


	// do the replaces
	for (key in replacements) {
		format = format.replace('%' + key, replacements[key]);
	}

	// Optionally capitalize the string and return
	return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
};

/**
 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
 * @param {Number} interval
 * @param {Array} multiples
 * @param {Number} magnitude
 * @param {Object} options
 */
function normalizeTickInterval(interval, multiples, magnitude, options) {
	var normalized, i;

	// round to a tenfold of 1, 2, 2.5 or 5
	magnitude = pick(magnitude, 1);
	normalized = interval / magnitude;

	// multiples for a linear scale
	if (!multiples) {
		multiples = [1, 2, 2.5, 5, 10];

		// the allowDecimals option
		if (options && options.allowDecimals === false) {
			if (magnitude === 1) {
				multiples = [1, 2, 5, 10];
			} else if (magnitude <= 0.1) {
				multiples = [1 / magnitude];
			}
		}
	}

	// normalize the interval to the nearest multiple
	for (i = 0; i < multiples.length; i++) {
		interval = multiples[i];
		if (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
			break;
		}
	}

	// multiply back to the correct magnitude
	interval *= magnitude;

	return interval;
}

/**
 * Get a normalized tick interval for dates. Returns a configuration object with
 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
 * of segments in stock charts, the normalizing logic was extracted in order to 
 * prevent it for running over again for each segment having the same interval. 
 * #662, #697.
 */
function normalizeTimeTickInterval(tickInterval, unitsOption) {
	var units = unitsOption || [[
				MILLISECOND, // unit name
				[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
			], [
				SECOND,
				[1, 2, 5, 10, 15, 30]
			], [
				MINUTE,
				[1, 2, 5, 10, 15, 30]
			], [
				HOUR,
				[1, 2, 3, 4, 6, 8, 12]
			], [
				DAY,
				[1, 2]
			], [
				WEEK,
				[1, 2]
			], [
				MONTH,
				[1, 2, 3, 4, 6]
			], [
				YEAR,
				null
			]],
		unit = units[units.length - 1], // default unit is years
		interval = timeUnits[unit[0]],
		multiples = unit[1],
		count,
		i;
		
	// loop through the units to find the one that best fits the tickInterval
	for (i = 0; i < units.length; i++) {
		unit = units[i];
		interval = timeUnits[unit[0]];
		multiples = unit[1];


		if (units[i + 1]) {
			// lessThan is in the middle between the highest multiple and the next unit.
			var lessThan = (interval * multiples[multiples.length - 1] +
						timeUnits[units[i + 1][0]]) / 2;

			// break and keep the current unit
			if (tickInterval <= lessThan) {
				break;
			}
		}
	}

	// prevent 2.5 years intervals, though 25, 250 etc. are allowed
	if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
		multiples = [1, 2, 5];
	}
	
	// prevent 2.5 years intervals, though 25, 250 etc. are allowed
	if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
		multiples = [1, 2, 5];
	}

	// get the count
	count = normalizeTickInterval(tickInterval / interval, multiples);
	
	return {
		unitRange: interval,
		count: count,
		unitName: unit[0]
	};
}

/**
 * Set the tick positions to a time unit that makes sense, for example
 * on the first of each month or on every Monday. Return an array
 * with the time positions. Used in datetime axes as well as for grouping
 * data on a datetime axis.
 *
 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
 * @param {Number} min The minimum in axis values
 * @param {Number} max The maximum in axis values
 * @param {Number} startOfWeek
 */
function getTimeTicks(normalizedInterval, min, max, startOfWeek) {
	var tickPositions = [],
		i,
		higherRanks = {},
		useUTC = defaultOptions.global.useUTC,
		minYear, // used in months and years as a basis for Date.UTC()
		minDate = new Date(min),
		interval = normalizedInterval.unitRange,
		count = normalizedInterval.count;

	

	if (interval >= timeUnits[SECOND]) { // second
		minDate.setMilliseconds(0);
		minDate.setSeconds(interval >= timeUnits[MINUTE] ? 0 :
			count * mathFloor(minDate.getSeconds() / count));
	}

	if (interval >= timeUnits[MINUTE]) { // minute
		minDate[setMinutes](interval >= timeUnits[HOUR] ? 0 :
			count * mathFloor(minDate[getMinutes]() / count));
	}

	if (interval >= timeUnits[HOUR]) { // hour
		minDate[setHours](interval >= timeUnits[DAY] ? 0 :
			count * mathFloor(minDate[getHours]() / count));
	}

	if (interval >= timeUnits[DAY]) { // day
		minDate[setDate](interval >= timeUnits[MONTH] ? 1 :
			count * mathFloor(minDate[getDate]() / count));
	}

	if (interval >= timeUnits[MONTH]) { // month
		minDate[setMonth](interval >= timeUnits[YEAR] ? 0 :
			count * mathFloor(minDate[getMonth]() / count));
		minYear = minDate[getFullYear]();
	}

	if (interval >= timeUnits[YEAR]) { // year
		minYear -= minYear % count;
		minDate[setFullYear](minYear);
	}

	// week is a special case that runs outside the hierarchy
	if (interval === timeUnits[WEEK]) {
		// get start of current week, independent of count
		minDate[setDate](minDate[getDate]() - minDate[getDay]() +
			pick(startOfWeek, 1));
	}


	// get tick positions
	i = 1;
	minYear = minDate[getFullYear]();
	var time = minDate.getTime(),
		minMonth = minDate[getMonth](),
		minDateDate = minDate[getDate]();

	// iterate and add tick positions at appropriate values
	while (time < max) {
		tickPositions.push(time);

		// if the interval is years, use Date.UTC to increase years
		if (interval === timeUnits[YEAR]) {
			time = makeTime(minYear + i * count, 0);

		// if the interval is months, use Date.UTC to increase months
		} else if (interval === timeUnits[MONTH]) {
			time = makeTime(minYear, minMonth + i * count);

		// if we're using global time, the interval is not fixed as it jumps
		// one hour at the DST crossover
		} else if (!useUTC && (interval === timeUnits[DAY] || interval === timeUnits[WEEK])) {
			time = makeTime(minYear, minMonth, minDateDate +
				i * count * (interval === timeUnits[DAY] ? 1 : 7));

		// else, the interval is fixed and we use simple addition
		} else {
			time += interval * count;
			
			// mark new days if the time is dividable by day
			if (interval <= timeUnits[HOUR] && time % timeUnits[DAY] === 0) {
				higherRanks[time] = DAY;
			}
		}

		i++;
	}
	
	// push the last time
	tickPositions.push(time);

	// record information on the chosen unit - for dynamic label formatter
	tickPositions.info = extend(normalizedInterval, {
		higherRanks: higherRanks,
		totalRange: interval * count
	});

	return tickPositions;
}

/**
 * Helper class that contains variuos counters that are local to the chart.
 */
function ChartCounters() {
	this.color = 0;
	this.symbol = 0;
}

ChartCounters.prototype =  {
	/**
	 * Wraps the color counter if it reaches the specified length.
	 */
	wrapColor: function (length) {
		if (this.color >= length) {
			this.color = 0;
		}
	},

	/**
	 * Wraps the symbol counter if it reaches the specified length.
	 */
	wrapSymbol: function (length) {
		if (this.symbol >= length) {
			this.symbol = 0;
		}
	}
};

/**
 * Utility method extracted from Tooltip code that places a tooltip in a chart without spilling over
 * and not covering the point it self.
 */
function placeBox(boxWidth, boxHeight, outerLeft, outerTop, outerWidth, outerHeight, point, distance, preferRight) {
	
	// keep the box within the chart area
	var pointX = point.x,
		pointY = point.y,
		x = pointX + outerLeft + (preferRight ? distance : -boxWidth - distance),
		y = pointY - boxHeight + outerTop + 15, // 15 means the point is 15 pixels up from the bottom of the tooltip
		alignedRight;

	// it is too far to the left, adjust it
	if (x < 7) {
		x = outerLeft + pointX + distance;
	}

	// Test to see if the tooltip is too far to the right,
	// if it is, move it back to be inside and then up to not cover the point.
	if ((x + boxWidth) > (outerLeft + outerWidth)) {
		x -= (x + boxWidth) - (outerLeft + outerWidth);
		y = pointY - boxHeight + outerTop - distance;
		alignedRight = true;
	}

	// if it is now above the plot area, align it to the top of the plot area
	if (y < outerTop + 5) {
		y = outerTop + 5;

		// If the tooltip is still covering the point, move it below instead
		if (alignedRight && pointY >= y && pointY <= (y + boxHeight)) {
			y = pointY + outerTop + distance; // below
		}
	} else if (y + boxHeight > outerTop + outerHeight) {
		y = outerTop + outerHeight - boxHeight - distance; // below
	}

	return {x: x, y: y};
}

/**
 * Utility method that sorts an object array and keeping the order of equal items.
 * ECMA script standard does not specify the behaviour when items are equal.
 */
function stableSort(arr, sortFunction) {
	var length = arr.length,
		sortValue,
		i;

	// Add index to each item
	for (i = 0; i < length; i++) {
		arr[i].ss_i = i; // stable sort index
	}

	arr.sort(function (a, b) {
		sortValue = sortFunction(a, b);
		return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
	});

	// Remove index from items
	for (i = 0; i < length; i++) {
		delete arr[i].ss_i; // stable sort index
	}
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMin(data) {
	var i = data.length,
		min = data[0];

	while (i--) {
		if (data[i] < min) {
			min = data[i];
		}
	}
	return min;
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMax(data) {
	var i = data.length,
		max = data[0];

	while (i--) {
		if (data[i] > max) {
			max = data[i];
		}
	}
	return max;
}

/**
 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
 * It loops all properties and invokes destroy if there is a destroy method. The property is
 * then delete'ed.
 */
function destroyObjectProperties(obj) {
	var n;
	for (n in obj) {
		// If the object is non-null and destroy is defined
		if (obj[n] && obj[n].destroy) {
			// Invoke the destroy
			obj[n].destroy();
		}

		// Delete the property from the object.
		delete obj[n];
	}
}


/**
 * Discard an element by moving it to the bin and delete
 * @param {Object} The HTML node to discard
 */
function discardElement(element) {
	// create a garbage bin element, not part of the DOM
	if (!garbageBin) {
		garbageBin = createElement(DIV);
	}

	// move the node and empty bin
	if (element) {
		garbageBin.appendChild(element);
	}
	garbageBin.innerHTML = '';
}

/**
 * Provide error messages for debugging, with links to online explanation 
 */
function error(code, stop) {
	var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
	if (stop) {
		throw msg;
	} else if (win.console) {
		console.log(msg);
	}
}

/**
 * Fix JS round off float errors
 * @param {Number} num
 */
function correctFloat(num) {
	return parseFloat(
		num.toPrecision(14)
	);
}

/**
 * The time unit lookup
 */
/*jslint white: true*/
timeUnits = hash(
	MILLISECOND, 1,
	SECOND, 1000,
	MINUTE, 60000,
	HOUR, 3600000,
	DAY, 24 * 3600000,
	WEEK, 7 * 24 * 3600000,
	MONTH, 30 * 24 * 3600000,
	YEAR, 31556952000
);
/*jslint white: false*/
/**
 * Path interpolation algorithm used across adapters
 */
pathAnim = {
	/**
	 * Prepare start and end values so that the path can be animated one to one
	 */
	init: function (elem, fromD, toD) {
		fromD = fromD || '';
		var shift = elem.shift,
			bezier = fromD.indexOf('C') > -1,
			numParams = bezier ? 7 : 3,
			endLength,
			slice,
			i,
			start = fromD.split(' '),
			end = [].concat(toD), // copy
			startBaseLine,
			endBaseLine,
			sixify = function (arr) { // in splines make move points have six parameters like bezier curves
				i = arr.length;
				while (i--) {
					if (arr[i] === M) {
						arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
					}
				}
			};

		if (bezier) {
			sixify(start);
			sixify(end);
		}

		// pull out the base lines before padding
		if (elem.isArea) {
			startBaseLine = start.splice(start.length - 6, 6);
			endBaseLine = end.splice(end.length - 6, 6);
		}

		// if shifting points, prepend a dummy point to the end path
		if (shift === 1) {

			end = [].concat(end).splice(0, numParams).concat(end);
		}
		elem.shift = 0; // reset for following animations

		// copy and append last point until the length matches the end length
		if (start.length) {
			endLength = end.length;
			while (start.length < endLength) {

				//bezier && sixify(start);
				slice = [].concat(start).splice(start.length - numParams, numParams);
				if (bezier) { // disable first control point
					slice[numParams - 6] = slice[numParams - 2];
					slice[numParams - 5] = slice[numParams - 1];
				}
				start = start.concat(slice);
			}
		}

		if (startBaseLine) { // append the base lines for areas
			start = start.concat(startBaseLine);
			end = end.concat(endBaseLine);
		}
		return [start, end];
	},

	/**
	 * Interpolate each value of the path and return the array
	 */
	step: function (start, end, pos, complete) {
		var ret = [],
			i = start.length,
			startVal;

		if (pos === 1) { // land on the final path without adjustment points appended in the ends
			ret = complete;

		} else if (i === end.length && pos < 1) {
			while (i--) {
				startVal = parseFloat(start[i]);
				ret[i] =
					isNaN(startVal) ? // a letter instruction like M or L
						start[i] :
						pos * (parseFloat(end[i] - startVal)) + startVal;

			}
		} else { // if animation is finished or length not matching, land on right value
			ret = end;
		}
		return ret;
	}
};


/**
 * Set the global animation to either a given value, or fall back to the
 * given chart's animation option
 * @param {Object} animation
 * @param {Object} chart
 */
function setAnimation(animation, chart) {
	globalAnimation = pick(animation, chart.animation);
}

/*
 * Define the adapter for frameworks. If an external adapter is not defined,
 * Highcharts reverts to the built-in jQuery adapter.
 */
if (globalAdapter && globalAdapter.init) {
	// Initialize the adapter with the pathAnim object that takes care
	// of path animations.
	globalAdapter.init(pathAnim);
}
if (!globalAdapter && win.jQuery) {
	var jQ = jQuery;

	/**
	 * Downloads a script and executes a callback when done.
	 * @param {String} scriptLocation
	 * @param {Function} callback
	 */
	getScript = jQ.getScript;

	/**
	 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
	 * @param {Array} arr
	 * @param {Function} fn
	 */
	each = function (arr, fn) {
		var i = 0,
			len = arr.length;
		for (; i < len; i++) {
			if (fn.call(arr[i], arr[i], i, arr) === false) {
				return i;
			}
		}
	};

	/**
	 * Filter an array
	 */
	grep = jQ.grep;

	/**
	 * Map an array
	 * @param {Array} arr
	 * @param {Function} fn
	 */
	map = function (arr, fn) {
		//return jQuery.map(arr, fn);
		var results = [],
			i = 0,
			len = arr.length;
		for (; i < len; i++) {
			results[i] = fn.call(arr[i], arr[i], i, arr);
		}
		return results;

	};

	/**
	 * Deep merge two objects and return a third object
	 */
	merge = function () {
		var args = arguments;
		return jQ.extend(true, null, args[0], args[1], args[2], args[3]);
	};

	/**
	 * Get the position of an element relative to the top left of the page
	 */
	offset = function (el) {
		return jQ(el).offset();
	};

	/**
	 * Add an event listener
	 * @param {Object} el A HTML element or custom object
	 * @param {String} event The event type
	 * @param {Function} fn The event handler
	 */
	addEvent = function (el, event, fn) {
		jQ(el).bind(event, fn);
	};

	/**
	 * Remove event added with addEvent
	 * @param {Object} el The object
	 * @param {String} eventType The event type. Leave blank to remove all events.
	 * @param {Function} handler The function to remove
	 */
	removeEvent = function (el, eventType, handler) {
		// workaround for jQuery issue with unbinding custom events:
		// http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
		var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
		if (doc[func] && !el[func]) {
			el[func] = function () {};
		}

		jQ(el).unbind(eventType, handler);
	};

	/**
	 * Fire an event on a custom object
	 * @param {Object} el
	 * @param {String} type
	 * @param {Object} eventArguments
	 * @param {Function} defaultFunction
	 */
	fireEvent = function (el, type, eventArguments, defaultFunction) {
		var event = jQ.Event(type),
			detachedType = 'detached' + type,
			defaultPrevented;

		extend(event, eventArguments);

		// Prevent jQuery from triggering the object method that is named the
		// same as the event. For example, if the event is 'select', jQuery
		// attempts calling el.select and it goes into a loop.
		if (el[type]) {
			el[detachedType] = el[type];
			el[type] = null;
		}

		// Wrap preventDefault and stopPropagation in try/catch blocks in
		// order to prevent JS errors when cancelling events on non-DOM
		// objects. #615.
		each(['preventDefault', 'stopPropagation'], function (fn) {
			var base = event[fn];
			event[fn] = function () {
				try {
					base.call(event);
				} catch (e) {
					if (fn === 'preventDefault') {
						defaultPrevented = true;
					}
				}
			};
		});

		// trigger it
		jQ(el).trigger(event);

		// attach the method
		if (el[detachedType]) {
			el[type] = el[detachedType];
			el[detachedType] = null;
		}

		if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
			defaultFunction(event);
		}
	};

	/**
	 * Animate a HTML element or SVG element wrapper
	 * @param {Object} el
	 * @param {Object} params
	 * @param {Object} options jQuery-like animation options: duration, easing, callback
	 */
	animate = function (el, params, options) {
		var $el = jQ(el);
		if (params.d) {
			el.toD = params.d; // keep the array form for paths, used in jQ.fx.step.d
			params.d = 1; // because in jQuery, animating to an array has a different meaning
		}

		$el.stop();
		$el.animate(params, options);

	};
	/**
	 * Stop running animation
	 */
	stop = function (el) {
		jQ(el).stop();
	};


	//=== Extend jQuery on init

	/*jslint unparam: true*//* allow unused param x in this function */
	jQ.extend(jQ.easing, {
		easeOutQuad: function (x, t, b, c, d) {
			return -c * (t /= d) * (t - 2) + b;
		}
	});
	/*jslint unparam: false*/

	// extend the animate function to allow SVG animations
	var jFx = jQuery.fx,
		jStep = jFx.step;

	// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
	each(['cur', '_default', 'width', 'height'], function (fn, i) {
		var obj = i ? jStep : jFx.prototype, // 'cur', the getter' relates to jFx.prototype
			base = obj[fn],
			elem;

		if (base) { // step.width and step.height don't exist in jQuery < 1.7

			// create the extended function replacement
			obj[fn] = function (fx) {

				// jFx.prototype.cur does not use fx argument
				fx = i ? fx : this;

				// shortcut
				elem = fx.elem;

				// jFX.prototype.cur returns the current value. The other ones are setters
				// and returning a value has no effect.
				return elem.attr ? // is SVG element wrapper
					elem.attr(fx.prop, fx.now) : // apply the SVG wrapper's method
					base.apply(this, arguments); // use jQuery's built-in method
			};
		}
	});

	// animate paths
	jStep.d = function (fx) {
		var elem = fx.elem;


		// Normally start and end should be set in state == 0, but sometimes,
		// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
		// in these cases
		if (!fx.started) {
			var ends = pathAnim.init(elem, elem.d, elem.toD);
			fx.start = ends[0];
			fx.end = ends[1];
			fx.started = true;
		}


		// interpolate each value of the path
		elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));

	};
}

/* ****************************************************************************
 * Handle the options                                                         *
 *****************************************************************************/
var

defaultLabelOptions = {
	enabled: true,
	// rotation: 0,
	align: 'center',
	x: 0,
	y: 15,
	/*formatter: function () {
		return this.value;
	},*/
	style: {
		color: '#666',
		fontSize: '11px',
		lineHeight: '14px'
	}
};

defaultOptions = {
	colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
		'#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],
	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	lang: {
		loading: 'Loading...',
		months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
				'August', 'September', 'October', 'November', 'December'],
		shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		decimalPoint: '.',
		resetZoom: 'Reset zoom',
		resetZoomTitle: 'Reset zoom level 1:1',
		thousandsSep: ','
	},
	global: {
		useUTC: true,
		canvasToolsURL: 'http://code.highcharts.com/stock/1.1.5/modules/canvas-tools.js'
	},
	chart: {
		//animation: true,
		//alignTicks: false,
		//reflow: true,
		//className: null,
		//events: { load, selection },
		//margin: [null],
		//marginTop: null,
		//marginRight: null,
		//marginBottom: null,
		//marginLeft: null,
		borderColor: '#4572A7',
		//borderWidth: 0,
		borderRadius: 5,
		defaultSeriesType: 'line',
		ignoreHiddenSeries: true,
		//inverted: false,
		//shadow: false,
		spacingTop: 10,
		spacingRight: 10,
		spacingBottom: 15,
		spacingLeft: 10,
		style: {
			fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
			fontSize: '12px'
		},
		backgroundColor: '#FFFFFF',
		//plotBackgroundColor: null,
		plotBorderColor: '#C0C0C0',
		//plotBorderWidth: 0,
		//plotShadow: false,
		//zoomType: ''
		resetZoomButton: {
			theme: {
				zIndex: 20
			},
			position: {
				align: 'right',
				x: -10,
				//verticalAlign: 'top',
				y: 10
			}
			// relativeTo: 'plot'
		}
	},
	title: {
		text: 'Chart title',
		align: 'center',
		// floating: false,
		// margin: 15,
		// x: 0,
		// verticalAlign: 'top',
		y: 15,
		style: {
			color: '#3E576F',
			fontSize: '16px'
		}

	},
	subtitle: {
		text: '',
		align: 'center',
		// floating: false
		// x: 0,
		// verticalAlign: 'top',
		y: 30,
		style: {
			color: '#6D869F'
		}
	},

	plotOptions: {
		line: { // base series options
			allowPointSelect: false,
			showCheckbox: false,
			animation: {
				duration: 1000
			},
			//connectNulls: false,
			//cursor: 'default',
			//clip: true,
			//dashStyle: null,
			//enableMouseTracking: true,
			events: {},
			//legendIndex: 0,
			lineWidth: 2,
			shadow: true,
			// stacking: null,
			marker: {
				enabled: true,
				//symbol: null,
				lineWidth: 0,
				radius: 4,
				lineColor: '#FFFFFF',
				//fillColor: null,
				states: { // states for a single point
					hover: {
						//radius: base + 2
					},
					select: {
						fillColor: '#FFFFFF',
						lineColor: '#000000',
						lineWidth: 2
					}
				}
			},
			point: {
				events: {}
			},
			dataLabels: merge(defaultLabelOptions, {
				enabled: false,
				y: -6,
				formatter: function () {
					return this.y;
				}
				// backgroundColor: undefined,
				// borderColor: undefined,
				// borderRadius: undefined,
				// borderWidth: undefined,
				// padding: 3,
				// shadow: false
			}),
			cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
			pointRange: 0,
			//pointStart: 0,
			//pointInterval: 1,
			showInLegend: true,
			states: { // states for the entire series
				hover: {
					//enabled: false,
					//lineWidth: base + 1,
					marker: {
						// lineWidth: base + 1,
						// radius: base + 1
					}
				},
				select: {
					marker: {}
				}
			},
			stickyTracking: true
			//tooltip: {
				//pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b>'
				//valueDecimals: null,
				//xDateFormat: '%A, %b %e, %Y',
				//valuePrefix: '',
				//ySuffix: ''				
			//}
			// turboThreshold: 1000
			// zIndex: null
		}
	},
	labels: {
		//items: [],
		style: {
			//font: defaultFont,
			position: ABSOLUTE,
			color: '#3E576F'
		}
	},
	legend: {
		enabled: true,
		align: 'center',
		//floating: false,
		layout: 'horizontal',
		labelFormatter: function () {
			return this.name;
		},
		borderWidth: 1,
		borderColor: '#909090',
		borderRadius: 5,
		// margin: 10,
		// reversed: false,
		shadow: false,
		// backgroundColor: null,
		style: {
			padding: '5px'
		},
		itemStyle: {
			cursor: 'pointer',
			color: '#3E576F'
		},
		itemHoverStyle: {
			//cursor: 'pointer', removed as of #601
			color: '#000000'
		},
		itemHiddenStyle: {
			color: '#C0C0C0'
		},
		itemCheckboxStyle: {
			position: ABSOLUTE,
			width: '13px', // for IE precision
			height: '13px'
		},
		// itemWidth: undefined,
		symbolWidth: 16,
		symbolPadding: 5,
		verticalAlign: 'bottom',
		// width: undefined,
		x: 0,
		y: 0
	},

	loading: {
		// hideDuration: 100,
		labelStyle: {
			fontWeight: 'bold',
			position: RELATIVE,
			top: '1em'
		},
		// showDuration: 0,
		style: {
			position: ABSOLUTE,
			backgroundColor: 'white',
			opacity: 0.5,
			textAlign: 'center'
		}
	},

	tooltip: {
		enabled: true,
		//crosshairs: null,
		backgroundColor: 'rgba(255, 255, 255, .85)',
		borderWidth: 2,
		borderRadius: 5,
		//formatter: defaultFormatter,
		headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
		pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>',
		shadow: true,
		shared: useCanVG,
		snap: hasTouch ? 25 : 10,
		style: {
			color: '#333333',
			fontSize: '12px',
			padding: '5px',
			whiteSpace: 'nowrap'
		}
		//xDateFormat: '%A, %b %e, %Y',
		//valueDecimals: null,
		//valuePrefix: '',
		//valueSuffix: ''
	},

	credits: {
		enabled: true,
		text: 'Highcharts.com',
		href: 'http://www.highcharts.com',
		position: {
			align: 'right',
			x: -10,
			verticalAlign: 'bottom',
			y: -5
		},
		style: {
			cursor: 'pointer',
			color: '#909090',
			fontSize: '10px'
		}
	}
};

// Axis defaults
/*jslint white: true*/
var defaultXAxisOptions = {
	// allowDecimals: null,
	// alternateGridColor: null,
	// categories: [],
	dateTimeLabelFormats: hash(
		MILLISECOND, '%H:%M:%S.%L',
		SECOND, '%H:%M:%S',
		MINUTE, '%H:%M',
		HOUR, '%H:%M',
		DAY, '%e. %b',
		WEEK, '%e. %b',
		MONTH, '%b \'%y',
		YEAR, '%Y'
	),
	endOnTick: false,
	gridLineColor: '#C0C0C0',
	// gridLineDashStyle: 'solid',
	// gridLineWidth: 0,
	// reversed: false,

	labels: defaultLabelOptions,
		// { step: null },
	lineColor: '#C0D0E0',
	lineWidth: 1,
	//linkedTo: null,
	max: null,
	min: null,
	minPadding: 0.01,
	maxPadding: 0.01,
	//minRange: null,
	minorGridLineColor: '#E0E0E0',
	// minorGridLineDashStyle: null,
	minorGridLineWidth: 1,
	minorTickColor: '#A0A0A0',
	//minorTickInterval: null,
	minorTickLength: 2,
	minorTickPosition: 'outside', // inside or outside
	//minorTickWidth: 0,
	//opposite: false,
	//offset: 0,
	//plotBands: [{
	//	events: {},
	//	zIndex: 1,
	//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	//}],
	//plotLines: [{
	//	events: {}
	//  dashStyle: {}
	//	zIndex:
	//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	//}],
	//reversed: false,
	// showFirstLabel: true,
	// showLastLabel: true,
	startOfWeek: 1,
	startOnTick: false,
	tickColor: '#C0D0E0',
	//tickInterval: null,
	tickLength: 5,
	tickmarkPlacement: 'between', // on or between
	tickPixelInterval: 100,
	tickPosition: 'outside',
	tickWidth: 1,
	title: {
		//text: null,
		align: 'middle', // low, middle or high
		//margin: 0 for horizontal, 10 for vertical axes,
		//rotation: 0,
		//side: 'outside',
		style: {
			color: '#6D869F',
			//font: defaultFont.replace('normal', 'bold')
			fontWeight: 'bold'
		}
		//x: 0,
		//y: 0
	},
	type: 'linear' // linear, logarithmic or datetime
},

defaultYAxisOptions = merge(defaultXAxisOptions, {
	endOnTick: true,
	gridLineWidth: 1,
	tickPixelInterval: 72,
	showLastLabel: true,
	labels: {
		align: 'right',
		x: -8,
		y: 3
	},
	lineWidth: 0,
	maxPadding: 0.05,
	minPadding: 0.05,
	startOnTick: true,
	tickWidth: 0,
	title: {
		rotation: 270,
		text: 'Y-values'
	},
	stackLabels: {
		enabled: false,
		//align: dynamic,
		//y: dynamic,
		//x: dynamic,
		//verticalAlign: dynamic,
		//textAlign: dynamic,
		//rotation: 0,
		formatter: function () {
			return this.total;
		},
		style: defaultLabelOptions.style
	}
}),

defaultLeftAxisOptions = {
	labels: {
		align: 'right',
		x: -8,
		y: null
	},
	title: {
		rotation: 270
	}
},
defaultRightAxisOptions = {
	labels: {
		align: 'left',
		x: 8,
		y: null
	},
	title: {
		rotation: 90
	}
},
defaultBottomAxisOptions = { // horizontal axis
	labels: {
		align: 'center',
		x: 0,
		y: 14,
		overflow: 'justify' // docs
		// staggerLines: null
	},
	title: {
		rotation: 0
	}
},
defaultTopAxisOptions = merge(defaultBottomAxisOptions, {
	labels: {
		y: -5,
		overflow: 'justify'
		// staggerLines: null
	}
});
/*jslint white: false*/



// Series defaults
var defaultPlotOptions = defaultOptions.plotOptions,
	defaultSeriesOptions = defaultPlotOptions.line;
//defaultPlotOptions.line = merge(defaultSeriesOptions);
defaultPlotOptions.spline = merge(defaultSeriesOptions);
defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
	lineWidth: 0,
	states: {
		hover: {
			lineWidth: 0
		}
	},
	tooltip: {
		headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>',
		pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
	}
});
defaultPlotOptions.area = merge(defaultSeriesOptions, {
	threshold: 0
	// lineColor: null, // overrides color, but lets fillColor be unaltered
	// fillOpacity: 0.75,
	// fillColor: null

});
defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
defaultPlotOptions.column = merge(defaultSeriesOptions, {
	borderColor: '#FFFFFF',
	borderWidth: 1,
	borderRadius: 0,
	//colorByPoint: undefined,
	groupPadding: 0.2,
	marker: null, // point options are specified in the base options
	pointPadding: 0.1,
	//pointWidth: null,
	minPointLength: 0,
	cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
	pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
	states: {
		hover: {
			brightness: 0.1,
			shadow: false
		},
		select: {
			color: '#C0C0C0',
			borderColor: '#000000',
			shadow: false
		}
	},
	dataLabels: {
		y: null,
		verticalAlign: null
	},
	threshold: 0
});
defaultPlotOptions.bar = merge(defaultPlotOptions.column, {
	dataLabels: {
		align: 'left',
		x: 5,
		y: null,
		verticalAlign: 'middle'
	}
});
defaultPlotOptions.pie = merge(defaultSeriesOptions, {
	//dragType: '', // n/a
	borderColor: '#FFFFFF',
	borderWidth: 1,
	center: ['50%', '50%'],
	colorByPoint: true, // always true for pies
	dataLabels: {
		// align: null,
		// connectorWidth: 1,
		// connectorColor: point.color,
		// connectorPadding: 5,
		distance: 30,
		enabled: true,
		formatter: function () {
			return this.point.name;
		},
		// softConnector: true,
		y: 5
	},
	//innerSize: 0,
	legendType: 'point',
	marker: null, // point options are specified in the base options
	size: '75%',
	showInLegend: false,
	slicedOffset: 10,
	states: {
		hover: {
			brightness: 0.1,
			shadow: false
		}
	}

});

// set the default time methods
setTimeMethods();



/**
 * Set the time methods globally based on the useUTC option. Time method can be either
 * local time or UTC (default).
 */
function setTimeMethods() {
	var useUTC = defaultOptions.global.useUTC,
		GET = useUTC ? 'getUTC' : 'get',
		SET = useUTC ? 'setUTC' : 'set';

	makeTime = useUTC ? Date.UTC : function (year, month, date, hours, minutes, seconds) {
		return new Date(
			year,
			month,
			pick(date, 1),
			pick(hours, 0),
			pick(minutes, 0),
			pick(seconds, 0)
		).getTime();
	};
	getMinutes =  GET + 'Minutes';
	getHours =    GET + 'Hours';
	getDay =      GET + 'Day';
	getDate =     GET + 'Date';
	getMonth =    GET + 'Month';
	getFullYear = GET + 'FullYear';
	setMinutes =  SET + 'Minutes';
	setHours =    SET + 'Hours';
	setDate =     SET + 'Date';
	setMonth =    SET + 'Month';
	setFullYear = SET + 'FullYear';

}

/**
 * Merge the default options with custom options and return the new options structure
 * @param {Object} options The new custom options
 */
function setOptions(options) {
	
	// Pull out axis options and apply them to the respective default axis options 
	defaultXAxisOptions = merge(defaultXAxisOptions, options.xAxis);
	defaultYAxisOptions = merge(defaultYAxisOptions, options.yAxis);
	options.xAxis = options.yAxis = UNDEFINED;
	
	// Merge in the default options
	defaultOptions = merge(defaultOptions, options);
	
	// Apply UTC
	setTimeMethods();

	return defaultOptions;
}

/**
 * Get the updated default options. Merely exposing defaultOptions for outside modules
 * isn't enough because the setOptions method creates a new object.
 */
function getOptions() {
	return defaultOptions;
}



/**
 * Handle color operations. The object methods are chainable.
 * @param {String} input The input color in either rbga or hex format
 */
var Color = function (input) {
	// declare variables
	var rgba = [], result;

	/**
	 * Parse the input color to rgba array
	 * @param {String} input
	 */
	function init(input) {

		// rgba
		result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
		if (result) {
			rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
		} else { // hex
			result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
			if (result) {
				rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
			}
		}

	}
	/**
	 * Return the color a specified format
	 * @param {String} format
	 */
	function get(format) {
		var ret;

		// it's NaN if gradient colors on a column chart
		if (rgba && !isNaN(rgba[0])) {
			if (format === 'rgb') {
				ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
			} else if (format === 'a') {
				ret = rgba[3];
			} else {
				ret = 'rgba(' + rgba.join(',') + ')';
			}
		} else {
			ret = input;
		}
		return ret;
	}

	/**
	 * Brighten the color
	 * @param {Number} alpha
	 */
	function brighten(alpha) {
		if (isNumber(alpha) && alpha !== 0) {
			var i;
			for (i = 0; i < 3; i++) {
				rgba[i] += pInt(alpha * 255);

				if (rgba[i] < 0) {
					rgba[i] = 0;
				}
				if (rgba[i] > 255) {
					rgba[i] = 255;
				}
			}
		}
		return this;
	}
	/**
	 * Set the color's opacity to a given alpha value
	 * @param {Number} alpha
	 */
	function setOpacity(alpha) {
		rgba[3] = alpha;
		return this;
	}

	// initialize: parse the input
	init(input);

	// public methods
	return {
		get: get,
		brighten: brighten,
		setOpacity: setOpacity
	};
};


/**
 * A wrapper object for SVG elements
 */
function SVGElement() {}

SVGElement.prototype = {
	/**
	 * Initialize the SVG renderer
	 * @param {Object} renderer
	 * @param {String} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this;
		wrapper.element = nodeName === 'span' ?
			createElement(nodeName) :
			doc.createElementNS(SVG_NS, nodeName);
		wrapper.renderer = renderer;
		/**
		 * A collection of attribute setters. These methods, if defined, are called right before a certain
		 * attribute is set on an element wrapper. Returning false prevents the default attribute
		 * setter to run. Returning a value causes the default setter to set that value. Used in
		 * Renderer.label.
		 */
		wrapper.attrSetters = {};
	},
	/**
	 * Animate a given attribute
	 * @param {Object} params
	 * @param {Number} options The same options as in jQuery animation
	 * @param {Function} complete Function to perform at the end of animation
	 */
	animate: function (params, options, complete) {
		var animOptions = pick(options, globalAnimation, true);
		stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
		if (animOptions) {
			animOptions = merge(animOptions);
			if (complete) { // allows using a callback with the global animation without overwriting it
				animOptions.complete = complete;
			}
			animate(this, params, animOptions);
		} else {
			this.attr(params);
			if (complete) {
				complete();
			}
		}
	},
	/**
	 * Set or get a given attribute
	 * @param {Object|String} hash
	 * @param {Mixed|Undefined} val
	 */
	attr: function (hash, val) {
		var wrapper = this,
			key,
			value,
			result,
			i,
			child,
			element = wrapper.element,
			nodeName = element.nodeName,
			renderer = wrapper.renderer,
			skipAttr,
			attrSetters = wrapper.attrSetters,
			shadows = wrapper.shadows,
			hasSetSymbolSize,
			ret = wrapper;

		// single key-value pair
		if (isString(hash) && defined(val)) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter: first argument is a string, second is undefined
		if (isString(hash)) {
			key = hash;
			if (nodeName === 'circle') {
				key = { x: 'cx', y: 'cy' }[key] || key;
			} else if (key === 'strokeWidth') {
				key = 'stroke-width';
			}
			ret = attr(element, key) || wrapper[key] || 0;

			if (key !== 'd' && key !== 'visibility') { // 'd' is string in animation step
				ret = parseFloat(ret);
			}

		// setter
		} else {

			for (key in hash) {
				skipAttr = false; // reset
				value = hash[key];

				// check for a specific attribute setter
				result = attrSetters[key] && attrSetters[key](value, key);

				if (result !== false) {

					if (result !== UNDEFINED) {
						value = result; // the attribute setter has returned a new value to set
					}

					// paths
					if (key === 'd') {
						if (value && value.join) { // join path
							value = value.join(' ');
						}
						if (/(NaN| {2}|^$)/.test(value)) {
							value = 'M 0 0';
						}
						wrapper.d = value; // shortcut for animations

					// update child tspans x values
					} else if (key === 'x' && nodeName === 'text') {
						for (i = 0; i < element.childNodes.length; i++) {
							child = element.childNodes[i];
							// if the x values are equal, the tspan represents a linebreak
							if (attr(child, 'x') === attr(element, 'x')) {
								//child.setAttribute('x', value);
								attr(child, 'x', value);
							}
						}

						if (wrapper.rotation) {
							attr(element, 'transform', 'rotate(' + wrapper.rotation + ' ' + value + ' ' +
								pInt(hash.y || attr(element, 'y')) + ')');
						}

					// apply gradients
					} else if (key === 'fill') {
						value = renderer.color(value, element, key);

					// circle x and y
					} else if (nodeName === 'circle' && (key === 'x' || key === 'y')) {
						key = { x: 'cx', y: 'cy' }[key] || key;

					// rectangle border radius
					} else if (nodeName === 'rect' && key === 'r') {
						attr(element, {
							rx: value,
							ry: value
						});
						skipAttr = true;

					// translation and text rotation
					} else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'verticalAlign') {
						wrapper[key] = value;
						wrapper.updateTransform();
						skipAttr = true;

					// apply opacity as subnode (required by legacy WebKit and Batik)
					} else if (key === 'stroke') {
						value = renderer.color(value, element, key);

					// emulate VML's dashstyle implementation
					} else if (key === 'dashstyle') {
						key = 'stroke-dasharray';
						value = value && value.toLowerCase();
						if (value === 'solid') {
							value = NONE;
						} else if (value) {
							value = value
								.replace('shortdashdotdot', '3,1,1,1,1,1,')
								.replace('shortdashdot', '3,1,1,1')
								.replace('shortdot', '1,1,')
								.replace('shortdash', '3,1,')
								.replace('longdash', '8,3,')
								.replace(/dot/g, '1,3,')
								.replace('dash', '4,3,')
								.replace(/,$/, '')
								.split(','); // ending comma

							i = value.length;
							while (i--) {
								value[i] = pInt(value[i]) * hash['stroke-width'];
							}
							value = value.join(',');
						}

					// special
					} else if (key === 'isTracker') {
						wrapper[key] = value;

					// IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2
					// is unable to cast them. Test again with final IE9.
					} else if (key === 'width') {
						value = pInt(value);

					// Text alignment
					} else if (key === 'align') {
						key = 'text-anchor';
						value = { left: 'start', center: 'middle', right: 'end' }[value];

					// Title requires a subnode, #431
					} else if (key === 'title') {
						var title = doc.createElementNS(SVG_NS, 'title');
						title.appendChild(doc.createTextNode(value));
						element.appendChild(title);
					}

					// jQuery animate changes case
					if (key === 'strokeWidth') {
						key = 'stroke-width';
					}

					// Chrome/Win < 6 bug (http://code.google.com/p/chromium/issues/detail?id=15461)
					if (isWebKit && key === 'stroke-width' && value === 0) {
						value = 0.000001;
					}

					// symbols
					if (wrapper.symbolName && /^(x|y|r|start|end|innerR|anchorX|anchorY)/.test(key)) {


						if (!hasSetSymbolSize) {
							wrapper.symbolAttr(hash);
							hasSetSymbolSize = true;
						}
						skipAttr = true;
					}

					// let the shadow follow the main element
					if (shadows && /^(width|height|visibility|x|y|d|transform)$/.test(key)) {
						i = shadows.length;
						while (i--) {
							attr(shadows[i], key, value);
						}
					}

					// validate heights
					if ((key === 'width' || key === 'height') && nodeName === 'rect' && value < 0) {
						value = 0;
					}




					if (key === 'text') {
						// only one node allowed
						wrapper.textStr = value;
						if (wrapper.added) {
							renderer.buildText(wrapper);
						}
					} else if (!skipAttr) {
						attr(element, key, value);
					}

				}

			}

		}
		
		// Workaround for our #732, WebKit's issue https://bugs.webkit.org/show_bug.cgi?id=78385
		// TODO: If the WebKit team fix this bug before the final release of Chrome 18, remove the workaround.
		if (isWebKit && /Chrome\/(18|19)/.test(userAgent)) {
			if (nodeName === 'text' && (hash.x !== UNDEFINED || hash.y !== UNDEFINED)) {
				var parent = element.parentNode,
					next = element.nextSibling;
			
				if (parent) {
					parent.removeChild(element);
					if (next) {
						parent.insertBefore(element, next);
					} else {
						parent.appendChild(element);
					}
				}
			}
		}
		// End of workaround for #732
		
		return ret;
	},

	/**
	 * If one of the symbol size affecting parameters are changed,
	 * check all the others only once for each call to an element's
	 * .attr() method
	 * @param {Object} hash
	 */
	symbolAttr: function (hash) {
		var wrapper = this;

		each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
			wrapper[key] = pick(hash[key], wrapper[key]);
		});

		wrapper.attr({
			d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
		});
	},

	/**
	 * Apply a clipping path to this object
	 * @param {String} id
	 */
	clip: function (clipRect) {
		return this.attr('clip-path', 'url(' + this.renderer.url + '#' + clipRect.id + ')');
	},

	/**
	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
	 * calculated attributes
	 * @param {Number} strokeWidth
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	crisp: function (strokeWidth, x, y, width, height) {

		var wrapper = this,
			key,
			attribs = {},
			values = {},
			normalizer;

		strokeWidth = strokeWidth || wrapper.strokeWidth || (wrapper.attr && wrapper.attr('stroke-width')) || 0;
		normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

		// normalize for crisp edges
		values.x = mathFloor(x || wrapper.x || 0) + normalizer;
		values.y = mathFloor(y || wrapper.y || 0) + normalizer;
		values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
		values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
		values.strokeWidth = strokeWidth;

		for (key in values) {
			if (wrapper[key] !== values[key]) { // only set attribute if changed
				wrapper[key] = attribs[key] = values[key];
			}
		}

		return attribs;
	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: function (styles) {
		/*jslint unparam: true*//* allow unused param a in the regexp function below */
		var elemWrapper = this,
			elem = elemWrapper.element,
			textWidth = styles && styles.width && elem.nodeName === 'text',
			n,
			serializedCss = '',
			hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
		/*jslint unparam: false*/

		// convert legacy
		if (styles && styles.color) {
			styles.fill = styles.color;
		}

		// Merge the new styles with the old ones
		styles = extend(
			elemWrapper.styles,
			styles
		);

		// store object
		elemWrapper.styles = styles;

		// serialize and set style attribute
		if (isIE && !hasSVG) { // legacy IE doesn't support setting style attribute
			if (textWidth) {
				delete styles.width;
			}
			css(elemWrapper.element, styles);
		} else {
			for (n in styles) {
				serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
			}
			elemWrapper.attr({
				style: serializedCss
			});
		}


		// re-build text
		if (textWidth && elemWrapper.added) {
			elemWrapper.renderer.buildText(elemWrapper);
		}

		return elemWrapper;
	},

	/**
	 * Add an event listener
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		var fn = handler;
		// touch
		if (hasTouch && eventType === 'click') {
			eventType = 'touchstart';
			fn = function (e) {
				e.preventDefault();
				handler();
			};
		}
		// simplest possible event model for internal use
		this.element['on' + eventType] = fn;
		return this;
	},


	/**
	 * Move an object and its children by x and y values
	 * @param {Number} x
	 * @param {Number} y
	 */
	translate: function (x, y) {
		return this.attr({
			translateX: x,
			translateY: y
		});
	},

	/**
	 * Invert a group, rotate and flip
	 */
	invert: function () {
		var wrapper = this;
		wrapper.inverted = true;
		wrapper.updateTransform();
		return wrapper;
	},

	/**
	 * Apply CSS to HTML elements. This is used in text within SVG rendering and
	 * by the VML renderer
	 */
	htmlCss: function (styles) {
		var wrapper = this,
			element = wrapper.element,
			textWidth = styles && element.tagName === 'SPAN' && styles.width;

		if (textWidth) {
			delete styles.width;
			wrapper.textWidth = textWidth;
			wrapper.updateTransform();
		}

		wrapper.styles = extend(wrapper.styles, styles);
		css(wrapper.element, styles);

		return wrapper;
	},



	/**
	 * VML and useHTML method for calculating the bounding box based on offsets
	 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
	 * use the cached value
	 *
	 * @return {Object} A hash containing values for x, y, width and height
	 */

	htmlGetBBox: function (refresh) {
		var wrapper = this,
			element = wrapper.element,
			bBox = wrapper.bBox;

		// faking getBBox in exported SVG in legacy IE
		if (!bBox || refresh) {
			// faking getBBox in exported SVG in legacy IE
			if (element.nodeName === 'text') {
				element.style.position = ABSOLUTE;
			}

			bBox = wrapper.bBox = {
				x: element.offsetLeft,
				y: element.offsetTop,
				width: element.offsetWidth,
				height: element.offsetHeight
			};
		}

		return bBox;
	},

	/**
	 * VML override private method to update elements based on internal
	 * properties based on SVG transform
	 */
	htmlUpdateTransform: function () {
		// aligning non added elements is expensive
		if (!this.added) {
			this.alignOnAdd = true;
			return;
		}

		var wrapper = this,
			renderer = wrapper.renderer,
			elem = wrapper.element,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			x = wrapper.x || 0,
			y = wrapper.y || 0,
			align = wrapper.textAlign || 'left',
			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
			nonLeft = align && align !== 'left',
			shadows = wrapper.shadows;

		// apply translate
		if (translateX || translateY) {
			css(elem, {
				marginLeft: translateX,
				marginTop: translateY
			});
			if (shadows) { // used in labels/tooltip
				each(shadows, function (shadow) {
					css(shadow, {
						marginLeft: translateX + 1,
						marginTop: translateY + 1
					});
				});
			}
		}

		// apply inversion
		if (wrapper.inverted) { // wrapper is a group
			each(elem.childNodes, function (child) {
				renderer.invertChild(child, elem);
			});
		}

		if (elem.tagName === 'SPAN') {

			var width, height,
				rotation = wrapper.rotation,
				baseline,
				radians = 0,
				costheta = 1,
				sintheta = 0,
				quad,
				textWidth = pInt(wrapper.textWidth),
				xCorr = wrapper.xCorr || 0,
				yCorr = wrapper.yCorr || 0,
				currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

			if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed

				if (defined(rotation)) {
					radians = rotation * deg2rad; // deg to rad
					costheta = mathCos(radians);
					sintheta = mathSin(radians);

					// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
					// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
					// has support for CSS3 transform. The getBBox method also needs to be updated
					// to compensate for the rotation, like it currently does for SVG.
					// Test case: http://highcharts.com/tests/?file=text-rotation
					css(elem, {
						filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
							', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
							', sizingMethod=\'auto expand\')'].join('') : NONE
					});
				}

				width = pick(wrapper.elemWidth, elem.offsetWidth);
				height = pick(wrapper.elemHeight, elem.offsetHeight);

				// update textWidth
				if (width > textWidth) {
					css(elem, {
						width: textWidth + PX,
						display: 'block',
						whiteSpace: 'normal'
					});
					width = textWidth;
				}

				// correct x and y
				baseline = renderer.fontMetrics(elem.style.fontSize).b;
				xCorr = costheta < 0 && -width;
				yCorr = sintheta < 0 && -height;

				// correct for baseline and corners spilling out after rotation
				quad = costheta * sintheta < 0;
				xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
				yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);

				// correct for the length/height of the text
				if (nonLeft) {
					xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
					if (rotation) {
						yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
					}
					css(elem, {
						textAlign: align
					});
				}

				// record correction
				wrapper.xCorr = xCorr;
				wrapper.yCorr = yCorr;
			}

			// apply position with correction
			css(elem, {
				left: (x + xCorr) + PX,
				top: (y + yCorr) + PX
			});

			// record current text transform
			wrapper.cTT = currentTextTransform;
		}
	},

	/**
	 * Private method to update the transform attribute based on internal
	 * properties
	 */
	updateTransform: function () {
		var wrapper = this,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			inverted = wrapper.inverted,
			rotation = wrapper.rotation,
			transform = [];

		// flipping affects translate as adjustment for flipping around the group's axis
		if (inverted) {
			translateX += wrapper.attr('width');
			translateY += wrapper.attr('height');
		}

		// apply translate
		if (translateX || translateY) {
			transform.push('translate(' + translateX + ',' + translateY + ')');
		}

		// apply rotation
		if (inverted) {
			transform.push('rotate(90) scale(-1,1)');
		} else if (rotation) { // text rotation
			transform.push('rotate(' + rotation + ' ' + wrapper.x + ' ' + wrapper.y + ')');
		}

		if (transform.length) {
			attr(wrapper.element, 'transform', transform.join(' '));
		}
	},
	/**
	 * Bring the element to the front
	 */
	toFront: function () {
		var element = this.element;
		element.parentNode.appendChild(element);
		return this;
	},


	/**
	 * Break down alignment options like align, verticalAlign, x and y
	 * to x and y relative to the chart.
	 *
	 * @param {Object} alignOptions
	 * @param {Boolean} alignByTranslate
	 * @param {Object} box The box to align to, needs a width and height
	 *
	 */
	align: function (alignOptions, alignByTranslate, box) {
		var elemWrapper = this;

		if (!alignOptions) { // called on resize
			alignOptions = elemWrapper.alignOptions;
			alignByTranslate = elemWrapper.alignByTranslate;
		} else { // first call on instanciate
			elemWrapper.alignOptions = alignOptions;
			elemWrapper.alignByTranslate = alignByTranslate;
			if (!box) { // boxes other than renderer handle this internally
				elemWrapper.renderer.alignedObjects.push(elemWrapper);
			}
		}

		box = pick(box, elemWrapper.renderer);

		var align = alignOptions.align,
			vAlign = alignOptions.verticalAlign,
			x = (box.x || 0) + (alignOptions.x || 0), // default: left align
			y = (box.y || 0) + (alignOptions.y || 0), // default: top align
			attribs = {};


		// align
		if (/^(right|center)$/.test(align)) {
			x += (box.width - (alignOptions.width || 0)) /
					{ right: 1, center: 2 }[align];
		}
		attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


		// vertical align
		if (/^(bottom|middle)$/.test(vAlign)) {
			y += (box.height - (alignOptions.height || 0)) /
					({ bottom: 1, middle: 2 }[vAlign] || 1);

		}
		attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

		// animate only if already placed
		elemWrapper[elemWrapper.placed ? 'animate' : 'attr'](attribs);
		elemWrapper.placed = true;
		elemWrapper.alignAttr = attribs;

		return elemWrapper;
	},

	/**
	 * Get the bounding box (width, height, x and y) for the element
	 */
	getBBox: function (refresh) {
		var wrapper = this,
			bBox,
			width,
			height,
			rotation = wrapper.rotation,
			element = wrapper.element,
			rad = rotation * deg2rad;

		// SVG elements
		if (element.namespaceURI === SVG_NS) {
			try { // Fails in Firefox if the container has display: none.
				
				bBox = element.getBBox ?
					// SVG: use extend because IE9 is not allowed to change width and height in case
					// of rotation (below)
					extend({}, element.getBBox()) :
					// Canvas renderer: // TODO: can this be removed now that we're checking for the SVG NS?
					{
						width: element.offsetWidth,
						height: element.offsetHeight
					};
			} catch (e) {}
			
			// If the bBox is not set, the try-catch block above failed. The other condition
			// is for Opera that returns a width of -Infinity on hidden elements.
			if (!bBox || bBox.width < 0) {
				bBox = { width: 0, height: 0 };
			}
			
			width = bBox.width;
			height = bBox.height;

			// adjust for rotated text
			if (rotation) {
				bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
				bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
			}

		// VML Renderer or useHTML within SVG
		} else {
			bBox = wrapper.htmlGetBBox(refresh);
		}

		return bBox;
	},

	/**
	 * Show the element
	 */
	show: function () {
		return this.attr({ visibility: VISIBLE });
	},

	/**
	 * Hide the element
	 */
	hide: function () {
		return this.attr({ visibility: HIDDEN });
	},

	/**
	 * Add the element
	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
	 *    to append the element to the renderer.box.
	 */
	add: function (parent) {

		var renderer = this.renderer,
			parentWrapper = parent || renderer,
			parentNode = parentWrapper.element || renderer.box,
			childNodes = parentNode.childNodes,
			element = this.element,
			zIndex = attr(element, 'zIndex'),
			otherElement,
			otherZIndex,
			i,
			inserted;

		// mark as inverted
		this.parentInverted = parent && parent.inverted;

		// build formatted text
		if (this.textStr !== undefined) {
			renderer.buildText(this);
		}

		// mark the container as having z indexed children
		if (zIndex) {
			parentWrapper.handleZ = true;
			zIndex = pInt(zIndex);
		}

		// insert according to this and other elements' zIndex
		if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
			for (i = 0; i < childNodes.length; i++) {
				otherElement = childNodes[i];
				otherZIndex = attr(otherElement, 'zIndex');
				if (otherElement !== element && (
						// insert before the first element with a higher zIndex
						pInt(otherZIndex) > zIndex ||
						// if no zIndex given, insert before the first element with a zIndex
						(!defined(zIndex) && defined(otherZIndex))

						)) {
					parentNode.insertBefore(element, otherElement);
					inserted = true;
					break;
				}
			}
		}

		// default: append at the end
		if (!inserted) {
			parentNode.appendChild(element);
		}

		// mark as added
		this.added = true;

		// fire an event for internal hooks
		fireEvent(this, 'add');

		return this;
	},

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		var parentNode = element.parentNode;
		if (parentNode) {
			parentNode.removeChild(element);
		}
	},

	/**
	 * Destroy the element and element wrapper
	 */
	destroy: function () {
		var wrapper = this,
			element = wrapper.element || {},
			shadows = wrapper.shadows,
			box = wrapper.box,
			key,
			i;

		// remove events
		element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = null;
		stop(wrapper); // stop running animations

		if (wrapper.clipPath) {
			wrapper.clipPath = wrapper.clipPath.destroy();
		}

		// Destroy stops in case this is a gradient object
		if (wrapper.stops) {
			for (i = 0; i < wrapper.stops.length; i++) {
				wrapper.stops[i] = wrapper.stops[i].destroy();
			}
			wrapper.stops = null;
		}

		// remove element
		wrapper.safeRemoveChild(element);

		// destroy shadows
		if (shadows) {
			each(shadows, function (shadow) {
				wrapper.safeRemoveChild(shadow);
			});
		}

		// destroy label box
		if (box) {
			box.destroy();
		}

		// remove from alignObjects
		erase(wrapper.renderer.alignedObjects, wrapper);

		for (key in wrapper) {
			delete wrapper[key];
		}

		return null;
	},

	/**
	 * Empty a group element
	 */
	empty: function () {
		var element = this.element,
			childNodes = element.childNodes,
			i = childNodes.length;

		while (i--) {
			element.removeChild(childNodes[i]);
		}
	},

	/**
	 * Add a shadow to the element. Must be done after the element is added to the DOM
	 * @param {Boolean} apply
	 */
	shadow: function (apply, group) {
		var shadows = [],
			i,
			shadow,
			element = this.element,

			// compensate for inverted plot area
			transform = this.parentInverted ? '(-1,-1)' : '(1,1)';


		if (apply) {
			for (i = 1; i <= 3; i++) {
				shadow = element.cloneNode(0);
				attr(shadow, {
					'isShadow': 'true',
					'stroke': 'rgb(0, 0, 0)',
					'stroke-opacity': 0.05 * i,
					'stroke-width': 7 - 2 * i,
					'transform': 'translate' + transform,
					'fill': NONE
				});

				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				shadows.push(shadow);
			}

			this.shadows = shadows;
		}
		return this;

	}
};


/**
 * The default SVG renderer
 */
var SVGRenderer = function () {
	this.init.apply(this, arguments);
};
SVGRenderer.prototype = {
	Element: SVGElement,

	/**
	 * Initialize the SVGRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Boolean} forExport
	 */
	init: function (container, width, height, forExport) {
		var renderer = this,
			loc = location,
			boxWrapper;

		boxWrapper = renderer.createElement('svg')
			.attr({
				xmlns: SVG_NS,
				version: '1.1'
			});
		container.appendChild(boxWrapper.element);

		// object properties
		renderer.isSVG = true;
		renderer.box = boxWrapper.element;
		renderer.boxWrapper = boxWrapper;
		renderer.alignedObjects = [];
		renderer.url = isIE ? '' : loc.href.replace(/#.*?$/, '')
			.replace(/([\('\)])/g, '\\$1'); // Page url used for internal references. #24, #672.
		renderer.defs = this.createElement('defs').add();
		renderer.forExport = forExport;
		renderer.gradients = {}; // Object where gradient SvgElements are stored

		renderer.setSize(width, height, false);
	},

	/**
	 * Destroys the renderer and its allocated members.
	 */
	destroy: function () {
		var renderer = this,
			rendererDefs = renderer.defs;
		renderer.box = null;
		renderer.boxWrapper = renderer.boxWrapper.destroy();

		// Call destroy on all gradient elements
		destroyObjectProperties(renderer.gradients || {});
		renderer.gradients = null;

		// Defs are null in VMLRenderer
		// Otherwise, destroy them here.
		if (rendererDefs) {
			renderer.defs = rendererDefs.destroy();
		}

		renderer.alignedObjects = null;

		return null;
	},

	/**
	 * Create a wrapper for an SVG element
	 * @param {Object} nodeName
	 */
	createElement: function (nodeName) {
		var wrapper = new this.Element();
		wrapper.init(this, nodeName);
		return wrapper;
	},

	/**
	 * Dummy function for use in canvas renderer
	 */
	draw: function () {},

	/**
	 * Parse a simple HTML string into SVG tspans
	 *
	 * @param {Object} textNode The parent text SVG node
	 */
	buildText: function (wrapper) {
		var textNode = wrapper.element,
			lines = pick(wrapper.textStr, '').toString()
				.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
				.replace(/<(i|em)>/g, '<span style="font-style:italic">')
				.replace(/<a/g, '<span')
				.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
				.split(/<br.*?>/g),
			childNodes = textNode.childNodes,
			styleRegex = /style="([^"]+)"/,
			hrefRegex = /href="([^"]+)"/,
			parentX = attr(textNode, 'x'),
			textStyles = wrapper.styles,
			width = textStyles && pInt(textStyles.width),
			textLineHeight = textStyles && textStyles.lineHeight,
			lastLine,
			GET_COMPUTED_STYLE = 'getComputedStyle',
			i = childNodes.length;

		// remove old text
		while (i--) {
			textNode.removeChild(childNodes[i]);
		}

		if (width && !wrapper.added) {
			this.box.appendChild(textNode); // attach it to the DOM to read offset width
		}

		// remove empty line at end
		if (lines[lines.length - 1] === '') {
			lines.pop();
		}

		// build the lines
		each(lines, function (line, lineNo) {
			var spans, spanNo = 0, lineHeight;

			line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
			spans = line.split('|||');

			each(spans, function (span) {
				if (span !== '' || spans.length === 1) {
					var attributes = {},
						tspan = doc.createElementNS(SVG_NS, 'tspan');
					if (styleRegex.test(span)) {
						attr(
							tspan,
							'style',
							span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2')
						);
					}
					if (hrefRegex.test(span)) {
						attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
						css(tspan, { cursor: 'pointer' });
					}

					span = (span.replace(/<(.|\n)*?>/g, '') || ' ')
						.replace(/&lt;/g, '<')
						.replace(/&gt;/g, '>');

					// issue #38 workaround.
					/*if (reverse) {
						arr = [];
						i = span.length;
						while (i--) {
							arr.push(span.charAt(i));
						}
						span = arr.join('');
					}*/

					// add the text node
					tspan.appendChild(doc.createTextNode(span));

					if (!spanNo) { // first span in a line, align it to the left
						attributes.x = parentX;
					} else {
						// Firefox ignores spaces at the front or end of the tspan
						attributes.dx = 3; // space
					}

					// first span on subsequent line, add the line height
					if (!spanNo) {
						if (lineNo) {

							// allow getting the right offset height in exporting in IE
							if (!hasSVG && wrapper.renderer.forExport) {
								css(tspan, { display: 'block' });
							}

							// Webkit and opera sometimes return 'normal' as the line height. In that
							// case, webkit uses offsetHeight, while Opera falls back to 18
							lineHeight = win[GET_COMPUTED_STYLE] &&
								pInt(win[GET_COMPUTED_STYLE](lastLine, null).getPropertyValue('line-height'));

							if (!lineHeight || isNaN(lineHeight)) {
								lineHeight = textLineHeight || lastLine.offsetHeight || 18;
							}
							attr(tspan, 'dy', lineHeight);
						}
						lastLine = tspan; // record for use in next line
					}

					// add attributes
					attr(tspan, attributes);

					// append it
					textNode.appendChild(tspan);

					spanNo++;

					// check width and apply soft breaks
					if (width) {
						var words = span.replace(/-/g, '- ').split(' '),
							tooLong,
							actualWidth,
							rest = [];

						while (words.length || rest.length) {
							actualWidth = wrapper.getBBox().width;
							tooLong = actualWidth > width;
							if (!tooLong || words.length === 1) { // new line needed
								words = rest;
								rest = [];
								if (words.length) {
									tspan = doc.createElementNS(SVG_NS, 'tspan');
									attr(tspan, {
										dy: textLineHeight || 16,
										x: parentX
									});
									textNode.appendChild(tspan);

									if (actualWidth > width) { // a single word is pressing it out
										width = actualWidth;
									}
								}
							} else { // append to existing line tspan
								tspan.removeChild(tspan.firstChild);
								rest.unshift(words.pop());
							}
							if (words.length) {
								tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
							}
						}
					}
				}
			});
		});
	},

	/**
	 * Create a button with preset states
	 * @param {String} text
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Function} callback
	 * @param {Object} normalState
	 * @param {Object} hoverState
	 * @param {Object} pressedState
	 */
	button: function (text, x, y, callback, normalState, hoverState, pressedState) {
		var label = this.label(text, x, y),
			curState = 0,
			stateOptions,
			stateStyle,
			normalStyle,
			hoverStyle,
			pressedStyle,
			STYLE = 'style',
			verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

		// prepare the attributes
		/*jslint white: true*/
		normalState = merge(hash(
			STROKE_WIDTH, 1,
			STROKE, '#999',
			FILL, hash(
				LINEAR_GRADIENT, verticalGradient,
				STOPS, [
					[0, '#FFF'],
					[1, '#DDD']
				]
			),
			'r', 3,
			'padding', 3,
			STYLE, hash(
				'color', 'black'
			)
		), normalState);
		/*jslint white: false*/
		normalStyle = normalState[STYLE];
		delete normalState[STYLE];

		/*jslint white: true*/
		hoverState = merge(normalState, hash(
			STROKE, '#68A',
			FILL, hash(
				LINEAR_GRADIENT, verticalGradient,
				STOPS, [
					[0, '#FFF'],
					[1, '#ACF']
				]
			)
		), hoverState);
		/*jslint white: false*/
		hoverStyle = hoverState[STYLE];
		delete hoverState[STYLE];

		/*jslint white: true*/
		pressedState = merge(normalState, hash(
			STROKE, '#68A',
			FILL, hash(
				LINEAR_GRADIENT, verticalGradient,
				STOPS, [
					[0, '#9BD'],
					[1, '#CDF']
				]
			)
		), pressedState);
		/*jslint white: false*/
		pressedStyle = pressedState[STYLE];
		delete pressedState[STYLE];

		// add the events
		addEvent(label.element, 'mouseenter', function () {
			label.attr(hoverState)
				.css(hoverStyle);
		});
		addEvent(label.element, 'mouseleave', function () {
			stateOptions = [normalState, hoverState, pressedState][curState];
			stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
			label.attr(stateOptions)
				.css(stateStyle);
		});

		label.setState = function (state) {
			curState = state;
			if (!state) {
				label.attr(normalState)
					.css(normalStyle);
			} else if (state === 2) {
				label.attr(pressedState)
					.css(pressedStyle);
			}
		};

		return label
			.on('click', function () {
				callback.call(label);
			})
			.attr(normalState)
			.css(extend({ cursor: 'default' }, normalStyle));
	},

	/**
	 * Make a straight line crisper by not spilling out to neighbour pixels
	 * @param {Array} points
	 * @param {Number} width
	 */
	crispLine: function (points, width) {
		// points format: [M, 0, 0, L, 100, 0]
		// normalize to a crisp line
		if (points[1] === points[4]) {
			points[1] = points[4] = mathRound(points[1]) + (width % 2 / 2);
		}
		if (points[2] === points[5]) {
			points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
		}
		return points;
	},


	/**
	 * Draw a path
	 * @param {Array} path An SVG path in array form
	 */
	path: function (path) {
		return this.createElement('path').attr({
			d: path,
			fill: NONE
		});
	},

	/**
	 * Draw and return an SVG circle
	 * @param {Number} x The x position
	 * @param {Number} y The y position
	 * @param {Number} r The radius
	 */
	circle: function (x, y, r) {
		var attr = isObject(x) ?
			x :
			{
				x: x,
				y: y,
				r: r
			};

		return this.createElement('circle').attr(attr);
	},

	/**
	 * Draw and return an arc
	 * @param {Number} x X position
	 * @param {Number} y Y position
	 * @param {Number} r Radius
	 * @param {Number} innerR Inner radius like used in donut charts
	 * @param {Number} start Starting angle
	 * @param {Number} end Ending angle
	 */
	arc: function (x, y, r, innerR, start, end) {
		// arcs are defined as symbols for the ability to set
		// attributes in attr and animate

		if (isObject(x)) {
			y = x.y;
			r = x.r;
			innerR = x.innerR;
			start = x.start;
			end = x.end;
			x = x.x;
		}
		return this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
			innerR: innerR || 0,
			start: start || 0,
			end: end || 0
		});
	},

	/**
	 * Draw and return a rectangle
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Number} r Border corner radius
	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
	 */
	rect: function (x, y, width, height, r, strokeWidth) {
		if (isObject(x)) {
			y = x.y;
			width = x.width;
			height = x.height;
			r = x.r;
			strokeWidth = x.strokeWidth;
			x = x.x;
		}
		var wrapper = this.createElement('rect').attr({
			rx: r,
			ry: r,
			fill: NONE
		});

		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
	},

	/**
	 * Resize the box and re-align all aligned elements
	 * @param {Object} width
	 * @param {Object} height
	 * @param {Boolean} animate
	 *
	 */
	setSize: function (width, height, animate) {
		var renderer = this,
			alignedObjects = renderer.alignedObjects,
			i = alignedObjects.length;

		renderer.width = width;
		renderer.height = height;

		renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
			width: width,
			height: height
		});

		while (i--) {
			alignedObjects[i].align();
		}
	},

	/**
	 * Create a group
	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
	 *     This can be used for styling and scripting.
	 */
	g: function (name) {
		var elem = this.createElement('g');
		return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
	},

	/**
	 * Display an image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var attribs = {
				preserveAspectRatio: NONE
			},
			elemWrapper;

		// optional properties
		if (arguments.length > 1) {
			extend(attribs, {
				x: x,
				y: y,
				width: width,
				height: height
			});
		}

		elemWrapper = this.createElement('image').attr(attribs);

		// set the href in the xlink namespace
		if (elemWrapper.element.setAttributeNS) {
			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
				'href', src);
		} else {
			// could be exporting in IE
			// using href throws "not supported" in ie7 and under, requries regex shim to fix later
			elemWrapper.element.setAttribute('hc-svg-href', src);
	}

		return elemWrapper;
	},

	/**
	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
	 *
	 * @param {Object} symbol
	 * @param {Object} x
	 * @param {Object} y
	 * @param {Object} radius
	 * @param {Object} options
	 */
	symbol: function (symbol, x, y, width, height, options) {

		var obj,

			// get the symbol definition function
			symbolFn = this.symbols[symbol],

			// check if there's a path defined for this symbol
			path = symbolFn && symbolFn(
				mathRound(x),
				mathRound(y),
				width,
				height,
				options
			),

			imageRegex = /^url\((.*?)\)$/,
			imageSrc,
			imageSize;

		if (path) {

			obj = this.path(path);
			// expando properties for use in animate and attr
			extend(obj, {
				symbolName: symbol,
				x: x,
				y: y,
				width: width,
				height: height
			});
			if (options) {
				extend(obj, options);
			}


		// image symbols
		} else if (imageRegex.test(symbol)) {

			var centerImage = function (img, size) {
				img.attr({
					width: size[0],
					height: size[1]
				}).translate(
					-mathRound(size[0] / 2),
					-mathRound(size[1] / 2)
				);
			};

			imageSrc = symbol.match(imageRegex)[1];
			imageSize = symbolSizes[imageSrc];

			// create the image synchronously, add attribs async
			obj = this.image(imageSrc)
				.attr({
					x: x,
					y: y
				});

			if (imageSize) {
				centerImage(obj, imageSize);
			} else {
				// initialize image to be 0 size so export will still function if there's no cached sizes
				obj.attr({ width: 0, height: 0 });

				// create a dummy JavaScript image to get the width and height
				createElement('img', {
					onload: function () {
						var img = this;

						centerImage(obj, symbolSizes[imageSrc] = [img.width, img.height]);
					},
					src: imageSrc
				});
			}
		}

		return obj;
	},

	/**
	 * An extendable collection of functions for defining symbol paths.
	 */
	symbols: {
		'circle': function (x, y, w, h) {
			var cpw = 0.166 * w;
			return [
				M, x + w / 2, y,
				'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
				'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
				'Z'
			];
		},

		'square': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle-down': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w / 2, y + h,
				'Z'
			];
		},
		'diamond': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h / 2,
				x + w / 2, y + h,
				x, y + h / 2,
				'Z'
			];
		},
		'arc': function (x, y, w, h, options) {
			var start = options.start,
				radius = options.r || w || h,
				end = options.end - 0.000001, // to prevent cos and sin of start and end from becoming equal on 360 arcs
				innerRadius = options.innerR,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				longArc = options.end - start < mathPI ? 0 : 1;

			return [
				M,
				x + radius * cosStart,
				y + radius * sinStart,
				'A', // arcTo
				radius, // x radius
				radius, // y radius
				0, // slanting
				longArc, // long or short arc
				1, // clockwise
				x + radius * cosEnd,
				y + radius * sinEnd,
				L,
				x + innerRadius * cosEnd,
				y + innerRadius * sinEnd,
				'A', // arcTo
				innerRadius, // x radius
				innerRadius, // y radius
				0, // slanting
				longArc, // long or short arc
				0, // clockwise
				x + innerRadius * cosStart,
				y + innerRadius * sinStart,

				'Z' // close
			];
		}
	},

	/**
	 * Define a clipping rectangle
	 * @param {String} id
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {
		var wrapper,
			id = PREFIX + idCounter++,

			clipPath = this.createElement('clipPath').attr({
				id: id
			}).add(this.defs);

		wrapper = this.rect(x, y, width, height, 0).add(clipPath);
		wrapper.id = id;
		wrapper.clipPath = clipPath;

		return wrapper;
	},


	/**
	 * Take a color and return it if it's a string, make it a gradient if it's a
	 * gradient configuration object. Prior to Highstock, an array was used to define
	 * a linear gradient with pixel positions relative to the SVG. In newer versions
	 * we change the coordinates to apply relative to the shape, using coordinates
	 * 0-1 within the shape. To preserve backwards compatibility, linearGradient
	 * in this definition is an object of x1, y1, x2 and y2.
	 *
	 * @param {Object} color The color or config object
	 */
	color: function (color, elem, prop) {
		var colorObject,
			regexRgba = /^rgba/;
		if (color && color.linearGradient) {
			var renderer = this,
				linearGradient = color[LINEAR_GRADIENT],
				relativeToShape = !isArray(linearGradient), // keep backwards compatibility
				id,
				gradients = renderer.gradients,
				gradientObject,
				x1 = linearGradient.x1 || linearGradient[0] || 0,
				y1 = linearGradient.y1 || linearGradient[1] || 0,
				x2 = linearGradient.x2 || linearGradient[2] || 0,
				y2 = linearGradient.y2 || linearGradient[3] || 0,
				stopColor,
				stopOpacity,
				// Create a unique key in order to reuse gradient objects. #671.
				key = [relativeToShape, x1, y1, x2, y2, color.stops.join(',')].join(',');

			// If the gradient with the same setup is already created, reuse it
			if (gradients[key]) {
				id = attr(gradients[key].element, 'id');

			// If not, create a new one and keep the reference.
			} else {
				id = PREFIX + idCounter++;
				gradientObject = renderer.createElement(LINEAR_GRADIENT)
					.attr(extend({
						id: id,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2
					}, relativeToShape ? null : { gradientUnits: 'userSpaceOnUse' }))
					.add(renderer.defs);

				// The gradient needs to keep a list of stops to be able to destroy them
				gradientObject.stops = [];
				each(color.stops, function (stop) {
					var stopObject;
					if (regexRgba.test(stop[1])) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}
					stopObject = renderer.createElement('stop').attr({
						offset: stop[0],
						'stop-color': stopColor,
						'stop-opacity': stopOpacity
					}).add(gradientObject);

					// Add the stop element to the gradient
					gradientObject.stops.push(stopObject);
				});

				// Keep a reference to the gradient object so it is possible to reuse it and
				// destroy it later
				gradients[key] = gradientObject;
			}

			return 'url(' + this.url + '#' + id + ')';

		// Webkit and Batik can't show rgba.
		} else if (regexRgba.test(color)) {
			colorObject = Color(color);
			attr(elem, prop + '-opacity', colorObject.get('a'));

			return colorObject.get('rgb');


		} else {
			// Remove the opacity attribute added above. Does not throw if the attribute is not there.
			elem.removeAttribute(prop + '-opacity');

			return color;
		}

	},


	/**
	 * Add text to the SVG object
	 * @param {String} str
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Boolean} useHTML Use HTML to render the text
	 */
	text: function (str, x, y, useHTML) {

		// declare variables
		var renderer = this,
			defaultChartStyle = defaultOptions.chart.style,
			wrapper;

		if (useHTML && !renderer.forExport) {
			return renderer.html(str, x, y);
		}

		x = mathRound(pick(x, 0));
		y = mathRound(pick(y, 0));

		wrapper = renderer.createElement('text')
			.attr({
				x: x,
				y: y,
				text: str
			})
			.css({
				fontFamily: defaultChartStyle.fontFamily,
				fontSize: defaultChartStyle.fontSize
			});

		wrapper.x = x;
		wrapper.y = y;
		return wrapper;
	},


	/**
	 * Create HTML text node. This is used by the VML renderer as well as the SVG
	 * renderer through the useHTML option.
	 *
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	html: function (str, x, y) {
		var defaultChartStyle = defaultOptions.chart.style,
			wrapper = this.createElement('span'),
			attrSetters = wrapper.attrSetters,
			element = wrapper.element,
			renderer = wrapper.renderer;

		// Text setter
		attrSetters.text = function (value) {
			element.innerHTML = value;
			return false;
		};

		// Various setters which rely on update transform
		attrSetters.x = attrSetters.y = attrSetters.align = function (value, key) {
			if (key === 'align') {
				key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
			}
			wrapper[key] = value;
			wrapper.htmlUpdateTransform();
			return false;
		};

		// Set the default attributes
		wrapper.attr({
				text: str,
				x: mathRound(x),
				y: mathRound(y)
			})
			.css({
				position: ABSOLUTE,
				whiteSpace: 'nowrap',
				fontFamily: defaultChartStyle.fontFamily,
				fontSize: defaultChartStyle.fontSize
			});

		// Use the HTML specific .css method
		wrapper.css = wrapper.htmlCss;

		// This is specific for HTML within SVG
		if (renderer.isSVG) {
			wrapper.add = function (svgGroupWrapper) {

				var htmlGroup,
					htmlGroupStyle,
					container = renderer.box.parentNode;

				// Create a mock group to hold the HTML elements
				if (svgGroupWrapper) {
					htmlGroup = svgGroupWrapper.div;
					if (!htmlGroup) {
						htmlGroup = svgGroupWrapper.div = createElement(DIV, {
							className: attr(svgGroupWrapper.element, 'class')
						}, {
							position: ABSOLUTE,
							left: svgGroupWrapper.attr('translateX') + PX,
							top: svgGroupWrapper.attr('translateY') + PX
						}, container);

						// Ensure dynamic updating position
						htmlGroupStyle = htmlGroup.style;
						extend(svgGroupWrapper.attrSetters, {
							translateX: function (value) {
								htmlGroupStyle.left = value + PX;
							},
							translateY: function (value) {
								htmlGroupStyle.top = value + PX;
							},
							visibility: function (value, key) {
								htmlGroupStyle[key] = value;
							}
						});

					}
				} else {
					htmlGroup = container;
				}

				htmlGroup.appendChild(element);

				// Shared with VML:
				wrapper.added = true;
				if (wrapper.alignOnAdd) {
					wrapper.htmlUpdateTransform();
				}

				return wrapper;
			};
		}
		return wrapper;
	},

	/**
	 * Utility to return the baseline offset and total line height from the font size
	 */
	fontMetrics: function (fontSize) {
		fontSize = pInt(fontSize || 11);
		
		// Empirical values found by comparing font size and bounding box height.
		// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
		var lineHeight = fontSize < 24 ? fontSize + 4 : mathRound(fontSize * 1.2),
			baseline = mathRound(lineHeight * 0.8);
		
		return {
			h: lineHeight, 
			b: baseline
		};
	},

	/**
	 * Add a label, a text item that can hold a colored or gradient background
	 * as well as a border and shadow.
	 * @param {string} str
	 * @param {Number} x
	 * @param {Number} y
	 * @param {String} shape
	 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
	 *    coordinates it should be pinned to
	 * @param {Number} anchorY
	 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
	 *    like renderer.text, or to the upper border of the rectangle. 
	 */
	label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline) {

		var renderer = this,
			wrapper = renderer.g(),
			text = renderer.text('', 0, 0, useHTML)
				.attr({
					zIndex: 1
				})
				.add(wrapper),
			box,
			bBox,
			align = 'left',
			padding = 3,
			width,
			height,
			wrapperX,
			wrapperY,
			crispAdjust = 0,
			deferredAttr = {},
			baselineOffset,
			attrSetters = wrapper.attrSetters;

		/**
		 * This function runs after the label is added to the DOM (when the bounding box is
		 * available), and after the text of the label is updated to detect the new bounding
		 * box and reflect it in the border box.
		 */
		function updateBoxSize() {
			var boxY,
				style = text.element.style;
				
			bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) &&
				text.getBBox(true);
			wrapper.width = (width || bBox.width) + 2 * padding;
			wrapper.height = (height || bBox.height) + 2 * padding;
			
			// update the label-scoped y offset
			baselineOffset = padding + renderer.fontMetrics(style && style.fontSize).b;
			
			
			// create the border box if it is not already present
			if (!box) {
				boxY = baseline ? -baselineOffset : 0;
			
				wrapper.box = box = shape ?
					renderer.symbol(shape, 0, boxY, wrapper.width, wrapper.height) :
					renderer.rect(0, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
				box.add(wrapper);
			}

			// apply the box attributes
			box.attr(merge({
				width: wrapper.width,
				height: wrapper.height
			}, deferredAttr));
			deferredAttr = null;
		}

		/**
		 * This function runs after setting text or padding, but only if padding is changed
		 */
		function updateTextPadding() {
			var styles = wrapper.styles,
				textAlign = styles && styles.textAlign,
				x = padding,
				y;
			
			// determin y based on the baseline
			y = baseline ? 0 : baselineOffset;

			// compensate for alignment
			if (defined(width) && (textAlign === 'center' || textAlign === 'right')) {
				x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
			}

			// update if anything changed
			if (x !== text.x || y !== text.y) {
				text.attr({
					x: x,
					y: y
				});
			}

			// record current values
			text.x = x;
			text.y = y;
		}

		/**
		 * Set a box attribute, or defer it if the box is not yet created
		 * @param {Object} key
		 * @param {Object} value
		 */
		function boxAttr(key, value) {
			if (box) {
				box.attr(key, value);
			} else {
				deferredAttr[key] = value;
			}
		}

		function getSizeAfterAdd() {
			wrapper.attr({
				text: str, // alignment is available now
				x: x,
				y: y,
				anchorX: anchorX,
				anchorY: anchorY
			});
		}

		/**
		 * After the text element is added, get the desired size of the border box
		 * and add it before the text in the DOM.
		 */
		addEvent(wrapper, 'add', getSizeAfterAdd);

		/*
		 * Add specific attribute setters.
		 */

		// only change local variables
		attrSetters.width = function (value) {
			width = value;
			return false;
		};
		attrSetters.height = function (value) {
			height = value;
			return false;
		};
		attrSetters.padding = function (value) {
			if (defined(value) && value !== padding) {
				padding = value;
				updateTextPadding();
			}

			return false;
		};

		// change local variable and set attribue as well
		attrSetters.align = function (value) {
			align = value;
			return false; // prevent setting text-anchor on the group
		};
		
		// apply these to the box and the text alike
		attrSetters.text = function (value, key) {
			text.attr(key, value);
			updateBoxSize();
			updateTextPadding();
			return false;
		};

		// apply these to the box but not to the text
		attrSetters[STROKE_WIDTH] = function (value, key) {
			crispAdjust = value % 2 / 2;
			boxAttr(key, value);
			return false;
		};
		attrSetters.stroke = attrSetters.fill = attrSetters.r = function (value, key) {
			boxAttr(key, value);
			return false;
		};
		attrSetters.anchorX = function (value, key) {
			anchorX = value;
			boxAttr(key, value + crispAdjust - wrapperX);
			return false;
		};
		attrSetters.anchorY = function (value, key) {
			anchorY = value;
			boxAttr(key, value - wrapperY);
			return false;
		};
		
		// rename attributes
		attrSetters.x = function (value) {
			value -= { left: 0, center: 0.5, right: 1 }[align] * ((width || bBox.width) + padding);
			wrapperX = wrapper.x = mathRound(value); // wrapper.x is for animation getter
			
			wrapper.attr('translateX', wrapperX);
			return false;
		};
		attrSetters.y = function (value) {
			wrapperY = wrapper.y = mathRound(value);
			wrapper.attr('translateY', value);
			return false;
		};

		// Redirect certain methods to either the box or the text
		var baseCss = wrapper.css;
		return extend(wrapper, {
			/**
			 * Pick up some properties and apply them to the text instead of the wrapper
			 */
			css: function (styles) {
				if (styles) {
					var textStyles = {};
					styles = merge({}, styles); // create a copy to avoid altering the original object (#537)
					each(['fontSize', 'fontWeight', 'fontFamily', 'color', 'lineHeight', 'width'], function (prop) {
						if (styles[prop] !== UNDEFINED) {
							textStyles[prop] = styles[prop];
							delete styles[prop];
						}
					});
					text.css(textStyles);
				}
				return baseCss.call(wrapper, styles);
			},
			/**
			 * Return the bounding box of the box, not the group
			 */
			getBBox: function () {
				return box.getBBox();
			},
			/**
			 * Apply the shadow to the box
			 */
			shadow: function (b) {
				box.shadow(b);
				return wrapper;
			},
			/**
			 * Destroy and release memory.
			 */
			destroy: function () {
				removeEvent(wrapper, 'add', getSizeAfterAdd);

				// Added by button implementation
				removeEvent(wrapper.element, 'mouseenter');
				removeEvent(wrapper.element, 'mouseleave');

				if (text) {
					// Destroy the text element
					text = text.destroy();
				}
				// Call base implementation to destroy the rest
				SVGElement.prototype.destroy.call(wrapper);
			}
		});
	}
}; // end SVGRenderer


// general renderer
Renderer = SVGRenderer;


/* ****************************************************************************
 *                                                                            *
 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
 *                                                                            *
 * For applications and websites that don't need IE support, like platform    *
 * targeted mobile apps and web apps, this code can be removed.               *
 *                                                                            *
 *****************************************************************************/

/**
 * @constructor
 */
var VMLRenderer;
if (!hasSVG && !useCanVG) {

/**
 * The VML element wrapper.
 */
var VMLElement = {

	/**
	 * Initialize a new VML element wrapper. It builds the markup as a string
	 * to minimize DOM traffic.
	 * @param {Object} renderer
	 * @param {Object} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this,
			markup =  ['<', nodeName, ' filled="f" stroked="f"'],
			style = ['position: ', ABSOLUTE, ';'];

		// divs and shapes need size
		if (nodeName === 'shape' || nodeName === DIV) {
			style.push('left:0;top:0;width:10px;height:10px;');
		}
		if (docMode8) {
			style.push('visibility: ', nodeName === DIV ? HIDDEN : VISIBLE);
		}

		markup.push(' style="', style.join(''), '"/>');

		// create element with default attributes and style
		if (nodeName) {
			markup = nodeName === DIV || nodeName === 'span' || nodeName === 'img' ?
				markup.join('')
				: renderer.prepVML(markup);
			wrapper.element = createElement(markup);
		}

		wrapper.renderer = renderer;
		wrapper.attrSetters = {};
	},

	/**
	 * Add the node to the given parent
	 * @param {Object} parent
	 */
	add: function (parent) {
		var wrapper = this,
			renderer = wrapper.renderer,
			element = wrapper.element,
			box = renderer.box,
			inverted = parent && parent.inverted,

			// get the parent node
			parentNode = parent ?
				parent.element || parent :
				box;


		// if the parent group is inverted, apply inversion on all children
		if (inverted) { // only on groups
			renderer.invertChild(element, parentNode);
		}

		// issue #140 workaround - related to #61 and #74
		if (docMode8 && parentNode.gVis === HIDDEN) {
			css(element, { visibility: HIDDEN });
		}

		// append it
		parentNode.appendChild(element);

		// align text after adding to be able to read offset
		wrapper.added = true;
		if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
			wrapper.updateTransform();
		}

		// fire an event for internal hooks
		fireEvent(wrapper, 'add');

		return wrapper;
	},

	/**
	 * In IE8 documentMode 8, we need to recursively set the visibility down in the DOM
	 * tree for nested groups. Related to #61, #586.
	 */
	toggleChildren: function (element, visibility) {
		var childNodes = element.childNodes,
			i = childNodes.length;
			
		while (i--) {
			
			// apply the visibility
			css(childNodes[i], { visibility: visibility });
			
			// we have a nested group, apply it to its children again
			if (childNodes[i].nodeName === 'DIV') {
				this.toggleChildren(childNodes[i], visibility);
			}
		}
	},

	/**
	 * VML always uses htmlUpdateTransform
	 */
	updateTransform: SVGElement.prototype.htmlUpdateTransform,

	/**
	 * Get or set attributes
	 */
	attr: function (hash, val) {
		var wrapper = this,
			key,
			value,
			i,
			result,
			element = wrapper.element || {},
			elemStyle = element.style,
			nodeName = element.nodeName,
			renderer = wrapper.renderer,
			symbolName = wrapper.symbolName,
			hasSetSymbolSize,
			shadows = wrapper.shadows,
			skipAttr,
			attrSetters = wrapper.attrSetters,
			ret = wrapper;

		// single key-value pair
		if (isString(hash) && defined(val)) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter, val is undefined
		if (isString(hash)) {
			key = hash;
			if (key === 'strokeWidth' || key === 'stroke-width') {
				ret = wrapper.strokeweight;
			} else {
				ret = wrapper[key];
			}

		// setter
		} else {
			for (key in hash) {
				value = hash[key];
				skipAttr = false;

				// check for a specific attribute setter
				result = attrSetters[key] && attrSetters[key](value, key);

				if (result !== false && value !== null) { // #620

					if (result !== UNDEFINED) {
						value = result; // the attribute setter has returned a new value to set
					}


					// prepare paths
					// symbols
					if (symbolName && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(key)) {
						// if one of the symbol size affecting parameters are changed,
						// check all the others only once for each call to an element's
						// .attr() method
						if (!hasSetSymbolSize) {
							wrapper.symbolAttr(hash);

							hasSetSymbolSize = true;
						}
						skipAttr = true;

					} else if (key === 'd') {
						value = value || [];
						wrapper.d = value.join(' '); // used in getter for animation

						// convert paths
						i = value.length;
						var convertedPath = [];
						while (i--) {

							// Multiply by 10 to allow subpixel precision.
							// Substracting half a pixel seems to make the coordinates
							// align with SVG, but this hasn't been tested thoroughly
							if (isNumber(value[i])) {
								convertedPath[i] = mathRound(value[i] * 10) - 5;
							} else if (value[i] === 'Z') { // close the path
								convertedPath[i] = 'x';
							} else {
								convertedPath[i] = value[i];
							}

						}
						value = convertedPath.join(' ') || 'x';
						element.path = value;

						// update shadows
						if (shadows) {
							i = shadows.length;
							while (i--) {
								shadows[i].path = value;
							}
						}
						skipAttr = true;

					// directly mapped to css
					} else if (key === 'zIndex' || key === 'visibility') {

						// workaround for #61 and #586
						if (docMode8 && key === 'visibility' && nodeName === 'DIV') {
							element.gVis = value;
							wrapper.toggleChildren(element, value);
							if (value === VISIBLE) { // #74
								value = null;
							}
						}

						if (value) {
							elemStyle[key] = value;
						}



						skipAttr = true;

					// width and height
					} else if (key === 'width' || key === 'height') {
						
						value = mathMax(0, value); // don't set width or height below zero (#311)
						
						this[key] = value; // used in getter

						// clipping rectangle special
						if (wrapper.updateClipping) {
							wrapper[key] = value;
							wrapper.updateClipping();
						} else {
							// normal
							elemStyle[key] = value;
						}

						skipAttr = true;

					// x and y
					} else if (key === 'x' || key === 'y') {

						wrapper[key] = value; // used in getter
						elemStyle[{ x: 'left', y: 'top' }[key]] = value;

					// class name
					} else if (key === 'class') {
						// IE8 Standards mode has problems retrieving the className
						element.className = value;

					// stroke
					} else if (key === 'stroke') {

						value = renderer.color(value, element, key);

						key = 'strokecolor';

					// stroke width
					} else if (key === 'stroke-width' || key === 'strokeWidth') {
						element.stroked = value ? true : false;
						key = 'strokeweight';
						wrapper[key] = value; // used in getter, issue #113
						if (isNumber(value)) {
							value += PX;
						}

					// dashStyle
					} else if (key === 'dashstyle') {
						var strokeElem = element.getElementsByTagName('stroke')[0] ||
							createElement(renderer.prepVML(['<stroke/>']), null, null, element);
						strokeElem[key] = value || 'solid';
						wrapper.dashstyle = value; /* because changing stroke-width will change the dash length
							and cause an epileptic effect */
						skipAttr = true;

					// fill
					} else if (key === 'fill') {

						if (nodeName === 'SPAN') { // text color
							elemStyle.color = value;
						} else {
							element.filled = value !== NONE ? true : false;

							value = renderer.color(value, element, key);

							key = 'fillcolor';
						}

					// translation for animation
					} else if (key === 'translateX' || key === 'translateY' || key === 'rotation') {
						wrapper[key] = value;
						wrapper.updateTransform();

						skipAttr = true;

					// text for rotated and non-rotated elements
					} else if (key === 'text') {
						this.bBox = null;
						element.innerHTML = value;
						skipAttr = true;
					}

					// let the shadow follow the main element
					if (shadows && key === 'visibility') {
						i = shadows.length;
						while (i--) {
							shadows[i].style[key] = value;
						}
					}



					if (!skipAttr) {
						if (docMode8) { // IE8 setAttribute bug
							element[key] = value;
						} else {
							attr(element, key, value);
						}
					}

				}
			}
		}
		return ret;
	},

	/**
	 * Set the element's clipping to a predefined rectangle
	 *
	 * @param {String} id The id of the clip rectangle
	 */
	clip: function (clipRect) {
		var wrapper = this,
			clipMembers = clipRect.members;

		clipMembers.push(wrapper);
		wrapper.destroyClip = function () {
			erase(clipMembers, wrapper);
		};
		return wrapper.css(clipRect.getCSS(wrapper.inverted));
	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: SVGElement.prototype.htmlCss,

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		// discardElement will detach the node from its parent before attaching it
		// to the garbage bin. Therefore it is important that the node is attached and have parent.
		var parentNode = element.parentNode;
		if (parentNode) {
			discardElement(element);
		}
	},

	/**
	 * Extend element.destroy by removing it from the clip members array
	 */
	destroy: function () {
		var wrapper = this;

		if (wrapper.destroyClip) {
			wrapper.destroyClip();
		}

		return SVGElement.prototype.destroy.apply(wrapper);
	},

	/**
	 * Remove all child nodes of a group, except the v:group element
	 */
	empty: function () {
		var element = this.element,
			childNodes = element.childNodes,
			i = childNodes.length,
			node;

		while (i--) {
			node = childNodes[i];
			node.parentNode.removeChild(node);
		}
	},

	/**
	 * Add an event listener. VML override for normalizing event parameters.
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		// simplest possible event model for internal use
		this.element['on' + eventType] = function () {
			var evt = win.event;
			evt.target = evt.srcElement;
			handler(evt);
		};
		return this;
	},

	/**
	 * Apply a drop shadow by copying elements and giving them different strokes
	 * @param {Boolean} apply
	 */
	shadow: function (apply, group) {
		var shadows = [],
			i,
			element = this.element,
			renderer = this.renderer,
			shadow,
			elemStyle = element.style,
			markup,
			path = element.path;

		// some times empty paths are not strings
		if (path && typeof path.value !== 'string') {
			path = 'x';
		}

		if (apply) {
			for (i = 1; i <= 3; i++) {
				markup = ['<shape isShadow="true" strokeweight="', (7 - 2 * i),
					'" filled="false" path="', path,
					'" coordsize="100,100" style="', element.style.cssText, '" />'];
				shadow = createElement(renderer.prepVML(markup),
					null, {
						left: pInt(elemStyle.left) + 1,
						top: pInt(elemStyle.top) + 1
					}
				);

				// apply the opacity
				markup = ['<stroke color="black" opacity="', (0.05 * i), '"/>'];
				createElement(renderer.prepVML(markup), null, null, shadow);


				// insert it
				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				// record it
				shadows.push(shadow);

			}

			this.shadows = shadows;
		}
		return this;

	}
};
VMLElement = extendClass(SVGElement, VMLElement);

/**
 * The VML renderer
 */
var VMLRendererExtension = { // inherit SVGRenderer

	Element: VMLElement,
	isIE8: userAgent.indexOf('MSIE 8.0') > -1,


	/**
	 * Initialize the VMLRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 */
	init: function (container, width, height) {
		var renderer = this,
			boxWrapper,
			box;

		renderer.alignedObjects = [];

		boxWrapper = renderer.createElement(DIV);
		box = boxWrapper.element;
		box.style.position = RELATIVE; // for freeform drawing using renderer directly
		container.appendChild(boxWrapper.element);


		// generate the containing box
		renderer.box = box;
		renderer.boxWrapper = boxWrapper;


		renderer.setSize(width, height, false);

		// The only way to make IE6 and IE7 print is to use a global namespace. However,
		// with IE8 the only way to make the dynamic shapes visible in screen and print mode
		// seems to be to add the xmlns attribute and the behaviour style inline.
		if (!doc.namespaces.hcv) {

			doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

			// setup default css
			doc.createStyleSheet().cssText =
				'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
				'{ behavior:url(#default#VML); display: inline-block; } ';

		}
	},

	/**
	 * Define a clipping rectangle. In VML it is accomplished by storing the values
	 * for setting the CSS style to all associated members.
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {

		// create a dummy element
		var clipRect = this.createElement();

		// mimic a rectangle with its style object for automatic updating in attr
		return extend(clipRect, {
			members: [],
			left: x,
			top: y,
			width: width,
			height: height,
			getCSS: function (inverted) {
				var rect = this,//clipRect.element.style,
					top = rect.top,
					left = rect.left,
					right = left + rect.width,
					bottom = top + rect.height,
					ret = {
						clip: 'rect(' +
							mathRound(inverted ? left : top) + 'px,' +
							mathRound(inverted ? bottom : right) + 'px,' +
							mathRound(inverted ? right : bottom) + 'px,' +
							mathRound(inverted ? top : left) + 'px)'
					};

				// issue 74 workaround
				if (!inverted && docMode8) {
					extend(ret, {
						width: right + PX,
						height: bottom + PX
					});
				}
				return ret;
			},

			// used in attr and animation to update the clipping of all members
			updateClipping: function () {
				each(clipRect.members, function (member) {
					member.css(clipRect.getCSS(member.inverted));
				});
			}
		});

	},


	/**
	 * Take a color and return it if it's a string, make it a gradient if it's a
	 * gradient configuration object, and apply opacity.
	 *
	 * @param {Object} color The color or config object
	 */
	color: function (color, elem, prop) {
		var colorObject,
			regexRgba = /^rgba/,
			markup;

		if (color && color[LINEAR_GRADIENT]) {

			var stopColor,
				stopOpacity,
				linearGradient = color[LINEAR_GRADIENT],
				x1 = linearGradient.x1 || linearGradient[0] || 0,
				y1 = linearGradient.y1 || linearGradient[1] || 0,
				x2 = linearGradient.x2 || linearGradient[2] || 0,
				y2 = linearGradient.y2 || linearGradient[3] || 0,
				angle,
				color1,
				opacity1,
				color2,
				opacity2;

			each(color.stops, function (stop, i) {
				if (regexRgba.test(stop[1])) {
					colorObject = Color(stop[1]);
					stopColor = colorObject.get('rgb');
					stopOpacity = colorObject.get('a');
				} else {
					stopColor = stop[1];
					stopOpacity = 1;
				}

				if (!i) { // first
					color1 = stopColor;
					opacity1 = stopOpacity;
				} else {
					color2 = stopColor;
					opacity2 = stopOpacity;
				}
			});

			// Apply the gradient to fills only.
			if (prop === 'fill') {
				// calculate the angle based on the linear vector
				angle = 90  - math.atan(
					(y2 - y1) / // y vector
					(x2 - x1) // x vector
					) * 180 / mathPI;
	
	
				// when colors attribute is used, the meanings of opacity and o:opacity2
				// are reversed.
				markup = ['<fill colors="0% ', color1, ',100% ', color2, '" angle="', angle,
					'" opacity="', opacity2, '" o:opacity2="', opacity1,
					'" type="gradient" focus="100%" method="sigma" />'];
				createElement(this.prepVML(markup), null, null, elem);
			
			// Gradients are not supported for VML stroke, return the first color. #722.
			} else {
				return stopColor;
			}


		// if the color is an rgba color, split it and add a fill node
		// to hold the opacity component
		} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

			colorObject = Color(color);

			markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
			createElement(this.prepVML(markup), null, null, elem);

			return colorObject.get('rgb');


		} else {
			var strokeNodes = elem.getElementsByTagName(prop);
			if (strokeNodes.length) {
				strokeNodes[0].opacity = 1;
			}
			return color;
		}

	},

	/**
	 * Take a VML string and prepare it for either IE8 or IE6/IE7.
	 * @param {Array} markup A string array of the VML markup to prepare
	 */
	prepVML: function (markup) {
		var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
			isIE8 = this.isIE8;

		markup = markup.join('');

		if (isIE8) { // add xmlns and style inline
			markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
			if (markup.indexOf('style="') === -1) {
				markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
			} else {
				markup = markup.replace('style="', 'style="' + vmlStyle);
			}

		} else { // add namespace
			markup = markup.replace('<', '<hcv:');
		}

		return markup;
	},

	/**
	 * Create rotated and aligned text
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	text: SVGRenderer.prototype.html,

	/**
	 * Create and return a path element
	 * @param {Array} path
	 */
	path: function (path) {
		// create the shape
		return this.createElement('shape').attr({
			// subpixel precision down to 0.1 (width and height = 10px)
			coordsize: '100 100',
			d: path
		});
	},

	/**
	 * Create and return a circle element. In VML circles are implemented as
	 * shapes, which is faster than v:oval
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} r
	 */
	circle: function (x, y, r) {
		return this.symbol('circle').attr({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });
	},

	/**
	 * Create a group using an outer div and an inner v:group to allow rotating
	 * and flipping. A simple v:group would have problems with positioning
	 * child HTML elements and CSS clip.
	 *
	 * @param {String} name The name of the group
	 */
	g: function (name) {
		var wrapper,
			attribs;

		// set the class name
		if (name) {
			attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
		}

		// the div to hold HTML and clipping
		wrapper = this.createElement(DIV).attr(attribs);

		return wrapper;
	},

	/**
	 * VML override to create a regular HTML image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var obj = this.createElement('img')
			.attr({ src: src });

		if (arguments.length > 1) {
			obj.css({
				left: x,
				top: y,
				width: width,
				height: height
			});
		}
		return obj;
	},

	/**
	 * VML uses a shape for rect to overcome bugs and rotation problems
	 */
	rect: function (x, y, width, height, r, strokeWidth) {

		if (isObject(x)) {
			y = x.y;
			width = x.width;
			height = x.height;
			strokeWidth = x.strokeWidth;
			x = x.x;
		}
		var wrapper = this.symbol('rect');
		wrapper.r = r;

		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
	},

	/**
	 * In the VML renderer, each child of an inverted div (group) is inverted
	 * @param {Object} element
	 * @param {Object} parentNode
	 */
	invertChild: function (element, parentNode) {
		var parentStyle = parentNode.style;

		css(element, {
			flip: 'x',
			left: pInt(parentStyle.width) - 10,
			top: pInt(parentStyle.height) - 10,
			rotation: -90
		});
	},

	/**
	 * Symbol definitions that override the parent SVG renderer's symbols
	 *
	 */
	symbols: {
		// VML specific arc function
		arc: function (x, y, w, h, options) {
			var start = options.start,
				end = options.end,
				radius = options.r || w || h,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				innerRadius = options.innerR,
				circleCorrection = 0.08 / radius, // #760
				innerCorrection = (innerRadius && 0.25 / innerRadius) || 0;

			if (end - start === 0) { // no angle, don't show it.
				return ['x'];

			} else if (2 * mathPI - end + start < circleCorrection) { // full circle
				// empirical correction found by trying out the limits for different radii
				cosEnd = -circleCorrection;
			} else if (end - start < innerCorrection) { // issue #186, another mysterious VML arc problem
				cosEnd = mathCos(start + innerCorrection);
			}

			return [
				'wa', // clockwise arc to
				x - radius, // left
				y - radius, // top
				x + radius, // right
				y + radius, // bottom
				x + radius * cosStart, // start x
				y + radius * sinStart, // start y
				x + radius * cosEnd, // end x
				y + radius * sinEnd, // end y


				'at', // anti clockwise arc to
				x - innerRadius, // left
				y - innerRadius, // top
				x + innerRadius, // right
				y + innerRadius, // bottom
				x + innerRadius * cosEnd, // start x
				y + innerRadius * sinEnd, // start y
				x + innerRadius * cosStart, // end x
				y + innerRadius * sinStart, // end y

				'x', // finish path
				'e' // close
			];

		},
		// Add circle symbol path. This performs significantly faster than v:oval.
		circle: function (x, y, w, h) {

			return [
				'wa', // clockwisearcto
				x, // left
				y, // top
				x + w, // right
				y + h, // bottom
				x + w, // start x
				y + h / 2,     // start y
				x + w, // end x
				y + h / 2,     // end y
				//'x', // finish path
				'e' // close
			];
		},
		/**
		 * Add rectangle symbol path which eases rotation and omits arcsize problems
		 * compared to the built-in VML roundrect shape
		 *
		 * @param {Number} left Left position
		 * @param {Number} top Top position
		 * @param {Number} r Border radius
		 * @param {Object} options Width and height
		 */

		rect: function (left, top, width, height, options) {
			/*for (var n in r) {
				logTime && console .log(n)
				}*/

			if (!defined(options)) {
				return [];
			}
			var right = left + width,
				bottom = top + height,
				r = mathMin(options.r || 0, width, height);

			return [
				M,
				left + r, top,

				L,
				right - r, top,
				'wa',
				right - 2 * r, top,
				right, top + 2 * r,
				right - r, top,
				right, top + r,

				L,
				right, bottom - r,
				'wa',
				right - 2 * r, bottom - 2 * r,
				right, bottom,
				right, bottom - r,
				right - r, bottom,

				L,
				left + r, bottom,
				'wa',
				left, bottom - 2 * r,
				left + 2 * r, bottom,
				left + r, bottom,
				left, bottom - r,

				L,
				left, top + r,
				'wa',
				left, top,
				left + 2 * r, top + 2 * r,
				left, top + r,
				left + r, top,


				'x',
				'e'
			];

		}
	}
};
VMLRenderer = function () {
	this.init.apply(this, arguments);
};
VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

	// general renderer
	Renderer = VMLRenderer;
}

/* ****************************************************************************
 *                                                                            *
 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
 *                                                                            *
 *****************************************************************************/
/* ****************************************************************************
 *                                                                            *
 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
 * TARGETING THAT SYSTEM.                                                     *
 *                                                                            *
 *****************************************************************************/
var CanVGRenderer,
	CanVGController;

if (useCanVG) {
	/**
	 * The CanVGRenderer is empty from start to keep the source footprint small.
	 * When requested, the CanVGController downloads the rest of the source packaged
	 * together with the canvg library.
	 */
	CanVGRenderer = function () {
		// Empty constructor
	};

	/**
	 * Handles on demand download of canvg rendering support.
	 */
	CanVGController = (function () {
		// List of renderering calls
		var deferredRenderCalls = [];

		/**
		 * When downloaded, we are ready to draw deferred charts.
		 */
		function drawDeferred() {
			var callLength = deferredRenderCalls.length,
				callIndex;

			// Draw all pending render calls
			for (callIndex = 0; callIndex < callLength; callIndex++) {
				deferredRenderCalls[callIndex]();
			}
			// Clear the list
			deferredRenderCalls = [];
		}

		return {
			push: function (func, scriptLocation) {
				// Only get the script once
				if (deferredRenderCalls.length === 0) {
					getScript(scriptLocation, drawDeferred);
				}
				// Register render call
				deferredRenderCalls.push(func);
			}
		};
	}());
} // end CanVGRenderer

/* ****************************************************************************
 *                                                                            *
 * END OF ANDROID < 3 SPECIFIC CODE                                           *
 *                                                                            *
 *****************************************************************************/

/**
 * General renderer
 */
Renderer = VMLRenderer || CanVGRenderer || SVGRenderer;

/**
 * The chart class
 * @param {Object} options
 * @param {Function} callback Function to run when the chart has loaded
 */
function Chart(userOptions, callback) {

	// Handle regular options
	var options,
		seriesOptions = userOptions.series; // skip merging data points to increase performance
	userOptions.series = null;
	options = merge(defaultOptions, userOptions); // do the merge
	options.series = userOptions.series = seriesOptions; // set back the series data
	
	var optionsChart = options.chart,
		optionsMargin = optionsChart.margin,
		margin = isObject(optionsMargin) ?
			optionsMargin :
			[optionsMargin, optionsMargin, optionsMargin, optionsMargin],
		optionsMarginTop = pick(optionsChart.marginTop, margin[0]),
		optionsMarginRight = pick(optionsChart.marginRight, margin[1]),
		optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]),
		optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]),
		spacingTop = optionsChart.spacingTop,
		spacingRight = optionsChart.spacingRight,
		spacingBottom = optionsChart.spacingBottom,
		spacingLeft = optionsChart.spacingLeft,
		spacingBox,
		chartTitleOptions,
		chartSubtitleOptions,
		plotTop,
		marginRight,
		marginBottom,
		plotLeft,
		axisOffset,
		renderTo,
		renderToClone,
		container,
		containerId,
		containerWidth,
		containerHeight,
		chartWidth,
		chartHeight,
		oldChartWidth,
		oldChartHeight,
		chartBackground,
		plotBackground,
		plotBGImage,
		plotBorder,
		chart = this,
		chartEvents = optionsChart.events,
		runChartClick = chartEvents && !!chartEvents.click,
		eventType,
		isInsidePlot, // function
		tooltip,
		mouseIsDown,
		loadingDiv,
		loadingSpan,
		loadingShown,
		plotHeight,
		plotWidth,
		tracker,
		trackerGroup,
		legend,
		legendWidth,
		legendHeight,
		chartPosition,
		hasCartesianSeries = optionsChart.showAxes,
		isResizing = 0,
		axes = [],
		maxTicks, // handle the greatest amount of ticks on grouped axes
		series = [],
		inverted,
		renderer,
		tooltipTick,
		tooltipInterval,
		hoverX,
		drawChartBox, // function
		getMargins, // function
		resetMargins, // function
		setChartSize, // function
		resize,
		zoom, // function
		zoomOut; // function


	/**
	 * Create a new axis object
	 * @param {Object} options
	 */
	function Axis(userOptions) {

		// Define variables
		var isXAxis = userOptions.isX,
			opposite = userOptions.opposite, // needed in setOptions
			horiz = inverted ? !isXAxis : isXAxis,
			side = horiz ?
				(opposite ? 0 : 2) : // top : bottom
				(opposite ? 1 : 3),  // right : left
			stacks = {},

			options = merge(
				isXAxis ? defaultXAxisOptions : defaultYAxisOptions,
				[defaultTopAxisOptions, defaultRightAxisOptions,
					defaultBottomAxisOptions, defaultLeftAxisOptions][side],
				userOptions
			),

			axis = this,
			axisTitle,
			type = options.type,
			isDatetimeAxis = type === 'datetime',
			isLog = type === 'logarithmic',
			offset = options.offset || 0,
			xOrY = isXAxis ? 'x' : 'y',
			axisLength = 0,
			oldAxisLength,
			transA, // translation factor
			transB, // translation addend
			oldTransA, // used for prerendering
			axisLeft,
			axisTop,
			axisWidth,
			axisHeight,
			axisBottom,
			axisRight,
			translate, // fn
			setAxisTranslation, // fn
			getPlotLinePath, // fn
			axisGroup,
			gridGroup,
			axisLine,
			dataMin,
			dataMax,
			minRange = options.minRange || options.maxZoom,
			range = options.range,
			userMin,
			userMax,
			oldUserMin,
			oldUserMax,
			max = null,
			min = null,
			oldMin,
			oldMax,
			minPadding = options.minPadding,
			maxPadding = options.maxPadding,
			minPixelPadding = 0,
			isLinked = defined(options.linkedTo),
			linkedParent,
			ignoreMinPadding, // can be set to true by a column or bar series
			ignoreMaxPadding,
			usePercentage,
			events = options.events,
			eventType,
			plotLinesAndBands = [],
			tickInterval,
			minorTickInterval,
			magnitude,
			tickPositions, // array containing predefined positions
			tickPositioner = options.tickPositioner,
			ticks = {},
			minorTicks = {},
			alternateBands = {},
			tickAmount,
			labelOffset,
			axisTitleMargin,// = options.title.margin,
			categories = options.categories,
			labelFormatter = options.labels.formatter ||  // can be overwritten by dynamic format
				function () {
					var value = this.value,
						dateTimeLabelFormat = this.dateTimeLabelFormat,
						ret;

					if (dateTimeLabelFormat) { // datetime axis
						ret = dateFormat(dateTimeLabelFormat, value);

					} else if (tickInterval % 1000000 === 0) { // use M abbreviation
						ret = (value / 1000000) + 'M';

					} else if (tickInterval % 1000 === 0) { // use k abbreviation
						ret = (value / 1000) + 'k';

					} else if (!categories && value >= 1000) { // add thousands separators
						ret = numberFormat(value, 0);

					} else { // strings (categories) and small numbers
						ret = value;
					}
					return ret;
				},

			staggerLines = horiz && options.labels.staggerLines,
			reversed = options.reversed,
			tickmarkOffset = (categories && options.tickmarkPlacement === 'between') ? 0.5 : 0;

		/**
		 * The Tick class
		 */
		function Tick(pos, type) {
			var tick = this;
			tick.pos = pos;
			tick.type = type || '';
			tick.isNew = true;

			if (!type) {
				tick.addLabel();
			}
		}
		Tick.prototype = {

			/**
			 * Write the tick label
			 */
			addLabel: function () {
				var tick = this,
					pos = tick.pos,
					labelOptions = options.labels,
					str,
					width = (categories && horiz && categories.length &&
						!labelOptions.step && !labelOptions.staggerLines &&
						!labelOptions.rotation &&
						plotWidth / categories.length) ||
						(!horiz && plotWidth / 2),
					isFirst = pos === tickPositions[0],
					isLast = pos === tickPositions[tickPositions.length - 1],
					css,
					value = categories && defined(categories[pos]) ? categories[pos] : pos,
					label = tick.label,
					tickPositionInfo = tickPositions.info,
					dateTimeLabelFormat;

				// Set the datetime label format. If a higher rank is set for this position, use that. If not,
				// use the general format.
				if (isDatetimeAxis && tickPositionInfo) {
					dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
				}

				// set properties for access in render method
				tick.isFirst = isFirst;
				tick.isLast = isLast;

				// get the string
				str = labelFormatter.call({
					axis: axis,
					chart: chart,
					isFirst: isFirst,
					isLast: isLast,
					dateTimeLabelFormat: dateTimeLabelFormat,
					value: isLog ? correctFloat(lin2log(value)) : value
				});


				// prepare CSS
				css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
				css = extend(css, labelOptions.style);

				// first call
				if (!defined(label)) {
					tick.label =
						defined(str) && labelOptions.enabled ?
							renderer.text(
									str,
									0,
									0,
									labelOptions.useHTML
								)
								.attr({
									align: labelOptions.align,
									rotation: labelOptions.rotation
								})
								// without position absolute, IE export sometimes is wrong
								.css(css)
								.add(axisGroup) :
							null;

				// update
				} else if (label) {
					label.attr({
							text: str
						})
						.css(css);
				}
			},
			/**
			 * Get the offset height or width of the label
			 */
			getLabelSize: function () {
				var label = this.label;
				return label ?
					((this.labelBBox = label.getBBox()))[horiz ? 'height' : 'width'] :
					0;
			},
			
			/**
			 * Find how far the labels extend to the right and left of the tick's x position. Used for anti-collision
			 * detection with overflow logic.
			 */
			getLabelSides: function () {
				var bBox = this.labelBBox, // assume getLabelSize has run at this point
					labelOptions = options.labels,
					width = bBox.width,
					leftSide = width * { left: 0, center: 0.5, right: 1 }[labelOptions.align] - labelOptions.x;
					
				return [-leftSide, width - leftSide];				
			},
			
			/**
			 * Handle the label overflow by adjusting the labels to the left and right edge, or
			 * hide them if they collide into the neighbour label.
			 */
			handleOverflow: function (index) {
				var show = true,
					isFirst = this.isFirst,
					isLast = this.isLast,
					label = this.label,
					x = label.x;
					
				if (isFirst || isLast) {
					
					var sides = this.getLabelSides(),
						leftSide = sides[0],
						rightSide = sides[1],
						plotLeft = chart.plotLeft,
						plotRight = plotLeft + axis.len,
						neighbour = ticks[tickPositions[index + (isFirst ? 1 : -1)]],
						neighbourEdge = neighbour && neighbour.label.x + neighbour.getLabelSides()[isFirst ? 0 : 1];
					
					if ((isFirst && !reversed) || (isLast && reversed)) {
						// Is the label spilling out to the left of the plot area?
						if (x + leftSide < plotLeft) {
							
							// Align it to plot left
							x = plotLeft - leftSide;
							
							// Hide it if it now overlaps the neighbour label
							if (neighbour && x + rightSide > neighbourEdge) {
								show = false;
							}
						}
										
					} else {
						// Is the label spilling out to the right of the plot area?
						if (x + rightSide > plotRight) {
							
							// Align it to plot right
							x = plotRight - rightSide;
							
							// Hide it if it now overlaps the neighbour label
							if (neighbour && x + leftSide < neighbourEdge) {
								show = false;
							}
							
						}
					}
					
					// Set the modified x position of the label
					label.x = x;
				}
				return show;
			},
			
			/**
			 * Put everything in place
			 *
			 * @param index {Number}
			 * @param old {Boolean} Use old coordinates to prepare an animation into new position
			 */
			render: function (index, old) {
				var tick = this,
					type = tick.type,
					label = tick.label,
					pos = tick.pos,
					labelOptions = options.labels,
					gridLine = tick.gridLine,
					gridPrefix = type ? type + 'Grid' : 'grid',
					tickPrefix = type ? type + 'Tick' : 'tick',
					gridLineWidth = options[gridPrefix + 'LineWidth'],
					gridLineColor = options[gridPrefix + 'LineColor'],
					dashStyle = options[gridPrefix + 'LineDashStyle'],
					tickLength = options[tickPrefix + 'Length'],
					tickWidth = options[tickPrefix + 'Width'] || 0,
					tickColor = options[tickPrefix + 'Color'],
					tickPosition = options[tickPrefix + 'Position'],
					gridLinePath,
					mark = tick.mark,
					markPath,
					step = labelOptions.step,
					cHeight = (old && oldChartHeight) || chartHeight,
					attribs,
					show = true,
					x,
					y;

				// get x and y position for ticks and labels
				x = horiz ?
					translate(pos + tickmarkOffset, null, null, old) + transB :
					axisLeft + offset + (opposite ? ((old && oldChartWidth) || chartWidth) - axisRight - axisLeft : 0);

				y = horiz ?
					cHeight - axisBottom + offset - (opposite ? axisHeight : 0) :
					cHeight - translate(pos + tickmarkOffset, null, null, old) - transB;

				// create the grid line
				if (gridLineWidth) {
					gridLinePath = getPlotLinePath(pos + tickmarkOffset, gridLineWidth, old);

					if (gridLine === UNDEFINED) {
						attribs = {
							stroke: gridLineColor,
							'stroke-width': gridLineWidth
						};
						if (dashStyle) {
							attribs.dashstyle = dashStyle;
						}
						if (!type) {
							attribs.zIndex = 1;
						}
						tick.gridLine = gridLine =
							gridLineWidth ?
								renderer.path(gridLinePath)
									.attr(attribs).add(gridGroup) :
								null;
					}

					// If the parameter 'old' is set, the current call will be followed
					// by another call, therefore do not do any animations this time
					if (!old && gridLine && gridLinePath) {
						gridLine.animate({
							d: gridLinePath
						});
					}
				}

				// create the tick mark
				if (tickWidth) {

					// negate the length
					if (tickPosition === 'inside') {
						tickLength = -tickLength;
					}
					if (opposite) {
						tickLength = -tickLength;
					}

					markPath = renderer.crispLine([
						M,
						x,
						y,
						L,
						x + (horiz ? 0 : -tickLength),
						y + (horiz ? tickLength : 0)
					], tickWidth);

					if (mark) { // updating
						mark.animate({
							d: markPath
						});
					} else { // first time
						tick.mark = renderer.path(
							markPath
						).attr({
							stroke: tickColor,
							'stroke-width': tickWidth
						}).add(axisGroup);
					}
				}

				// the label is created on init - now move it into place
				if (label && !isNaN(x)) {
					x = x + labelOptions.x - (tickmarkOffset && horiz ?
						tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
					y = y + labelOptions.y - (tickmarkOffset && !horiz ?
						tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

					// vertically centered
					if (!defined(labelOptions.y)) {
						y += pInt(label.styles.lineHeight) * 0.9 - label.getBBox().height / 2;
					}


					// correct for staggered labels
					if (staggerLines) {
						y += (index / (step || 1) % staggerLines) * 16;
					}
					
					// Cache x and y to be able to read final position before animation
					label.x = x;
					label.y = y;

					// apply show first and show last
					if ((tick.isFirst && !pick(options.showFirstLabel, 1)) ||
							(tick.isLast && !pick(options.showLastLabel, 1))) {
						show = false;
						
					// Handle label overflow and show or hide accordingly
					} else if (!staggerLines && horiz && labelOptions.overflow === 'justify' && !tick.handleOverflow(index)) {						
						show = false;
					}

					// apply step
					if (step && index % step) {
						// show those indices dividable by step
						show = false;
					}
					
					// Set the new position, and show or hide
					if (show) {
						label[tick.isNew ? 'attr' : 'animate']({
							x: label.x,
							y: label.y
						});
						label.show();
						tick.isNew = false;
					} else {
						label.hide();
					}
				}

				
			},
			
			/**
			 * Destructor for the tick prototype
			 */
			destroy: function () {
				destroyObjectProperties(this);
			}
		};

		/**
		 * The object wrapper for plot lines and plot bands
		 * @param {Object} options
		 */
		function PlotLineOrBand(options) {
			var plotLine = this;
			if (options) {
				plotLine.options = options;
				plotLine.id = options.id;
			}

			//plotLine.render()
			return plotLine;
		}

		PlotLineOrBand.prototype = {

		/**
		 * Render the plot line or plot band. If it is already existing,
		 * move it.
		 */
		render: function () {
			var plotLine = this,
				halfPointRange = (axis.pointRange || 0) / 2,
				options = plotLine.options,
				optionsLabel = options.label,
				label = plotLine.label,
				width = options.width,
				to = options.to,
				from = options.from,
				value = options.value,
				toPath, // bands only
				dashStyle = options.dashStyle,
				svgElem = plotLine.svgElem,
				path = [],
				addEvent,
				eventType,
				xs,
				ys,
				x,
				y,
				color = options.color,
				zIndex = options.zIndex,
				events = options.events,
				attribs;

			// logarithmic conversion
			if (isLog) {
				from = log2lin(from);
				to = log2lin(to);
				value = log2lin(value);
			}

			// plot line
			if (width) {
				path = getPlotLinePath(value, width);
				attribs = {
					stroke: color,
					'stroke-width': width
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
			} else if (defined(from) && defined(to)) { // plot band
				// keep within plot area
				from = mathMax(from, min - halfPointRange);
				to = mathMin(to, max + halfPointRange);

				toPath = getPlotLinePath(to);
				path = getPlotLinePath(from);
				if (path && toPath) {
					path.push(
						toPath[4],
						toPath[5],
						toPath[1],
						toPath[2]
					);
				} else { // outside the axis area
					path = null;
				}
				attribs = {
					fill: color
				};
			} else {
				return;
			}
			// zIndex
			if (defined(zIndex)) {
				attribs.zIndex = zIndex;
			}

			// common for lines and bands
			if (svgElem) {
				if (path) {
					svgElem.animate({
						d: path
					}, null, svgElem.onGetPath);
				} else {
					svgElem.hide();
					svgElem.onGetPath = function () {
						svgElem.show();
					};
				}
			} else if (path && path.length) {
				plotLine.svgElem = svgElem = renderer.path(path)
					.attr(attribs).add();

				// events
				if (events) {
					addEvent = function (eventType) {
						svgElem.on(eventType, function (e) {
							events[eventType].apply(plotLine, [e]);
						});
					};
					for (eventType in events) {
						addEvent(eventType);
					}
				}
			}

			// the plot band/line label
			if (optionsLabel && defined(optionsLabel.text) && path && path.length && axisWidth > 0 && axisHeight > 0) {
				// apply defaults
				optionsLabel = merge({
					align: horiz && toPath && 'center',
					x: horiz ? !toPath && 4 : 10,
					verticalAlign : !horiz && toPath && 'middle',
					y: horiz ? toPath ? 16 : 10 : toPath ? 6 : -4,
					rotation: horiz && !toPath && 90
				}, optionsLabel);

				// add the SVG element
				if (!label) {
					plotLine.label = label = renderer.text(
							optionsLabel.text,
							0,
							0
						)
						.attr({
							align: optionsLabel.textAlign || optionsLabel.align,
							rotation: optionsLabel.rotation,
							zIndex: zIndex
						})
						.css(optionsLabel.style)
						.add();
				}

				// get the bounding box and align the label
				xs = [path[1], path[4], pick(path[6], path[1])];
				ys = [path[2], path[5], pick(path[7], path[2])];
				x = arrayMin(xs);
				y = arrayMin(ys);

				label.align(optionsLabel, false, {
					x: x,
					y: y,
					width: arrayMax(xs) - x,
					height: arrayMax(ys) - y
				});
				label.show();

			} else if (label) { // move out of sight
				label.hide();
			}

			// chainable
			return plotLine;
		},

		/**
		 * Remove the plot line or band
		 */
		destroy: function () {
			var obj = this;

			destroyObjectProperties(obj);

			// remove it from the lookup
			erase(plotLinesAndBands, obj);
		}
		};

		/**
		 * The class for stack items
		 */
		function StackItem(options, isNegative, x, stackOption) {
			var stackItem = this;

			// Tells if the stack is negative
			stackItem.isNegative = isNegative;

			// Save the options to be able to style the label
			stackItem.options = options;

			// Save the x value to be able to position the label later
			stackItem.x = x;

			// Save the stack option on the series configuration object
			stackItem.stack = stackOption;

			// The align options and text align varies on whether the stack is negative and
			// if the chart is inverted or not.
			// First test the user supplied value, then use the dynamic.
			stackItem.alignOptions = {
				align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
				verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
				y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
				x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
			};

			stackItem.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
		}

		StackItem.prototype = {
			destroy: function () {
				destroyObjectProperties(this);
			},

			/**
			 * Sets the total of this stack. Should be called when a serie is hidden or shown
			 * since that will affect the total of other stacks.
			 */
			setTotal: function (total) {
				this.total = total;
				this.cum = total;
			},

			/**
			 * Renders the stack total label and adds it to the stack label group.
			 */
			render: function (group) {
				var stackItem = this,									// aliased this
					str = stackItem.options.formatter.call(stackItem);  // format the text in the label

				// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
				if (stackItem.label) {
					stackItem.label.attr({text: str, visibility: HIDDEN});
				// Create new label
				} else {
					stackItem.label =
						chart.renderer.text(str, 0, 0)				// dummy positions, actual position updated with setOffset method in columnseries
							.css(stackItem.options.style)			// apply style
							.attr({align: stackItem.textAlign,			// fix the text-anchor
								rotation: stackItem.options.rotation,	// rotation
								visibility: HIDDEN })					// hidden until setOffset is called
							.add(group);							// add to the labels-group
				}
			},

			/**
			 * Sets the offset that the stack has from the x value and repositions the label.
			 */
			setOffset: function (xOffset, xWidth) {
				var stackItem = this,										// aliased this
					neg = stackItem.isNegative,								// special treatment is needed for negative stacks
					y = axis.translate(stackItem.total, 0, 0, 0, 1),		// stack value translated mapped to chart coordinates
					yZero = axis.translate(0),								// stack origin
					h = mathAbs(y - yZero),									// stack height
					x = chart.xAxis[0].translate(stackItem.x) + xOffset,	// stack x position
					plotHeight = chart.plotHeight,
					stackBox = {	// this is the box for the complete stack
							x: inverted ? (neg ? y : y - h) : x,
							y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
							width: inverted ? h : xWidth,
							height: inverted ? xWidth : h
					};

				if (stackItem.label) {
					stackItem.label
						.align(stackItem.alignOptions, null, stackBox)	// align the label to the box
						.attr({visibility: VISIBLE});					// set visibility
				}
			}
		};

		/**
		 * Get the minimum and maximum for the series of each axis
		 */
		function getSeriesExtremes() {
			var posStack = [],
				negStack = [],
				i;

			// reset dataMin and dataMax in case we're redrawing
			dataMin = dataMax = null;

			// loop through this axis' series
			each(axis.series, function (series) {

				if (series.visible || !optionsChart.ignoreHiddenSeries) {

					var seriesOptions = series.options,
						stacking,
						posPointStack,
						negPointStack,
						stackKey,
						stackOption,
						negKey,
						xData,
						yData,
						x,
						y,
						threshold = seriesOptions.threshold,
						yDataLength,
						activeYData = [],
						activeCounter = 0;
						
					// Validate threshold in logarithmic axes
					if (isLog && threshold <= 0) {
						threshold = seriesOptions.threshold = null;
					}

					// Get dataMin and dataMax for X axes
					if (isXAxis) {
						xData = series.xData;
						if (xData.length) {
							dataMin = mathMin(pick(dataMin, xData[0]), arrayMin(xData));
							dataMax = mathMax(pick(dataMax, xData[0]), arrayMax(xData));
						}

					// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
					} else {
						var isNegative,
							pointStack,
							key,
							cropped = series.cropped,
							xExtremes = series.xAxis.getExtremes(),
							//findPointRange,
							//pointRange,
							j,
							hasModifyValue = !!series.modifyValue;


						// Handle stacking
						stacking = seriesOptions.stacking;
						usePercentage = stacking === 'percent';

						// create a stack for this particular series type
						if (stacking) {
							stackOption = seriesOptions.stack;
							stackKey = series.type + pick(stackOption, '');
							negKey = '-' + stackKey;
							series.stackKey = stackKey; // used in translate

							posPointStack = posStack[stackKey] || []; // contains the total values for each x
							posStack[stackKey] = posPointStack;

							negPointStack = negStack[negKey] || [];
							negStack[negKey] = negPointStack;
						}
						if (usePercentage) {
							dataMin = 0;
							dataMax = 99;
						}


						// processData can alter series.pointRange, so this goes after
						//findPointRange = series.pointRange === null;

						xData = series.processedXData;
						yData = series.processedYData;
						yDataLength = yData.length;

						// loop over the non-null y values and read them into a local array
						for (i = 0; i < yDataLength; i++) {
							x = xData[i];
							y = yData[i];
							if (y !== null && y !== UNDEFINED) {

								// read stacked values into a stack based on the x value,
								// the sign of y and the stack key
								if (stacking) {
									isNegative = y < threshold;
									pointStack = isNegative ? negPointStack : posPointStack;
									key = isNegative ? negKey : stackKey;

									y = pointStack[x] =
										defined(pointStack[x]) ?
										pointStack[x] + y : y;


									// add the series
									if (!stacks[key]) {
										stacks[key] = {};
									}

									// If the StackItem is there, just update the values,
									// if not, create one first
									if (!stacks[key][x]) {
										stacks[key][x] = new StackItem(options.stackLabels, isNegative, x, stackOption);
									}
									stacks[key][x].setTotal(y);


								// general hook, used for Highstock compare values feature
								} else if (hasModifyValue) {
									y = series.modifyValue(y);
								}

								// get the smallest distance between points
								/*if (i) {
									distance = mathAbs(xData[i] - xData[i - 1]);
									pointRange = pointRange === UNDEFINED ? distance : mathMin(distance, pointRange);
								}*/

								// for points within the visible range, including the first point outside the
								// visible range, consider y extremes
								if (cropped || ((xData[i + 1] || x) >= xExtremes.min && (xData[i - 1] || x) <= xExtremes.max)) {

									j = y.length;
									if (j) { // array, like ohlc data
										while (j--) {
											if (y[j] !== null) {
												activeYData[activeCounter++] = y[j];
											}
										}
									} else {
										activeYData[activeCounter++] = y;
									}
								}
							}
						}

						// record the least unit distance
						/*if (findPointRange) {
							series.pointRange = pointRange || 1;
						}
						series.closestPointRange = pointRange;*/

						// Get the dataMin and dataMax so far. If percentage is used, the min and max are
						// always 0 and 100. If the length of activeYData is 0, continue with null values.
						if (!usePercentage && activeYData.length) {
							dataMin = mathMin(pick(dataMin, activeYData[0]), arrayMin(activeYData));
							dataMax = mathMax(pick(dataMax, activeYData[0]), arrayMax(activeYData));
						}

						// Adjust to threshold
						if (defined(threshold)) {
							if (dataMin >= threshold) {
								dataMin = threshold;
								ignoreMinPadding = true;
							} else if (dataMax < threshold) {
								dataMax = threshold;
								ignoreMaxPadding = true;
							}
						}
					}
				}
			});

		}

		/**
		 * Translate from axis value to pixel position on the chart, or back
		 *
		 */
		translate = function (val, backwards, cvsCoord, old, handleLog) {
			
			var sign = 1,
				cvsOffset = 0,
				localA = old ? oldTransA : transA,
				localMin = old ? oldMin : min,
				returnValue,
				postTranslate = options.ordinal || (isLog && handleLog);

			if (!localA) {
				localA = transA;
			}

			if (cvsCoord) {
				sign *= -1; // canvas coordinates inverts the value
				cvsOffset = axisLength;
			}
			if (reversed) { // reversed axis
				sign *= -1;
				cvsOffset -= sign * axisLength;
			}

			if (backwards) { // reverse translation
				if (reversed) {
					val = axisLength - val;
				}
				returnValue = val / localA + localMin; // from chart pixel to value
				if (postTranslate) { // log and ordinal axes
					returnValue = axis.lin2val(returnValue);
				}

			} else { // normal translation, from axis value to pixel, relative to plot
				if (postTranslate) { // log and ordinal axes
					val = axis.val2lin(val);
				}

				returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding);
			}

			return returnValue;
		};

		/**
		 * Create the path for a plot line that goes from the given value on
		 * this axis, across the plot to the opposite side
		 * @param {Number} value
		 * @param {Number} lineWidth Used for calculation crisp line
		 * @param {Number] old Use old coordinates (for resizing and rescaling)
		 */
		getPlotLinePath = function (value, lineWidth, old) {
			var x1,
				y1,
				x2,
				y2,
				translatedValue = translate(value, null, null, old),
				cHeight = (old && oldChartHeight) || chartHeight,
				cWidth = (old && oldChartWidth) || chartWidth,
				skip;

			x1 = x2 = mathRound(translatedValue + transB);
			y1 = y2 = mathRound(cHeight - translatedValue - transB);

			if (isNaN(translatedValue)) { // no min or max
				skip = true;

			} else if (horiz) {
				y1 = axisTop;
				y2 = cHeight - axisBottom;
				if (x1 < axisLeft || x1 > axisLeft + axisWidth) {
					skip = true;
				}
			} else {
				x1 = axisLeft;
				x2 = cWidth - axisRight;

				if (y1 < axisTop || y1 > axisTop + axisHeight) {
					skip = true;
				}
			}
			return skip ?
				null :
				renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);
		};

		/**
		 * Set the tick positions of a linear axis to round values like whole tens or every five.
		 */
		function getLinearTickPositions(tickInterval, min, max) {

			var pos,
				lastPos,
				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
				tickPositions = [];

			// Populate the intermediate values
			pos = roundedMin;
			while (pos <= roundedMax) {

				// Place the tick on the rounded value
				tickPositions.push(pos);

				// Always add the raw tickInterval, not the corrected one.
				pos = correctFloat(pos + tickInterval);

				// If the interval is not big enough in the current min - max range to actually increase
				// the loop variable, we need to break out to prevent endless loop. Issue #619
				if (pos === lastPos) {
					break;
				}

				// Record the last value
				lastPos = pos;
			}
			return tickPositions;
		}
		
		/**
		 * Set the tick positions of a logarithmic axis
		 */
		function getLogTickPositions(interval, min, max, minor) {
			
			// Since we use this method for both major and minor ticks,
			// use a local variable and return the result
			var positions = []; 
			
			// Reset
			if (!minor) {
				axis._minorAutoInterval = null;
			}
			
			// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
			if (interval >= 0.5) {
				interval = mathRound(interval);
				positions = getLinearTickPositions(interval, min, max);
				
			// Second case: We need intermediary ticks. For example 
			// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
			} else if (interval >= 0.08) {
				var roundedMin = mathFloor(min),
					intermediate,
					i,
					j,
					len,
					pos,
					lastPos,
					break2;
					
				if (interval > 0.3) {
					intermediate = [1, 2, 4];
				} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
					intermediate = [1, 2, 4, 6, 8];
				} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
					intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
				}
				
				for (i = roundedMin; i < max + 1 && !break2; i++) {
					len = intermediate.length;
					for (j = 0; j < len && !break2; j++) {
						pos = log2lin(lin2log(i) * intermediate[j]);
						
						if (pos > min) {
							positions.push(lastPos);
						}
						
						if (lastPos > max) {
							break2 = true;
						}
						lastPos = pos;
					}
				}
				
			// Third case: We are so deep in between whole logarithmic values that
			// we might as well handle the tick positions like a linear axis. For
			// example 1.01, 1.02, 1.03, 1.04.
			} else {
				var realMin = lin2log(min),
					realMax = lin2log(max),
					tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
					filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
					tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
					totalPixelLength = minor ? axisLength / tickPositions.length : axisLength;
				
				interval = pick(
					filteredTickIntervalOption,
					axis._minorAutoInterval,
					(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
				);
				
				interval = normalizeTickInterval(
					interval, 
					null, 
					math.pow(10, mathFloor(math.log(interval) / math.LN10))
				);
				
				positions = map(getLinearTickPositions(
					interval, 
					realMin,
					realMax	
				), log2lin);
				
				if (!minor) {
					axis._minorAutoInterval = interval / 5;
				}
			}
			
			// Set the axis-level tickInterval variable 
			if (!minor) {
				tickInterval = interval;
			}
			return positions;
		}
		
		/**
		 * Return the minor tick positions. For logarithmic axes, reuse the same logic
		 * as for major ticks.
		 */
		function getMinorTickPositions() {
			var minorTickPositions = [],
				pos,
				i,
				len;
			
			if (isLog) {
				len = tickPositions.length;
				for (i = 1; i < len; i++) {
					minorTickPositions = minorTickPositions.concat(
						getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
					);	
				}
			
			} else {			
				for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
					minorTickPositions.push(pos);	
				}
			}
			
			return minorTickPositions;
		}

		/**
		 * Adjust the min and max for the minimum range. Keep in mind that the series data is 
		 * not yet processed, so we don't have information on data cropping and grouping, or 
		 * updated axis.pointRange or series.pointRange. The data can't be processed until
		 * we have finally established min and max.
		 */
		function adjustForMinRange() {
			var zoomOffset,
				spaceAvailable = dataMax - dataMin >= minRange,
				closestDataRange,
				i,
				distance,
				xData,
				loopLength,
				minArgs,
				maxArgs;
				
			// Set the automatic minimum range based on the closest point distance
			if (isXAxis && minRange === UNDEFINED && !isLog) {
				
				if (defined(options.min) || defined(options.max)) {
					minRange = null; // don't do this again

				} else {

					// Find the closest distance between raw data points, as opposed to
					// closestPointRange that applies to processed points (cropped and grouped)
					each(axis.series, function (series) {
						xData = series.xData;
						loopLength = series.xIncrement ? 1 : xData.length - 1;
						for (i = loopLength; i > 0; i--) {
							distance = xData[i] - xData[i - 1];
							if (closestDataRange === UNDEFINED || distance < closestDataRange) {
								closestDataRange = distance;
							}
						}
					});
					minRange = mathMin(closestDataRange * 5, dataMax - dataMin);
				}
			}
			
			// if minRange is exceeded, adjust
			if (max - min < minRange) {

				zoomOffset = (minRange - max + min) / 2;

				// if min and max options have been set, don't go beyond it
				minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
				if (spaceAvailable) { // if space is available, stay within the data range
					minArgs[2] = dataMin;
				}
				min = arrayMax(minArgs);

				maxArgs = [min + minRange, pick(options.max, min + minRange)];
				if (spaceAvailable) { // if space is availabe, stay within the data range
					maxArgs[2] = dataMax;
				}
				
				max = arrayMin(maxArgs);

				// now if the max is adjusted, adjust the min back
				if (max - min < minRange) {
					minArgs[0] = max - minRange;
					minArgs[1] = pick(options.min, max - minRange);
					min = arrayMax(minArgs);
				}
			}
		}

		/**
		 * Set the tick positions to round values and optionally extend the extremes
		 * to the nearest tick
		 */
		function setTickPositions(secondPass) {

			var length,
				linkedParentExtremes,
				tickIntervalOption = options.tickInterval,
				tickPixelIntervalOption = options.tickPixelInterval;

			// linked axis gets the extremes from the parent axis
			if (isLinked) {
				linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];
				linkedParentExtremes = linkedParent.getExtremes();
				min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
				max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
				if (options.type !== linkedParent.options.type) {
					error(11, 1); // Can't link axes of different type
				}
			} else { // initial min and max from the extreme data values
				min = pick(userMin, options.min, dataMin);
				max = pick(userMax, options.max, dataMax);
			}

			if (isLog) {
				if (!secondPass && mathMin(min, dataMin) <= 0) {
					error(10, 1); // Can't plot negative values on log axis
				}
				min = log2lin(min);
				max = log2lin(max);
			}

			// handle zoomed range
			if (range) {
				userMin = min = mathMax(min, max - range); // #618
				userMax = max;
				if (secondPass) {
					range = null;  // don't use it when running setExtremes
				}
			}

			// adjust min and max for the minimum range
			adjustForMinRange();

			// pad the values to get clear of the chart's edges
			if (!categories && !usePercentage && !isLinked && defined(min) && defined(max)) {
				length = (max - min) || 1;
				if (!defined(options.min) && !defined(userMin) && minPadding && (dataMin < 0 || !ignoreMinPadding)) {
					min -= length * minPadding;
				}
				if (!defined(options.max) && !defined(userMax)  && maxPadding && (dataMax > 0 || !ignoreMaxPadding)) {
					max += length * maxPadding;
				}
			}

			// get tickInterval
			if (min === max || min === undefined || max === undefined) {
				tickInterval = 1;
			} else if (isLinked && !tickIntervalOption &&
					tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
				tickInterval = linkedParent.tickInterval;
			} else {
				tickInterval = pick(
					tickIntervalOption,
					categories ? // for categoried axis, 1 is default, for linear axis use tickPix
						1 :
						(max - min) * tickPixelIntervalOption / (axisLength || 1)
				);
			}

			// Now we're finished detecting min and max, crop and group series data. This
			// is in turn needed in order to find tick positions in ordinal axes. 
			if (isXAxis && !secondPass) {
				each(axis.series, function (series) {
					series.processData(min !== oldMin || max !== oldMax);             
				});
			}

			// set the translation factor used in translate function
			setAxisTranslation();

			// hook for ordinal axes. To do: merge with below
			if (axis.beforeSetTickPositions) {
				axis.beforeSetTickPositions();
			}
			
			// hook for extensions, used in Highstock ordinal axes
			if (axis.postProcessTickInterval) {
				tickInterval = axis.postProcessTickInterval(tickInterval);				
			}

			// for linear axes, get magnitude and normalize the interval
			if (!isDatetimeAxis && !isLog) { // linear
				magnitude = math.pow(10, mathFloor(math.log(tickInterval) / math.LN10));
				if (!defined(options.tickInterval)) {
					tickInterval = normalizeTickInterval(tickInterval, null, magnitude, options);
				}
			}

			// record the tick interval for linked axis
			axis.tickInterval = tickInterval;

			// get minorTickInterval
			minorTickInterval = options.minorTickInterval === 'auto' && tickInterval ?
					tickInterval / 5 : options.minorTickInterval;

			// find the tick positions
			tickPositions = options.tickPositions || (tickPositioner && tickPositioner.apply(axis, [min, max]));
			if (!tickPositions) {
				if (isDatetimeAxis) {
					tickPositions = (axis.getNonLinearTimeTicks || getTimeTicks)(
						normalizeTimeTickInterval(tickInterval, options.units),
						min,
						max,
						options.startOfWeek,
						axis.ordinalPositions,
						axis.closestPointRange,
						true
					);
				} else if (isLog) {
					tickPositions = getLogTickPositions(tickInterval, min, max);
				} else {
					tickPositions = getLinearTickPositions(tickInterval, min, max);
				}
			}

			if (!isLinked) {

				// reset min/max or remove extremes based on start/end on tick
				var roundedMin = tickPositions[0],
					roundedMax = tickPositions[tickPositions.length - 1];

				if (options.startOnTick) {
					min = roundedMin;
				} else if (min > roundedMin) {
					tickPositions.shift();
				}

				if (options.endOnTick) {
					max = roundedMax;
				} else if (max < roundedMax) {
					tickPositions.pop();
				}

				// record the greatest number of ticks for multi axis
				if (!maxTicks) { // first call, or maxTicks have been reset after a zoom operation
					maxTicks = {
						x: 0,
						y: 0
					};
				}

				if (!isDatetimeAxis && tickPositions.length > maxTicks[xOrY] && options.alignTicks !== false) {
					maxTicks[xOrY] = tickPositions.length;
				}
			}
		}

		/**
		 * When using multiple axes, adjust the number of ticks to match the highest
		 * number of ticks in that group
		 */
		function adjustTickAmount() {

			if (maxTicks && maxTicks[xOrY] && !isDatetimeAxis && !categories && !isLinked && options.alignTicks !== false) { // only apply to linear scale
				var oldTickAmount = tickAmount,
					calculatedTickAmount = tickPositions.length;

				// set the axis-level tickAmount to use below
				tickAmount = maxTicks[xOrY];

				if (calculatedTickAmount < tickAmount) {
					while (tickPositions.length < tickAmount) {
						tickPositions.push(correctFloat(
							tickPositions[tickPositions.length - 1] + tickInterval
						));
					}
					transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
					max = tickPositions[tickPositions.length - 1];

				}
				if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
					axis.isDirty = true;
				}
			}


		}

		/**
		 * Set the scale based on data min and max, user set min and max or options
		 *
		 */
		function setScale() {
			var type,
				i,
				isDirtyData,
				isDirtyAxisLength;
				
			oldMin = min;
			oldMax = max;
			oldAxisLength = axisLength;

			// set the new axisLength
			axisLength = horiz ? axisWidth : axisHeight;
			isDirtyAxisLength = axisLength !== oldAxisLength;

			// is there new data?
			each(axis.series, function (series) {
				if (series.isDirtyData || series.isDirty ||
						series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
					isDirtyData = true;
				}
			});

			// do we really need to go through all this?
			if (isDirtyAxisLength || isDirtyData || isLinked ||
				userMin !== oldUserMin || userMax !== oldUserMax) {

				// get data extremes if needed
				getSeriesExtremes();

				// get fixed positions based on tickInterval
				setTickPositions();

				// record old values to decide whether a rescale is necessary later on (#540)
				oldUserMin = userMin;
				oldUserMax = userMax;

				// reset stacks
				if (!isXAxis) {
					for (type in stacks) {
						for (i in stacks[type]) {
							stacks[type][i].cum = stacks[type][i].total;
						}
					}
				}

				// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
				if (!axis.isDirty) {
					axis.isDirty = isDirtyAxisLength || min !== oldMin || max !== oldMax;
				}
			}
		}

		/**
		 * Set the extremes and optionally redraw
		 * @param {Number} newMin
		 * @param {Number} newMax
		 * @param {Boolean} redraw
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 * @param {Object} eventArguments 
		 *
		 */
		function setExtremes(newMin, newMax, redraw, animation, eventArguments) {

			redraw = pick(redraw, true); // defaults to true
			
			// Extend the arguments with min and max
			eventArguments = extend(eventArguments, {
				min: newMin,
				max: newMax
			});

			// Fire the event
			fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

				userMin = newMin;
				userMax = newMax;
				
				// Mark for running afterSetExtremes
				axis.isDirtyExtremes = true;
				
				// redraw
				if (redraw) {
					chart.redraw(animation);
				}
			});
		}
		
		/**
		 * Update translation information
		 */
		setAxisTranslation = function () {
			var range = max - min,
				pointRange = 0,
				closestPointRange,
				seriesClosestPointRange;
			
			// adjust translation for padding
			if (isXAxis) {
				if (isLinked) {
					pointRange = linkedParent.pointRange;
				} else {
					each(axis.series, function (series) {
						pointRange = mathMax(pointRange, series.pointRange);
						seriesClosestPointRange = series.closestPointRange;
						if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
							closestPointRange = defined(closestPointRange) ?
								mathMin(closestPointRange, seriesClosestPointRange) :
								seriesClosestPointRange;
						}
					});
				}
				
				// pointRange means the width reserved for each point, like in a column chart
				axis.pointRange = pointRange;

				// closestPointRange means the closest distance between points. In columns
				// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
				// is some other value
				axis.closestPointRange = closestPointRange;
			}

			// secondary values
			oldTransA = transA;
			axis.translationSlope = transA = axisLength / ((range + pointRange) || 1);
			transB = horiz ? axisLeft : axisBottom; // translation addend
			minPixelPadding = transA * (pointRange / 2);
		};

		/**
		 * Update the axis metrics
		 */
		function setAxisSize() {

			var offsetLeft = options.offsetLeft || 0,
				offsetRight = options.offsetRight || 0;

			// basic values
			axisLeft = pick(options.left, plotLeft + offsetLeft);
			axisTop = pick(options.top, plotTop);
			axisWidth = pick(options.width, plotWidth - offsetLeft + offsetRight);
			axisHeight = pick(options.height, plotHeight);
			axisBottom = chartHeight - axisHeight - axisTop;
			axisRight = chartWidth - axisWidth - axisLeft;
			axisLength = horiz ? axisWidth : axisHeight;

			// expose to use in Series object and navigator
			axis.left = axisLeft;
			axis.top = axisTop;
			axis.len = axisLength;

		}

		/**
		 * Get the actual axis extremes
		 */
		function getExtremes() {
			return {
				min: isLog ? correctFloat(lin2log(min)) : min,
				max: isLog ? correctFloat(lin2log(max)) : max,
				dataMin: dataMin,
				dataMax: dataMax,
				userMin: userMin,
				userMax: userMax
			};
		}

		/**
		 * Get the zero plane either based on zero or on the min or max value.
		 * Used in bar and area plots
		 */
		function getThreshold(threshold) {
			var realMin = isLog ? lin2log(min) : min,
				realMax = isLog ? lin2log(max) : max;
			
			if (realMin > threshold || threshold === null) {
				threshold = realMin;
			} else if (realMax < threshold) {
				threshold = realMax;
			}

			return translate(threshold, 0, 1, 0, 1);
		}

		/**
		 * Add a plot band or plot line after render time
		 *
		 * @param options {Object} The plotBand or plotLine configuration object
		 */
		function addPlotBandOrLine(options) {
			var obj = new PlotLineOrBand(options).render();
			plotLinesAndBands.push(obj);
			return obj;
		}

		/**
		 * Render the tick labels to a preliminary position to get their sizes
		 */
		function getOffset() {

			var hasData = axis.series.length && defined(min) && defined(max),
				showAxis = hasData || pick(options.showEmpty, true),
				titleOffset = 0,
				titleOffsetOption,
				titleMargin = 0,
				axisTitleOptions = options.title,
				labelOptions = options.labels,
				directionFactor = [-1, 1, 1, -1][side],
				n;

			if (!axisGroup) {
				axisGroup = renderer.g('axis')
					.attr({ zIndex: 7 })
					.add();
				gridGroup = renderer.g('grid')
					.attr({ zIndex: options.gridZIndex || 1 })
					.add();
			}

			labelOffset = 0; // reset

			if (hasData || isLinked) {
				each(tickPositions, function (pos) {
					if (!ticks[pos]) {
						ticks[pos] = new Tick(pos);
					} else {
						ticks[pos].addLabel(); // update labels depending on tick interval
					}

				});

				each(tickPositions, function (pos) {
					// left side must be align: right and right side must have align: left for labels
					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === labelOptions.align) {

						// get the highest offset
						labelOffset = mathMax(
							ticks[pos].getLabelSize(),
							labelOffset
						);
					}

				});

				if (staggerLines) {
					labelOffset += (staggerLines - 1) * 16;
				}

			} else { // doesn't have data
				for (n in ticks) {
					ticks[n].destroy();
					delete ticks[n];
				}
			}

			if (axisTitleOptions && axisTitleOptions.text) {
				if (!axisTitle) {
					axisTitle = axis.axisTitle = renderer.text(
						axisTitleOptions.text,
						0,
						0,
						axisTitleOptions.useHTML
					)
					.attr({
						zIndex: 7,
						rotation: axisTitleOptions.rotation || 0,
						align:
							axisTitleOptions.textAlign ||
							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
					})
					.css(axisTitleOptions.style)
					.add();
					axisTitle.isNew = true;
				}

				if (showAxis) {
					titleOffset = axisTitle.getBBox()[horiz ? 'height' : 'width'];
					titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);
					titleOffsetOption = axisTitleOptions.offset;
				}

				// hide or show the title depending on whether showEmpty is set
				axisTitle[showAxis ? 'show' : 'hide']();


			}

			// handle automatic or user set offset
			offset = directionFactor * pick(options.offset, axisOffset[side]);

			axisTitleMargin =
				pick(titleOffsetOption,
					labelOffset + titleMargin +
					(side !== 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x'])
				);

			axisOffset[side] = mathMax(
				axisOffset[side],
				axisTitleMargin + titleOffset + directionFactor * offset
			);

		}

		/**
		 * Render the axis
		 */
		function render() {
			var axisTitleOptions = options.title,
				stackLabelOptions = options.stackLabels,
				alternateGridColor = options.alternateGridColor,
				lineWidth = options.lineWidth,
				lineLeft,
				lineTop,
				linePath,
				hasRendered = chart.hasRendered,
				slideInTicks = hasRendered && defined(oldMin) && !isNaN(oldMin),
				hasData = axis.series.length && defined(min) && defined(max),
				showAxis = hasData || pick(options.showEmpty, true),
				from,
				to;

			// If the series has data draw the ticks. Else only the line and title
			if (hasData || isLinked) {

				// minor ticks
				if (minorTickInterval && !categories) {
					each(getMinorTickPositions(), function (pos) {
						if (!minorTicks[pos]) {
							minorTicks[pos] = new Tick(pos, 'minor');
						}

						// render new ticks in old position
						if (slideInTicks && minorTicks[pos].isNew) {
							minorTicks[pos].render(null, true);
						}


						minorTicks[pos].isActive = true;
						minorTicks[pos].render();
					});
				}

				// Major ticks. Pull out the first item and render it last so that
				// we can get the position of the neighbour label. #808.
				each(tickPositions.slice(1).concat([tickPositions[0]]), function (pos, i) {
					
					// Reorganize the indices
					i = (i === tickPositions.length - 1) ? 0 : i + 1;
					
					// linked axes need an extra check to find out if
					if (!isLinked || (pos >= min && pos <= max)) {

						if (!ticks[pos]) {
							ticks[pos] = new Tick(pos);
						}

						// render new ticks in old position
						if (slideInTicks && ticks[pos].isNew) {
							ticks[pos].render(i, true);
						}

						ticks[pos].isActive = true;
						ticks[pos].render(i);
					}

				});

				// alternate grid color
				if (alternateGridColor) {
					each(tickPositions, function (pos, i) {
						if (i % 2 === 0 && pos < max) {
							if (!alternateBands[pos]) {
								alternateBands[pos] = new PlotLineOrBand();
							}
							from = pos;
							to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max;
							alternateBands[pos].options = {
								from: isLog ? lin2log(from) : from,
								to: isLog ? lin2log(to) : to,
								color: alternateGridColor
							};
							alternateBands[pos].render();
							alternateBands[pos].isActive = true;
						}
					});
				}

				// custom plot lines and bands
				if (!axis._addedPlotLB) { // only first time
					each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
						//plotLinesAndBands.push(new PlotLineOrBand(plotLineOptions).render());
						addPlotBandOrLine(plotLineOptions);
					});
					axis._addedPlotLB = true;
				}



			} // end if hasData

			// remove inactive ticks
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos;
				for (pos in coll) {
					if (!coll[pos].isActive) {
						coll[pos].destroy();
						delete coll[pos];
					} else {
						coll[pos].isActive = false; // reset
					}
				}
			});




			// Static items. As the axis group is cleared on subsequent calls
			// to render, these items are added outside the group.
			// axis line
			if (lineWidth) {
				lineLeft = axisLeft + (opposite ? axisWidth : 0) + offset;
				lineTop = chartHeight - axisBottom - (opposite ? axisHeight : 0) + offset;

				linePath = renderer.crispLine([
						M,
						horiz ?
							axisLeft :
							lineLeft,
						horiz ?
							lineTop :
							axisTop,
						L,
						horiz ?
							chartWidth - axisRight :
							lineLeft,
						horiz ?
							lineTop :
							chartHeight - axisBottom
					], lineWidth);
				if (!axisLine) {
					axisLine = renderer.path(linePath)
						.attr({
							stroke: options.lineColor,
							'stroke-width': lineWidth,
							zIndex: 7
						})
						.add();
				} else {
					axisLine.animate({ d: linePath });
				}

				// show or hide the line depending on options.showEmpty
				axisLine[showAxis ? 'show' : 'hide']();

			}

			if (axisTitle && showAxis) {
				// compute anchor points for each of the title align options
				var margin = horiz ? axisLeft : axisTop,
					fontSize = pInt(axisTitleOptions.style.fontSize || 12),
				// the position in the length direction of the axis
				alongAxis = {
					low: margin + (horiz ? 0 : axisLength),
					middle: margin + axisLength / 2,
					high: margin + (horiz ? axisLength : 0)
				}[axisTitleOptions.align],

				// the position in the perpendicular direction of the axis
				offAxis = (horiz ? axisTop + axisHeight : axisLeft) +
					(horiz ? 1 : -1) * // horizontal axis reverses the margin
					(opposite ? -1 : 1) * // so does opposite axes
					axisTitleMargin +
					(side === 2 ? fontSize : 0);

				axisTitle[axisTitle.isNew ? 'attr' : 'animate']({
					x: horiz ?
						alongAxis :
						offAxis + (opposite ? axisWidth : 0) + offset +
							(axisTitleOptions.x || 0), // x
					y: horiz ?
						offAxis - (opposite ? axisHeight : 0) + offset :
						alongAxis + (axisTitleOptions.y || 0) // y
				});
				axisTitle.isNew = false;
			}

			// Stacked totals:
			if (stackLabelOptions && stackLabelOptions.enabled) {
				var stackKey, oneStack, stackCategory,
					stackTotalGroup = axis.stackTotalGroup;

				// Create a separate group for the stack total labels
				if (!stackTotalGroup) {
					axis.stackTotalGroup = stackTotalGroup =
						renderer.g('stack-labels')
							.attr({
								visibility: VISIBLE,
								zIndex: 6
							})
							.translate(plotLeft, plotTop)
							.add();
				}

				// Render each stack total
				for (stackKey in stacks) {
					oneStack = stacks[stackKey];
					for (stackCategory in oneStack) {
						oneStack[stackCategory].render(stackTotalGroup);
					}
				}
			}
			// End stacked totals

			axis.isDirty = false;
		}

		/**
		 * Remove a plot band or plot line from the chart by id
		 * @param {Object} id
		 */
		function removePlotBandOrLine(id) {
			var i = plotLinesAndBands.length;
			while (i--) {
				if (plotLinesAndBands[i].id === id) {
					plotLinesAndBands[i].destroy();
				}
			}
		}
		
		/**
		 * Update the axis title by options
		 */
		function setTitle(newTitleOptions, redraw) {
			options.title = merge(options.title, newTitleOptions);
			
			axisTitle = axisTitle.destroy();
			axis.isDirty = true;
			
			if (pick(redraw, true)) {
				chart.redraw();
			}
		}

		/**
		 * Redraw the axis to reflect changes in the data or axis extremes
		 */
		function redraw() {

			// hide tooltip and hover states
			if (tracker.resetTracker) {
				tracker.resetTracker();
			}

			// render the axis
			render();

			// move plot lines and bands
			each(plotLinesAndBands, function (plotLine) {
				plotLine.render();
			});

			// mark associated series as dirty and ready for redraw
			each(axis.series, function (series) {
				series.isDirty = true;
			});

		}

		/**
		 * Set new axis categories and optionally redraw
		 * @param {Array} newCategories
		 * @param {Boolean} doRedraw
		 */
		function setCategories(newCategories, doRedraw) {
				// set the categories
				axis.categories = userOptions.categories = categories = newCategories;

				// force reindexing tooltips
				each(axis.series, function (series) {
					series.translate();
					series.setTooltipPoints(true);
				});


				// optionally redraw
				axis.isDirty = true;

				if (pick(doRedraw, true)) {
					chart.redraw();
				}
		}

		/**
		 * Destroys an Axis instance.
		 */
		function destroy() {
			var stackKey;

			// Remove the events
			removeEvent(axis);

			// Destroy each stack total
			for (stackKey in stacks) {
				destroyObjectProperties(stacks[stackKey]);

				stacks[stackKey] = null;
			}

			// Destroy stack total group
			if (axis.stackTotalGroup) {
				axis.stackTotalGroup = axis.stackTotalGroup.destroy();
			}

			// Destroy collections
			each([ticks, minorTicks, alternateBands, plotLinesAndBands], function (coll) {
				destroyObjectProperties(coll);
			});

			// Destroy local variables
			each([axisLine, axisGroup, gridGroup, axisTitle], function (obj) {
				if (obj) {
					obj.destroy();
				}
			});
			axisLine = axisGroup = gridGroup = axisTitle = null;
		}


		// Run Axis

		// Register
		axes.push(axis);
		chart[isXAxis ? 'xAxis' : 'yAxis'].push(axis);

		// inverted charts have reversed xAxes as default
		if (inverted && isXAxis && reversed === UNDEFINED) {
			reversed = true;
		}


		// expose some variables
		extend(axis, {
			addPlotBand: addPlotBandOrLine,
			addPlotLine: addPlotBandOrLine,
			adjustTickAmount: adjustTickAmount,
			categories: categories,
			getExtremes: getExtremes,
			getPlotLinePath: getPlotLinePath,
			getThreshold: getThreshold,
			isXAxis: isXAxis,
			options: options,
			plotLinesAndBands: plotLinesAndBands,
			getOffset: getOffset,
			render: render,
			setAxisSize: setAxisSize,
			setAxisTranslation: setAxisTranslation,
			setCategories: setCategories,
			setExtremes: setExtremes,
			setScale: setScale,
			setTickPositions: setTickPositions,
			translate: translate,
			redraw: redraw,
			removePlotBand: removePlotBandOrLine,
			removePlotLine: removePlotBandOrLine,
			reversed: reversed,
			setTitle: setTitle,
			series: [], // populated by Series
			stacks: stacks,
			destroy: destroy
		});

		// register event listeners
		for (eventType in events) {
			addEvent(axis, eventType, events[eventType]);
		}

		// extend logarithmic axis
		if (isLog) {
			axis.val2lin = log2lin;
			axis.lin2val = lin2log;
		}

	} // end Axis


	/**
	 * The tooltip object
	 * @param {Object} options Tooltip options
	 */
	function Tooltip(options) {
		var currentSeries,
			borderWidth = options.borderWidth,
			crosshairsOptions = options.crosshairs,
			crosshairs = [],
			style = options.style,
			shared = options.shared,
			padding = pInt(style.padding),
			tooltipIsHidden = true,
			currentX = 0,
			currentY = 0;

		// remove padding CSS and apply padding on box instead
		style.padding = 0;

		// create the label
		var label = renderer.label('', 0, 0, null, null, null, options.useHTML)
			.attr({
				padding: padding,
				fill: options.backgroundColor,
				'stroke-width': borderWidth,
				r: options.borderRadius,
				zIndex: 8
			})
			.css(style)
			.hide()
			.add();

		// When using canVG the shadow shows up as a gray circle
		// even if the tooltip is hidden.
		if (!useCanVG) {
			label.shadow(options.shadow);
		}

		/**
		 * Destroy the tooltip and its elements.
		 */
		function destroy() {
			each(crosshairs, function (crosshair) {
				if (crosshair) {
					crosshair.destroy();
				}
			});

			// Destroy and clear local variables
			if (label) {
				label = label.destroy();
			}
		}

		/**
		 * In case no user defined formatter is given, this will be used
		 */
		function defaultFormatter() {
			var pThis = this,
				items = pThis.points || splat(pThis),
				series = items[0].series,
				s;

			// build the header
			s = [series.tooltipHeaderFormatter(items[0].key)];

			// build the values
			each(items, function (item) {
				series = item.series;
				s.push((series.tooltipFormatter && series.tooltipFormatter(item)) ||
					item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
			});
			
			// footer
			s.push(options.footerFormat || '');
			
			return s.join('');
		}

		/**
		 * Provide a soft movement for the tooltip
		 *
		 * @param {Number} finalX
		 * @param {Number} finalY
		 */
		function move(finalX, finalY) {

			// get intermediate values for animation
			currentX = tooltipIsHidden ? finalX : (2 * currentX + finalX) / 3;
			currentY = tooltipIsHidden ? finalY : (currentY + finalY) / 2;
			
			// [CUSTOMIZED] forbiden annimation in IE8 or earlier.
			if (ieVersion <= 8) {
				label.attr({ x: finalX, y: currentY });
				return;
			}

			// move to the intermediate value
			label.attr({ x: currentX, y: currentY });

			// run on next tick of the mouse tracker
			if (mathAbs(finalX - currentX) > 1 || mathAbs(finalY - currentY) > 1) {
				tooltipTick = function () {
					move(finalX, finalY);
				};
			} else {
				tooltipTick = null;
			}
		}

		/**
		 * Hide the tooltip
		 */
		function hide() {
			if (!tooltipIsHidden) {
				var hoverPoints = chart.hoverPoints;

				label.hide();

				// hide previous hoverPoints and set new
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}
				chart.hoverPoints = null;


				tooltipIsHidden = true;
			}

		}

		/**
		 * Hide the crosshairs
		 */
		function hideCrosshairs() {
			each(crosshairs, function (crosshair) {
				if (crosshair) {
					crosshair.hide();
				}
			});
		}

		/**
		 * Refresh the tooltip's text and position.
		 * @param {Object} point
		 *
		 */
		function refresh(point) {
			var x,
				y,
				show,
				plotX,
				plotY,
				textConfig = {},
				text,
				pointConfig = [],
				tooltipPos = point.tooltipPos,
				formatter = options.formatter || defaultFormatter,
				hoverPoints = chart.hoverPoints,
				placedTooltipPoint,
				borderColor;

			// shared tooltip, array is sent over
			if (shared && !(point.series && point.series.noSharedTooltip)) {
				plotY = 0;

				// hide previous hoverPoints and set new
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}
				chart.hoverPoints = point;

				each(point, function (item) {
					item.setState(HOVER_STATE);
					plotY += item.plotY; // for average

					pointConfig.push(item.getLabelConfig());
				});

				plotX = point[0].plotX;
				plotY = mathRound(plotY) / point.length; // mathRound because Opera 10 has problems here

				textConfig = {
					x: point[0].category
				};
				textConfig.points = pointConfig;
				point = point[0];

			// single point tooltip
			} else {
				textConfig = point.getLabelConfig();
			}
			text = formatter.call(textConfig);

			// register the current series
			currentSeries = point.series;

			// get the reference point coordinates (pie charts use tooltipPos)
			plotX = pick(plotX, point.plotX);
			plotY = pick(plotY, point.plotY);

			x = mathRound(tooltipPos ? tooltipPos[0] : (inverted ? plotWidth - plotY : plotX));
			y = mathRound(tooltipPos ? tooltipPos[1] : (inverted ? plotHeight - plotX : plotY));


			// For line type series, hide tooltip if the point falls outside the plot
			show = shared || !currentSeries.isCartesian || currentSeries.tooltipOutsidePlot || isInsidePlot(x, y);

			// update the inner HTML
			if (text === false || !show) {
				hide();
			} else {

				// show it
				if (tooltipIsHidden) {
					label.show();
					tooltipIsHidden = false;
				}

				// update text
				label.attr({
					text: text
				});

				// set the stroke color of the box
				borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
				label.attr({
					stroke: borderColor
				});

				placedTooltipPoint = placeBox(
					label.width,
					label.height,
					plotLeft,
					plotTop,
					plotWidth,
					plotHeight,
					{x: x, y: y},
					pick(options.distance, 12),
					inverted
				);

				// do the move
				move(mathRound(placedTooltipPoint.x), mathRound(placedTooltipPoint.y));
			}


			// crosshairs
			if (crosshairsOptions) {
				crosshairsOptions = splat(crosshairsOptions); // [x, y]

				var path,
					i = crosshairsOptions.length,
					attribs,
					axis;

				while (i--) {
					axis = point.series[i ? 'yAxis' : 'xAxis'];
					if (crosshairsOptions[i] && axis) {
						path = axis.getPlotLinePath(
							i ? pick(point.stackY, point.y) : point.x, // #814 
							1
						);
						if (crosshairs[i]) {
							crosshairs[i].attr({ d: path, visibility: VISIBLE });

						} else {
							attribs = {
								'stroke-width': crosshairsOptions[i].width || 1,
								stroke: crosshairsOptions[i].color || '#C0C0C0',
								zIndex: crosshairsOptions[i].zIndex || 2
							};
							if (crosshairsOptions[i].dashStyle) {
								attribs.dashstyle = crosshairsOptions[i].dashStyle;
							}
							crosshairs[i] = renderer.path(path)
								.attr(attribs)
								.add();
						}
					}
				}
			}
			fireEvent(chart, 'tooltipRefresh', {
					text: text,
					x: x + plotLeft,
					y: y + plotTop,
					borderColor: borderColor
				});
		}



		// public members
		return {
			shared: shared,
			refresh: refresh,
			hide: hide,
			hideCrosshairs: hideCrosshairs,
			destroy: destroy
		};
	}

	/**
	 * The mouse tracker object
	 * @param {Object} options
	 */
	function MouseTracker(options) {


		var mouseDownX,
			mouseDownY,
			hasDragged,
			selectionMarker,
			zoomType = useCanVG ? '' : optionsChart.zoomType,
			zoomX = /x/.test(zoomType),
			zoomY = /y/.test(zoomType),
			zoomHor = (zoomX && !inverted) || (zoomY && inverted),
			zoomVert = (zoomY && !inverted) || (zoomX && inverted);

		/**
		 * Add crossbrowser support for chartX and chartY
		 * @param {Object} e The event object in standard browsers
		 */
		function normalizeMouseEvent(e) {
			var ePos,
				chartPosLeft,
				chartPosTop,
				chartX,
				chartY;

			// common IE normalizing
			e = e || win.event;
			if (!e.target) {
				e.target = e.srcElement;
			}

			// jQuery only copies over some properties. IE needs e.x and iOS needs touches.
			if (e.originalEvent) {
				e = e.originalEvent;
			}

			// The same for MooTools. It renames e.pageX to e.page.x. #445.
			if (e.event) {
				e = e.event;
			}

			// iOS
			ePos = e.touches ? e.touches.item(0) : e;

			// get mouse position
			chartPosition = offset(container);
			chartPosLeft = chartPosition.left;
			chartPosTop = chartPosition.top;

			// chartX and chartY
			if (isIE) { // IE including IE9 that has pageX but in a different meaning
				chartX = e.x;
				chartY = e.y;
			} else {
				chartX = ePos.pageX - chartPosLeft;
				chartY = ePos.pageY - chartPosTop;
			}

			return extend(e, {
				chartX: mathRound(chartX),
				chartY: mathRound(chartY)
			});
		}

		/**
		 * Get the click position in terms of axis values.
		 *
		 * @param {Object} e A mouse event
		 */
		function getMouseCoordinates(e) {
			var coordinates = {
				xAxis: [],
				yAxis: []
			};
			each(axes, function (axis) {
				var translate = axis.translate,
					isXAxis = axis.isXAxis,
					isHorizontal = inverted ? !isXAxis : isXAxis;

				coordinates[isXAxis ? 'xAxis' : 'yAxis'].push({
					axis: axis,
					value: translate(
						isHorizontal ?
							e.chartX - plotLeft  :
							plotHeight - e.chartY + plotTop,
						true
					)
				});
			});
			return coordinates;
		}

		/**
		 * With line type charts with a single tracker, get the point closest to the mouse
		 */
		function onmousemove(e) {
			var point,
				points,
				hoverPoint = chart.hoverPoint,
				hoverSeries = chart.hoverSeries,
				i,
				j,
				distance = chartWidth,
				index = inverted ? e.chartY : e.chartX - plotLeft; // wtf?

			// shared tooltip
			if (tooltip && options.shared && !(hoverSeries && hoverSeries.noSharedTooltip)) {
				points = [];

				// loop over all series and find the ones with points closest to the mouse
				i = series.length;
				for (j = 0; j < i; j++) {
					if (series[j].visible &&
							series[j].options.enableMouseTracking !== false &&
							!series[j].noSharedTooltip && series[j].tooltipPoints.length) {
						point = series[j].tooltipPoints[index];
						point._dist = mathAbs(index - point.plotX);
						distance = mathMin(distance, point._dist);
						points.push(point);
					}
				}
				// remove furthest points
				i = points.length;
				while (i--) {
					if (points[i]._dist > distance) {
						points.splice(i, 1);
					}
				}
				// refresh the tooltip if necessary
				if (points.length && (points[0].plotX !== hoverX)) {
					tooltip.refresh(points);
					hoverX = points[0].plotX;
				}
			}

			// separate tooltip and general mouse events
			if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker

				// get the point
				point = hoverSeries.tooltipPoints[index];

				// a new point is hovered, refresh the tooltip
				if (point && point !== hoverPoint) {

					// trigger the events
					point.onMouseOver();

				}
			}
		}



		/**
		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
		 */
		function resetTracker() {
			var hoverSeries = chart.hoverSeries,
				hoverPoint = chart.hoverPoint;

			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			if (hoverSeries) {
				hoverSeries.onMouseOut();
			}

			if (tooltip) {
				tooltip.hide();
				tooltip.hideCrosshairs();
			}

			hoverX = null;
		}

		/**
		 * Mouse up or outside the plot area
		 */
		function drop() {
			if (selectionMarker) {
				var selectionData = {
						xAxis: [],
						yAxis: []
					},
					selectionBox = selectionMarker.getBBox(),
					selectionLeft = selectionBox.x - plotLeft,
					selectionTop = selectionBox.y - plotTop;


				// a selection has been made
				if (hasDragged) {

					// record each axis' min and max
					each(axes, function (axis) {
						if (axis.options.zoomEnabled !== false) {
							var translate = axis.translate,
								isXAxis = axis.isXAxis,
								isHorizontal = inverted ? !isXAxis : isXAxis,
								selectionMin = translate(
									isHorizontal ?
										selectionLeft :
										plotHeight - selectionTop - selectionBox.height,
									true,
									0,
									0,
									1
								),
								selectionMax = translate(
									isHorizontal ?
										selectionLeft + selectionBox.width :
										plotHeight - selectionTop,
									true,
									0,
									0,
									1
								);

								selectionData[isXAxis ? 'xAxis' : 'yAxis'].push({
									axis: axis,
									min: mathMin(selectionMin, selectionMax), // for reversed axes,
									max: mathMax(selectionMin, selectionMax)
								});
						}
					});
					fireEvent(chart, 'selection', selectionData, zoom);

				}
				selectionMarker = selectionMarker.destroy();
			}

			css(container, { cursor: 'auto' });

			chart.mouseIsDown = mouseIsDown = hasDragged = false;
			removeEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);

		}

		/**
		 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
		 */
		function hideTooltipOnMouseMove(e) {
			var pageX = defined(e.pageX) ? e.pageX : e.page.x, // In mootools the event is wrapped and the page x/y position is named e.page.x
				pageY = defined(e.pageX) ? e.pageY : e.page.y; // Ref: http://mootools.net/docs/core/Types/DOMEvent

			if (chartPosition &&
					!isInsidePlot(pageX - chartPosition.left - plotLeft,
						pageY - chartPosition.top - plotTop)) {
				resetTracker();
			}
		}

		/**
		 * When mouse leaves the container, hide the tooltip.
		 */
		function hideTooltipOnMouseLeave() {
			resetTracker();
			chartPosition = null; // also reset the chart position, used in #149 fix
		}

		/**
		 * Set the JS events on the container element
		 */
		function setDOMEvents() {
			var lastWasOutsidePlot = true;
			/*
			 * Record the starting position of a dragoperation
			 */
			container.onmousedown = function (e) {
				e = normalizeMouseEvent(e);

				// issue #295, dragging not always working in Firefox
				if (!hasTouch && e.preventDefault) {
					e.preventDefault();
				}

				// record the start position
				chart.mouseIsDown = mouseIsDown = true;
				chart.mouseDownX = mouseDownX = e.chartX;
				mouseDownY = e.chartY;

				addEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
			};

			// The mousemove, touchmove and touchstart event handler
			var mouseMove = function (e) {

				// let the system handle multitouch operations like two finger scroll
				// and pinching
				if (e && e.touches && e.touches.length > 1) {
					return;
				}

				// normalize
				e = normalizeMouseEvent(e);
				if (!hasTouch) { // not for touch devices
					e.returnValue = false;
				}

				var chartX = e.chartX,
					chartY = e.chartY,
					isOutsidePlot = !isInsidePlot(chartX - plotLeft, chartY - plotTop);

				// on touch devices, only trigger click if a handler is defined
				if (hasTouch && e.type === 'touchstart') {
					if (attr(e.target, 'isTracker')) {
						if (!chart.runTrackerClick) {
							e.preventDefault();
						}
					} else if (!runChartClick && !isOutsidePlot) {
						e.preventDefault();
					}
				}

				// cancel on mouse outside
				if (isOutsidePlot) {

					/*if (!lastWasOutsidePlot) {
						// reset the tracker
						resetTracker();
					}*/

					// drop the selection if any and reset mouseIsDown and hasDragged
					//drop();
					if (chartX < plotLeft) {
						chartX = plotLeft;
					} else if (chartX > plotLeft + plotWidth) {
						chartX = plotLeft + plotWidth;
					}

					if (chartY < plotTop) {
						chartY = plotTop;
					} else if (chartY > plotTop + plotHeight) {
						chartY = plotTop + plotHeight;
					}

				}

				if (mouseIsDown && e.type !== 'touchstart') { // make selection

					// determine if the mouse has moved more than 10px
					hasDragged = Math.sqrt(
						Math.pow(mouseDownX - chartX, 2) +
						Math.pow(mouseDownY - chartY, 2)
					);
					if (hasDragged > 10) {
						var clickedInside = isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

						// make a selection
						if (hasCartesianSeries && (zoomX || zoomY) && clickedInside) {
							if (!selectionMarker) {
								selectionMarker = renderer.rect(
									plotLeft,
									plotTop,
									zoomHor ? 1 : plotWidth,
									zoomVert ? 1 : plotHeight,
									0
								)
								.attr({
									fill: optionsChart.selectionMarkerFill || 'rgba(69,114,167,0.25)',
									zIndex: 7
								})
								.add();
							}
						}

						// adjust the width of the selection marker
						if (selectionMarker && zoomHor) {
							var xSize = chartX - mouseDownX;
							selectionMarker.attr({
								width: mathAbs(xSize),
								x: (xSize > 0 ? 0 : xSize) + mouseDownX
							});
						}
						// adjust the height of the selection marker
						if (selectionMarker && zoomVert) {
							var ySize = chartY - mouseDownY;
							selectionMarker.attr({
								height: mathAbs(ySize),
								y: (ySize > 0 ? 0 : ySize) + mouseDownY
							});
						}

						// panning
						if (clickedInside && !selectionMarker && optionsChart.panning) {
							chart.pan(chartX);
						}
					}

				} else if (!isOutsidePlot) {
					// show the tooltip
					onmousemove(e);
				}

				lastWasOutsidePlot = isOutsidePlot;

				// when outside plot, allow touch-drag by returning true
				return isOutsidePlot || !hasCartesianSeries;
			};

			/*
			 * When the mouse enters the container, run mouseMove
			 */
			container.onmousemove = mouseMove;

			/*
			 * When the mouse leaves the container, hide the tracking (tooltip).
			 */
			addEvent(container, 'mouseleave', hideTooltipOnMouseLeave);

			// issue #149 workaround
			// The mouseleave event above does not always fire. Whenever the mouse is moving
			// outside the plotarea, hide the tooltip
			addEvent(doc, 'mousemove', hideTooltipOnMouseMove);

			container.ontouchstart = function (e) {
				// For touch devices, use touchmove to zoom
				if (zoomX || zoomY) {
					container.onmousedown(e);
				}
				// Show tooltip and prevent the lower mouse pseudo event
				mouseMove(e);
			};

			/*
			 * Allow dragging the finger over the chart to read the values on touch
			 * devices
			 */
			container.ontouchmove = mouseMove;

			/*
			 * Allow dragging the finger over the chart to read the values on touch
			 * devices
			 */
			container.ontouchend = function () {
				if (hasDragged) {
					resetTracker();
				}
			};


			// MooTools 1.2.3 doesn't fire this in IE when using addEvent
			container.onclick = function (e) {
				var hoverPoint = chart.hoverPoint;
				e = normalizeMouseEvent(e);

				e.cancelBubble = true; // IE specific


				if (!hasDragged) {
					
					// Detect clicks on trackers or tracker groups, #783 
					if (hoverPoint && (attr(e.target, 'isTracker') || attr(e.target.parentNode, 'isTracker'))) {
						var plotX = hoverPoint.plotX,
							plotY = hoverPoint.plotY;

						// add page position info
						extend(hoverPoint, {
							pageX: chartPosition.left + plotLeft +
								(inverted ? plotWidth - plotY : plotX),
							pageY: chartPosition.top + plotTop +
								(inverted ? plotHeight - plotX : plotY)
						});

						// the series click event
						fireEvent(hoverPoint.series, 'click', extend(e, {
							point: hoverPoint
						}));

						// the point click event
						hoverPoint.firePointEvent('click', e);

					} else {
						extend(e, getMouseCoordinates(e));

						// fire a click event in the chart
						if (isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
							fireEvent(chart, 'click', e);
						}
					}


				}
				// reset mouseIsDown and hasDragged
				hasDragged = false;
			};

		}

		/**
		 * Destroys the MouseTracker object and disconnects DOM events.
		 */
		function destroy() {
			// Destroy the tracker group element
			if (chart.trackerGroup) {
				chart.trackerGroup = trackerGroup = chart.trackerGroup.destroy();
			}

			removeEvent(container, 'mouseleave', hideTooltipOnMouseLeave);
			removeEvent(doc, 'mousemove', hideTooltipOnMouseMove);
			container.onclick = container.onmousedown = container.onmousemove = container.ontouchstart = container.ontouchend = container.ontouchmove = null;
		}

		
		// Run MouseTracker
		
		if (!trackerGroup) {
			chart.trackerGroup = trackerGroup = renderer.g('tracker')
				.attr({ zIndex: 9 })
				.add();
		}
		
		if (options.enabled) {
			chart.tooltip = tooltip = Tooltip(options);

			// set the fixed interval ticking for the smooth tooltip
			tooltipInterval = setInterval(function () {
				if (tooltipTick) {
					tooltipTick();
				}
			}, 32);
		}

		setDOMEvents();

		// expose properties
		extend(this, {
			zoomX: zoomX,
			zoomY: zoomY,
			resetTracker: resetTracker,
			normalizeMouseEvent: normalizeMouseEvent,
			destroy: destroy
		});
	}



	/**
	 * The overview of the chart's series
	 */
	var Legend = function () {

		var options = chart.options.legend;

		if (!options.enabled) {
			return;
		}

		var horizontal = options.layout === 'horizontal',
			symbolWidth = options.symbolWidth,
			symbolPadding = options.symbolPadding,
			allItems,
			style = options.style,
			itemStyle = options.itemStyle,
			itemHoverStyle = options.itemHoverStyle,
			itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle),
			padding = options.padding || pInt(style.padding),
			ltr = !options.rtl,
			itemMarginTop = options.itemMarginTop || 0,
			itemMarginBottom = options.itemMarginBottom || 0,
			y = 18,
			maxItemWidth = 0,
			initialItemX = 4 + padding + symbolWidth + symbolPadding,
			initialItemY = padding + itemMarginTop + y - 5, // 5 is the number of pixels above the text
			itemX,
			itemY,
			lastItemY,
			itemHeight = 0,
			box,
			legendBorderWidth = options.borderWidth,
			legendBackgroundColor = options.backgroundColor,
			legendGroup,
			offsetWidth,
			widthOption = options.width,
			series = chart.series,
			reversedLegend = options.reversed;



		/**
		 * Set the colors for the legend item
		 * @param {Object} item A Series or Point instance
		 * @param {Object} visible Dimmed or colored
		 */
		function colorizeItem(item, visible) {
			var legendItem = item.legendItem,
				legendLine = item.legendLine,
				legendSymbol = item.legendSymbol,
				hiddenColor = itemHiddenStyle.color,
				textColor = visible ? options.itemStyle.color : hiddenColor,
				symbolColor = visible ? item.color : hiddenColor;

			if (legendItem) {
				legendItem.css({ fill: textColor });
			}
			if (legendLine) {
				legendLine.attr({ stroke: symbolColor });
			}
			if (legendSymbol) {
				legendSymbol.attr({
					stroke: symbolColor,
					fill: symbolColor
				});
			}
		}

		/**
		 * Position the legend item
		 * @param {Object} item A Series or Point instance
		 * @param {Object} visible Dimmed or colored
		 */
		function positionItem(item) {
			var legendItem = item.legendItem,
				legendLine = item.legendLine,
				legendItemPos = item._legendItemPos,
				itemX = legendItemPos[0],
				itemY = legendItemPos[1],
				legendSymbol = item.legendSymbol,
				symbolX,
				checkbox = item.checkbox;
			
			if (legendItem) {
				legendItem.attr({
					x: ltr ? itemX : legendWidth - itemX,
					y: itemY
				});
			}
			if (legendLine) {
				legendLine.translate(
					ltr ? itemX : legendWidth - itemX,
					itemY - 4
				);
			}
			if (legendSymbol) {
				symbolX = itemX + legendSymbol.xOff;
				legendSymbol.attr({
					x: ltr ? symbolX : legendWidth - symbolX,
					y: itemY + legendSymbol.yOff
				});
			}
			if (checkbox) {
				checkbox.x = itemX;
				checkbox.y = itemY;
			}
		}

		/**
		 * Destroy a single legend item
		 * @param {Object} item The series or point
		 */
		function destroyItem(item) {
			var checkbox = item.checkbox;

			// destroy SVG elements
			each(['legendItem', 'legendLine', 'legendSymbol'], function (key) {
				if (item[key]) {
					item[key].destroy();
				}
			});

			if (checkbox) {
				discardElement(item.checkbox);
			}


		}

		/**
		 * Destroys the legend.
		 */
		function destroy() {
			if (box) {
				box = box.destroy();
			}

			if (legendGroup) {
				legendGroup = legendGroup.destroy();
			}
		}

		/**
		 * Position the checkboxes after the width is determined
		 */
		function positionCheckboxes() {
			each(allItems, function (item) {
				var checkbox = item.checkbox,
					alignAttr = legendGroup.alignAttr;
				if (checkbox) {
					css(checkbox, {
						left: (alignAttr.translateX + item.legendItemWidth + checkbox.x - 40) + PX,
						top: (alignAttr.translateY + checkbox.y - 11) + PX
					});
				}
			});
		}

		/**
		 * Render a single specific legend item
		 * @param {Object} item A series or point
		 */
		function renderItem(item) {
			var bBox,
				itemWidth,
				legendSymbol,
				symbolX,
				symbolY,
				simpleSymbol,
				radius,
				li = item.legendItem,
				series = item.series || item,
				itemOptions = series.options,
				strokeWidth = (itemOptions && itemOptions.borderWidth) || 0;


			if (!li) { // generate it once, later move it

				// let these series types use a simple symbol
				simpleSymbol = /^(bar|pie|area|column)$/.test(series.type);

				// generate the list item text
				item.legendItem = li = renderer.text(
						options.labelFormatter.call(item),
						0,
						0,
						options.useHTML
					)
					.css(item.visible ? itemStyle : itemHiddenStyle)
					.on('mouseover', function () {
						item.setState(HOVER_STATE);
						li.css(itemHoverStyle);
					})
					.on('mouseout', function () {
						li.css(item.visible ? itemStyle : itemHiddenStyle);
						item.setState();
					})
					.on('click', function () {
						var strLegendItemClick = 'legendItemClick',
							fnLegendItemClick = function () {
								item.setVisible();
							};

						// click the name or symbol
						if (item.firePointEvent) { // point
							item.firePointEvent(strLegendItemClick, null, fnLegendItemClick);
						} else {
							fireEvent(item, strLegendItemClick, null, fnLegendItemClick);
						}
					})
					.attr({
						align: ltr ? 'left' : 'right',
						zIndex: 2
					})
					.add(legendGroup);

				// draw the line
				if (!simpleSymbol && itemOptions && itemOptions.lineWidth) {
					var attrs = {
							'stroke-width': itemOptions.lineWidth,
							zIndex: 2
						};
					if (itemOptions.dashStyle) {
						attrs.dashstyle = itemOptions.dashStyle;
					}
					item.legendLine = renderer.path([
						M,
						(-symbolWidth - symbolPadding) * (ltr ? 1 : -1),
						0,
						L,
						(-symbolPadding) * (ltr ? 1 : -1),
						0
					])
					.attr(attrs)
					.add(legendGroup);
				}

				// draw a simple symbol
				if (simpleSymbol) { // bar|pie|area|column

					legendSymbol = renderer.rect(
						(symbolX = -symbolWidth - symbolPadding),
						(symbolY = -11),
						symbolWidth,
						12,
						2
					).attr({
						//'stroke-width': 0,
						zIndex: 3
					}).add(legendGroup);
					
					if (!ltr) {
						symbolX += symbolWidth;
					}
					
				} else if (itemOptions && itemOptions.marker && itemOptions.marker.enabled) { // draw the marker
					radius = itemOptions.marker.radius;
					legendSymbol = renderer.symbol(
						item.symbol,
						(symbolX = -symbolWidth / 2 - symbolPadding - radius),
						(symbolY = -4 - radius),
						2 * radius,
						2 * radius
					)
					.attr(item.pointAttr[NORMAL_STATE])
					.attr({ zIndex: 3 })
					.add(legendGroup);
					
					if (!ltr) {
						symbolX += symbolWidth / 2;
					}

				}
				if (legendSymbol) {
					
					legendSymbol.xOff = symbolX + (strokeWidth % 2 / 2);
					legendSymbol.yOff = symbolY + (strokeWidth % 2 / 2);
				}

				item.legendSymbol = legendSymbol;

				// colorize the items
				colorizeItem(item, item.visible);


				// add the HTML checkbox on top
				if (itemOptions && itemOptions.showCheckbox) {
					item.checkbox = createElement('input', {
						type: 'checkbox',
						checked: item.selected,
						defaultChecked: item.selected // required by IE7
					}, options.itemCheckboxStyle, container);

					addEvent(item.checkbox, 'click', function (event) {
						var target = event.target;
						fireEvent(item, 'checkboxClick', {
								checked: target.checked
							},
							function () {
								item.select();
							}
						);
					});
				}
			}


			// calculate the positions for the next line
			bBox = li.getBBox();

			itemWidth = item.legendItemWidth =
				options.itemWidth || symbolWidth + symbolPadding + bBox.width + padding;
			itemHeight = bBox.height;

			// if the item exceeds the width, start a new line
			if (horizontal && itemX - initialItemX + itemWidth >
					(widthOption || (chartWidth - 2 * padding - initialItemX))) {
				itemX = initialItemX;
				itemY += itemMarginTop + itemHeight + itemMarginBottom;
			}
			
			// If the item exceeds the height, start a new column
			if (!horizontal && itemY + options.y + itemHeight > chartHeight - spacingTop - spacingBottom) {
				itemY = initialItemY;
				itemX += maxItemWidth;
				maxItemWidth = 0;
			}

			// Set the edge positions
			maxItemWidth = mathMax(maxItemWidth, itemWidth);
			lastItemY = mathMax(lastItemY, itemY + itemMarginBottom);
			
			// cache the position of the newly generated or reordered items
			item._legendItemPos = [itemX, itemY];

			// advance
			if (horizontal) {
				itemX += itemWidth;
			} else {
				itemY += itemMarginTop + itemHeight + itemMarginBottom;
			}

			// the width of the widest item
			offsetWidth = widthOption || mathMax(
				(itemX - initialItemX) + (horizontal ? 0 : itemWidth),
				offsetWidth
			);

		}

		/**
		 * Render the legend. This method can be called both before and after
		 * chart.render. If called after, it will only rearrange items instead
		 * of creating new ones.
		 */
		function renderLegend() {
			itemX = initialItemX;
			itemY = initialItemY;
			offsetWidth = 0;
			lastItemY = 0;

			if (!legendGroup) {
				legendGroup = renderer.g('legend')
					// #414, #759. Trackers will be drawn above the legend, but we have 
					// to sacrifice that because tooltips need to be above the legend
					// and trackers above tooltips
					.attr({ zIndex: 7 }) 
					.add();
			}


			// add each series or point
			allItems = [];
			each(series, function (serie) {
				var seriesOptions = serie.options;

				if (!seriesOptions.showInLegend) {
					return;
				}

				// use points or series for the legend item depending on legendType
				allItems = allItems.concat(
						serie.legendItems ||
						(seriesOptions.legendType === 'point' ?
								serie.data :
								serie)
				);

			});

			// sort by legendIndex
			stableSort(allItems, function (a, b) {
				return (a.options.legendIndex || 0) - (b.options.legendIndex || 0);
			});

			// reversed legend
			if (reversedLegend) {
				allItems.reverse();
			}

			// render the items
			each(allItems, renderItem);


			// Draw the border
			legendWidth = widthOption || offsetWidth;
			legendHeight = lastItemY - y + itemHeight;

			if (legendBorderWidth || legendBackgroundColor) {
				legendWidth += 2 * padding;
				legendHeight += 2 * padding;

				if (!box) {
					box = renderer.rect(
						0,
						0,
						legendWidth,
						legendHeight,
						options.borderRadius,
						legendBorderWidth || 0
					).attr({
						stroke: options.borderColor,
						'stroke-width': legendBorderWidth || 0,
						fill: legendBackgroundColor || NONE
					})
					.add(legendGroup)
					.shadow(options.shadow);
					box.isNew = true;

				} else if (legendWidth > 0 && legendHeight > 0) {
					box[box.isNew ? 'attr' : 'animate'](
						box.crisp(null, null, null, legendWidth, legendHeight)
					);
					box.isNew = false;
				}

				// hide the border if no items
				box[allItems.length ? 'show' : 'hide']();
			}
			
			// Now that the legend width and height are extablished, put the items in the 
			// final position
			each(allItems, positionItem);

			// 1.x compatibility: positioning based on style
			var props = ['left', 'right', 'top', 'bottom'],
				prop,
				i = 4;
			while (i--) {
				prop = props[i];
				if (style[prop] && style[prop] !== 'auto') {
					options[i < 2 ? 'align' : 'verticalAlign'] = prop;
					options[i < 2 ? 'x' : 'y'] = pInt(style[prop]) * (i % 2 ? -1 : 1);
				}
			}

			if (allItems.length) {
				legendGroup.align(extend(options, {
					width: legendWidth,
					height: legendHeight
				}), true, spacingBox);
			}

			if (!isResizing) {
				positionCheckboxes();
			}
		}


		// run legend
		renderLegend();

		// move checkboxes
		addEvent(chart, 'endResize', positionCheckboxes);

		// expose
		return {
			colorizeItem: colorizeItem,
			destroyItem: destroyItem,
			renderLegend: renderLegend,
			destroy: destroy
		};
	};






	/**
	 * Initialize an individual series, called internally before render time
	 */
	function initSeries(options) {
		var type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
			typeClass = seriesTypes[type],
			serie,
			hasRendered = chart.hasRendered;

		// an inverted chart can't take a column series and vice versa
		if (hasRendered) {
			if (inverted && type === 'column') {
				typeClass = seriesTypes.bar;
			} else if (!inverted && type === 'bar') {
				typeClass = seriesTypes.column;
			}
		}

		serie = new typeClass();

		serie.init(chart, options);

		// set internal chart properties
		if (!hasRendered && serie.inverted) {
			inverted = true;
		}
		if (serie.isCartesian) {
			hasCartesianSeries = serie.isCartesian;
		}

		series.push(serie);

		return serie;
	}

	/**
	 * Add a series dynamically after  time
	 *
	 * @param {Object} options The config options
	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 * @return {Object} series The newly created series object
	 */
	function addSeries(options, redraw, animation) {
		var series;

		if (options) {
			setAnimation(animation, chart);
			redraw = pick(redraw, true); // defaults to true

			fireEvent(chart, 'addSeries', { options: options }, function () {
				series = initSeries(options);
				series.isDirty = true;

				chart.isDirtyLegend = true; // the series array is out of sync with the display
				if (redraw) {
					chart.redraw();
				}
			});
		}

		return series;
	}

	/**
	 * Check whether a given point is within the plot area
	 *
	 * @param {Number} x Pixel x relative to the plot area
	 * @param {Number} y Pixel y relative to the plot area
	 */
	isInsidePlot = function (x, y) {
		return x >= 0 &&
			x <= plotWidth &&
			y >= 0 &&
			y <= plotHeight;
	};

	/**
	 * Adjust all axes tick amounts
	 */
	function adjustTickAmounts() {
		if (optionsChart.alignTicks !== false) {
			each(axes, function (axis) {
				axis.adjustTickAmount();
			});
		}
		maxTicks = null;
	}

	/**
	 * Redraw legend, axes or series based on updated data
	 *
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	function redraw(animation) {
		var redrawLegend = chart.isDirtyLegend,
			hasStackedSeries,
			isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
			seriesLength = series.length,
			i = seriesLength,
			clipRect = chart.clipRect,
			serie;

		setAnimation(animation, chart);

		// link stacked series
		while (i--) {
			serie = series[i];
			if (serie.isDirty && serie.options.stacking) {
				hasStackedSeries = true;
				break;
			}
		}
		if (hasStackedSeries) { // mark others as dirty
			i = seriesLength;
			while (i--) {
				serie = series[i];
				if (serie.options.stacking) {
					serie.isDirty = true;
				}
			}
		}

		// handle updated data in the series
		each(series, function (serie) {
			if (serie.isDirty) { // prepare the data so axis can read it
				if (serie.options.legendType === 'point') {
					redrawLegend = true;
				}
			}
		});

		// handle added or removed series
		if (redrawLegend && legend.renderLegend) { // series or pie points are added or removed
			// draw legend graphics
			legend.renderLegend();

			chart.isDirtyLegend = false;
		}


		if (hasCartesianSeries) {
			if (!isResizing) {

				// reset maxTicks
				maxTicks = null;

				// set axes scales
				each(axes, function (axis) {
					axis.setScale();
				});
			}
			adjustTickAmounts();
			getMargins();

			// redraw axes
			each(axes, function (axis) {
				
				// Fire 'afterSetExtremes' only if extremes are set
				if (axis.isDirtyExtremes) { // #821
					axis.isDirtyExtremes = false;
					fireEvent(axis, 'afterSetExtremes', axis.getExtremes()); // #747, #751
				}
								
				if (axis.isDirty || isDirtyBox) {					
					axis.redraw();
					isDirtyBox = true; // #792
				}
			});


		}

		// the plot areas size has changed
		if (isDirtyBox) {
			drawChartBox();

			// move clip rect
			if (clipRect) {
				stop(clipRect);
				clipRect.animate({ // for chart resize
					width: chart.plotSizeX,
					height: chart.plotSizeY + 1
				});
			}

		}


		// redraw affected series
		each(series, function (serie) {
			if (serie.isDirty && serie.visible &&
					(!serie.isCartesian || serie.xAxis)) { // issue #153
				serie.redraw();
			}
		});


		// hide tooltip and hover states
		if (tracker && tracker.resetTracker) {
			tracker.resetTracker();
		}

		// redraw if canvas
		renderer.draw();

		// fire the event
		fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
	}



	/**
	 * Dim the chart and show a loading text or symbol
	 * @param {String} str An optional text to show in the loading label instead of the default one
	 */
	function showLoading(str) {
		var loadingOptions = options.loading;

		// create the layer at the first call
		if (!loadingDiv) {
			loadingDiv = createElement(DIV, {
				className: PREFIX + 'loading'
			}, extend(loadingOptions.style, {
				left: plotLeft + PX,
				top: plotTop + PX,
				width: plotWidth + PX,
				height: plotHeight + PX,
				zIndex: 10,
				display: NONE
			}), container);

			loadingSpan = createElement(
				'span',
				null,
				loadingOptions.labelStyle,
				loadingDiv
			);

		}

		// update text
		loadingSpan.innerHTML = str || options.lang.loading;

		// show it
		if (!loadingShown) {
			css(loadingDiv, { opacity: 0, display: '' });
			animate(loadingDiv, {
				opacity: loadingOptions.style.opacity
			}, {
				duration: loadingOptions.showDuration || 0
			});
			loadingShown = true;
		}
	}
	/**
	 * Hide the loading layer
	 */
	function hideLoading() {
		if (loadingDiv) {
			animate(loadingDiv, {
				opacity: 0
			}, {
				duration: options.loading.hideDuration || 100,
				complete: function () {
					css(loadingDiv, { display: NONE });
				}
			});
		}
		loadingShown = false;
	}

	/**
	 * Get an axis, series or point object by id.
	 * @param id {String} The id as given in the configuration options
	 */
	function get(id) {
		var i,
			j,
			points;

		// search axes
		for (i = 0; i < axes.length; i++) {
			if (axes[i].options.id === id) {
				return axes[i];
			}
		}

		// search series
		for (i = 0; i < series.length; i++) {
			if (series[i].options.id === id) {
				return series[i];
			}
		}

		// search points
		for (i = 0; i < series.length; i++) {
			points = series[i].points || [];
			for (j = 0; j < points.length; j++) {
				if (points[j].id === id) {
					return points[j];
				}
			}
		}
		return null;
	}

	/**
	 * Create the Axis instances based on the config options
	 */
	function getAxes() {
		var xAxisOptions = options.xAxis || {},
			yAxisOptions = options.yAxis || {},
			optionsArray,
			axis;

		// make sure the options are arrays and add some members
		xAxisOptions = splat(xAxisOptions);
		each(xAxisOptions, function (axis, i) {
			axis.index = i;
			axis.isX = true;
		});

		yAxisOptions = splat(yAxisOptions);
		each(yAxisOptions, function (axis, i) {
			axis.index = i;
		});

		// concatenate all axis options into one array
		optionsArray = xAxisOptions.concat(yAxisOptions);

		each(optionsArray, function (axisOptions) {
			axis = new Axis(axisOptions);
		});

		adjustTickAmounts();
	}


	/**
	 * Get the currently selected points from all series
	 */
	function getSelectedPoints() {
		var points = [];
		each(series, function (serie) {
			points = points.concat(grep(serie.points, function (point) {
				return point.selected;
			}));
		});
		return points;
	}

	/**
	 * Get the currently selected series
	 */
	function getSelectedSeries() {
		return grep(series, function (serie) {
			return serie.selected;
		});
	}

	/**
	 * Display the zoom button
	 */
	function showResetZoom() {
		var lang = defaultOptions.lang,
			btnOptions = optionsChart.resetZoomButton,
			theme = btnOptions.theme,
			states = theme.states,
			box = btnOptions.relativeTo === 'chart' ? null : {
				x: plotLeft,
				y: plotTop,
				width: plotWidth,
				height: plotHeight
			};
		chart.resetZoomButton = renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)
			.attr({
				align: btnOptions.position.align,
				title: lang.resetZoomTitle
			})
			.add()
			.align(btnOptions.position, false, box);
	}

	/**
	 * Zoom out to 1:1
	 */
	zoomOut = function () {
		var resetZoomButton = chart.resetZoomButton;

		fireEvent(chart, 'selection', { resetSelection: true }, zoom);
		if (resetZoomButton) {
			chart.resetZoomButton = resetZoomButton.destroy();
		}
	};
	/**
	 * Zoom into a given portion of the chart given by axis coordinates
	 * @param {Object} event
	 */
	zoom = function (event) {

		// add button to reset selection
		var hasZoomed;

		if (chart.resetZoomEnabled !== false && !chart.resetZoomButton) { // hook for Stock charts etc.
			showResetZoom();
		}

		// if zoom is called with no arguments, reset the axes
		if (!event || event.resetSelection) {
			each(axes, function (axis) {
				if (axis.options.zoomEnabled !== false) {
					axis.setExtremes(null, null, false);
					hasZoomed = true;
				}
			});
		} else { // else, zoom in on all axes
			each(event.xAxis.concat(event.yAxis), function (axisData) {
				var axis = axisData.axis;

				// don't zoom more than minRange
				if (chart.tracker[axis.isXAxis ? 'zoomX' : 'zoomY']) {
					axis.setExtremes(axisData.min, axisData.max, false);
					hasZoomed = true;
				}
			});
		}

		// Redraw
		if (hasZoomed) {
			redraw( 
				pick(optionsChart.animation, chart.pointCount < 100) // animation
			);
		}
	};

	/**
	 * Pan the chart by dragging the mouse across the pane. This function is called
	 * on mouse move, and the distance to pan is computed from chartX compared to
	 * the first chartX position in the dragging operation.
	 */
	chart.pan = function (chartX) {

		var xAxis = chart.xAxis[0],
			mouseDownX = chart.mouseDownX,
			halfPointRange = xAxis.pointRange / 2,
			extremes = xAxis.getExtremes(),
			newMin = xAxis.translate(mouseDownX - chartX, true) + halfPointRange,
			newMax = xAxis.translate(mouseDownX + plotWidth - chartX, true) - halfPointRange,
			hoverPoints = chart.hoverPoints;

		// remove active points for shared tooltip
		if (hoverPoints) {
			each(hoverPoints, function (point) {
				point.setState();
			});
		}

		if (newMin > mathMin(extremes.dataMin, extremes.min) && newMax < mathMax(extremes.dataMax, extremes.max)) {
			xAxis.setExtremes(newMin, newMax, true, false);
		}

		chart.mouseDownX = chartX; // set new reference for next run
		css(container, { cursor: 'move' });
	};

	/**
	 * Show the title and subtitle of the chart
	 *
	 * @param titleOptions {Object} New title options
	 * @param subtitleOptions {Object} New subtitle options
	 *
	 */
	function setTitle(titleOptions, subtitleOptions) {

		chartTitleOptions = merge(options.title, titleOptions);
		chartSubtitleOptions = merge(options.subtitle, subtitleOptions);

		// add title and subtitle
		each([
			['title', titleOptions, chartTitleOptions],
			['subtitle', subtitleOptions, chartSubtitleOptions]
		], function (arr) {
			var name = arr[0],
				title = chart[name],
				titleOptions = arr[1],
				chartTitleOptions = arr[2];

			if (title && titleOptions) {
				title = title.destroy(); // remove old
			}
			if (chartTitleOptions && chartTitleOptions.text && !title) {
				chart[name] = renderer.text(
					chartTitleOptions.text,
					0,
					0,
					chartTitleOptions.useHTML
				)
				.attr({
					align: chartTitleOptions.align,
					'class': PREFIX + name,
					zIndex: chartTitleOptions.zIndex || 4
				})
				.css(chartTitleOptions.style)
				.add()
				.align(chartTitleOptions, false, spacingBox);
			}
		});

	}

	/**
	 * Get chart width and height according to options and container size
	 */
	function getChartSize() {

		containerWidth = (renderToClone || renderTo).offsetWidth;
		containerHeight = (renderToClone || renderTo).offsetHeight;
		chart.chartWidth = chartWidth = optionsChart.width || containerWidth || 600;
		chart.chartHeight = chartHeight = optionsChart.height ||
			// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
			(containerHeight > 19 ? containerHeight : 400);
	}


	/**
	 * Get the containing element, determine the size and create the inner container
	 * div to hold the chart
	 */
	function getContainer() {
		renderTo = optionsChart.renderTo;
		containerId = PREFIX + idCounter++;

		if (isString(renderTo)) {
			renderTo = doc.getElementById(renderTo);
		}
		
		// Display an error if the renderTo is wrong
		if (!renderTo) {
			error(13, true);
		}

		// remove previous chart
		renderTo.innerHTML = '';

		// If the container doesn't have an offsetWidth, it has or is a child of a node
		// that has display:none. We need to temporarily move it out to a visible
		// state to determine the size, else the legend and tooltips won't render
		// properly
		if (!renderTo.offsetWidth) {
			renderToClone = renderTo.cloneNode(0);
			css(renderToClone, {
				position: ABSOLUTE,
				top: '-9999px',
				display: ''
			});
			doc.body.appendChild(renderToClone);
		}

		// get the width and height
		getChartSize();

		// create the inner container
		chart.container = container = createElement(DIV, {
				className: PREFIX + 'container' +
					(optionsChart.className ? ' ' + optionsChart.className : ''),
				id: containerId
			}, extend({
				position: RELATIVE,
				overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
					// content overflow in IE
				width: chartWidth + PX,
				height: chartHeight + PX,
				textAlign: 'left',
				lineHeight: 'normal' // #427
			}, optionsChart.style),
			renderToClone || renderTo
		);

		chart.renderer = renderer =
			optionsChart.forExport ? // force SVG, used for SVG export
				new SVGRenderer(container, chartWidth, chartHeight, true) :
				new Renderer(container, chartWidth, chartHeight);

		if (useCanVG) {
			// If we need canvg library, extend and configure the renderer
			// to get the tracker for translating mouse events
			renderer.create(chart, container, chartWidth, chartHeight);
		}

		// Issue 110 workaround:
		// In Firefox, if a div is positioned by percentage, its pixel position may land
		// between pixels. The container itself doesn't display this, but an SVG element
		// inside this container will be drawn at subpixel precision. In order to draw
		// sharp lines, this must be compensated for. This doesn't seem to work inside
		// iframes though (like in jsFiddle).
		var subPixelFix, rect;
		if (isFirefox && container.getBoundingClientRect) {
			subPixelFix = function () {
				css(container, { left: 0, top: 0 });
				rect = container.getBoundingClientRect();
				css(container, {
					left: (-(rect.left - pInt(rect.left))) + PX,
					top: (-(rect.top - pInt(rect.top))) + PX
				});
			};

			// run the fix now
			subPixelFix();

			// run it on resize
			addEvent(win, 'resize', subPixelFix);

			// remove it on chart destroy
			addEvent(chart, 'destroy', function () {
				removeEvent(win, 'resize', subPixelFix);
			});
		}
	}

	/**
	 * Calculate margins by rendering axis labels in a preliminary position. Title,
	 * subtitle and legend have already been rendered at this stage, but will be
	 * moved into their final positions
	 */
	getMargins = function () {
		var legendOptions = options.legend,
			legendMargin = pick(legendOptions.margin, 10),
			legendX = legendOptions.x,
			legendY = legendOptions.y,
			align = legendOptions.align,
			verticalAlign = legendOptions.verticalAlign,
			titleOffset;

		resetMargins();

		// adjust for title and subtitle
		if ((chart.title || chart.subtitle) && !defined(optionsMarginTop)) {
			titleOffset = mathMax(
				(chart.title && !chartTitleOptions.floating && !chartTitleOptions.verticalAlign && chartTitleOptions.y) || 0,
				(chart.subtitle && !chartSubtitleOptions.floating && !chartSubtitleOptions.verticalAlign && chartSubtitleOptions.y) || 0
			);
			if (titleOffset) {
				plotTop = mathMax(plotTop, titleOffset + pick(chartTitleOptions.margin, 15) + spacingTop);
			}
		}
		// adjust for legend
		if (legendOptions.enabled && !legendOptions.floating) {
			if (align === 'right') { // horizontal alignment handled first
				if (!defined(optionsMarginRight)) {
					marginRight = mathMax(
						marginRight,
						legendWidth - legendX + legendMargin + spacingRight
					);
				}
			} else if (align === 'left') {
				if (!defined(optionsMarginLeft)) {
					plotLeft = mathMax(
						plotLeft,
						legendWidth + legendX + legendMargin + spacingLeft
					);
				}

			} else if (verticalAlign === 'top') {
				if (!defined(optionsMarginTop)) {
					plotTop = mathMax(
						plotTop,
						legendHeight + legendY + legendMargin + spacingTop
					);
				}

			} else if (verticalAlign === 'bottom') {
				if (!defined(optionsMarginBottom)) {
					marginBottom = mathMax(
						marginBottom,
						legendHeight - legendY + legendMargin + spacingBottom
					);
				}
			}
		}

		// adjust for scroller
		if (chart.extraBottomMargin) {
			marginBottom += chart.extraBottomMargin;
		}
		if (chart.extraTopMargin) {
			plotTop += chart.extraTopMargin;
		}

		// pre-render axes to get labels offset width
		if (hasCartesianSeries) {
			each(axes, function (axis) {
				axis.getOffset();
			});
		}

		if (!defined(optionsMarginLeft)) {
			plotLeft += axisOffset[3];
		}
		if (!defined(optionsMarginTop)) {
			plotTop += axisOffset[0];
		}
		if (!defined(optionsMarginBottom)) {
			marginBottom += axisOffset[2];
		}
		if (!defined(optionsMarginRight)) {
			marginRight += axisOffset[1];
		}

		setChartSize();

	};

	/**
	 * Add the event handlers necessary for auto resizing
	 *
	 */
	function initReflow() {
		var reflowTimeout;
		function reflow(e) {
			var width = optionsChart.width || renderTo.offsetWidth,
				height = optionsChart.height || renderTo.offsetHeight,
				target = e ? e.target : win; // #805 - MooTools doesn't supply e
				
			// Width and height checks for display:none. Target is doc in IE8 and Opera,
			// win in Firefox, Chrome and IE9.
			if (width && height && (target === win || target === doc)) {
				
				if (width !== containerWidth || height !== containerHeight) {
					clearTimeout(reflowTimeout);
					reflowTimeout = setTimeout(function () {
						resize(width, height, false);
					}, 100);
				}
				containerWidth = width;
				containerHeight = height;
			}
		}
		addEvent(win, 'resize', reflow);
		addEvent(chart, 'destroy', function () {
			removeEvent(win, 'resize', reflow);
		});
	}

	/**
	 * Fires endResize event on chart instance.
	 */
	function fireEndResize() {
		if (chart) {
			fireEvent(chart, 'endResize', null, function () {
				isResizing -= 1;
			});
		}
	}

	/**
	 * Resize the chart to a given width and height
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Object|Boolean} animation
	 */
	resize = function (width, height, animation) {
        // [CUSTOMIZED]
        // chart may be destroyed when invoke resize by setTimeout
        if (!chart) {
            return;
        }
        
		var chartTitle = chart.title,
			chartSubtitle = chart.subtitle;

		isResizing += 1;

		// set the animation for the current process
		setAnimation(animation, chart);

		oldChartHeight = chartHeight;
		oldChartWidth = chartWidth;
		if (defined(width)) {
			chart.chartWidth = chartWidth = mathRound(width);
		}
		if (defined(height)) {
			chart.chartHeight = chartHeight = mathRound(height);
		}

		css(container, {
			width: chartWidth + PX,
			height: chartHeight + PX
		});
		renderer.setSize(chartWidth, chartHeight, animation);

		// update axis lengths for more correct tick intervals:
		plotWidth = chartWidth - plotLeft - marginRight;
		plotHeight = chartHeight - plotTop - marginBottom;

		// handle axes
		maxTicks = null;
		each(axes, function (axis) {
			axis.isDirty = true;
			axis.setScale();
		});

		// make sure non-cartesian series are also handled
		each(series, function (serie) {
			serie.isDirty = true;
		});

		chart.isDirtyLegend = true; // force legend redraw
		chart.isDirtyBox = true; // force redraw of plot and chart border

		getMargins();

		// move titles
		if (chartTitle) {
			chartTitle.align(null, null, spacingBox);
		}
		if (chartSubtitle) {
			chartSubtitle.align(null, null, spacingBox);
		}

		redraw(animation);


		oldChartHeight = null;
		fireEvent(chart, 'resize');

		// fire endResize and set isResizing back
		// If animation is disabled, fire without delay
		if (globalAnimation === false) {
			fireEndResize();
		} else { // else set a timeout with the animation duration
			setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
		}
	};

	/**
	 * Set the public chart properties. This is done before and after the pre-render
	 * to determine margin sizes
	 */
	setChartSize = function () {

		chart.plotLeft = plotLeft = mathRound(plotLeft);
		chart.plotTop = plotTop = mathRound(plotTop);
		chart.plotWidth = plotWidth = mathRound(chartWidth - plotLeft - marginRight);
		chart.plotHeight = plotHeight = mathRound(chartHeight - plotTop - marginBottom);

		chart.plotSizeX = inverted ? plotHeight : plotWidth;
		chart.plotSizeY = inverted ? plotWidth : plotHeight;

		spacingBox = {
			x: spacingLeft,
			y: spacingTop,
			width: chartWidth - spacingLeft - spacingRight,
			height: chartHeight - spacingTop - spacingBottom
		};

		each(axes, function (axis) {
			axis.setAxisSize();
			axis.setAxisTranslation();
		});
	};

	/**
	 * Initial margins before auto size margins are applied
	 */
	resetMargins = function () {
		plotTop = pick(optionsMarginTop, spacingTop);
		marginRight = pick(optionsMarginRight, spacingRight);
		marginBottom = pick(optionsMarginBottom, spacingBottom);
		plotLeft = pick(optionsMarginLeft, spacingLeft);
		axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
	};

	/**
	 * Draw the borders and backgrounds for chart and plot area
	 */
	drawChartBox = function () {
		var chartBorderWidth = optionsChart.borderWidth || 0,
			chartBackgroundColor = optionsChart.backgroundColor,
			plotBackgroundColor = optionsChart.plotBackgroundColor,
			plotBackgroundImage = optionsChart.plotBackgroundImage,
			mgn,
			plotSize = {
				x: plotLeft,
				y: plotTop,
				width: plotWidth,
				height: plotHeight
			};

		// Chart area
		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

		if (chartBorderWidth || chartBackgroundColor) {
			if (!chartBackground) {
				chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
						optionsChart.borderRadius, chartBorderWidth)
					.attr({
						stroke: optionsChart.borderColor,
						'stroke-width': chartBorderWidth,
						fill: chartBackgroundColor || NONE
					})
					.add()
					.shadow(optionsChart.shadow);
			} else { // resize
				chartBackground.animate(
					chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn)
				);
			}
		}


		// Plot background
		if (plotBackgroundColor) {
			if (!plotBackground) {
				plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
					.attr({
						fill: plotBackgroundColor
					})
					.add()
					.shadow(optionsChart.plotShadow);
			} else {
				plotBackground.animate(plotSize);
			}
		}
		if (plotBackgroundImage) {
			if (!plotBGImage) {
				plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
					.add();
			} else {
				plotBGImage.animate(plotSize);
			}
		}

		// Plot area border
		if (optionsChart.plotBorderWidth) {
			if (!plotBorder) {
				plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, optionsChart.plotBorderWidth)
					.attr({
						stroke: optionsChart.plotBorderColor,
						'stroke-width': optionsChart.plotBorderWidth,
						zIndex: 4
					})
					.add();
			} else {
				plotBorder.animate(
					plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight)
				);
			}
		}

		// reset
		chart.isDirtyBox = false;
	};

	/**
	 * Detect whether the chart is inverted, either by setting the chart.inverted option
	 * or adding a bar series to the configuration options
	 */
	function setInverted() {
		var BAR = 'bar',
			isInverted = (
				inverted || // it is set before
				optionsChart.inverted ||
				optionsChart.type === BAR || // default series type
				optionsChart.defaultSeriesType === BAR // backwards compatible
			),
			seriesOptions = options.series,
			i = seriesOptions && seriesOptions.length;

		// check if a bar series is present in the config options
		while (!isInverted && i--) {
			if (seriesOptions[i].type === BAR) {
				isInverted = true;
			}
		}

		// set the chart property and the chart scope variable
		chart.inverted = inverted = isInverted;
	}

	/**
	 * Render all graphics for the chart
	 */
	function render() {
		var labels = options.labels,
			credits = options.credits,
			creditsHref;

		// Title
		setTitle();


		// Legend
		legend = chart.legend = new Legend();

		// Get margins by pre-rendering axes
		// set axes scales
		each(axes, function (axis) {
			axis.setScale();
		});
		getMargins();
		each(axes, function (axis) {
			axis.setTickPositions(true); // update to reflect the new margins
		});
		adjustTickAmounts();
		getMargins(); // second pass to check for new labels


		// Draw the borders and backgrounds
		drawChartBox();

		// Axes
		if (hasCartesianSeries) {
			each(axes, function (axis) {
				axis.render();
			});
		}


		// The series
		if (!chart.seriesGroup) {
			chart.seriesGroup = renderer.g('series-group')
				.attr({ zIndex: 3 })
				.add();
		}
		each(series, function (serie) {
			serie.translate();
			serie.setTooltipPoints();
			serie.render();
		});


		// Labels
		if (labels.items) {
			each(labels.items, function () {
				var style = extend(labels.style, this.style),
					x = pInt(style.left) + plotLeft,
					y = pInt(style.top) + plotTop + 12;

				// delete to prevent rewriting in IE
				delete style.left;
				delete style.top;

				renderer.text(
					this.html,
					x,
					y
				)
				.attr({ zIndex: 2 })
				.css(style)
				.add();

			});
		}

		// Credits
		if (credits.enabled && !chart.credits) {
			creditsHref = credits.href;
			chart.credits = renderer.text(
				credits.text,
				0,
				0
			)
			.on('click', function () {
				if (creditsHref) {
					location.href = creditsHref;
				}
			})
			.attr({
				align: credits.position.align,
				zIndex: 8
			})
			.css(credits.style)
			.add()
			.align(credits.position);
		}

		// Set flag
		chart.hasRendered = true;

	}

	/**
	 * Clean up memory usage
	 */
	function destroy() {
		var i,
			parentNode = container && container.parentNode;

		// If the chart is destroyed already, do nothing.
		// This will happen if if a script invokes chart.destroy and
		// then it will be called again on win.unload
		if (chart === null) {
			return;
		}

		// fire the chart.destoy event
		fireEvent(chart, 'destroy');

		// remove events
		removeEvent(chart);

		// ==== Destroy collections:
		// Destroy axes
		i = axes.length;
		while (i--) {
			axes[i] = axes[i].destroy();
		}

		// Destroy each series
		i = series.length;
		while (i--) {
			series[i] = series[i].destroy();
		}

		// ==== Destroy chart properties:
		each(['title', 'subtitle', 'seriesGroup', 'clipRect', 'credits', 'tracker', 'scroller', 'rangeSelector'], function (name) {
			var prop = chart[name];

			if (prop) {
				chart[name] = prop.destroy();
			}
		});

		// ==== Destroy local variables:
		each([chartBackground, plotBorder, plotBackground, legend, tooltip, renderer, tracker], function (obj) {
			if (obj && obj.destroy) {
				obj.destroy();
			}
		});
		chartBackground = plotBorder = plotBackground = legend = tooltip = renderer = tracker = null;

		// remove container and all SVG
		if (container) { // can break in IE when destroyed before finished loading
			container.innerHTML = '';
			removeEvent(container);
			if (parentNode) {
				discardElement(container);
			}

			// IE6 leak
			container = null;
		}

		// memory and CPU leak
		clearInterval(tooltipInterval);

		// clean it all up
		for (i in chart) {
			delete chart[i];
		}

		chart = null;
		options = null;
	}
	/**
	 * Prepare for first rendering after all data are loaded
	 */
	function firstRender() {
		// VML namespaces can't be added until after complete. Listening
		// for Perini's doScroll hack is not enough.
		var ONREADYSTATECHANGE = 'onreadystatechange',
		COMPLETE = 'complete';
		// Note: in spite of JSLint's complaints, win == win.top is required
		/*jslint eqeq: true*/
		if ((!hasSVG && (win == win.top && doc.readyState !== COMPLETE)) || (useCanVG && !win.canvg)) {
		/*jslint eqeq: false*/
			if (useCanVG) {
				// Delay rendering until canvg library is downloaded and ready
				CanVGController.push(firstRender, options.global.canvasToolsURL);
			} else {
				doc.attachEvent(ONREADYSTATECHANGE, function () {
					doc.detachEvent(ONREADYSTATECHANGE, firstRender);
					if (doc.readyState === COMPLETE) {
						firstRender();
					}
				});
			}
			return;
		}

		// create the container
		getContainer();

		// Run an early event after the container and renderer are established
		fireEvent(chart, 'init');

		// Initialize range selector for stock charts
		if (Highcharts.RangeSelector && options.rangeSelector.enabled) {
			chart.rangeSelector = new Highcharts.RangeSelector(chart);
		}

		resetMargins();
		setChartSize();

		// Set the common inversion and transformation for inverted series after initSeries
		setInverted();

		// get axes
		getAxes();

		// Initialize the series
		each(options.series || [], function (serieOptions) {
			initSeries(serieOptions);
		});

		// Run an event where series and axes can be added
		//fireEvent(chart, 'beforeRender');

		// Initialize scroller for stock charts
		if (Highcharts.Scroller && (options.navigator.enabled || options.scrollbar.enabled)) {
			chart.scroller = new Highcharts.Scroller(chart);
		}

		chart.render = render;

		// depends on inverted and on margins being set
		chart.tracker = tracker = new MouseTracker(options.tooltip);


		render();

		// add canvas
		renderer.draw();
		// run callbacks
		if (callback) {
			callback.apply(chart, [chart]);
		}
		each(chart.callbacks, function (fn) {
			fn.apply(chart, [chart]);
		});
		
		
		// If the chart was rendered outside the top container, put it back in
		if (renderToClone) {
			renderTo.appendChild(container);
			discardElement(renderToClone);
		}

		fireEvent(chart, 'load');

	}

	// Run chart

	// Set up auto resize
	if (optionsChart.reflow !== false) {
		addEvent(chart, 'load', initReflow);
	}

	// Chart event handlers
	if (chartEvents) {
		for (eventType in chartEvents) {
			addEvent(chart, eventType, chartEvents[eventType]);
		}
	}


	chart.options = options;
	chart.series = series;


	chart.xAxis = [];
	chart.yAxis = [];




	// Expose methods and variables
	chart.addSeries = addSeries;
	chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
	chart.Axis = Axis;
	chart.destroy = destroy;
	chart.get = get;
	chart.getSelectedPoints = getSelectedPoints;
	chart.getSelectedSeries = getSelectedSeries;
	chart.hideLoading = hideLoading;
	chart.initSeries = initSeries;
	chart.isInsidePlot = isInsidePlot;
	chart.redraw = redraw;
	chart.setSize = resize;
	chart.setTitle = setTitle;
	chart.showLoading = showLoading;
	chart.pointCount = 0;
	chart.counters = new ChartCounters();
	/*
	if ($) $(function () {
		$container = $('#container');
		var origChartWidth,
			origChartHeight;
		if ($container) {
			$('<button>+</button>')
				.insertBefore($container)
				.click(function () {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(chartWidth *= 1.1, chartHeight *= 1.1);
				});
			$('<button>-</button>')
				.insertBefore($container)
				.click(function () {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(chartWidth *= 0.9, chartHeight *= 0.9);
				});
			$('<button>1:1</button>')
				.insertBefore($container)
				.click(function () {
					if (origChartWidth === UNDEFINED) {
						origChartWidth = chartWidth;
						origChartHeight = chartHeight;
					}
					chart.resize(origChartWidth, origChartHeight);
				});
		}
	})
	*/




	firstRender();


} // end Chart

// Hook for exporting module
Chart.prototype.callbacks = [];
/**
 * The Point object and prototype. Inheritable and used as base for PiePoint
 */
var Point = function () {};
Point.prototype = {

	/**
	 * Initialize the point
	 * @param {Object} series The series object containing this point
	 * @param {Object} options The data in either number, array or object format
	 */
	init: function (series, options, x) {
		var point = this,
			counters = series.chart.counters,
			defaultColors;
		point.series = series;
		point.applyOptions(options, x);
		point.pointAttr = {};

		if (series.options.colorByPoint) {
			defaultColors = series.chart.options.colors;
			if (!point.options) {
				point.options = {};
			}
			point.color = point.options.color = point.color || defaultColors[counters.color++];

			// loop back to zero
			counters.wrapColor(defaultColors.length);
		}

		series.chart.pointCount++;
		return point;
	},
	/**
	 * Apply the options containing the x and y data and possible some extra properties.
	 * This is called on point init or from point.update.
	 *
	 * @param {Object} options
	 */
	applyOptions: function (options, x) {
		var point = this,
			series = point.series,
			optionsType = typeof options;

		point.config = options;

		// onedimensional array input
		if (optionsType === 'number' || options === null) {
			point.y = options;
		} else if (typeof options[0] === 'number') { // two-dimentional array
			point.x = options[0];
			point.y = options[1];
		} else if (optionsType === 'object' && typeof options.length !== 'number') { // object input
			// copy options directly to point
			extend(point, options);
			point.options = options;
			
			// This is the fastest way to detect if there are individual point dataLabels that need 
			// to be considered in drawDataLabels. These can only occur in object configs.
			if (options.dataLabels) {
				series._hasPointLabels = true;
			}
		} else if (typeof options[0] === 'string') { // categorized data with name in first position
			point.name = options[0];
			point.y = options[1];
		}
		
		/*
		 * If no x is set by now, get auto incremented value. All points must have an
		 * x value, however the y value can be null to create a gap in the series
		 */
		// todo: skip this? It is only used in applyOptions, in translate it should not be used
		if (point.x === UNDEFINED) {
			point.x = x === UNDEFINED ? series.autoIncrement() : x;
		}
		
		

	},

	/**
	 * Destroy a point to clear memory. Its reference still stays in series.data.
	 */
	destroy: function () {
		var point = this,
			series = point.series,
			hoverPoints = series.chart.hoverPoints,
			prop;

		series.chart.pointCount--;

		if (hoverPoints) {
			point.setState();
			erase(hoverPoints, point);
		}
		if (point === series.chart.hoverPoint) {
			point.onMouseOut();
		}
		series.chart.hoverPoints = null;

		// remove all events
		if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
			removeEvent(point);
			point.destroyElements();
		}

		if (point.legendItem) { // pies have legend items
			point.series.chart.legend.destroyItem(point);
		}

		for (prop in point) {
			point[prop] = null;
		}


	},

	/**
	 * Destroy SVG elements associated with the point
	 */
	destroyElements: function () {
		var point = this,
			props = ['graphic', 'tracker', 'dataLabel', 'group', 'connector', 'shadowGroup'],
			prop,
			i = 6;
		while (i--) {
			prop = props[i];
			if (point[prop]) {
				point[prop] = point[prop].destroy();
			}
		}
	},

	/**
	 * Return the configuration hash needed for the data label and tooltip formatters
	 */
	getLabelConfig: function () {
		var point = this;
		return {
			x: point.category,
			y: point.y,
			key: point.name || point.category,
			series: point.series,
			point: point,
			percentage: point.percentage,
			total: point.total || point.stackTotal
		};
	},

	/**
	 * Toggle the selection status of a point
	 * @param {Boolean} selected Whether to select or unselect the point.
	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
	 *     this happens if the control key (Cmd on Mac) was pressed during clicking.
	 */
	select: function (selected, accumulate) {
		var point = this,
			series = point.series,
			chart = series.chart;

		selected = pick(selected, !point.selected);

		// fire the event with the defalut handler
		point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
			point.selected = selected;
			point.setState(selected && SELECT_STATE);

			// unselect all other points unless Ctrl or Cmd + click
			if (!accumulate) {
				each(chart.getSelectedPoints(), function (loopPoint) {
					if (loopPoint.selected && loopPoint !== point) {
						loopPoint.selected = false;
						loopPoint.setState(NORMAL_STATE);
						loopPoint.firePointEvent('unselect');
					}
				});
			}
		});
	},

	onMouseOver: function () {
		var point = this,
			series = point.series,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		// set normal state to previous series
		if (hoverPoint && hoverPoint !== point) {
			hoverPoint.onMouseOut();
		}

		// trigger the event
		point.firePointEvent('mouseOver');

		// update the tooltip
		if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
			tooltip.refresh(point);
		}

		// hover this
		point.setState(HOVER_STATE);
		chart.hoverPoint = point;
	},

	onMouseOut: function () {
		var point = this;
		point.firePointEvent('mouseOut');

		point.setState();
		point.series.chart.hoverPoint = null;
	},

	/**
	 * Extendable method for formatting each point's tooltip line
	 *
	 * @return {String} A string to be concatenated in to the common tooltip text
	 */
	tooltipFormatter: function (pointFormat) {
		var point = this,
			series = point.series,
			seriesTooltipOptions = series.tooltipOptions,
			split = String(point.y).split('.'),
			originalDecimals = split[1] ? split[1].length : 0,
			match = pointFormat.match(/\{(series|point)\.[a-zA-Z]+\}/g),
			splitter = /[{\.}]/,
			obj,
			key,
			replacement,
			parts,
			prop,
			i;

		// loop over the variables defined on the form {series.name}, {point.y} etc
		for (i in match) {
			key = match[i];
			if (isString(key) && key !== pointFormat) { // IE matches more than just the variables
				
				// Split it further into parts
				parts = (' ' + key).split(splitter); // add empty string because IE and the rest handles it differently
				obj = { 'point': point, 'series': series }[parts[1]];
				prop = parts[2];
				
				// Add some preformatting
				if (obj === point && (prop === 'y' || prop === 'open' || prop === 'high' || 
						prop === 'low' || prop === 'close')) { 
					replacement = (seriesTooltipOptions.valuePrefix || seriesTooltipOptions.yPrefix || '') + 
						numberFormat(point[prop], pick(seriesTooltipOptions.valueDecimals, seriesTooltipOptions.yDecimals, originalDecimals)) +
						(seriesTooltipOptions.valueSuffix || seriesTooltipOptions.ySuffix || '');
				
				// Automatic replacement
				} else {
					replacement = obj[prop];
				}
				
				pointFormat = pointFormat.replace(key, replacement);
			}
		}
		
		return pointFormat;
	},

	/**
	 * Update the point with new options (typically x/y data) and optionally redraw the series.
	 *
	 * @param {Object} options Point options as defined in the series.data array
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 */
	update: function (options, redraw, animation) {
		var point = this,
			series = point.series,
			graphic = point.graphic,
			i,
			data = series.data,
			dataLength = data.length,
			chart = series.chart;

		redraw = pick(redraw, true);

		// fire the event with a default handler of doing the update
		point.firePointEvent('update', { options: options }, function () {

			point.applyOptions(options);

			// update visuals
			if (isObject(options)) {
				series.getAttribs();
				if (graphic) {
					graphic.attr(point.pointAttr[series.state]);
				}
			}

			// record changes in the parallel arrays
			for (i = 0; i < dataLength; i++) {
				if (data[i] === point) {
					series.xData[i] = point.x;
					series.yData[i] = point.y;
					series.options.data[i] = options;
					break;
				}
			}

			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				chart.redraw(animation);
			}
		});
	},

	/**
	 * Remove a point and optionally redraw the series and if necessary the axes
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	remove: function (redraw, animation) {
		var point = this,
			series = point.series,
			chart = series.chart,
			i,
			data = series.data,
			dataLength = data.length;

		setAnimation(animation, chart);
		redraw = pick(redraw, true);

		// fire the event with a default handler of removing the point
		point.firePointEvent('remove', null, function () {

			//erase(series.data, point);

			for (i = 0; i < dataLength; i++) {
				if (data[i] === point) {

					// splice all the parallel arrays
					data.splice(i, 1);
					series.options.data.splice(i, 1);
					series.xData.splice(i, 1);
					series.yData.splice(i, 1);
					break;
				}
			}

			point.destroy();


			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				chart.redraw();
			}
		});


	},

	/**
	 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
	 * causes a name clash in MooTools
	 * @param {String} eventType
	 * @param {Object} eventArgs Additional event arguments
	 * @param {Function} defaultFunction Default event handler
	 */
	firePointEvent: function (eventType, eventArgs, defaultFunction) {
		var point = this,
			series = this.series,
			seriesOptions = series.options;

		// load event handlers on demand to save time on mouseover/out
		if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
			this.importEvents();
		}

		// add default handler if in selection mode
		if (eventType === 'click' && seriesOptions.allowPointSelect) {
			defaultFunction = function (event) {
				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
				point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
			};
		}

		fireEvent(this, eventType, eventArgs, defaultFunction);
	},
	/**
	 * Import events from the series' and point's options. Only do it on
	 * demand, to save processing time on hovering.
	 */
	importEvents: function () {
		if (!this.hasImportedEvents) {
			var point = this,
				options = merge(point.series.options.point, point.options),
				events = options.events,
				eventType;

			point.events = events;

			for (eventType in events) {
				addEvent(point, eventType, events[eventType]);
			}
			this.hasImportedEvents = true;

		}
	},

	/**
	 * Set the point's state
	 * @param {String} state
	 */
	setState: function (state) {
		var point = this,
			plotX = point.plotX,
			plotY = point.plotY,
			series = point.series,
			stateOptions = series.options.states,
			markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
			normalDisabled = markerOptions && !markerOptions.enabled,
			markerStateOptions = markerOptions && markerOptions.states[state],
			stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
			stateMarkerGraphic = series.stateMarkerGraphic,
			chart = series.chart,
			radius,
			pointAttr = point.pointAttr;

		state = state || NORMAL_STATE; // empty string

		if (
				// already has this state
				state === point.state ||
				// selected points don't respond to hover
				(point.selected && state !== SELECT_STATE) ||
				// series' state options is disabled
				(stateOptions[state] && stateOptions[state].enabled === false) ||
				// point marker's state options is disabled
				(state && (stateDisabled || (normalDisabled && !markerStateOptions.enabled)))

			) {
			return;
		}

		// apply hover styles to the existing point
		if (point.graphic) {
			radius = markerOptions && point.graphic.symbolName && pointAttr[state].r;
			point.graphic.attr(merge(
				pointAttr[state],
				radius ? { // new symbol attributes (#507, #612)
					x: plotX - radius,
					y: plotY - radius,
					width: 2 * radius,
					height: 2 * radius
				} : {}
			));
		} else {
			// if a graphic is not applied to each point in the normal state, create a shared
			// graphic for the hover state
			if (state) {
				if (!stateMarkerGraphic) {
					radius = markerOptions.radius;
					series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
						series.symbol,
						-radius,
						-radius,
						2 * radius,
						2 * radius
					)
					.attr(pointAttr[state])
					.add(series.group);
				}

				stateMarkerGraphic.translate(
					plotX,
					plotY
				);
			}

			if (stateMarkerGraphic) {
				stateMarkerGraphic[state ? 'show' : 'hide']();
			}
		}

		point.state = state;
	}
};

/**
 * @classDescription The base function which all other series types inherit from. The data in the series is stored
 * in various arrays.
 *
 * - First, series.options.data contains all the original config options for
 * each point whether added by options or methods like series.addPoint.
 * - Next, series.data contains those values converted to points, but in case the series data length
 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
 * only contains the points that have been created on demand.
 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
 * compared to series.data and series.options.data. If however the series data is grouped, these can't
 * be correlated one to one.
 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
 *
 * @param {Object} chart
 * @param {Object} options
 */
var Series = function () {};

Series.prototype = {

	isCartesian: true,
	type: 'line',
	pointClass: Point,
	sorted: true, // requires the data to be sorted
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'lineColor',
		'stroke-width': 'lineWidth',
		fill: 'fillColor',
		r: 'radius'
	},
	init: function (chart, options) {
		var series = this,
			eventType,
			events,
			//pointEvent,
			index = chart.series.length;

		series.chart = chart;
		series.options = options = series.setOptions(options); // merge with plotOptions
		
		// bind the axes
		series.bindAxes();

		// set some variables
		extend(series, {
			index: index,
			name: options.name || 'Series ' + (index + 1),
			state: NORMAL_STATE,
			pointAttr: {},
			visible: options.visible !== false, // true by default
			selected: options.selected === true // false by default
		});
		
		// special
		if (useCanVG) {
			options.animation = false;
		}

		// register event listeners
		events = options.events;
		for (eventType in events) {
			addEvent(series, eventType, events[eventType]);
		}
		if (
			(events && events.click) ||
			(options.point && options.point.events && options.point.events.click) ||
			options.allowPointSelect
		) {
			chart.runTrackerClick = true;
		}

		series.getColor();
		series.getSymbol();

		// set the data
		series.setData(options.data, false);

	},
	
	
	
	/**
	 * Set the xAxis and yAxis properties of cartesian series, and register the series
	 * in the axis.series array
	 */
	bindAxes: function () {
		var series = this,
			seriesOptions = series.options,
			chart = series.chart,
			axisOptions;
			
		if (series.isCartesian) {
			
			each(['xAxis', 'yAxis'], function (AXIS) { // repeat for xAxis and yAxis
				
				each(chart[AXIS], function (axis) { // loop through the chart's axis objects
					
					axisOptions = axis.options;
					
					// apply if the series xAxis or yAxis option mathches the number of the 
					// axis, or if undefined, use the first axis
					if ((seriesOptions[AXIS] === axisOptions.index) ||
							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {
						
						// register this series in the axis.series lookup
						axis.series.push(series);
						
						// set this series.xAxis or series.yAxis reference
						series[AXIS] = axis;
						
						// mark dirty for redraw
						axis.isDirty = true;
					}
				});
				
			});
		}
	},


	/**
	 * Return an auto incremented x value based on the pointStart and pointInterval options.
	 * This is only used if an x value is not given for the point that calls autoIncrement.
	 */
	autoIncrement: function () {
		var series = this,
			options = series.options,
			xIncrement = series.xIncrement;

		xIncrement = pick(xIncrement, options.pointStart, 0);

		series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);

		series.xIncrement = xIncrement + series.pointInterval;
		return xIncrement;
	},

	/**
	 * Divide the series data into segments divided by null values.
	 */
	getSegments: function () {
		var series = this,
			lastNull = -1,
			segments = [],
			i,
			points = series.points,
			pointsLength = points.length;

		if (pointsLength) { // no action required for []
			
			// if connect nulls, just remove null points
			if (series.options.connectNulls) {
				i = pointsLength;
				while (i--) {
					if (points[i].y === null) {
						points.splice(i, 1);
					}
				}
				if (points.length) {
					segments = [points];
				}
				
			// else, split on null points
			} else {
				each(points, function (point, i) {
					if (point.y === null) {
						if (i > lastNull + 1) {
							segments.push(points.slice(lastNull + 1, i));
						}
						lastNull = i;
					} else if (i === pointsLength - 1) { // last value
						segments.push(points.slice(lastNull + 1, i + 1));
					}
				});
			}
		}
		
		// register it
		series.segments = segments;
	},
	/**
	 * Set the series options by merging from the options tree
	 * @param {Object} itemOptions
	 */
	setOptions: function (itemOptions) {
		var series = this,
			chart = series.chart,
			chartOptions = chart.options,
			plotOptions = chartOptions.plotOptions,
			data = itemOptions.data,
			options;

		itemOptions.data = null; // remove from merge to prevent looping over the data set

		options = merge(
			plotOptions[this.type],
			plotOptions.series,
			itemOptions
		);
		
		// Re-insert the data array to the options and the original config (#717)
		options.data = itemOptions.data = data;
		
		// the tooltip options are merged between global and series specific options
		series.tooltipOptions = merge(chartOptions.tooltip, options.tooltip);
		
		return options;

	},
	/**
	 * Get the series' color
	 */
	getColor: function () {
		var defaultColors = this.chart.options.colors,
			counters = this.chart.counters;
		this.color = this.options.color || defaultColors[counters.color++] || '#0000ff';
		counters.wrapColor(defaultColors.length);
	},
	/**
	 * Get the series' symbol
	 */
	getSymbol: function () {
		var series = this,
			seriesMarkerOption = series.options.marker,
			chart = series.chart,
			defaultSymbols = chart.options.symbols,
			counters = chart.counters;
		series.symbol = seriesMarkerOption.symbol || defaultSymbols[counters.symbol++];
		
		// don't substract radius in image symbols (#604)
		if (/^url/.test(series.symbol)) {
			seriesMarkerOption.radius = 0;
		}
		counters.wrapSymbol(defaultSymbols.length);
	},

	/**
	 * Add a point dynamically after chart load time
	 * @param {Object} options Point options as given in series.data
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean} shift If shift is true, a point is shifted off the start
	 *    of the series as one is appended to the end.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	addPoint: function (options, redraw, shift, animation) {
		var series = this,
			data = series.data,
			graph = series.graph,
			area = series.area,
			chart = series.chart,
			xData = series.xData,
			yData = series.yData,
			currentShift = (graph && graph.shift) || 0,
			dataOptions = series.options.data,
			point;
			//point = (new series.pointClass()).init(series, options);

		setAnimation(animation, chart);

		// Make graph animate sideways
		if (graph && shift) { 
			graph.shift = currentShift + 1;
		}
		if (area) {
			if (shift) { // #780
				area.shift = currentShift + 1;
			}
			area.isArea = true; // needed in animation, both with and without shift
		}
		
		// Optional redraw, defaults to true
		redraw = pick(redraw, true);

		// Get options and push the point to xData, yData and series.options. In series.generatePoints
		// the Point instance will be created on demand and pushed to the series.data array.
		point = { series: series };
		series.pointClass.prototype.applyOptions.apply(point, [options]);
		xData.push(point.x);
		yData.push(series.valueCount === 4 ? [point.open, point.high, point.low, point.close] : point.y);
		dataOptions.push(options);


		// Shift the first point off the parallel arrays
		// todo: consider series.removePoint(i) method
		if (shift) {
			if (data[0] && data[0].remove) {
				data[0].remove(false);
			} else {
				data.shift();
				xData.shift();
				yData.shift();
				dataOptions.shift();
			}
		}
		series.getAttribs();

		// redraw
		series.isDirty = true;
		series.isDirtyData = true;
		if (redraw) {
			chart.redraw();
		}
	},

	/**
	 * Replace the series data with a new set of data
	 * @param {Object} data
	 * @param {Object} redraw
	 */
	setData: function (data, redraw) {
		var series = this,
			oldData = series.points,
			options = series.options,
			initialColor = series.initialColor,
			chart = series.chart,
			firstPoint = null,
			i;

		// reset properties
		series.xIncrement = null;
		series.pointRange = (series.xAxis && series.xAxis.categories && 1) || options.pointRange;
		
		if (defined(initialColor)) { // reset colors for pie
			chart.counters.color = initialColor;
		}
		
		// parallel arrays
		var xData = [],
			yData = [],
			dataLength = data ? data.length : [],
			turboThreshold = options.turboThreshold || 1000,
			pt,
			ohlc = series.valueCount === 4;

		// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
		// first value is tested, and we assume that all the rest are defined the same
		// way. Although the 'for' loops are similar, they are repeated inside each
		// if-else conditional for max performance.
		if (dataLength > turboThreshold) {
			
			// find the first non-null point
			i = 0;
			while (firstPoint === null && i < dataLength) {
				firstPoint = data[i];
				i++;
			}
		
		
			if (isNumber(firstPoint)) { // assume all points are numbers
				var x = pick(options.pointStart, 0),
					pointInterval = pick(options.pointInterval, 1);

				for (i = 0; i < dataLength; i++) {
					xData[i] = x;
					yData[i] = data[i];
					x += pointInterval;
				}
				series.xIncrement = x;
			} else if (isArray(firstPoint)) { // assume all points are arrays
				if (ohlc) { // [x, o, h, l, c]
					for (i = 0; i < dataLength; i++) {
						pt = data[i];
						xData[i] = pt[0];
						yData[i] = pt.slice(1, 5);
					}
				} else { // [x, y]
					for (i = 0; i < dataLength; i++) {
						pt = data[i];
						xData[i] = pt[0];
						yData[i] = pt[1];
					}
				}
			} /* else {
				error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
			}*/
		} else {
			for (i = 0; i < dataLength; i++) {
				pt = { series: series };
				series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
				xData[i] = pt.x;
				yData[i] = ohlc ? [pt.open, pt.high, pt.low, pt.close] : pt.y;
			}
		}

		series.data = [];
		series.options.data = data;
		series.xData = xData;
		series.yData = yData;

		// destroy old points
		i = (oldData && oldData.length) || 0;
		while (i--) {
			if (oldData[i] && oldData[i].destroy) {
				oldData[i].destroy();
			}
		}

		// redraw
		series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
		if (pick(redraw, true)) {
			chart.redraw(false);
		}
	},

	/**
	 * Remove a series and optionally redraw the chart
	 *
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */

	remove: function (redraw, animation) {
		var series = this,
			chart = series.chart;
		redraw = pick(redraw, true);

		if (!series.isRemoving) {  /* prevent triggering native event in jQuery
				(calling the remove function from the remove event) */
			series.isRemoving = true;

			// fire the event with a default handler of removing the point
			fireEvent(series, 'remove', null, function () {


				// destroy elements
				series.destroy();


				// redraw
				chart.isDirtyLegend = chart.isDirtyBox = true;
				if (redraw) {
					chart.redraw(animation);
				}
			});

		}
		series.isRemoving = false;
	},

	/**
	 * Process the data by cropping away unused data points if the series is longer
	 * than the crop threshold. This saves computing time for lage series.
	 */
	processData: function (force) {
		var series = this,
			processedXData = series.xData, // copied during slice operation below
			processedYData = series.yData,
			dataLength = processedXData.length,
			cropStart = 0,
			cropEnd = dataLength,
			cropped,
			distance,
			closestPointRange,
			xAxis = series.xAxis,
			i, // loop variable
			options = series.options,
			cropThreshold = options.cropThreshold,
			isCartesian = series.isCartesian;

		// If the series data or axes haven't changed, don't go through this. Return false to pass
		// the message on to override methods like in data grouping. 
		if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
			return false;
		}

		// optionally filter out points outside the plot area
		if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
			var extremes = xAxis.getExtremes(),
				min = extremes.min,
				max = extremes.max;

			// it's outside current extremes
			if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
				processedXData = [];
				processedYData = [];
			
			// only crop if it's actually spilling out
			} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {

				// iterate up to find slice start
				for (i = 0; i < dataLength; i++) {
					if (processedXData[i] >= min) {
						cropStart = mathMax(0, i - 1);
						break;
					}
				}
				// proceed to find slice end
				for (; i < dataLength; i++) {
					if (processedXData[i] > max) {
						cropEnd = i + 1;
						break;
					}
					
				}
				processedXData = processedXData.slice(cropStart, cropEnd);
				processedYData = processedYData.slice(cropStart, cropEnd);
				cropped = true;
			}
		}
		
		
		// Find the closest distance between processed points
		for (i = processedXData.length - 1; i > 0; i--) {
			distance = processedXData[i] - processedXData[i - 1];
			if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
				closestPointRange = distance;
			}
		}
		
		// Record the properties
		series.cropped = cropped; // undefined or true
		series.cropStart = cropStart;
		series.processedXData = processedXData;
		series.processedYData = processedYData;
		
		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
			series.pointRange = closestPointRange || 1;
		}
		series.closestPointRange = closestPointRange;
		
	},

	/**
	 * Generate the data point after the data has been processed by cropping away
	 * unused points and optionally grouped in Highcharts Stock.
	 */
	generatePoints: function () {
		var series = this,
			options = series.options,
			dataOptions = options.data,
			data = series.data,
			dataLength,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			pointClass = series.pointClass,
			processedDataLength = processedXData.length,
			cropStart = series.cropStart || 0,
			cursor,
			hasGroupedData = series.hasGroupedData,
			point,
			points = [],
			i;

		if (!data && !hasGroupedData) {
			var arr = [];
			arr.length = dataOptions.length;
			data = series.data = arr;
		}

		for (i = 0; i < processedDataLength; i++) {
			cursor = cropStart + i;
			if (!hasGroupedData) {
				if (data[cursor]) {
					point = data[cursor];
				} else {
					data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
				}
				points[i] = point;
			} else {
				// splat the y data in case of ohlc data array
				points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
			}
		}

		// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
		// swithching view from non-grouped data to grouped data (#637)	
		if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
			for (i = 0; i < dataLength; i++) {
				if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
					i += processedDataLength;
				}
				if (data[i]) {
					data[i].destroyElements();
				}
			}
		}

		series.data = data;
		series.points = points;
	},

	/**
	 * Translate data points from raw data values to chart specific positioning data
	 * needed later in drawPoints, drawGraph and drawTracker.
	 */
	translate: function () {
		if (!this.processedXData) { // hidden series
			this.processData();
		}
		this.generatePoints();
		var series = this,
			chart = series.chart,
			options = series.options,
			stacking = options.stacking,
			xAxis = series.xAxis,
			categories = xAxis.categories,
			yAxis = series.yAxis,
			points = series.points,
			dataLength = points.length,
			hasModifyValue = !!series.modifyValue,
			isLastSeries,
			allStackSeries = yAxis.series,
			i = allStackSeries.length;
			
		// Is it the last visible series?
		while (i--) {
			if (allStackSeries[i].visible) {
				if (i === series.index) {
					isLastSeries = true;
				}
				break;
			}
		}
		
		// Translate each point
		for (i = 0; i < dataLength; i++) {
			var point = points[i],
				xValue = point.x,
				yValue = point.y,
				yBottom = point.low,
				stack = yAxis.stacks[(yValue < options.threshold ? '-' : '') + series.stackKey],
				pointStack,
				pointStackTotal;
				
			// get the plotX translation
			point.plotX = mathRound(xAxis.translate(xValue, 0, 0, 0, 1) * 10) / 10; // Math.round fixes #591

			// calculate the bottom y value for stacked series
			if (stacking && series.visible && stack && stack[xValue]) {
				pointStack = stack[xValue];
				pointStackTotal = pointStack.total;
				pointStack.cum = yBottom = pointStack.cum - yValue; // start from top
				yValue = yBottom + yValue;
				
				if (isLastSeries) {
					yBottom = options.threshold;
				}
				
				if (stacking === 'percent') {
					yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
					yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
				}

				point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
				point.stackTotal = pointStackTotal;
				point.stackY = yValue;
			}

			// Set translated yBottom or remove it
			point.yBottom = defined(yBottom) ? 
				yAxis.translate(yBottom, 0, 1, 0, 1) :
				null;
			
			// general hook, used for Highstock compare mode
			if (hasModifyValue) {
				yValue = series.modifyValue(yValue, point);
			}

			// Set the the plotY value, reset it for redraws
			point.plotY = (typeof yValue === 'number') ? 
				mathRound(yAxis.translate(yValue, 0, 1, 0, 1) * 10) / 10 : // Math.round fixes #591
				UNDEFINED;

			// set client related positions for mouse tracking
			point.clientX = chart.inverted ?
				chart.plotHeight - point.plotX :
				point.plotX; // for mouse tracking

			// some API data
			point.category = categories && categories[point.x] !== UNDEFINED ?
				categories[point.x] : point.x;


		}

		// now that we have the cropped data, build the segments
		series.getSegments();
	},
	/**
	 * Memoize tooltip texts and positions
	 */
	setTooltipPoints: function (renew) {
		var series = this,
			chart = series.chart,
			inverted = chart.inverted,
			points = [],
			pointsLength,
			plotSize = mathRound((inverted ? chart.plotTop : chart.plotLeft) + chart.plotSizeX),
			low,
			high,
			xAxis = series.xAxis,
			point,
			i,
			tooltipPoints = []; // a lookup array for each pixel in the x dimension

		// don't waste resources if tracker is disabled
		if (series.options.enableMouseTracking === false) {
			return;
		}

		// renew
		if (renew) {
			series.tooltipPoints = null;
		}

		// concat segments to overcome null values
		each(series.segments || series.points, function (segment) {
			points = points.concat(segment);
		});

		// loop the concatenated points and apply each point to all the closest
		// pixel positions
		if (xAxis && xAxis.reversed) {
			points = points.reverse();//reverseArray(points);
		}

		//each(points, function (point, i) {
		pointsLength = points.length;
		for (i = 0; i < pointsLength; i++) {
			point = points[i];
			low = points[i - 1] ? points[i - 1]._high + 1 : 0;
			high = point._high = points[i + 1] ?
				(mathFloor((point.plotX + (points[i + 1] ? points[i + 1].plotX : plotSize)) / 2)) :
				plotSize;

			while (low <= high) {
				tooltipPoints[inverted ? plotSize - low++ : low++] = point;
			}
		}
		series.tooltipPoints = tooltipPoints;
	},

	/**
	 * Format the header of the tooltip
	 */
	tooltipHeaderFormatter: function (key) {
		var series = this,
			tooltipOptions = series.tooltipOptions,
			xDateFormat = tooltipOptions.xDateFormat || '%A, %b %e, %Y',
			xAxis = series.xAxis,
			isDateTime = xAxis && xAxis.options.type === 'datetime';
		
		return tooltipOptions.headerFormat
			.replace('{point.key}', isDateTime ? dateFormat(xDateFormat, key) :  key)
			.replace('{series.name}', series.name)
			.replace('{series.color}', series.color);
	},

	/**
	 * Series mouse over handler
	 */
	onMouseOver: function () {
		var series = this,
			chart = series.chart,
			hoverSeries = chart.hoverSeries;

		if (!hasTouch && chart.mouseIsDown) {
			return;
		}

		// set normal state to previous series
		if (hoverSeries && hoverSeries !== series) {
			hoverSeries.onMouseOut();
		}

		// trigger the event, but to save processing time,
		// only if defined
		if (series.options.events.mouseOver) {
			fireEvent(series, 'mouseOver');
		}

		// hover this
		series.setState(HOVER_STATE);
		chart.hoverSeries = series;
	},

	/**
	 * Series mouse out handler
	 */
	onMouseOut: function () {
		// trigger the event only if listeners exist
		var series = this,
			options = series.options,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		// trigger mouse out on the point, which must be in this series
		if (hoverPoint) {
			hoverPoint.onMouseOut();
		}

		// fire the mouse out event
		if (series && options.events.mouseOut) {
			fireEvent(series, 'mouseOut');
		}


		// hide the tooltip
		if (tooltip && !options.stickyTracking && !tooltip.shared) {
			tooltip.hide();
		}

		// set normal state
		series.setState();
		chart.hoverSeries = null;
	},

	/**
	 * Animate in the series
	 */
	animate: function (init) {
		var series = this,
			chart = series.chart,
			clipRect = series.clipRect,
			animation = series.options.animation;

		if (animation && !isObject(animation)) {
			animation = {};
		}

		if (init) { // initialize the animation
			if (!clipRect.isAnimating) { // apply it only for one of the series
				clipRect.attr('width', 0);
				clipRect.isAnimating = true;
			}

		} else { // run the animation
			clipRect.animate({
				width: chart.plotSizeX
			}, animation);

			// delete this function to allow it only once
			this.animate = null;
		}
	},


	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			pointAttr,
			points = series.points,
			chart = series.chart,
			plotX,
			plotY,
			i,
			point,
			radius,
			symbol,
			isImage,
			graphic;

		if (series.options.marker.enabled) {
			i = points.length;
			while (i--) {
				point = points[i];
				plotX = point.plotX;
				plotY = point.plotY;
				graphic = point.graphic;

				// only draw the point if y is defined
				if (plotY !== UNDEFINED && !isNaN(plotY)) {

					// shortcuts
					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
					radius = pointAttr.r;
					symbol = pick(point.marker && point.marker.symbol, series.symbol);
					isImage = symbol.indexOf('url') === 0;

					if (graphic) { // update
						graphic.animate(extend({
							x: plotX - radius,
							y: plotY - radius
						}, graphic.symbolName ? { // don't apply to image symbols #507
							width: 2 * radius,
							height: 2 * radius
						} : {}));
					} else if (radius > 0 || isImage) {
						point.graphic = chart.renderer.symbol(
							symbol,
							plotX - radius,
							plotY - radius,
							2 * radius,
							2 * radius
						)
						.attr(pointAttr)
						.add(series.group);
					}
				}
			}
		}

	},

	/**
	 * Convert state properties from API naming conventions to SVG attributes
	 *
	 * @param {Object} options API options object
	 * @param {Object} base1 SVG attribute object to inherit from
	 * @param {Object} base2 Second level SVG attribute object to inherit from
	 */
	convertAttribs: function (options, base1, base2, base3) {
		var conversion = this.pointAttrToOptions,
			attr,
			option,
			obj = {};

		options = options || {};
		base1 = base1 || {};
		base2 = base2 || {};
		base3 = base3 || {};

		for (attr in conversion) {
			option = conversion[attr];
			obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
		}
		return obj;
	},

	/**
	 * Get the state attributes. Each series type has its own set of attributes
	 * that are allowed to change on a point's state change. Series wide attributes are stored for
	 * all series, and additionally point specific attributes are stored for all
	 * points with individual marker options. If such options are not defined for the point,
	 * a reference to the series wide attributes is stored in point.pointAttr.
	 */
	getAttribs: function () {
		var series = this,
			normalOptions = defaultPlotOptions[series.type].marker ? series.options.marker : series.options,
			stateOptions = normalOptions.states,
			stateOptionsHover = stateOptions[HOVER_STATE],
			pointStateOptionsHover,
			seriesColor = series.color,
			normalDefaults = {
				stroke: seriesColor,
				fill: seriesColor
			},
			points = series.points,
			i,
			point,
			seriesPointAttr = [],
			pointAttr,
			pointAttrToOptions = series.pointAttrToOptions,
			hasPointSpecificOptions,
			key;

		// series type specific modifications
		if (series.options.marker) { // line, spline, area, areaspline, scatter

			// if no hover radius is given, default to normal radius + 2
			stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
			stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;

		} else { // column, bar, pie

			// if no hover color is given, brighten the normal color
			stateOptionsHover.color = stateOptionsHover.color ||
				Color(stateOptionsHover.color || seriesColor)
					.brighten(stateOptionsHover.brightness).get();
		}

		// general point attributes for the series normal state
		seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

		// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
		each([HOVER_STATE, SELECT_STATE], function (state) {
			seriesPointAttr[state] =
					series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
		});

		// set it
		series.pointAttr = seriesPointAttr;


		// Generate the point-specific attribute collections if specific point
		// options are given. If not, create a referance to the series wide point
		// attributes
		i = points.length;
		while (i--) {
			point = points[i];
			normalOptions = (point.options && point.options.marker) || point.options;
			if (normalOptions && normalOptions.enabled === false) {
				normalOptions.radius = 0;
			}
			hasPointSpecificOptions = false;

			// check if the point has specific visual options
			if (point.options) {
				for (key in pointAttrToOptions) {
					if (defined(normalOptions[pointAttrToOptions[key]])) {
						hasPointSpecificOptions = true;
					}
				}
			}



			// a specific marker config object is defined for the individual point:
			// create it's own attribute collection
			if (hasPointSpecificOptions) {

				pointAttr = [];
				stateOptions = normalOptions.states || {}; // reassign for individual point
				pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

				// if no hover color is given, brighten the normal color
				if (!series.options.marker) { // column, bar, point
					pointStateOptionsHover.color =
						Color(pointStateOptionsHover.color || point.options.color)
							.brighten(pointStateOptionsHover.brightness ||
								stateOptionsHover.brightness).get();

				}

				// normal point state inherits series wide normal state
				pointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, seriesPointAttr[NORMAL_STATE]);

				// inherit from point normal and series hover
				pointAttr[HOVER_STATE] = series.convertAttribs(
					stateOptions[HOVER_STATE],
					seriesPointAttr[HOVER_STATE],
					pointAttr[NORMAL_STATE]
				);
				// inherit from point normal and series hover
				pointAttr[SELECT_STATE] = series.convertAttribs(
					stateOptions[SELECT_STATE],
					seriesPointAttr[SELECT_STATE],
					pointAttr[NORMAL_STATE]
				);



			// no marker config object is created: copy a reference to the series-wide
			// attribute collection
			} else {
				pointAttr = seriesPointAttr;
			}

			point.pointAttr = pointAttr;

		}

	},


	/**
	 * Clear DOM objects and free up memory
	 */
	destroy: function () {
		var series = this,
			chart = series.chart,
			seriesClipRect = series.clipRect,
			issue134 = /AppleWebKit\/533/.test(userAgent),
			destroy,
			i,
			data = series.data || [],
			point,
			prop,
			axis;

		// add event hook
		fireEvent(series, 'destroy');

		// remove all events
		removeEvent(series);
		
		// erase from axes
		each(['xAxis', 'yAxis'], function (AXIS) {
			axis = series[AXIS];
			if (axis) {
				erase(axis.series, series);
				axis.isDirty = true;
			}
		});

		// remove legend items
		if (series.legendItem) {
			series.chart.legend.destroyItem(series);
		}

		// destroy all points with their elements
		i = data.length;
		while (i--) {
			point = data[i];
			if (point && point.destroy) {
				point.destroy();
			}
		}
		series.points = null;

		// If this series clipRect is not the global one (which is removed on chart.destroy) we
		// destroy it here.
		if (seriesClipRect && seriesClipRect !== chart.clipRect) {
			series.clipRect = seriesClipRect.destroy();
		}

		// destroy all SVGElements associated to the series
		each(['area', 'graph', 'dataLabelsGroup', 'group', 'tracker'], function (prop) {
			if (series[prop]) {

				// issue 134 workaround
				destroy = issue134 && prop === 'group' ?
					'hide' :
					'destroy';

				series[prop][destroy]();
			}
		});

		// remove from hoverSeries
		if (chart.hoverSeries === series) {
			chart.hoverSeries = null;
		}
		erase(chart.series, series);

		// clear all members
		for (prop in series) {
			delete series[prop];
		}
	},

	/**
	 * Draw the data labels
	 */
	drawDataLabels: function () {
		
		var series = this,
			seriesOptions = series.options,
			options = seriesOptions.dataLabels;
		
		if (options.enabled || series._hasPointLabels) {
			var x,
				y,
				points = series.points,
				pointOptions,
				generalOptions,
				str,
				dataLabelsGroup = series.dataLabelsGroup,
				chart = series.chart,
				xAxis = series.xAxis,
				groupLeft = xAxis ? xAxis.left : chart.plotLeft,
				yAxis = series.yAxis,
				groupTop = yAxis ? yAxis.top : chart.plotTop,
				renderer = chart.renderer,
				inverted = chart.inverted,
				seriesType = series.type,
				stacking = seriesOptions.stacking,
				isBarLike = seriesType === 'column' || seriesType === 'bar',
				vAlignIsNull = options.verticalAlign === null,
				yIsNull = options.y === null,
				fontMetrics = renderer.fontMetrics(options.style.fontSize), // height and baseline
				fontLineHeight = fontMetrics.h,
				fontBaseline = fontMetrics.b,
				dataLabel,
				enabled;

			if (isBarLike) {
				var defaultYs = {
					top: fontBaseline, 
					middle: fontBaseline - fontLineHeight / 2, 
					bottom: -fontLineHeight + fontBaseline
				};
				if (stacking) {
					// In stacked series the default label placement is inside the bars
					if (vAlignIsNull) {
						options = merge(options, {verticalAlign: 'middle'});
					}

					// If no y delta is specified, try to create a good default
					if (yIsNull) {
						options = merge(options, { y: defaultYs[options.verticalAlign]});
					}
				} else {
					// In non stacked series the default label placement is on top of the bars
					if (vAlignIsNull) {
						options = merge(options, {verticalAlign: 'top'});
					
					// If no y delta is specified, try to create a good default (like default bar)
					} else if (yIsNull) {
						options = merge(options, { y: defaultYs[options.verticalAlign]});
					}
					
				}
			}


			// create a separate group for the data labels to avoid rotation
			if (!dataLabelsGroup) {
				dataLabelsGroup = series.dataLabelsGroup =
					renderer.g('data-labels')
						.attr({
							visibility: series.visible ? VISIBLE : HIDDEN,
							zIndex: 6
						})
						.translate(groupLeft, groupTop)
						.add();
			} else {
				dataLabelsGroup.translate(groupLeft, groupTop);
			}
			
			// make the labels for each point
			generalOptions = options;
			each(points, function (point) {
				
				dataLabel = point.dataLabel;
				
				// Merge in individual options from point
				options = generalOptions; // reset changes from previous points
				pointOptions = point.options;
				if (pointOptions && pointOptions.dataLabels) {
					options = merge(options, pointOptions.dataLabels);
				}
				enabled = options.enabled;
				
				// Get the positions
				if (enabled) {
					var plotX = (point.barX && point.barX + point.barW / 2) || pick(point.plotX, -999),
						plotY = pick(point.plotY, -999),
						
						// if options.y is null, which happens by default on column charts, set the position
						// above or below the column depending on the threshold
						individualYDelta = options.y === null ? 
							(point.y >= seriesOptions.threshold ? 
								-fontLineHeight + fontBaseline : // below the threshold 
								fontBaseline) : // above the threshold
							options.y;
					
					x = (inverted ? chart.plotWidth - plotY : plotX) + options.x;
					y = mathRound((inverted ? chart.plotHeight - plotX : plotY) + individualYDelta);
					
				}
				
				// If the point is outside the plot area, destroy it. #678, #820
				if (dataLabel && series.isCartesian && (!chart.isInsidePlot(x, y) || !enabled)) {
					point.dataLabel = dataLabel.destroy();
				
				// Individual labels are disabled if the are explicitly disabled 
				// in the point options, or if they fall outside the plot area.
				} else if (enabled) {
					
					var align = options.align;
				
					// Get the string
					str = options.formatter.call(point.getLabelConfig(), options);
					
					// in columns, align the string to the column
					if (seriesType === 'column') {
						x += { left: -1, right: 1 }[align] * point.barW / 2 || 0;
					}
	
					if (!stacking && inverted && point.y < 0) {
						align = 'right';
						x -= 10;
					}
					
					// Determine the color
					options.style.color = pick(options.color, options.style.color, series.color, 'black');
	
					
					// update existing label
					if (dataLabel) {
						// vertically centered
						dataLabel
							.attr({
								text: str
							}).animate({
								x: x,
								y: y
							});
					// create new label
					} else if (defined(str)) {
						dataLabel = point.dataLabel = renderer[options.rotation ? 'text' : 'label']( // labels don't support rotation
							str,
							x,
							y,
							null,
							null,
							null,
							options.useHTML,
							true // baseline for backwards compat
						)
						.attr({
							align: align,
							fill: options.backgroundColor,
							stroke: options.borderColor,
							'stroke-width': options.borderWidth,
							r: options.borderRadius,
							rotation: options.rotation,
							padding: options.padding,
							zIndex: 1
						})
						.css(options.style)
						.add(dataLabelsGroup)
						.shadow(options.shadow);
					}
	
					if (isBarLike && seriesOptions.stacking && dataLabel) {
						var barX = point.barX,
							barY = point.barY,
							barW = point.barW,
							barH = point.barH;
	
						dataLabel.align(options, null,
							{
								x: inverted ? chart.plotWidth - barY - barH : barX,
								y: inverted ? chart.plotHeight - barX - barW : barY,
								width: inverted ? barH : barW,
								height: inverted ? barW : barH
							});
					}
					
					
				}
			});
		}
	},

	/**
	 * Draw the actual graph
	 */
	drawGraph: function () {
		var series = this,
			options = series.options,
			chart = series.chart,
			graph = series.graph,
			graphPath = [],
			fillColor,
			area = series.area,
			group = series.group,
			color = options.lineColor || series.color,
			lineWidth = options.lineWidth,
			dashStyle =  options.dashStyle,
			segmentPath,
			renderer = chart.renderer,
			translatedThreshold = series.yAxis.getThreshold(options.threshold),
			useArea = /^area/.test(series.type),
			singlePoints = [], // used in drawTracker
			areaPath = [],
			attribs;


		// divide into segments and build graph and area paths
		each(series.segments, function (segment) {
			segmentPath = [];

			// build the segment line
			each(segment, function (point, i) {

				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

				} else {

					// moveTo or lineTo
					segmentPath.push(i ? L : M);

					// step line?
					if (i && options.step) {
						var lastPoint = segment[i - 1];
						segmentPath.push(
							point.plotX,
							lastPoint.plotY
						);
					}

					// normal line to next point
					segmentPath.push(
						point.plotX,
						point.plotY
					);
				}
			});

			// add the segment to the graph, or a single point for tracking
			if (segment.length > 1) {
				graphPath = graphPath.concat(segmentPath);
			} else {
				singlePoints.push(segment[0]);
			}

			// build the area
			if (useArea) {
				var areaSegmentPath = [],
					i,
					segLength = segmentPath.length;
				for (i = 0; i < segLength; i++) {
					areaSegmentPath.push(segmentPath[i]);
				}
				if (segLength === 3) { // for animation from 1 to two points
					areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
				}
				if (options.stacking && series.type !== 'areaspline') {
					
					// Follow stack back. Todo: implement areaspline. A general solution could be to 
					// reverse the entire graphPath of the previous series, though may be hard with
					// splines and with series with different extremes
					for (i = segment.length - 1; i >= 0; i--) {
					
						// step line?
						if (i < segment.length - 1 && options.step) {
							areaSegmentPath.push(segment[i + 1].plotX, segment[i].yBottom);
						}
						
						areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
					}

				} else { // follow zero line back
					areaSegmentPath.push(
						L,
						segment[segment.length - 1].plotX,
						translatedThreshold,
						L,
						segment[0].plotX,
						translatedThreshold
					);
				}
				areaPath = areaPath.concat(areaSegmentPath);
			}
		});

		// used in drawTracker:
		series.graphPath = graphPath;
		series.singlePoints = singlePoints;

		// draw the area if area series or areaspline
		if (useArea) {
			fillColor = pick(
				options.fillColor,
				Color(series.color).setOpacity(options.fillOpacity || 0.75).get()
			);
			if (area) {
				area.animate({ d: areaPath });

			} else {
				// draw the area
				series.area = series.chart.renderer.path(areaPath)
					.attr({
						fill: fillColor
					}).add(group);
			}
		}

		// draw the graph
		if (graph) {
			stop(graph); // cancel running animations, #459
			graph.animate({ d: graphPath });

		} else {
			if (lineWidth) {
				attribs = {
					'stroke': color,
					'stroke-width': lineWidth
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}

				series.graph = renderer.path(graphPath)
					.attr(attribs).add(group).shadow(options.shadow);
			}
		}
	},

	/**
	 * Initialize and perform group inversion on series.group and series.trackerGroup
	 */
	invertGroups: function () {
		var series = this,
			group = series.group,
			trackerGroup = series.trackerGroup,
			chart = series.chart;
		
		// A fixed size is needed for inversion to work
		function setInvert() {			
			var size = {
				width: series.yAxis.len,
				height: series.xAxis.len
			};
			
			// Set the series.group size
			group.attr(size).invert();
			
			// Set the tracker group size
			if (trackerGroup) {
				trackerGroup.attr(size).invert();
			}
		}

		addEvent(chart, 'resize', setInvert); // do it on resize
		addEvent(series, 'destroy', function () {
			removeEvent(chart, 'resize', setInvert);
		});

		// Do it now
		setInvert(); // do it now
		
		// On subsequent render and redraw, just do setInvert without setting up events again
		series.invertGroups = setInvert;
	},

	/**
	 * Render the graph and markers
	 */
	render: function () {
		var series = this,
			chart = series.chart,
			group,
			options = series.options,
			doClip = options.clip !== false,
			animation = options.animation,
			doAnimation = animation && series.animate,
			duration = doAnimation ? (animation && animation.duration) || 500 : 0,
			clipRect = series.clipRect,
			renderer = chart.renderer;


		// Add plot area clipping rectangle. If this is before chart.hasRendered,
		// create one shared clipRect.

		// Todo: since creating the clip property, the clipRect is created but
		// never used when clip is false. A better way would be that the animation
		// would run, then the clipRect destroyed.
		if (!clipRect) {
			clipRect = series.clipRect = !chart.hasRendered && chart.clipRect ?
				chart.clipRect :
				renderer.clipRect(0, 0, chart.plotSizeX, chart.plotSizeY + 1);
			if (!chart.clipRect) {
				chart.clipRect = clipRect;
			}
		}
		

		// the group
		if (!series.group) {
			group = series.group = renderer.g('series');

			group.attr({
					visibility: series.visible ? VISIBLE : HIDDEN,
					zIndex: options.zIndex
				})
				.translate(series.xAxis.left, series.yAxis.top)
				.add(chart.seriesGroup);
		}

		series.drawDataLabels();

		// initiate the animation
		if (doAnimation) {
			series.animate(true);
		}

		// cache attributes for shapes
		series.getAttribs();

		// draw the graph if any
		if (series.drawGraph) {
			series.drawGraph();
		}

		// draw the points
		series.drawPoints();

		// draw the mouse tracking area
		if (series.options.enableMouseTracking !== false) {
			series.drawTracker();
		}
		
		// Handle inverted series and tracker groups
		if (chart.inverted) {
			series.invertGroups();
		}
		
		// Do the initial clipping. This must be done after inverting for VML.
		if (doClip && !series.hasRendered) {
			group.clip(clipRect);
			if (series.trackerGroup) {
				series.trackerGroup.clip(chart.clipRect);
			}
		}
			

		// run the animation
		if (doAnimation) {
			series.animate();
		}

		// finish the individual clipRect
		setTimeout(function () {
			clipRect.isAnimating = false;
			group = series.group; // can be destroyed during the timeout
			if (group && clipRect !== chart.clipRect && clipRect.renderer) {
				if (doClip) {
					group.clip((series.clipRect = chart.clipRect));
				}
				clipRect.destroy();
			}
		}, duration);

		series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		series.hasRendered = true;
	},

	/**
	 * Redraw the series after an update in the axes.
	 */
	redraw: function () {
		var series = this,
			chart = series.chart,
			wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
			group = series.group;

		// reposition on resize
		if (group) {
			if (chart.inverted) {
				group.attr({
					width: chart.plotWidth,
					height: chart.plotHeight
				});
			}

			group.animate({
				translateX: series.xAxis.left,
				translateY: series.yAxis.top
			});
		}

		series.translate();
		series.setTooltipPoints(true);

		series.render();
		if (wasDirtyData) {
			fireEvent(series, 'updatedData');
		}
	},

	/**
	 * Set the state of the graph
	 */
	setState: function (state) {
		var series = this,
			options = series.options,
			graph = series.graph,
			stateOptions = options.states,
			lineWidth = options.lineWidth;

		state = state || NORMAL_STATE;

		if (series.state !== state) {
			series.state = state;

			if (stateOptions[state] && stateOptions[state].enabled === false) {
				return;
			}

			if (state) {
				lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
			}

			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
				graph.attr({ // use attr because animate will cause any other animation on the graph to stop
					'stroke-width': lineWidth
				}, state ? 0 : 500);
			}
		}
	},

	/**
	 * Set the visibility of the graph
	 *
	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
	 *        the visibility is toggled.
	 */
	setVisible: function (vis, redraw) {
		var series = this,
			chart = series.chart,
			legendItem = series.legendItem,
			seriesGroup = series.group,
			seriesTracker = series.tracker,
			dataLabelsGroup = series.dataLabelsGroup,
			showOrHide,
			i,
			points = series.points,
			point,
			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
			oldVisibility = series.visible;

		// if called without an argument, toggle visibility
		series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
		showOrHide = vis ? 'show' : 'hide';

		// show or hide series
		if (seriesGroup) { // pies don't have one
			seriesGroup[showOrHide]();
		}

		// show or hide trackers
		if (seriesTracker) {
			seriesTracker[showOrHide]();
		} else if (points) {
			i = points.length;
			while (i--) {
				point = points[i];
				if (point.tracker) {
					point.tracker[showOrHide]();
				}
			}
		}


		if (dataLabelsGroup) {
			dataLabelsGroup[showOrHide]();
		}

		if (legendItem) {
			chart.legend.colorizeItem(series, vis);
		}


		// rescale or adapt to resized chart
		series.isDirty = true;
		// in a stack, all other series are affected
		if (series.options.stacking) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.options.stacking && otherSeries.visible) {
					otherSeries.isDirty = true;
				}
			});
		}

		if (ignoreHiddenSeries) {
			chart.isDirtyBox = true;
		}
		if (redraw !== false) {
			chart.redraw();
		}

		fireEvent(series, showOrHide);
	},

	/**
	 * Show the graph
	 */
	show: function () {
		this.setVisible(true);
	},

	/**
	 * Hide the graph
	 */
	hide: function () {
		this.setVisible(false);
	},


	/**
	 * Set the selected state of the graph
	 *
	 * @param selected {Boolean} True to select the series, false to unselect. If
	 *        UNDEFINED, the selection state is toggled.
	 */
	select: function (selected) {
		var series = this;
		// if called without an argument, toggle
		series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

		if (series.checkbox) {
			series.checkbox.checked = selected;
		}

		fireEvent(series, selected ? 'select' : 'unselect');
	},

	/**
	 * Create a group that holds the tracking object or objects. This allows for
	 * individual clipping and placement of each series tracker.
	 */
	drawTrackerGroup: function () {
		var trackerGroup = this.trackerGroup,
			chart = this.chart;
		
		if (this.isCartesian) {
		
			// Generate it on first call
			if (!trackerGroup) {	
				this.trackerGroup = trackerGroup = chart.renderer.g()
					.attr({
						zIndex: this.options.zIndex || 1
					})
					.add(chart.trackerGroup);
					
			}
			// Place it on first and subsequent (redraw) calls
			trackerGroup.translate(this.xAxis.left, this.yAxis.top);
			
		}
		
		return trackerGroup;
	},
	
	/**
	 * Draw the tracker object that sits above all data labels and markers to
	 * track mouse events on the graph or points. For the line type charts
	 * the tracker uses the same graphPath, but with a greater stroke width
	 * for better control.
	 */
	drawTracker: function () {
		var series = this,
			options = series.options,
			trackerPath = [].concat(series.graphPath),
			trackerPathLength = trackerPath.length,
			chart = series.chart,
			renderer = chart.renderer,
			snap = chart.options.tooltip.snap,
			tracker = series.tracker,
			cursor = options.cursor,
			css = cursor && { cursor: cursor },
			singlePoints = series.singlePoints,
			trackerGroup = series.drawTrackerGroup(),
			singlePoint,
			i;

		// Extend end points. A better way would be to use round linecaps,
		// but those are not clickable in VML.
		if (trackerPathLength) {
			i = trackerPathLength + 1;
			while (i--) {
				if (trackerPath[i] === M) { // extend left side
					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
				}
				if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
					trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
				}
			}
		}

		// handle single points
		for (i = 0; i < singlePoints.length; i++) {
			singlePoint = singlePoints[i];
			trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
				L, singlePoint.plotX + snap, singlePoint.plotY);
		}
		
		

		// draw the tracker
		if (tracker) {
			tracker.attr({ d: trackerPath });

		} else { // create
				
			series.tracker = renderer.path(trackerPath)
				.attr({
					isTracker: true,
					stroke: TRACKER_FILL,
					fill: NONE,
					'stroke-linejoin': 'bevel',
					'stroke-width' : options.lineWidth + 2 * snap,
					visibility: series.visible ? VISIBLE : HIDDEN
				})
				.on(hasTouch ? 'touchstart' : 'mouseover', function () {
					if (chart.hoverSeries !== series) {
						series.onMouseOver();
					}
				})
				.on('mouseout', function () {
					if (!options.stickyTracking) {
						series.onMouseOut();
					}
				})
				.css(css)
				.add(trackerGroup);
		}

	}

}; // end Series prototype


/**
 * LineSeries object
 */
var LineSeries = extendClass(Series);
seriesTypes.line = LineSeries;

/**
 * AreaSeries object
 */
var AreaSeries = extendClass(Series, {
	type: 'area'
});
seriesTypes.area = AreaSeries;




/**
 * SplineSeries object
 */
var SplineSeries = extendClass(Series, {
	type: 'spline',

	/**
	 * Draw the actual graph
	 */
	getPointSpline: function (segment, point, i) {
		var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
			denom = smoothing + 1,
			plotX = point.plotX,
			plotY = point.plotY,
			lastPoint = segment[i - 1],
			nextPoint = segment[i + 1],
			leftContX,
			leftContY,
			rightContX,
			rightContY,
			ret;

		// find control points
		if (i && i < segment.length - 1) {
			var lastX = lastPoint.plotX,
				lastY = lastPoint.plotY,
				nextX = nextPoint.plotX,
				nextY = nextPoint.plotY,
				correction;

			leftContX = (smoothing * plotX + lastX) / denom;
			leftContY = (smoothing * plotY + lastY) / denom;
			rightContX = (smoothing * plotX + nextX) / denom;
			rightContY = (smoothing * plotY + nextY) / denom;

			// have the two control points make a straight line through main point
			correction = ((rightContY - leftContY) * (rightContX - plotX)) /
				(rightContX - leftContX) + plotY - rightContY;

			leftContY += correction;
			rightContY += correction;

			// to prevent false extremes, check that control points are between
			// neighbouring points' y values
			if (leftContY > lastY && leftContY > plotY) {
				leftContY = mathMax(lastY, plotY);
				rightContY = 2 * plotY - leftContY; // mirror of left control point
			} else if (leftContY < lastY && leftContY < plotY) {
				leftContY = mathMin(lastY, plotY);
				rightContY = 2 * plotY - leftContY;
			}
			if (rightContY > nextY && rightContY > plotY) {
				rightContY = mathMax(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			} else if (rightContY < nextY && rightContY < plotY) {
				rightContY = mathMin(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			}

			// record for drawing in next point
			point.rightContX = rightContX;
			point.rightContY = rightContY;

		}

		// moveTo or lineTo
		if (!i) {
			ret = [M, plotX, plotY];
		} else { // curve from last point to this
			ret = [
				'C',
				lastPoint.rightContX || lastPoint.plotX,
				lastPoint.rightContY || lastPoint.plotY,
				leftContX || plotX,
				leftContY || plotY,
				plotX,
				plotY
			];
			lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
		}
		return ret;
	}
});
seriesTypes.spline = SplineSeries;



/**
 * AreaSplineSeries object
 */
var AreaSplineSeries = extendClass(SplineSeries, {
	type: 'areaspline'
});
seriesTypes.areaspline = AreaSplineSeries;

/**
 * ColumnSeries object
 */
var ColumnSeries = extendClass(Series, {
	type: 'column',
	tooltipOutsidePlot: true,
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		'stroke-width': 'borderWidth',
		fill: 'color',
		r: 'borderRadius'
	},
	init: function () {
		Series.prototype.init.apply(this, arguments);

		var series = this,
			chart = series.chart;

		// if the series is added dynamically, force redraw of other
		// series affected by a new column
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}
	},

	/**
	 * Translate each point to the plot area coordinate system and find shape positions
	 */
	translate: function () {
		var series = this,
			chart = series.chart,
			options = series.options,
			stacking = options.stacking,
			borderWidth = options.borderWidth,
			columnCount = 0,
			xAxis = series.xAxis,
			reversedXAxis = xAxis.reversed,
			stackGroups = {},
			stackKey,
			columnIndex;

		Series.prototype.translate.apply(series);

		// Get the total number of column type series.
		// This is called on every series. Consider moving this logic to a
		// chart.orderStacks() function and call it on init, addSeries and removeSeries
		each(chart.series, function (otherSeries) {
			if (otherSeries.type === series.type && otherSeries.visible &&
					series.options.group === otherSeries.options.group) { // used in Stock charts navigator series
				if (otherSeries.options.stacking) {
					stackKey = otherSeries.stackKey;
					if (stackGroups[stackKey] === UNDEFINED) {
						stackGroups[stackKey] = columnCount++;
					}
					columnIndex = stackGroups[stackKey];
				} else {
					columnIndex = columnCount++;
				}
				otherSeries.columnIndex = columnIndex;
			}
		});

		// calculate the width and position of each column based on
		// the number of column series in the plot, the groupPadding
		// and the pointPadding options
		var points = series.points,
			categoryWidth = mathAbs(xAxis.translationSlope) * (xAxis.ordinalSlope || xAxis.closestPointRange || 1),
			groupPadding = categoryWidth * options.groupPadding,
			groupWidth = categoryWidth - 2 * groupPadding,
			pointOffsetWidth = groupWidth / columnCount,
			optionPointWidth = options.pointWidth,
			pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
				pointOffsetWidth * options.pointPadding,
			pointWidth = mathCeil(mathMax(pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), 1 + 2 * borderWidth)),
			colIndex = (reversedXAxis ? columnCount -
				series.columnIndex : series.columnIndex) || 0,
			pointXOffset = pointPadding + (groupPadding + colIndex *
				pointOffsetWidth - (categoryWidth / 2)) *
				(reversedXAxis ? -1 : 1),
			threshold = options.threshold,
			translatedThreshold = series.yAxis.getThreshold(threshold),
			minPointLength = pick(options.minPointLength, 5);

		// record the new values
		each(points, function (point) {
			var plotY = point.plotY,
				yBottom = pick(point.yBottom, translatedThreshold),
				barX = point.plotX + pointXOffset,
				barY = mathCeil(mathMin(plotY, yBottom)),
				barH = mathCeil(mathMax(plotY, yBottom) - barY),
				stack = series.yAxis.stacks[(point.y < 0 ? '-' : '') + series.stackKey],
				shapeArgs;

			// Record the offset'ed position and width of the bar to be able to align the stacking total correctly
			if (stacking && series.visible && stack && stack[point.x]) {
				stack[point.x].setOffset(pointXOffset, pointWidth);
			}

			// handle options.minPointLength
			if (mathAbs(barH) < minPointLength) {
				if (minPointLength) {
					barH = minPointLength;
					barY =
						mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
							yBottom - minPointLength : // keep position
							translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
				}
			}

			extend(point, {
				barX: barX,
				barY: barY,
				barW: pointWidth,
				barH: barH
			});

			// create shape type and shape args that are reused in drawPoints and drawTracker
			point.shapeType = 'rect';
			shapeArgs = {
				x: barX,
				y: barY,
				width: pointWidth,
				height: barH,
				r: options.borderRadius,
				strokeWidth: borderWidth
			};
			
			if (borderWidth % 2) { // correct for shorting in crisp method, visible in stacked columns with 1px border
				shapeArgs.y -= 1;
				shapeArgs.height += 1;
			}
			point.shapeArgs = shapeArgs;

			// make small columns responsive to mouse
			point.trackerArgs = mathAbs(barH) < 3 && merge(point.shapeArgs, {
				height: 6,
				y: barY - 3
			});
		});

	},

	getSymbol: function () {
	},

	/**
	 * Columns have no graph
	 */
	drawGraph: function () {},

	/**
	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	 * apply for columns and bars. This method is inherited by scatter series.
	 *
	 */
	drawPoints: function () {
		var series = this,
			options = series.options,
			renderer = series.chart.renderer,
			graphic,
			shapeArgs;


		// draw the columns
		each(series.points, function (point) {
			var plotY = point.plotY;
			if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
				graphic = point.graphic;
				shapeArgs = point.shapeArgs;
				if (graphic) { // update
					stop(graphic);
					graphic.animate(renderer.Element.prototype.crisp.apply({}, [
						shapeArgs.strokeWidth,
						shapeArgs.x,
						shapeArgs.y,
						shapeArgs.width,
						shapeArgs.height
					]));

				} else {
					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])
						.add(series.group)
						.shadow(options.shadow);
						
				}

			}
		});
	},
	/**
	 * Draw the individual tracker elements.
	 * This method is inherited by scatter and pie charts too.
	 */
	drawTracker: function () {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			shapeArgs,
			tracker,
			trackerLabel = +new Date(),
			options = series.options,
			cursor = options.cursor,
			css = cursor && { cursor: cursor },
			trackerGroup = series.drawTrackerGroup(),
			rel;
			
		each(series.points, function (point) {
			tracker = point.tracker;
			shapeArgs = point.trackerArgs || point.shapeArgs;
			delete shapeArgs.strokeWidth;
			if (point.y !== null) {
				if (tracker) {// update
					tracker.attr(shapeArgs);

				} else {
					point.tracker =
						renderer[point.shapeType](shapeArgs)
						.attr({
							isTracker: trackerLabel,
							fill: TRACKER_FILL,
							visibility: series.visible ? VISIBLE : HIDDEN
						})
						.on(hasTouch ? 'touchstart' : 'mouseover', function (event) {
							rel = event.relatedTarget || event.fromElement;
							if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {
								series.onMouseOver();
							}
							point.onMouseOver();

						})
						.on('mouseout', function (event) {
							if (!options.stickyTracking) {
								rel = event.relatedTarget || event.toElement;
								if (attr(rel, 'isTracker') !== trackerLabel) {
									series.onMouseOut();
								}
							}
						})
						.css(css)
						.add(point.group || trackerGroup); // pies have point group - see issue #118
				}
			}
		});
	},


	/**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
	animate: function (init) {
		var series = this,
			points = series.points,
			options = series.options;

		if (!init) { // run the animation
			/*
			 * Note: Ideally the animation should be initialized by calling
			 * series.group.hide(), and then calling series.group.show()
			 * after the animation was started. But this rendered the shadows
			 * invisible in IE8 standards mode. If the columns flicker on large
			 * datasets, this is the cause.
			 */

			each(points, function (point) {
				var graphic = point.graphic,
					shapeArgs = point.shapeArgs,
					yAxis = series.yAxis,
					threshold = options.threshold;

				if (graphic) {
					// start values
					graphic.attr({
						height: 0,
						y: defined(threshold) ? 
							yAxis.getThreshold(threshold) :
							yAxis.translate(yAxis.getExtremes().min, 0, 1, 0, 1)
					});

					// animate
					graphic.animate({
						height: shapeArgs.height,
						y: shapeArgs.y
					}, options.animation);
				}
			});


			// delete this function to allow it only once
			series.animate = null;
		}

	},
	/**
	 * Remove this series from the chart
	 */
	remove: function () {
		var series = this,
			chart = series.chart;

		// column and bar series affects other series of the same type
		// as they are either stacked or grouped
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}

		Series.prototype.remove.apply(series, arguments);
	}
});
seriesTypes.column = ColumnSeries;

var BarSeries = extendClass(ColumnSeries, {
	type: 'bar',
	init: function () {
		this.inverted = true;
		ColumnSeries.prototype.init.apply(this, arguments);
	}
});
seriesTypes.bar = BarSeries;

/**
 * The scatter series class
 */
var ScatterSeries = extendClass(Series, {
	type: 'scatter',
	sorted: false,
	/**
	 * Extend the base Series' translate method by adding shape type and
	 * arguments for the point trackers
	 */
	translate: function () {
		var series = this;

		Series.prototype.translate.apply(series);

		each(series.points, function (point) {
			point.shapeType = 'circle';
			point.shapeArgs = {
				x: point.plotX,
				y: point.plotY,
				r: series.chart.options.tooltip.snap
			};
		});
	},

	/**
	 * Add tracking event listener to the series group, so the point graphics
	 * themselves act as trackers
	 */
	drawTracker: function () {
		var series = this,
			cursor = series.options.cursor,
			css = cursor && { cursor: cursor },
			points = series.points,
			i = points.length,
			graphic;

		// Set an expando property for the point index, used below
		while (i--) {
			graphic = points[i].graphic;
			if (graphic) { // doesn't exist for null points
				graphic.element._i = i; 
			}
		}
		
		// Add the event listeners, we need to do this only once
		if (!series._hasTracking) {
			series.group
				.attr({
					isTracker: true
				})
				.on(hasTouch ? 'touchstart' : 'mouseover', function (e) {
					series.onMouseOver();
					if (e.target._i !== UNDEFINED) { // undefined on graph in scatterchart
						points[e.target._i].onMouseOver();
					}
				})
				.on('mouseout', function () {
					if (!series.options.stickyTracking) {
						series.onMouseOut();
					}
				})
				.css(css);
		} else {
			series._hasTracking = true;
		}

	}
});
seriesTypes.scatter = ScatterSeries;

/**
 * Extended point object for pies
 */
var PiePoint = extendClass(Point, {
	/**
	 * Initiate the pie slice
	 */
	init: function () {

		Point.prototype.init.apply(this, arguments);

		var point = this,
			toggleSlice;

		//visible: options.visible !== false,
		extend(point, {
			visible: point.visible !== false,
			name: pick(point.name, 'Slice')
		});

		// add event listener for select
		toggleSlice = function () {
			point.slice();
		};
		addEvent(point, 'select', toggleSlice);
		addEvent(point, 'unselect', toggleSlice);

		return point;
	},

	/**
	 * Toggle the visibility of the pie slice
	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	 *    visibility is toggled
	 */
	setVisible: function (vis) {
		var point = this,
			chart = point.series.chart,
			tracker = point.tracker,
			dataLabel = point.dataLabel,
			connector = point.connector,
			shadowGroup = point.shadowGroup,
			method;

		// if called without an argument, toggle visibility
		point.visible = vis = vis === UNDEFINED ? !point.visible : vis;

		method = vis ? 'show' : 'hide';

		point.group[method]();
		if (tracker) {
			tracker[method]();
		}
		if (dataLabel) {
			dataLabel[method]();
		}
		if (connector) {
			connector[method]();
		}
		if (shadowGroup) {
			shadowGroup[method]();
		}
		if (point.legendItem) {
			chart.legend.colorizeItem(point, vis);
		}
	},

	/**
	 * Set or toggle whether the slice is cut out from the pie
	 * @param {Boolean} sliced When undefined, the slice state is toggled
	 * @param {Boolean} redraw Whether to redraw the chart. True by default.
	 */
	slice: function (sliced, redraw, animation) {
		var point = this,
			series = point.series,
			chart = series.chart,
			slicedTranslation = point.slicedTranslation,
			translation;

		setAnimation(animation, chart);

		// redraw is true by default
		redraw = pick(redraw, true);

		// if called without an argument, toggle
		sliced = point.sliced = defined(sliced) ? sliced : !point.sliced;

		translation = {
			translateX: (sliced ? slicedTranslation[0] : chart.plotLeft),
			translateY: (sliced ? slicedTranslation[1] : chart.plotTop)
		};
		point.group.animate(translation);
		if (point.shadowGroup) {
			point.shadowGroup.animate(translation);
		}

	}
});

/**
 * The Pie series class
 */
var PieSeries = extendClass(Series, {
	type: 'pie',
	isCartesian: false,
	pointClass: PiePoint,
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		'stroke-width': 'borderWidth',
		fill: 'color'
	},

	/**
	 * Pies have one color each point
	 */
	getColor: function () {
		// record first color for use in setData
		this.initialColor = this.chart.counters.color;
	},

	/**
	 * Animate the column heights one by one from zero
	 */
	animate: function () {
		var series = this,
			points = series.points;

		each(points, function (point) {
			var graphic = point.graphic,
				args = point.shapeArgs,
				up = -mathPI / 2;

			if (graphic) {
				// start values
				graphic.attr({
					r: 0,
					start: up,
					end: up
				});

				// animate
				graphic.animate({
					r: args.r,
					start: args.start,
					end: args.end
				}, series.options.animation);
			}
		});

		// delete this function to allow it only once
		series.animate = null;

	},

	/**
	 * Extend the basic setData method by running processData and generatePoints immediately,
	 * in order to access the points from the legend.
	 */
	setData: function () {
		Series.prototype.setData.apply(this, arguments);
		this.processData();
		this.generatePoints();
	},
	/**
	 * Do translation for pie slices
	 */
	translate: function () {
		this.generatePoints();
		
		var total = 0,
			series = this,
			cumulative = -0.25, // start at top
			precision = 1000, // issue #172
			options = series.options,
			slicedOffset = options.slicedOffset,
			connectorOffset = slicedOffset + options.borderWidth,
			positions = options.center.concat([options.size, options.innerSize || 0]),
			chart = series.chart,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			start,
			end,
			angle,
			points = series.points,
			circ = 2 * mathPI,
			fraction,
			smallestSize = mathMin(plotWidth, plotHeight),
			isPercent,
			radiusX, // the x component of the radius vector for a given point
			radiusY,
			labelDistance = options.dataLabels.distance;

		// get positions - either an integer or a percentage string must be given
		positions = map(positions, function (length, i) {

			isPercent = /%$/.test(length);
			return isPercent ?
				// i == 0: centerX, relative to width
				// i == 1: centerY, relative to height
				// i == 2: size, relative to smallestSize
				// i == 4: innerSize, relative to smallestSize
				[plotWidth, plotHeight, smallestSize, smallestSize][i] *
					pInt(length) / 100 :
				length;
		});

		// utility for getting the x value from a given y, used for anticollision logic in data labels
		series.getX = function (y, left) {

			angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));

			return positions[0] +
				(left ? -1 : 1) *
				(mathCos(angle) * (positions[2] / 2 + labelDistance));
		};

		// set center for later use
		series.center = positions;

		// get the total sum
		each(points, function (point) {
			total += point.y;
		});

		each(points, function (point) {
			// set start and end angle
			fraction = total ? point.y / total : 0;
			start = mathRound(cumulative * circ * precision) / precision;
			cumulative += fraction;
			end = mathRound(cumulative * circ * precision) / precision;

			// set the shape
			point.shapeType = 'arc';
			point.shapeArgs = {
				x: positions[0],
				y: positions[1],
				r: positions[2] / 2,
				innerR: positions[3] / 2,
				start: start,
				end: end
			};

			// center for the sliced out slice
			angle = (end + start) / 2;
			point.slicedTranslation = map([
				mathCos(angle) * slicedOffset + chart.plotLeft,
				mathSin(angle) * slicedOffset + chart.plotTop
			], mathRound);

			// set the anchor point for tooltips
			radiusX = mathCos(angle) * positions[2] / 2;
			radiusY = mathSin(angle) * positions[2] / 2;
			point.tooltipPos = [
				positions[0] + radiusX * 0.7,
				positions[1] + radiusY * 0.7
			];

			// set the anchor point for data labels
			point.labelPos = [
				positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
				positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
				positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
				positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
				positions[0] + radiusX, // landing point for connector
				positions[1] + radiusY, // a/a
				labelDistance < 0 ? // alignment
					'center' :
					angle < circ / 4 ? 'left' : 'right', // alignment
				angle // center angle
			];

			// API properties
			point.percentage = fraction * 100;
			point.total = total;

		});


		this.setTooltipPoints();
	},

	/**
	 * Render the slices
	 */
	render: function () {
		var series = this;

		// cache attributes for shapes
		series.getAttribs();

		this.drawPoints();

		// draw the mouse tracking area
		if (series.options.enableMouseTracking !== false) {
			series.drawTracker();
		}

		this.drawDataLabels();

		if (series.options.animation && series.animate) {
			series.animate();
		}

		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		series.isDirty = false; // means data is in accordance with what you see
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			groupTranslation,
			//center,
			graphic,
			group,
			shadow = series.options.shadow,
			shadowGroup,
			shapeArgs;

		// draw the slices
		each(series.points, function (point) {
			graphic = point.graphic;
			shapeArgs = point.shapeArgs;
			group = point.group;
			shadowGroup = point.shadowGroup;

			// put the shadow behind all points
			if (shadow && !shadowGroup) {
				shadowGroup = point.shadowGroup = renderer.g('shadow')
					.attr({ zIndex: 4 })
					.add();
			}

			// create the group the first time
			if (!group) {
				group = point.group = renderer.g('point')
					.attr({ zIndex: 5 })
					.add();
			}

			// if the point is sliced, use special translation, else use plot area traslation
			groupTranslation = point.sliced ? point.slicedTranslation : [chart.plotLeft, chart.plotTop];
			group.translate(groupTranslation[0], groupTranslation[1]);
			if (shadowGroup) {
				shadowGroup.translate(groupTranslation[0], groupTranslation[1]);
			}

			// draw the slice
			if (graphic) {
				graphic.animate(shapeArgs);
			} else {
				point.graphic =
					renderer.arc(shapeArgs)
					.attr(extend(
						point.pointAttr[NORMAL_STATE],
						{ 'stroke-linejoin': 'round' }
					))
					.add(point.group)
					.shadow(shadow, shadowGroup);
			}

			// detect point specific visibility
			if (point.visible === false) {
				point.setVisible(false);
			}

		});

	},

	/**
	 * Override the base drawDataLabels method by pie specific functionality
	 */
	drawDataLabels: function () {
		var series = this,
			data = series.data,
			point,
			chart = series.chart,
			options = series.options.dataLabels,
			connectorPadding = pick(options.connectorPadding, 10),
			connectorWidth = pick(options.connectorWidth, 1),
			connector,
			connectorPath,
			softConnector = pick(options.softConnector, true),
			distanceOption = options.distance,
			seriesCenter = series.center,
			radius = seriesCenter[2] / 2,
			centerY = seriesCenter[1],
			outside = distanceOption > 0,
			dataLabel,
			labelPos,
			labelHeight,
			halves = [// divide the points into right and left halves for anti collision
				[], // right
				[]  // left
			],
			x,
			y,
			visibility,
			rankArr,
			sort,
			i = 2,
			j;

		// get out if not enabled
		if (!options.enabled) {
			return;
		}

		// run parent method
		Series.prototype.drawDataLabels.apply(series);

		// arrange points for detection collision
		each(data, function (point) {
			if (point.dataLabel) { // it may have been cancelled in the base method (#407)
				halves[
					point.labelPos[7] < mathPI / 2 ? 0 : 1
				].push(point);
			}
		});
		halves[1].reverse();

		// define the sorting algorithm
		sort = function (a, b) {
			return b.y - a.y;
		};

		// assume equal label heights
		labelHeight = halves[0][0] && halves[0][0].dataLabel && halves[0][0].dataLabel.getBBox().height;

		/* Loop over the points in each quartile, starting from the top and bottom
		 * of the pie to detect overlapping labels.
		 */
		while (i--) {

			var slots = [],
				slotsLength,
				usedSlots = [],
				points = halves[i],
				pos,
				length = points.length,
				slotIndex;


			// build the slots
			for (pos = centerY - radius - distanceOption; pos <= centerY + radius + distanceOption; pos += labelHeight) {
				slots.push(pos);
				// visualize the slot
				/*
				var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
					slotY = pos + chart.plotTop;
				if (!isNaN(slotX)) {
					chart.renderer.rect(slotX, slotY - 7, 100, labelHeight)
						.attr({
							'stroke-width': 1,
							stroke: 'silver'
						})
						.add();
					chart.renderer.text('Slot '+ (slots.length - 1), slotX, slotY + 4)
						.attr({
							fill: 'silver'
						}).add();
				}
				// */
			}
			slotsLength = slots.length;

			// if there are more values than available slots, remove lowest values
			if (length > slotsLength) {
				// create an array for sorting and ranking the points within each quarter
				rankArr = [].concat(points);
				rankArr.sort(sort);
				j = length;
				while (j--) {
					rankArr[j].rank = j;
				}
				j = length;
				while (j--) {
					if (points[j].rank >= slotsLength) {
						points.splice(j, 1);
					}
				}
				length = points.length;
			}

			// The label goes to the nearest open slot, but not closer to the edge than
			// the label's index.
			for (j = 0; j < length; j++) {

				point = points[j];
				labelPos = point.labelPos;

				var closest = 9999,
					distance,
					slotI;

				// find the closest slot index
				for (slotI = 0; slotI < slotsLength; slotI++) {
					distance = mathAbs(slots[slotI] - labelPos[1]);
					if (distance < closest) {
						closest = distance;
						slotIndex = slotI;
					}
				}

				// if that slot index is closer to the edges of the slots, move it
				// to the closest appropriate slot
				if (slotIndex < j && slots[j] !== null) { // cluster at the top
					slotIndex = j;
				} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
					slotIndex = slotsLength - length + j;
					while (slots[slotIndex] === null) { // make sure it is not taken
						slotIndex++;
					}
				} else {
					// Slot is taken, find next free slot below. In the next run, the next slice will find the
					// slot above these, because it is the closest one
					while (slots[slotIndex] === null) { // make sure it is not taken
						slotIndex++;
					}
				}

				usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
				slots[slotIndex] = null; // mark as taken
			}
			// sort them in order to fill in from the top
			usedSlots.sort(sort);


			// now the used slots are sorted, fill them up sequentially
			for (j = 0; j < length; j++) {

				point = points[j];
				labelPos = point.labelPos;
				dataLabel = point.dataLabel;
				var slot = usedSlots.pop(),
					naturalY = labelPos[1];

				visibility = point.visible === false ? HIDDEN : VISIBLE;
				slotIndex = slot.i;

				// if the slot next to currrent slot is free, the y value is allowed
				// to fall back to the natural position
				y = slot.y;
				if ((naturalY > y && slots[slotIndex + 1] !== null) ||
						(naturalY < y &&  slots[slotIndex - 1] !== null)) {
					y = naturalY;
				}

				// get the x - use the natural x position for first and last slot, to prevent the top
				// and botton slice connectors from touching each other on either side
				x = series.getX(slotIndex === 0 || slotIndex === slots.length - 1 ? naturalY : y, i);

				// move or place the data label
				dataLabel
					.attr({
						visibility: visibility,
						align: labelPos[6]
					})[dataLabel.moved ? 'animate' : 'attr']({
						x: x + options.x +
							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
						y: y + options.y
					});
				dataLabel.moved = true;

				// draw the connector
				if (outside && connectorWidth) {
					connector = point.connector;

					connectorPath = softConnector ? [
						M,
						x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
						'C',
						x, y, // first break, next to the label
						2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
						labelPos[2], labelPos[3], // second break
						L,
						labelPos[4], labelPos[5] // base
					] : [
						M,
						x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
						L,
						labelPos[2], labelPos[3], // second break
						L,
						labelPos[4], labelPos[5] // base
					];

					if (connector) {
						connector.animate({ d: connectorPath });
						connector.attr('visibility', visibility);

					} else {
						point.connector = connector = series.chart.renderer.path(connectorPath).attr({
							'stroke-width': connectorWidth,
							stroke: options.connectorColor || point.color || '#606060',
							visibility: visibility,
							zIndex: 3
						})
						.translate(chart.plotLeft, chart.plotTop)
						.add();
					}
				}
			}
		}
	},

	/**
	 * Draw point specific tracker objects. Inherit directly from column series.
	 */
	drawTracker: ColumnSeries.prototype.drawTracker,

	/**
	 * Pies don't have point marker symbols
	 */
	getSymbol: function () {}

});
seriesTypes.pie = PieSeries;

/* ****************************************************************************
 * Start data grouping module												 *
 ******************************************************************************/
/*jslint white:true */
var DATA_GROUPING = 'dataGrouping',
	seriesProto = Series.prototype,
	baseProcessData = seriesProto.processData,
	baseGeneratePoints = seriesProto.generatePoints,
	baseDestroy = seriesProto.destroy,
	baseTooltipHeaderFormatter = seriesProto.tooltipHeaderFormatter,
	NUMBER = 'number',
	
	commonOptions = {
			approximation: 'average', // average, open, high, low, close, sum
			//forced: undefined,
			groupPixelWidth: 2,
			// the first one is the point or start value, the second is the start value if we're dealing with range,
			// the third one is the end value if dealing with a range
			dateTimeLabelFormats: hash( 
				MILLISECOND, ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
				SECOND, ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
				MINUTE, ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
				HOUR, ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
				DAY, ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
				WEEK, ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
				MONTH, ['%B %Y', '%B', '-%B %Y'],
				YEAR, ['%Y', '%Y', '-%Y']
			)
			// smoothed = false, // enable this for navigator series only
		},
		
		// units are defined in a separate array to allow complete overriding in case of a user option
		defaultDataGroupingUnits = [[
				MILLISECOND, // unit name
				[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
			], [
				SECOND,
				[1, 2, 5, 10, 15, 30]
			], [
				MINUTE,
				[1, 2, 5, 10, 15, 30]
			], [
				HOUR,
				[1, 2, 3, 4, 6, 8, 12]
			], [
				DAY,
				[1]
			], [
				WEEK,
				[1]
			], [
				MONTH,
				[1, 3, 6]
			], [
				YEAR,
				null
			]
		],
	
	/**
	 * Define the available approximation types. The data grouping approximations takes an array
	 * or numbers as the first parameter. In case of ohlc, four arrays are sent in as four parameters.
	 * Each array consists only of numbers. In case null values belong to the group, the property
	 * .hasNulls will be set to true on the array.
	 */
	approximations = {
		sum: function (arr) {
			var len = arr.length, 
				ret;
				
			// 1. it consists of nulls exclusively
			if (!len && arr.hasNulls) {
				ret = null;
			// 2. it has a length and real values
			} else if (len) {
				ret = 0;
				while (len--) {
					ret += arr[len];
				}
			}
			// 3. it has zero length, so just return undefined 
			// => doNothing()
			
			return ret;
		},
		average: function (arr) {
			var len = arr.length,
				ret = approximations.sum(arr);
				
			// If we have a number, return it divided by the length. If not, return
			// null or undefined based on what the sum method finds.
			if (typeof ret === NUMBER && len) {
				ret = ret / len;
			}
			
			return ret;
		},
		open: function (arr) {
			return arr.length ? arr[0] : (arr.hasNulls ? null : UNDEFINED);
		},
		high: function (arr) {
			return arr.length ? arrayMax(arr) : (arr.hasNulls ? null : UNDEFINED);
		},
		low: function (arr) {
			return arr.length ? arrayMin(arr) : (arr.hasNulls ? null : UNDEFINED);
		},
		close: function (arr) {
			return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : UNDEFINED);
		},
		// ohlc is a special case where a multidimensional array is input and an array is output
		ohlc: function (open, high, low, close) {
			open = approximations.open(open);
			high = approximations.high(high);
			low = approximations.low(low);
			close = approximations.close(close);
			
			if (typeof open === NUMBER || typeof high === NUMBER || typeof low === NUMBER || typeof close === NUMBER) {
				return [open, high, low, close];
			} 
			// else, return is undefined
		}
	};

/*jslint white:false */

/**
 * Takes parallel arrays of x and y data and groups the data into intervals defined by groupPositions, a collection
 * of starting x values for each group.
 */
seriesProto.groupData = function (xData, yData, groupPositions, approximation) {
	var series = this,
		data = series.data,
		dataOptions = series.options.data,
		groupedXData = [],
		groupedYData = [],
		dataLength = xData.length,
		pointX,
		pointY,
		groupedY,
		handleYData = !!yData, // when grouping the fake extended axis for panning, we don't need to consider y
		values1 = [],
		values2 = [],
		values3 = [],
		values4 = [],
		approximationFn = typeof approximation === 'function' ? approximation : approximations[approximation],
		i;
	
		for (i = 0; i <= dataLength; i++) {

			// when a new group is entered, summarize and initiate the previous group
			while ((groupPositions[1] !== UNDEFINED && xData[i] >= groupPositions[1]) ||
					i === dataLength) { // get the last group

				// get group x and y 
				pointX = groupPositions.shift();				
				groupedY = approximationFn(values1, values2, values3, values4);
				
				// push the grouped data		
				if (groupedY !== UNDEFINED) {
					groupedXData.push(pointX);
					groupedYData.push(groupedY);
				}
				
				// reset the aggregate arrays
				values1 = [];
				values2 = [];
				values3 = [];
				values4 = [];
				
				// don't loop beyond the last group
				if (i === dataLength) {
					break;
				}
			}
			
			// break out
			if (i === dataLength) {
				break;
			}
			
			// for each raw data point, push it to an array that contains all values for this specific group
			pointY = handleYData ? yData[i] : null;
			if (approximation === 'ohlc') {
				
				var index = series.cropStart + i,
					point = (data && data[index]) || series.pointClass.prototype.applyOptions.apply({}, [dataOptions[index]]),
					open = point.open,
					high = point.high,
					low = point.low,
					close = point.close;
				
				
				if (typeof open === NUMBER) {
					values1.push(open);
				} else if (open === null) {
					values1.hasNulls = true;
				}
				
				if (typeof high === NUMBER) {
					values2.push(high);
				} else if (high === null) {
					values2.hasNulls = true;
				}
				
				if (typeof low === NUMBER) {
					values3.push(low);
				} else if (low === null) {
					values3.hasNulls = true;
				}
				
				if (typeof close === NUMBER) {
					values4.push(close);
				} else if (close === null) {
					values4.hasNulls = true;
				}
			} else {
				if (typeof pointY === NUMBER) {
					values1.push(pointY);
				} else if (pointY === null) {
					values1.hasNulls = true;
				}
			}

		}
	return [groupedXData, groupedYData];
};

/**
 * Extend the basic processData method, that crops the data to the current zoom
 * range, with data grouping logic.
 */
seriesProto.processData = function () {
	var series = this,
		options = series.options,
		dataGroupingOptions = options[DATA_GROUPING],
		groupingEnabled = dataGroupingOptions && dataGroupingOptions.enabled,
		groupedData = series.groupedData,
		hasGroupedData;

	// run base method
	series.forceCrop = groupingEnabled; // #334
	
	// skip if processData returns false or if grouping is disabled (in that order)
	if (baseProcessData.apply(series, arguments) === false || !groupingEnabled) {
		return;
		
	} else {
		// clear previous groups, #622, #740
		each(groupedData || [], function (point, i) {
			if (point) {
				groupedData[i] = point.destroy ? point.destroy() : null;
			}
		});
	}
	
	var i,
		chart = series.chart,
		processedXData = series.processedXData,
		processedYData = series.processedYData,
		plotSizeX = chart.plotSizeX,
		xAxis = series.xAxis,
		groupPixelWidth = pick(xAxis.groupPixelWidth, dataGroupingOptions.groupPixelWidth),
		dataLength = processedXData.length,
		chartSeries = chart.series,
		nonGroupedPointRange = series.pointRange;

	// attempt to solve #334: if multiple series are compared on the same x axis, give them the same
	// group pixel width
	if (!xAxis.groupPixelWidth) {
		i = chartSeries.length;
		while (i--) {
			if (chartSeries[i].xAxis === xAxis && chartSeries[i].options[DATA_GROUPING]) {
				groupPixelWidth = mathMax(groupPixelWidth, chartSeries[i].options[DATA_GROUPING].groupPixelWidth);
			}
		}
		xAxis.groupPixelWidth = groupPixelWidth;
		
	}

	// Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth
	if (dataLength > (plotSizeX / groupPixelWidth) || dataGroupingOptions.forced) {
		hasGroupedData = true;

		series.points = null; // force recreation of point instances in series.translate

		var extremes = xAxis.getExtremes(),
			xMin = extremes.min,
			xMax = extremes.max,
			groupIntervalFactor = (xAxis.getGroupIntervalFactor && xAxis.getGroupIntervalFactor(xMin, xMax, processedXData)) || 1,
			interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,			
			groupPositions = (xAxis.getNonLinearTimeTicks || getTimeTicks)(
				normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
				xMin, 
				xMax, 
				null, 
				processedXData, 
				series.closestPointRange
			),
			groupedXandY = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),
			groupedXData = groupedXandY[0],
			groupedYData = groupedXandY[1];
			
		// prevent the smoothed data to spill out left and right, and make
		// sure data is not shifted to the left
		if (dataGroupingOptions.smoothed) {
			i = groupedXData.length - 1;
			groupedXData[i] = xMax;
			while (i-- && i > 0) {
				groupedXData[i] += interval / 2;
			}
			groupedXData[0] = xMin;
		}

		// record what data grouping values were used
		series.currentDataGrouping = groupPositions.info;
		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
			series.pointRange = groupPositions.info.totalRange;
		}
		series.closestPointRange = groupPositions.info.totalRange;
		
		// set series props
		series.processedXData = groupedXData;
		series.processedYData = groupedYData;
	} else {
		series.currentDataGrouping = null;
		series.pointRange = nonGroupedPointRange;
	}

	series.hasGroupedData = hasGroupedData;
};

seriesProto.generatePoints = function () {
	var series = this;

	baseGeneratePoints.apply(series);

	// record grouped data in order to let it be destroyed the next time processData runs
	series.groupedData = series.hasGroupedData ? series.points : null;
};

/**
 * Make the tooltip's header reflect the grouped range
 */
seriesProto.tooltipHeaderFormatter = function (key) {
	var series = this,
		options = series.options,
		tooltipOptions = series.tooltipOptions,
		dataGroupingOptions = options.dataGrouping,
		xDateFormat = tooltipOptions.xDateFormat,
		xDateFormatEnd,
		xAxis = series.xAxis,
		currentDataGrouping,
		dateTimeLabelFormats,
		labelFormats,
		formattedKey,
		n,
		ret;
	
	// apply only to grouped series
	if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions) {
		
		// set variables
		currentDataGrouping = series.currentDataGrouping;		
		dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;
		
		// if we have grouped data, use the grouping information to get the right format
		if (currentDataGrouping) {
			labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
			if (currentDataGrouping.count === 1) {
				xDateFormat = labelFormats[0];
			} else {
				xDateFormat = labelFormats[1];
				xDateFormatEnd = labelFormats[2];
			} 
		// if not grouped, and we don't have set the xDateFormat option, get the best fit,
		// so if the least distance between points is one minute, show it, but if the 
		// least distance is one day, skip hours and minutes etc.
		} else if (!xDateFormat) {
			for (n in timeUnits) {
				if (timeUnits[n] >= xAxis.closestPointRange) {
					xDateFormat = dateTimeLabelFormats[n][0];
					break;
				}	
			}		
		}
		
		// now format the key
		formattedKey = dateFormat(xDateFormat, key);
		if (xDateFormatEnd) {
			formattedKey += dateFormat(xDateFormatEnd, key + currentDataGrouping.totalRange - 1);
		}
		
		// return the replaced format
		ret = tooltipOptions.headerFormat.replace('{point.key}', formattedKey);
	
	// else, fall back to the regular formatter
	} else {
		ret = baseTooltipHeaderFormatter.apply(series, [key]);
	}
	
	return ret;
};

/**
 * Extend the series destroyer
 */
seriesProto.destroy = function () {
	var series = this,
		groupedData = series.groupedData || [],
		i = groupedData.length;

	while (i--) {
		if (groupedData[i]) {
			groupedData[i].destroy();
		}
	}
	baseDestroy.apply(series);
};


// Extend the plot options

// line types
defaultPlotOptions.line[DATA_GROUPING] =
	defaultPlotOptions.spline[DATA_GROUPING] =
	defaultPlotOptions.area[DATA_GROUPING] =
	defaultPlotOptions.areaspline[DATA_GROUPING] = commonOptions;

// bar-like types (OHLC and candleticks inherit this as the classes are not yet built)
defaultPlotOptions.column[DATA_GROUPING] = merge(commonOptions, {
		approximation: 'sum',
		groupPixelWidth: 10
});
/* ****************************************************************************
 * End data grouping module												   *
 ******************************************************************************//* ****************************************************************************
 * Start OHLC series code													 *
 *****************************************************************************/

// 1 - Set default options
defaultPlotOptions.ohlc = merge(defaultPlotOptions.column, {
	lineWidth: 1,
	dataGrouping: {
		approximation: 'ohlc',
		enabled: true,
		groupPixelWidth: 5 // allows to be packed tighter than candlesticks
	},
	tooltip: {
		pointFormat: '<span style="color:{series.color};font-weight:bold">{series.name}</span><br/>' +
			'Open: {point.open}<br/>' +
			'High: {point.high}<br/>' +
			'Low: {point.low}<br/>' +
			'Close: {point.close}<br/>'	
	},
	states: {
		hover: {
			lineWidth: 3
		}
	},
	threshold: null
});

// 2- Create the OHLCPoint object
var OHLCPoint = extendClass(Point, {
	/**
	 * Apply the options containing the x and OHLC data and possible some extra properties.
	 * This is called on point init or from point.update. Extends base Point by adding
	 * multiple y-like values.
	 *
	 * @param {Object} options
	 */
	applyOptions: function (options) {
		var point = this,
			series = point.series,
			i = 0;


		// object input for example:
		// { x: Date(2010, 0, 1), open: 7.88, high: 7.99, low: 7.02, close: 7.65 }
		if (typeof options === 'object' && typeof options.length !== 'number') {

			// copy options directly to point
			extend(point, options);

			point.options = options;
		} else if (options.length) { // array
			// with leading x value
			if (options.length === 5) {
				if (typeof options[0] === 'string') {
					point.name = options[0];
				} else if (typeof options[0] === 'number') {
					point.x = options[0];
				}
				i++;
			}
			point.open = options[i++];
			point.high = options[i++];
			point.low = options[i++];
			point.close = options[i++];
		}

		/*
		 * If no x is set by now, get auto incremented value. All points must have an
		 * x value, however the y value can be null to create a gap in the series
		 */
		point.y = point.high;
		if (point.x === UNDEFINED && series) {
			point.x = series.autoIncrement();
		}
		return point;
	}

});

// 3 - Create the OHLCSeries object
var OHLCSeries = extendClass(seriesTypes.column, {
	type: 'ohlc',
	valueCount: 4, // four values per point
	pointClass: OHLCPoint,

	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'color',
		'stroke-width': 'lineWidth'
	},


	/**
	 * Translate data points from raw values x and y to plotX and plotY
	 */
	translate: function () {
		var series = this,
			yAxis = series.yAxis;

		seriesTypes.column.prototype.translate.apply(series);

		// do the translation
		each(series.points, function (point) {
			// the graphics
			if (point.open !== null) {
				point.plotOpen = yAxis.translate(point.open, 0, 1, 0, 1);
			}
			if (point.close !== null) {
				point.plotClose = yAxis.translate(point.close, 0, 1, 0, 1);
			}

		});
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			points = series.points,
			chart = series.chart,
			pointAttr,
			plotOpen,
			plotClose,
			crispCorr,
			halfWidth,
			path,
			graphic,
			crispX;


		each(points, function (point) {
			if (point.plotY !== UNDEFINED) {

				graphic = point.graphic;
				pointAttr = point.pointAttr[point.selected ? 'selected' : ''];

				// crisp vector coordinates
				crispCorr = (pointAttr['stroke-width'] % 2) / 2;
				crispX = mathRound(point.plotX) + crispCorr;
				halfWidth = mathRound(point.barW / 2);

				// the vertical stem
				path = [
					'M',
					crispX, mathRound(point.yBottom),
					'L',
					crispX, mathRound(point.plotY)
				];

				// open
				if (point.open !== null) {
					plotOpen = mathRound(point.plotOpen) + crispCorr;
					path.push(
						'M',
						crispX,
						plotOpen,
						'L',
						crispX - halfWidth,
						plotOpen
					);
				}

				// close
				if (point.close !== null) {
					plotClose = mathRound(point.plotClose) + crispCorr;
					path.push(
						'M',
						crispX,
						plotClose,
						'L',
						crispX + halfWidth,
						plotClose
					);
				}

				// create and/or update the graphic
				if (graphic) {
					graphic.animate({ d: path });
				} else {
					point.graphic = chart.renderer.path(path)
						.attr(pointAttr)
						.add(series.group);
				}

			}


		});

	},

	/**
	 * Disable animation
	 */
	animate: null


});
seriesTypes.ohlc = OHLCSeries;
/* ****************************************************************************
 * End OHLC series code													   *
 *****************************************************************************/
/* ****************************************************************************
 * Start Candlestick series code											  *
 *****************************************************************************/

// 1 - set default options
defaultPlotOptions.candlestick = merge(defaultPlotOptions.column, {
	dataGrouping: {
		approximation: 'ohlc',
		enabled: true
	},
	lineColor: 'black',
	lineWidth: 1,
	states: {
		hover: {
			lineWidth: 2
		}
	},
	tooltip: defaultPlotOptions.ohlc.tooltip,
	threshold: null,
	upColor: 'white'
});

// 2 - Create the CandlestickSeries object
var CandlestickSeries = extendClass(OHLCSeries, {
	type: 'candlestick',

	/**
	 * One-to-one mapping from options to SVG attributes
	 */
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		fill: 'color',
		stroke: 'lineColor',
		'stroke-width': 'lineWidth'
	},

	/**
	 * Postprocess mapping between options and SVG attributes
	 */
	getAttribs: function () {
		OHLCSeries.prototype.getAttribs.apply(this, arguments);
		var series = this,
			options = series.options,
			stateOptions = options.states,
			upColor = options.upColor,
			seriesDownPointAttr = merge(series.pointAttr);

		seriesDownPointAttr[''].fill = upColor;
		seriesDownPointAttr.hover.fill = stateOptions.hover.upColor || upColor;
		seriesDownPointAttr.select.fill = stateOptions.select.upColor || upColor;

		each(series.points, function (point) {
			if (point.open < point.close) {
				point.pointAttr = seriesDownPointAttr;
			}
		});
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,  //state = series.state,
			points = series.points,
			chart = series.chart,
			pointAttr,
			plotOpen,
			plotClose,
			topBox,
			bottomBox,
			crispCorr,
			crispX,
			graphic,
			path,
			halfWidth;


		each(points, function (point) {

			graphic = point.graphic;
			if (point.plotY !== UNDEFINED) {

				pointAttr = point.pointAttr[point.selected ? 'selected' : ''];

				// crisp vector coordinates
				crispCorr = (pointAttr['stroke-width'] % 2) / 2;
				crispX = mathRound(point.plotX) + crispCorr;
				plotOpen = mathRound(point.plotOpen) + crispCorr;
				plotClose = mathRound(point.plotClose) + crispCorr;
				topBox = math.min(plotOpen, plotClose);
				bottomBox = math.max(plotOpen, plotClose);
				halfWidth = mathRound(point.barW / 2);

				// create the path
				path = [
					'M',
					crispX - halfWidth, bottomBox,
					'L',
					crispX - halfWidth, topBox,
					'L',
					crispX + halfWidth, topBox,
					'L',
					crispX + halfWidth, bottomBox,
					'L',
					crispX - halfWidth, bottomBox,
					'M',
					crispX, bottomBox,
					'L',
					crispX, mathRound(point.yBottom),
					'M',
					crispX, topBox,
					'L',
					crispX, mathRound(point.plotY),
					'Z'
				];

				if (graphic) {
					graphic.animate({ d: path });
				} else {
					point.graphic = chart.renderer.path(path)
						.attr(pointAttr)
						.add(series.group);
				}

			}
		});

	}


});

seriesTypes.candlestick = CandlestickSeries;

/* ****************************************************************************
 * End Candlestick series code												*
 *****************************************************************************/
/* ****************************************************************************
 * Start Flags series code													*
 *****************************************************************************/

var symbols = SVGRenderer.prototype.symbols;

// 1 - set default options
defaultPlotOptions.flags = merge(defaultPlotOptions.column, {
	dataGrouping: null,
	fillColor: 'white',
	lineWidth: 1,
	pointRange: 0, // #673
	//radius: 2,
	shape: 'flag',
	stackDistance: 7,
	states: {
		hover: {
			lineColor: 'black',
			fillColor: '#FCFFC5'
		}
	},
	style: {
		fontSize: '11px',
		fontWeight: 'bold',
		textAlign: 'center'
	},
	threshold: null,
	y: -30
});

// 2 - Create the CandlestickSeries object
seriesTypes.flags = extendClass(seriesTypes.column, {
	type: 'flags',
	sorted: false,
	noSharedTooltip: true,
	/**
	 * Inherit the initialization from base Series
	 */
	init: Series.prototype.init,

	/**
	 * One-to-one mapping from options to SVG attributes
	 */
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		fill: 'fillColor',
		stroke: 'color',
		'stroke-width': 'lineWidth',
		r: 'radius'
	},

	/**
	 * Extend the translate method by placing the point on the related series
	 */
	translate: function () {

		seriesTypes.column.prototype.translate.apply(this);

		var series = this,
			options = series.options,
			chart = series.chart,
			points = series.points,
			cursor = points.length - 1,
			point,
			lastPoint,
			optionsOnSeries = options.onSeries,
			onSeries = optionsOnSeries && chart.get(optionsOnSeries),
			step = onSeries && onSeries.options.step,
			onData = onSeries && onSeries.points,
			i = onData && onData.length,
			leftPoint,
			lastX,
			rightPoint;

		// relate to a master series
		if (onSeries && onSeries.visible && i) {
			lastX = onData[i - 1].x;

			// sort the data points
			points.sort(function (a, b) {
				return (a.x - b.x);
			});

			while (i-- && points[cursor]) {
				point = points[cursor];
				leftPoint = onData[i];
				
				
				if (leftPoint.x <= point.x && leftPoint.plotY !== UNDEFINED) {
					
					if (point.x <= lastX) { // #803
					
						point.plotY = leftPoint.plotY;
					
						// interpolate between points, #666
						if (leftPoint.x < point.x && !step) { 
							rightPoint = onData[i + 1];
							if (rightPoint && rightPoint.plotY !== UNDEFINED) {
								point.plotY += 
									((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) * // the distance ratio, between 0 and 1 
									(rightPoint.plotY - leftPoint.plotY); // the y distance
							}
						}
					}
					cursor--;
					i++; // check again for points in the same x position
					if (cursor < 0) {
						break;
					}
				}
			}
		}

		each(points, function (point, i) {
			// place on y axis or custom position
			if (point.plotY === UNDEFINED) { // either on axis, outside series range or hidden series
				point.plotY = chart.plotHeight;
			}
			// if multiple flags appear at the same x, order them into a stack
			lastPoint = points[i - 1];
			if (lastPoint && lastPoint.plotX === point.plotX) {
				if (lastPoint.stackIndex === UNDEFINED) {
					lastPoint.stackIndex = 0;
				}
				point.stackIndex = lastPoint.stackIndex + 1;
			}
					
		});


	},

	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			pointAttr,
			points = series.points,
			chart = series.chart,
			renderer = chart.renderer,
			plotX,
			plotY,
			options = series.options,
			optionsY = options.y,
			shape = options.shape,
			box,
			bBox,
			i,
			point,
			graphic,
			connector,
			stackIndex,
			crisp = (options.lineWidth % 2 / 2),
			anchorX,
			anchorY;

		i = points.length;
		while (i--) {
			point = points[i];
			plotX = point.plotX + crisp;
			stackIndex = point.stackIndex;
			plotY = point.plotY;
			if (plotY !== UNDEFINED) {
				plotY = point.plotY + optionsY + crisp - (stackIndex !== UNDEFINED && stackIndex * options.stackDistance);
			}
			anchorX = stackIndex ? UNDEFINED : point.plotX + crisp; // skip connectors for higher level stacked points
			anchorY = stackIndex ? UNDEFINED : point.plotY;

			graphic = point.graphic;
			connector = point.connector;

			// only draw the point if y is defined
			if (plotY !== UNDEFINED) {
				// shortcuts
				pointAttr = point.pointAttr[point.selected ? 'select' : ''];
				if (graphic) { // update
					graphic.attr({
						x: plotX,
						y: plotY,
						r: pointAttr.r,
						anchorX: anchorX,
						anchorY: anchorY
					});
				} else {
					graphic = point.graphic = renderer.label(
						point.options.title || options.title || 'A',
						plotX,
						plotY,
						shape,
						anchorX,
						anchorY
					)
					.css(merge(options.style, point.style))
					.attr(pointAttr)
					.attr({
						align: shape === 'flag' ? 'left' : 'center',
						width: options.width,
						height: options.height
					})
					.add(series.group)
					.shadow(options.shadow);

				}

				// get the bounding box
				box = graphic.box;
				bBox = box.getBBox();

				// set the shape arguments for the tracker element
				point.shapeArgs = extend(
					bBox,
					{
						x: plotX - (shape === 'flag' ? 0 : box.attr('width') / 2), // flags align left, else align center
						y: plotY
					}
				);

			} else if (graphic) {
				point.graphic = graphic.destroy();
			}

		}

	},

	/**
	 * Extend the column trackers with listeners to expand and contract stacks
	 */
	drawTracker: function () {
		var series = this;

		seriesTypes.column.prototype.drawTracker.apply(series);

		// put each point in front on mouse over, this allows readability of vertically
		// stacked elements as well as tight points on the x axis
		each(series.points, function (point) {
			addEvent(point.tracker.element, 'mouseover', function () {
				point.graphic.toFront();
			});
		});
	},

	/**
	 * Override the regular tooltip formatter by returning the point text given
	 * in the options
	 */
	tooltipFormatter: function (item) {
		return item.point.text;
	},

	/**
	 * Disable animation
	 */
	animate: function () {}

});

// create the flag icon with anchor
symbols.flag = function (x, y, w, h, options) {
	var anchorX = (options && options.anchorX) || x,
		anchorY = (options &&  options.anchorY) || y;

	return [
		'M', anchorX, anchorY,
		'L', x, y + h,
		x, y,
		x + w, y,
		x + w, y + h,
		x, y + h,
		'M', anchorX, anchorY,
		'Z'
	];
};

// create the circlepin and squarepin icons with anchor
each(['circle', 'square'], function (shape) {
	symbols[shape + 'pin'] = function (x, y, w, h, options) {

		var anchorX = options && options.anchorX,
			anchorY = options &&  options.anchorY,
			path = symbols[shape](x, y, w, h);

		if (anchorX && anchorY) {
			path.push('M', anchorX, y + h, 'L', anchorX, anchorY);
		}

		return path;
	};
});

// The symbol callbacks are generated on the SVGRenderer object in all browsers. Even
// VML browsers need this in order to generate shapes in export. Now share
// them with the VMLRenderer.
if (Renderer === VMLRenderer) {
	each(['flag', 'circlepin', 'squarepin'], function (shape) {
		VMLRenderer.prototype.symbols[shape] = symbols[shape];
	});
}

/* ****************************************************************************
 * End Flags series code													  *
 *****************************************************************************/

// constants
var MOUSEDOWN = hasTouch ? 'touchstart' : 'mousedown',
	MOUSEMOVE = hasTouch ? 'touchmove' : 'mousemove',
	MOUSEUP = hasTouch ? 'touchend' : 'mouseup';




/* ****************************************************************************
 * Start Scroller code														*
 *****************************************************************************/
/*jslint white:true */
var buttonGradient = hash(
		LINEAR_GRADIENT, { x1: 0, y1: 0, x2: 0, y2: 1 },
		STOPS, [
			[0, '#FFF'],
			[1, '#CCC']
		]
	),
	units = [].concat(defaultDataGroupingUnits); // copy

// add more resolution to units
units[4] = [DAY, [1, 2, 3, 4]]; // allow more days
units[5] = [WEEK, [1, 2, 3]]; // allow more weeks

extend(defaultOptions, {
	navigator: {
		//enabled: true,
		handles: {
			backgroundColor: '#FFF',
			borderColor: '#666'
		},
		height: 40,
		margin: 10,
		maskFill: 'rgba(255, 255, 255, 0.75)',
		outlineColor: '#444',
		outlineWidth: 1,
		series: {
			type: 'areaspline',
			color: '#4572A7',
			compare: null,
			fillOpacity: 0.4,
			dataGrouping: {
				approximation: 'average',
				groupPixelWidth: 2,
				smoothed: true,
				units: units
			},
			dataLabels: {
				enabled: false
			},
			id: PREFIX + 'navigator-series',
			lineColor: '#4572A7',
			lineWidth: 1,
			marker: {
				enabled: false
			},
			pointRange: 0,
			shadow: false
		},
		//top: undefined,
		xAxis: {
			tickWidth: 0,
			lineWidth: 0,
			gridLineWidth: 1,
			tickPixelInterval: 200,
			labels: {
				align: 'left',
				x: 3,
				y: -4
			}
		},
		yAxis: {
			gridLineWidth: 0,
			startOnTick: false,
			endOnTick: false,
			minPadding: 0.1,
			maxPadding: 0.1,
			labels: {
				enabled: false
			},
			title: {
				text: null
			},
			tickWidth: 0
		}
	},
	scrollbar: {
		//enabled: true
		height: hasTouch ? 20 : 14,
		barBackgroundColor: buttonGradient,
		barBorderRadius: 2,
		barBorderWidth: 1,
		barBorderColor: '#666',
		buttonArrowColor: '#666',
		buttonBackgroundColor: buttonGradient,
		buttonBorderColor: '#666',
		buttonBorderRadius: 2,
		buttonBorderWidth: 1,
		rifleColor: '#666',
		trackBackgroundColor: hash(
			LINEAR_GRADIENT, { x1: 0, y1: 0, x2: 0, y2: 1 },
			STOPS, [
				[0, '#EEE'],
				[1, '#FFF']
			]
		),
		trackBorderColor: '#CCC',
		trackBorderWidth: 1
		// trackBorderRadius: 0
	}
});
/*jslint white:false */

/**
 * The Scroller class
 * @param {Object} chart
 */
Highcharts.Scroller = function (chart) {

	var renderer = chart.renderer,
		chartOptions = chart.options,
		navigatorOptions = chartOptions.navigator,
		navigatorEnabled = navigatorOptions.enabled,
		navigatorLeft,
		navigatorWidth,
		navigatorSeries,
		navigatorData,
		scrollbarOptions = chartOptions.scrollbar,
		scrollbarEnabled = scrollbarOptions.enabled,
		grabbedLeft,
		grabbedRight,
		grabbedCenter,
		otherHandlePos,
		dragOffset,
		hasDragged,
		xAxis,
		yAxis,
		zoomedMin,
		zoomedMax,
		range,

		bodyStyle = document.body.style,
		defaultBodyCursor,

		handlesOptions = navigatorOptions.handles,
		height = navigatorEnabled ? navigatorOptions.height : 0,
		outlineWidth = navigatorOptions.outlineWidth,
		scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0,
		outlineHeight = height + scrollbarHeight,
		barBorderRadius = scrollbarOptions.barBorderRadius,
		top,
		halfOutline = outlineWidth / 2,
		outlineTop,
		scrollerLeft,
		scrollerWidth,
		rendered,
		baseSeriesOption = navigatorOptions.baseSeries,
		baseSeries = chart.series[baseSeriesOption] ||
			(typeof baseSeriesOption === 'string' && chart.get(baseSeriesOption)) ||
			chart.series[0],

		// element wrappers
		leftShade,
		rightShade,
		outline,
		handles = [],
		scrollbarGroup,
		scrollbarTrack,
		scrollbar,
		scrollbarRifles,
		scrollbarButtons = [],
		elementsToDestroy = []; // Array containing the elements to destroy when Scroller is destroyed

	chart.resetZoomEnabled = false;

	/**
	 * Return the top of the navigation 
	 */
	function getAxisTop(chartHeight) {
		return navigatorOptions.top || chartHeight - height - scrollbarHeight - chartOptions.chart.spacingBottom;
	}

	/**
	 * Draw one of the handles on the side of the zoomed range in the navigator
	 * @param {Number} x The x center for the handle
	 * @param {Number} index 0 for left and 1 for right
	 */
	function drawHandle(x, index) {

		var attr = {
				fill: handlesOptions.backgroundColor,
				stroke: handlesOptions.borderColor,
				'stroke-width': 1
			},
			tempElem;

		// create the elements
		if (!rendered) {

			// the group
			handles[index] = renderer.g()
				.css({ cursor: 'e-resize' })
				.attr({ zIndex: 4 - index }) // zIndex = 3 for right handle, 4 for left
				.add();

			// the rectangle
			tempElem = renderer.rect(-4.5, 0, 9, 16, 3, 1)
				.attr(attr)
				.add(handles[index]);
			elementsToDestroy.push(tempElem);

			// the rifles
			tempElem = renderer.path([
					'M',
					-1.5, 4,
					'L',
					-1.5, 12,
					'M',
					0.5, 4,
					'L',
					0.5, 12
				]).attr(attr)
				.add(handles[index]);
			elementsToDestroy.push(tempElem);
		}

		handles[index].translate(scrollerLeft + scrollbarHeight + parseInt(x, 10), top + height / 2 - 8);
	}

	/**
	 * Draw the scrollbar buttons with arrows
	 * @param {Number} index 0 is left, 1 is right
	 */
	function drawScrollbarButton(index) {
		var tempElem;
		if (!rendered) {

			scrollbarButtons[index] = renderer.g().add(scrollbarGroup);

			tempElem = renderer.rect(
				-0.5,
				-0.5,
				scrollbarHeight + 1, // +1 to compensate for crispifying in rect method
				scrollbarHeight + 1,
				scrollbarOptions.buttonBorderRadius,
				scrollbarOptions.buttonBorderWidth
			).attr({
				stroke: scrollbarOptions.buttonBorderColor,
				'stroke-width': scrollbarOptions.buttonBorderWidth,
				fill: scrollbarOptions.buttonBackgroundColor
			}).add(scrollbarButtons[index]);
			elementsToDestroy.push(tempElem);

			tempElem = renderer.path([
				'M',
				scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 - 3,
				'L',
				scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 + 3,
				scrollbarHeight / 2 + (index ? 2 : -2), scrollbarHeight / 2
			]).attr({
				fill: scrollbarOptions.buttonArrowColor
			}).add(scrollbarButtons[index]);
			elementsToDestroy.push(tempElem);
		}

		// adjust the right side button to the varying length of the scroll track
		if (index) {
			scrollbarButtons[index].attr({
				translateX: scrollerWidth - scrollbarHeight
			});
		}
	}

	/**
	 * Render the navigator and scroll bar
	 * @param {Number} min X axis value minimum
	 * @param {Number} max X axis value maximum
	 * @param {Number} pxMin Pixel value minimum
	 * @param {Number} pxMax Pixel value maximum
	 */
	function render(min, max, pxMin, pxMax) {

		// don't render the navigator until we have data (#486)
		if (isNaN(min)) {
			return;
		}

		var strokeWidth,
			scrollbarStrokeWidth = scrollbarOptions.barBorderWidth,
			centerBarX;

		outlineTop = top + halfOutline;
		navigatorLeft = pick(
			xAxis.left,
			chart.plotLeft + scrollbarHeight // in case of scrollbar only, without navigator
		);
		navigatorWidth = pick(xAxis.len, chart.plotWidth - 2 * scrollbarHeight);
		scrollerLeft = navigatorLeft - scrollbarHeight;
		scrollerWidth = navigatorWidth + 2 * scrollbarHeight;

		// Set the scroller x axis extremes to reflect the total. The navigator extremes
		// should always be the extremes of the union of all series in the chart as
		// well as the navigator series.
		if (xAxis.getExtremes) {
			var baseExtremes = chart.xAxis[0].getExtremes(), // the base
				noBase = baseExtremes.dataMin === null,
				navExtremes = xAxis.getExtremes(),
				newMin = mathMin(baseExtremes.dataMin, navExtremes.dataMin),
				newMax = mathMax(baseExtremes.dataMax, navExtremes.dataMax);

			if (!noBase && (newMin !== navExtremes.min || newMax !== navExtremes.max)) {
				xAxis.setExtremes(newMin, newMax, true, false);
			}
		}

		// get the pixel position of the handles
		pxMin = pick(pxMin, xAxis.translate(min));
		pxMax = pick(pxMax, xAxis.translate(max));


		// handles are allowed to cross
		zoomedMin = pInt(mathMin(pxMin, pxMax));
		zoomedMax = pInt(mathMax(pxMin, pxMax));
		range = zoomedMax - zoomedMin;

		// on first render, create all elements
		if (!rendered) {

			if (navigatorEnabled) {

				leftShade = renderer.rect()
					.attr({
						fill: navigatorOptions.maskFill,
						zIndex: 3
					}).add();
				rightShade = renderer.rect()
					.attr({
						fill: navigatorOptions.maskFill,
						zIndex: 3
					}).add();
				outline = renderer.path()
					.attr({
						'stroke-width': outlineWidth,
						stroke: navigatorOptions.outlineColor,
						zIndex: 3
					})
					.add();
			}

			if (scrollbarEnabled) {

				// draw the scrollbar group
				scrollbarGroup = renderer.g().add();

				// the scrollbar track
				strokeWidth = scrollbarOptions.trackBorderWidth;
				scrollbarTrack = renderer.rect().attr({
					y: -strokeWidth % 2 / 2,
					fill: scrollbarOptions.trackBackgroundColor,
					stroke: scrollbarOptions.trackBorderColor,
					'stroke-width': strokeWidth,
					r: scrollbarOptions.trackBorderRadius || 0,
					height: scrollbarHeight
				}).add(scrollbarGroup);

				// the scrollbar itself
				scrollbar = renderer.rect()
					.attr({
						y: -scrollbarStrokeWidth % 2 / 2,
						height: scrollbarHeight,
						fill: scrollbarOptions.barBackgroundColor,
						stroke: scrollbarOptions.barBorderColor,
						'stroke-width': scrollbarStrokeWidth,
						r: barBorderRadius
					})
					.add(scrollbarGroup);

				scrollbarRifles = renderer.path()
					.attr({
						stroke: scrollbarOptions.rifleColor,
						'stroke-width': 1
					})
					.add(scrollbarGroup);
			}
		}

		// place elements
		if (navigatorEnabled) {
			leftShade.attr({
				x: navigatorLeft,
				y: top,
				width: zoomedMin,
				height: height
			});
			rightShade.attr({
				x: navigatorLeft + zoomedMax,
				y: top,
				width: navigatorWidth - zoomedMax,
				height: height
			});
			outline.attr({ d: [
				M,
				scrollerLeft, outlineTop, // left
				L,
				navigatorLeft + zoomedMin + halfOutline, outlineTop, // upper left of zoomed range
				navigatorLeft + zoomedMin + halfOutline, outlineTop + outlineHeight - scrollbarHeight, // lower left of z.r.
				M,
				navigatorLeft + zoomedMax - halfOutline, outlineTop + outlineHeight - scrollbarHeight, // lower right of z.r.
				L,
				navigatorLeft + zoomedMax - halfOutline, outlineTop, // upper right of z.r.
				scrollerLeft + scrollerWidth, outlineTop // right
			]});
			// draw handles
			drawHandle(zoomedMin + halfOutline, 0);
			drawHandle(zoomedMax + halfOutline, 1);
		}

		// draw the scrollbar
		if (scrollbarEnabled) {

			// draw the buttons
			drawScrollbarButton(0);
			drawScrollbarButton(1);

			scrollbarGroup.translate(scrollerLeft, mathRound(outlineTop + height));

			scrollbarTrack.attr({
				width: scrollerWidth
			});

			scrollbar.attr({
				x: mathRound(scrollbarHeight + zoomedMin) + (scrollbarStrokeWidth % 2 / 2),
				width: range - scrollbarStrokeWidth
			});

			centerBarX = scrollbarHeight + zoomedMin + range / 2 - 0.5;

			scrollbarRifles.attr({ d: [
					M,
					centerBarX - 3, scrollbarHeight / 4,
					L,
					centerBarX - 3, 2 * scrollbarHeight / 3,
					M,
					centerBarX, scrollbarHeight / 4,
					L,
					centerBarX, 2 * scrollbarHeight / 3,
					M,
					centerBarX + 3, scrollbarHeight / 4,
					L,
					centerBarX + 3, 2 * scrollbarHeight / 3
				],
				visibility: range > 12 ? VISIBLE : HIDDEN
			});
		}

		rendered = true;
	}

	/**
	 * Event handler for the mouse down event.
	 */
	function mouseDownHandler(e) {
		e = chart.tracker.normalizeMouseEvent(e);
		var chartX = e.chartX,
			chartY = e.chartY,
			handleSensitivity = hasTouch ? 10 : 7,
			left,
			isOnNavigator;

		if (chartY > top && chartY < top + height + scrollbarHeight) { // we're vertically inside the navigator
			isOnNavigator = !scrollbarEnabled || chartY < top + height;

			// grab the left handle
			if (isOnNavigator && math.abs(chartX - zoomedMin - navigatorLeft) < handleSensitivity) {
				grabbedLeft = true;
				otherHandlePos = zoomedMax;

			// grab the right handle
			} else if (isOnNavigator && math.abs(chartX - zoomedMax - navigatorLeft) < handleSensitivity) {
				grabbedRight = true;
				otherHandlePos = zoomedMin;

			// grab the zoomed range
			} else if (chartX > navigatorLeft + zoomedMin && chartX < navigatorLeft + zoomedMax) {
				grabbedCenter = chartX;
				defaultBodyCursor = bodyStyle.cursor;
				bodyStyle.cursor = 'ew-resize';

				dragOffset = chartX - zoomedMin;

			// shift the range by clicking on shaded areas, scrollbar track or scrollbar buttons
			} else if (chartX > scrollerLeft && chartX < scrollerLeft + scrollerWidth) {

				if (isOnNavigator) { // center around the clicked point
					left = chartX - navigatorLeft - range / 2;
				} else { // click on scrollbar
					if (chartX < navigatorLeft) { // click left scrollbar button
						left = zoomedMin - mathMin(10, range);
					} else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {
						left = zoomedMin + mathMin(10, range);
					} else {
						// click on scrollbar track, shift the scrollbar by one range
						left = chartX < navigatorLeft + zoomedMin ? // on the left
							zoomedMin - range :
							zoomedMax;
					}
				}
				if (left < 0) {
					left = 0;
				} else if (left + range > navigatorWidth) {
					left = navigatorWidth - range;
				}
				if (left !== zoomedMin) { // it has actually moved
					chart.xAxis[0].setExtremes(
						xAxis.translate(left, true),
						xAxis.translate(left + range, true),
						true,
						false
					);
				}
			}
		}
		
	}

	/**
	 * Event handler for the mouse move event.
	 */
	function mouseMoveHandler(e) {
		e = chart.tracker.normalizeMouseEvent(e);
		var chartX = e.chartX;

		// validation for handle dragging
		if (chartX < navigatorLeft) {
			chartX = navigatorLeft;
		} else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {
			chartX = scrollerLeft + scrollerWidth - scrollbarHeight;
		}

		// drag left handle
		if (grabbedLeft) {
			hasDragged = true;
			render(0, 0, chartX - navigatorLeft, otherHandlePos);

		// drag right handle
		} else if (grabbedRight) {
			hasDragged = true;
			render(0, 0, otherHandlePos, chartX - navigatorLeft);

		// drag scrollbar or open area in navigator
		} else if (grabbedCenter) {
			hasDragged = true;
			if (chartX < dragOffset) { // outside left
				chartX = dragOffset;
			} else if (chartX > navigatorWidth + dragOffset - range) { // outside right
				chartX = navigatorWidth + dragOffset - range;
			}

			render(0, 0, chartX - dragOffset, chartX - dragOffset + range);
		}
	}

	/**
	 * Event handler for the mouse up event.
	 */
	function mouseUpHandler() {
		if (hasDragged) {
				chart.xAxis[0].setExtremes(
					xAxis.translate(zoomedMin, true),
					xAxis.translate(zoomedMax, true),
					true,
					false
				);
			}
			grabbedLeft = grabbedRight = grabbedCenter = hasDragged = dragOffset = null;
			bodyStyle.cursor = defaultBodyCursor;
	}

	function updatedDataHandler() {
		var baseXAxis = baseSeries.xAxis,
			baseExtremes = baseXAxis.getExtremes(),
			baseMin = baseExtremes.min,
			baseMax = baseExtremes.max,
			baseDataMin = baseExtremes.dataMin,
			baseDataMax = baseExtremes.dataMax,
			range = baseMax - baseMin,
			stickToMin,
			stickToMax,
			newMax,
			newMin,
			doRedraw,
			navXData = navigatorSeries.xData,
			hasSetExtremes = !!baseXAxis.setExtremes;

		// detect whether to move the range
		stickToMax = baseMax >= navXData[navXData.length - 1];
		stickToMin = baseMin <= baseDataMin;

		// set the navigator series data to the new data of the base series
		if (!navigatorData) {
			navigatorSeries.options.pointStart = baseSeries.xData[0];
			navigatorSeries.setData(baseSeries.options.data, false);
			doRedraw = true;
		}

		// if the zoomed range is already at the min, move it to the right as new data
		// comes in
		if (stickToMin) {
			newMin = baseDataMin;
			newMax = newMin + range;
		}

		// if the zoomed range is already at the max, move it to the right as new data
		// comes in
		if (stickToMax) {
			newMax = baseDataMax;
			if (!stickToMin) { // if stickToMin is true, the new min value is set above
				newMin = mathMax(newMax - range, navigatorSeries.xData[0]);
			}
		}

		// update the extremes
		if (hasSetExtremes && (stickToMin || stickToMax)) {
			baseXAxis.setExtremes(newMin, newMax, true, false);
		// if it is not at any edge, just move the scroller window to reflect the new series data
		} else {
			if (doRedraw) {
				chart.redraw(false);
			}

			render(
				mathMax(baseMin, baseDataMin),
				mathMin(baseMax, baseDataMax)
			);
		}
	}

	/**
	 * Set up the mouse and touch events for the navigator and scrollbar
	 */
	function addEvents() {
		addEvent(chart.container, MOUSEDOWN, mouseDownHandler);
		addEvent(chart.container, MOUSEMOVE, mouseMoveHandler);
		addEvent(document, MOUSEUP, mouseUpHandler);
	}

	/**
	 * Removes the event handlers attached previously with addEvents.
	 */
	function removeEvents() {
		removeEvent(chart.container, MOUSEDOWN, mouseDownHandler);
		removeEvent(chart.container, MOUSEMOVE, mouseMoveHandler);
		removeEvent(document, MOUSEUP, mouseUpHandler);
		if (navigatorEnabled) {
			removeEvent(baseSeries, 'updatedData', updatedDataHandler);
		}
	}

	/**
	 * Initiate the Scroller object
	 */
	function init() {
		var xAxisIndex = chart.xAxis.length,
			yAxisIndex = chart.yAxis.length,
			baseChartSetSize = chart.setSize;

		// make room below the chart
		chart.extraBottomMargin = outlineHeight + navigatorOptions.margin;
		// get the top offset
		top = getAxisTop(chart.chartHeight);

		if (navigatorEnabled) {
			var baseOptions = baseSeries.options,
				mergedNavSeriesOptions,
				baseData = baseOptions.data,
				navigatorSeriesOptions = navigatorOptions.series;

			// remove it to prevent merging one by one
			navigatorData = navigatorSeriesOptions.data;
			baseOptions.data = navigatorSeriesOptions.data = null;


			// an x axis is required for scrollbar also
			xAxis = new chart.Axis(merge({
				ordinal: baseSeries.xAxis.options.ordinal // inherit base xAxis' ordinal option
			}, navigatorOptions.xAxis, {
				isX: true,
				type: 'datetime',
				index: xAxisIndex,
				height: height,
				top: top,
				offset: 0,
				offsetLeft: scrollbarHeight,
				offsetRight: -scrollbarHeight,
				startOnTick: false,
				endOnTick: false,
				minPadding: 0,
				maxPadding: 0,
				zoomEnabled: false
			}));

			yAxis = new chart.Axis(merge(navigatorOptions.yAxis, {
				alignTicks: false,
				height: height,
				top: top,
				offset: 0,
				index: yAxisIndex,
				zoomEnabled: false
			}));

			// dmerge the series options
			mergedNavSeriesOptions = merge(baseSeries.options, navigatorSeriesOptions, {
				threshold: null,
				clip: false,
				enableMouseTracking: false,
				group: 'nav', // for columns
				padXAxis: false,
				xAxis: xAxisIndex,
				yAxis: yAxisIndex,
				name: 'Navigator',
				showInLegend: false,
				isInternal: true,
				visible: true
			});

			// set the data back
			baseOptions.data = baseData;
			navigatorSeriesOptions.data = navigatorData;
			mergedNavSeriesOptions.data = navigatorData || baseData;

			// add the series
			navigatorSeries = chart.initSeries(mergedNavSeriesOptions);

			// respond to updated data in the base series
			// todo: use similiar hook when base series is not yet initialized
			addEvent(baseSeries, 'updatedData', updatedDataHandler);

		// in case of scrollbar only, fake an x axis to get translation
		} else {
			xAxis = {
				translate: function (value, reverse) {
					var ext = chart.xAxis[0].getExtremes(),
						scrollTrackWidth = chart.plotWidth - 2 * scrollbarHeight,
						dataMin = ext.dataMin,
						valueRange = ext.dataMax - dataMin;

					return reverse ?
						// from pixel to value
						(value * valueRange / scrollTrackWidth) + dataMin :
						// from value to pixel
						scrollTrackWidth * (value - dataMin) / valueRange;
				}
			};
		}
		
		
		// Override the chart.setSize method to adjust the xAxis and yAxis top option as well.
		// This needs to be done prior to chart.resize
		chart.setSize = function (width, height, animation) {
			xAxis.options.top = yAxis.options.top = top = getAxisTop(height);
			baseChartSetSize.call(chart, width, height, animation);
		};

		addEvents();
	}

	/**
	 * Destroys allocated elements.
	 */
	function destroy() {
		// Disconnect events added in addEvents
		removeEvents();

		// Destroy local variables
		each([xAxis, yAxis, leftShade, rightShade, outline, scrollbarTrack, scrollbar, scrollbarRifles, scrollbarGroup], function (obj) {
			if (obj && obj.destroy) {
				obj.destroy();
			}
		});
		xAxis = yAxis = leftShade = rightShade = outline = scrollbarTrack = scrollbar = scrollbarRifles = scrollbarGroup = null;

		// Destroy elements in collection
		each([scrollbarButtons, handles, elementsToDestroy], function (coll) {
			destroyObjectProperties(coll);
		});
	}

	// Run scroller
	init();

	// Expose
	return {
		render: render,
		destroy: destroy,
		series: navigatorSeries,
		xAxis: xAxis,
		yAxis: yAxis
	};

};

/* ****************************************************************************
 * End Scroller code														  *
 *****************************************************************************/

/* ****************************************************************************
 * Start Range Selector code												  *
 *****************************************************************************/
extend(defaultOptions, {
	rangeSelector: {
		// enabled: true,
		// buttons: {Object}
		// buttonSpacing: 0,
		buttonTheme: {
			width: 28,
			height: 16,
			padding: 1,
			r: 0,
			zIndex: 10 // #484
		//	states: {
		//		hover: {},
		//		select: {}
		// }
		}
		// inputDateFormat: '%b %e, %Y',
		// inputEditDateFormat: '%Y-%m-%d',
		// inputEnabled: true,
		// inputStyle: {}
		// labelStyle: {}
		// selected: undefined
		// todo:
		// - button styles for normal, hover and select state
		// - CSS text styles
		// - styles for the inputs and labels
	}
});
defaultOptions.lang = merge(defaultOptions.lang, {
	rangeSelectorZoom: 'Zoom',
	rangeSelectorFrom: 'From:',
	rangeSelectorTo: 'To:'
});

/**
 * The object constructor for the range selector
 * @param {Object} chart
 */
Highcharts.RangeSelector = function (chart) {
	var renderer = chart.renderer,
		rendered,
		container = chart.container,
		lang = defaultOptions.lang,
		div,
		leftBox,
		rightBox,
		boxSpanElements = {},
		divAbsolute,
		divRelative,
		selected,
		zoomText,
		buttons = [],
		buttonOptions,
		options,
		defaultButtons = [{
			type: 'month',
			count: 1,
			text: '1m'
		}, {
			type: 'month',
			count: 3,
			text: '3m'
		}, {
			type: 'month',
			count: 6,
			text: '6m'
		}, {
			type: 'ytd',
			text: 'YTD'
		}, {
			type: 'year',
			count: 1,
			text: '1y'
		}, {
			type: 'all',
			text: 'All'
		}];
		chart.resetZoomEnabled = false;

	/**
	 * The method to run when one of the buttons in the range selectors is clicked
	 * @param {Number} i The index of the button
	 * @param {Object} rangeOptions
	 * @param {Boolean} redraw
	 */
	function clickButton(i, rangeOptions, redraw) {

		var baseAxis = chart.xAxis[0],
			extremes = baseAxis && baseAxis.getExtremes(),
			navAxis = chart.scroller && chart.scroller.xAxis,
			navExtremes = navAxis && navAxis.getExtremes && navAxis.getExtremes(),
			navDataMin = navExtremes && navExtremes.dataMin,
			navDataMax = navExtremes && navExtremes.dataMax,
			baseDataMin = extremes && extremes.dataMin,
			baseDataMax = extremes && extremes.dataMax,
			dataMin = mathMin(baseDataMin, pick(navDataMin, baseDataMin)),
			dataMax = mathMax(baseDataMax, pick(navDataMax, baseDataMax)),
			newMin,
            newMax = rangeOptions.by == 'max' 
                // [CUSTOMIZED]
                ? dataMax
                : baseAxis && mathMin(extremes.max, dataMax),
            now,
            date = new Date(newMax),
            type = rangeOptions.type,
			count = rangeOptions.count,
			baseXAxisOptions,
			range,
			rangeMin,
			year,
            o,
			// these time intervals have a fixed number of milliseconds, as opposed
			// to month, ytd and year
			fixedTimes = {
				millisecond: 1,
				second: 1000,
				minute: 60 * 1000,
				hour: 3600 * 1000,
				day: 24 * 3600 * 1000,
				week: 7 * 24 * 3600 * 1000
			};



		if (dataMin === null || dataMax === null || // chart has no data, base series is removed
				i === selected) { // same button is clicked twice
			return;
		}

		if (fixedTimes[type]) {
            range = fixedTimes[type] * count;
            newMin = mathMax(newMax - range, dataMin);
		} else if (type === 'month') {
            date.setMonth(date.getMonth() - count);
            newMin = mathMax(date.getTime(), dataMin);
            range = 30 * 24 * 3600 * 1000 * count;
		} else if (type === 'ytd') {
			date = new Date(0);
			now = new Date(dataMax);
			year = now.getFullYear();
			date.setFullYear(year);

			// workaround for IE6 bug, which sets year to next year instead of current
			if (String(year) !== dateFormat('%Y', date)) {
				date.setFullYear(year - 1);
			}

			newMin = rangeMin = mathMax(dataMin || 0, date.getTime());
			now = now.getTime();
			newMax = mathMin(dataMax || now, now);
		} else if (type === 'year') {
			date.setFullYear(date.getFullYear() - count);
			newMin = mathMax(dataMin, date.getTime());
			range = 365 * 24 * 3600 * 1000 * count;
		} else if (type === 'all' && baseAxis) {
			newMin = dataMin;
			newMax = dataMax;
		} else if (Object.prototype.toString.call(type) == '[object Function]') {
            // [CUSTOMIZED]
            // user defined rangeSelector
            o = type({ newMax: newMax, dataMax: dataMax });
            o.newMin != null && (newMin = o.newMin);
            o.newMax != null && (newMax = o.newMax);
            o.range != null && (range = o.range);
        }

		// mark the button pressed
		if (buttons[i]) {
			buttons[i].setState(2);
		}

		// update the chart
		if (!baseAxis) { // axis not yet instanciated
			baseXAxisOptions = chart.options.xAxis;
			baseXAxisOptions[0] = merge(
				baseXAxisOptions[0],
				{
					range: range,
					min: rangeMin
				}
			);
			selected = i;

		} else { // existing axis object; after render time
			setTimeout(function () { // make sure the visual state is set before the heavy process begins
				baseAxis.setExtremes(
					newMin,
					newMax,
					pick(redraw, 1),
					0,
					{ rangeSelectorButton: rangeOptions }
				);
				selected = i;
			}, 1);
		}

	}

	/**
	 * The handler connected to container that handles mousedown.
	 */
	function mouseDownHandler() {
		if (leftBox) {
			leftBox.blur();
		}
		if (rightBox) {
			rightBox.blur();
		}
	}

	/**
	 * Initialize the range selector
	 */
	function init() {
		chart.extraTopMargin = 25;
		options = chart.options.rangeSelector;
		buttonOptions = options.buttons || defaultButtons;


		var selectedOption = options.selected;

		addEvent(container, MOUSEDOWN, mouseDownHandler);

		// zoomed range based on a pre-selected button index
		if (selectedOption !== UNDEFINED && buttonOptions[selectedOption]) {
			clickButton(selectedOption, buttonOptions[selectedOption], false);
		}

		// normalize the pressed button whenever a new range is selected
		addEvent(chart, 'load', function () {
			addEvent(chart.xAxis[0], 'afterSetExtremes', function () {
				//if (this.isDirty) {  // [CUSTOMIZED]
					if (buttons[selected]) {
						buttons[selected].setState(0);
					}
					selected = null;
				//}
			});
		});
	}


	/**
	 * Set the internal and displayed value of a HTML input for the dates
	 * @param {Object} input
	 * @param {Number} time
	 */
	function setInputValue(input, time) {
		var format = input.hasFocus ? options.inputEditDateFormat || '%Y-%m-%d' : options.inputDateFormat || '%b %e, %Y';
		if (time) {
			input.HCTime = time;
		}
		input.value = dateFormat(format, input.HCTime);
	}

	/**
	 * Draw either the 'from' or the 'to' HTML input box of the range selector
	 * @param {Object} name
	 */
	function drawInput(name) {
		var isMin = name === 'min',
			input;

		// create the text label
		boxSpanElements[name] = createElement('span', {
			innerHTML: lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo']
		}, options.labelStyle, div);

		// create the input element
		input = createElement('input', {
			name: name,
			className: PREFIX + 'range-selector',
			type: 'text'
		}, extend({
			width: '80px',
			height: '16px',
			border: '1px solid silver',
			marginLeft: '5px',
			marginRight: isMin ? '5px' : '0',
			textAlign: 'center'
		}, options.inputStyle), div);

		input.onfocus = input.onblur = function (e) {
			e = e || window.event;
			input.hasFocus = e.type === 'focus';
			setInputValue(input);
		};

		// handle changes in the input boxes
		input.onchange = function () {
			var inputValue = input.value,
				value = Date.parse(inputValue),
				extremes = chart.xAxis[0].getExtremes();

            // if the value isn't parsed directly to a value by the browser's Date.parse method,
            // like YYYY-MM-DD in IE, try parsing it a different way
            if (isNaN(value)) {
                value = inputValue.split('-');
                // value = Date.UTC(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));
                value = makeTime(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));
            }

			// if the value isn't parsed by methods above,
			// try parsing it by quarter parser
            if (isNaN(value)) {
                value = parseQuarter(inputValue);
            }

			if (!isNaN(value) &&
				((isMin && (value >= extremes.dataMin && value <= rightBox.HCTime)) ||
				(!isMin && (value <= extremes.dataMax && value >= leftBox.HCTime)))
			) {
				chart.xAxis[0].setExtremes(
					isMin ? value : extremes.min,
					isMin ? extremes.max : value
				);
			}
		};

		return input;
	}

    /**
     * Parse quarter, i.e. parse '2012-Q1' to the first Date of the quarter
     * [CUSTOMIZED]
     */    
    function parseQuarter(dateStr) {
        var par = [0, 0, 3, 6, 9];
        dateStr = dateStr.split('-Q'); 
        return dateStr.length != 2 
            ? NaN
            : new Date(
                parseInt(dateStr[0], 10), 
                par[parseInt(dateStr[1], 10)], 
                1
            ).getTime();
    };

	/**
	 * Render the range selector including the buttons and the inputs. The first time render
	 * is called, the elements are created and positioned. On subsequent calls, they are
	 * moved and updated.
	 * @param {Number} min X axis minimum
	 * @param {Number} max X axis maximum
	 */
	function render(min, max) {
		var chartStyle = chart.options.chart.style,
			buttonTheme = options.buttonTheme,
			inputEnabled = options.inputEnabled !== false,
			states = buttonTheme && buttonTheme.states,
			plotLeft = chart.plotLeft,
			buttonLeft;

		// create the elements
		if (!rendered) {
			zoomText = renderer.text(lang.rangeSelectorZoom, plotLeft, chart.plotTop - 10)
				.css(options.labelStyle)
				.add();

			// button starting position
			buttonLeft = plotLeft + zoomText.getBBox().width + 5;

			each(buttonOptions, function (rangeOptions, i) {
				buttons[i] = renderer.button(
					rangeOptions.text,
					buttonLeft,
					chart.plotTop - 25,
					function () {
						clickButton(i, rangeOptions);
						this.isActive = true;
					},
					buttonTheme,
					states && states.hover,
					states && states.select
				)
				.css({
					textAlign: 'center'
				})
				.add();

				// increase button position for the next button
				buttonLeft += buttons[i].width + (options.buttonSpacing || 0);

				if (selected === i) {
					buttons[i].setState(2);
				}

			});

			// first create a wrapper outside the container in order to make
			// the inputs work and make export correct
			if (inputEnabled) {
				divRelative = div = createElement('div', null, {
					position: 'relative',
					height: 0,
					fontFamily: chartStyle.fontFamily,
					fontSize: chartStyle.fontSize,
					zIndex: 1 // above container
				});

				container.parentNode.insertBefore(div, container);

				// create an absolutely positionied div to keep the inputs
				divAbsolute = div = createElement('div', null, extend({
					position: 'absolute',
					top: (chart.plotTop - 25) + 'px',
					right: (chart.chartWidth - chart.plotLeft - chart.plotWidth) + 'px'
				}, options.inputBoxStyle), div);

				leftBox = drawInput('min');

				rightBox = drawInput('max');
			}
		}

		if (inputEnabled) {
			setInputValue(leftBox, min);
			setInputValue(rightBox, max);
		}


		rendered = true;
	}

	/**
	 * Destroys allocated elements.
	 */
	function destroy() {
		removeEvent(container, MOUSEDOWN, mouseDownHandler);

		// Destroy elements in collections
		each([buttons], function (coll) {
			destroyObjectProperties(coll);
		});

		// Destroy zoomText
		if (zoomText) {
			zoomText = zoomText.destroy();
		}

		// Clear input element events
		if (leftBox) {
			leftBox.onfocus = leftBox.onblur = leftBox.onchange = null;
		}
		if (rightBox) {
			rightBox.onfocus = rightBox.onblur = rightBox.onchange = null;
		}

		// Discard divs and spans
		each([leftBox, rightBox, boxSpanElements.min, boxSpanElements.max, divAbsolute, divRelative], function (item) {
			discardElement(item);
		});
		// Null the references
		leftBox = rightBox = boxSpanElements = div = divAbsolute = divRelative = null;

	}

	// Run RangeSelector
	init();

	// Expose
	return {
		render: render,
		destroy: destroy
	};
};

/* ****************************************************************************
 * End Range Selector code													*
 *****************************************************************************/



Chart.prototype.callbacks.push(function (chart) {
	var extremes,
		scroller = chart.scroller,
		rangeSelector = chart.rangeSelector;

	function renderScroller() {
		extremes = chart.xAxis[0].getExtremes();
		scroller.render(
			mathMax(extremes.min, extremes.dataMin),
			mathMin(extremes.max, extremes.dataMax)
		);
	}

	function renderRangeSelector() {
		extremes = chart.xAxis[0].getExtremes();
		rangeSelector.render(extremes.min, extremes.max);
	}

	function afterSetExtremesHandlerScroller(e) {
		scroller.render(e.min, e.max);
	}

	function afterSetExtremesHandlerRangeSelector(e) {
		rangeSelector.render(e.min, e.max);
	}

	function destroyEvents() {
		if (scroller) {
			removeEvent(chart, 'resize', renderScroller);
			removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);
		}
		if (rangeSelector) {
			removeEvent(chart, 'resize', renderRangeSelector);
			removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);
		}
	}

	// initiate the scroller
	if (scroller) {
		// redraw the scroller on setExtremes
		addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);

		// redraw the scroller chart resize
		addEvent(chart, 'resize', renderScroller);

		// do it now
		renderScroller();
	}
	if (rangeSelector) {
		// redraw the scroller on setExtremes
		addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);

		// redraw the scroller chart resize
		addEvent(chart, 'resize', renderRangeSelector);

		// do it now
		renderRangeSelector();
	}

	// Remove resize/afterSetExtremes at chart destroy
	addEvent(chart, 'destroy', destroyEvents);
});
/**
 * A wrapper for Chart with all the default values for a Stock chart
 */
Highcharts.StockChart = function (options, callback) {
	var seriesOptions = options.series, // to increase performance, don't merge the data 
		opposite,
		lineOptions = {

			marker: {
				enabled: false,
				states: {
					hover: {
						enabled: true,
						radius: 5
					}
				}
			},
			// gapSize: 0,
			shadow: false,
			states: {
				hover: {
					lineWidth: 2
				}
			},
			dataGrouping: {
				enabled: true
			}
		};

	// apply X axis options to both single and multi y axes
	options.xAxis = map(splat(options.xAxis || {}), function (xAxisOptions) {
		return merge({ // defaults
				minPadding: 0,
				maxPadding: 0,
				ordinal: true,
				title: {
					text: null
				},
				showLastLabel: true
			}, xAxisOptions, // user options 
			{ // forced options
				type: 'datetime',
				categories: null
			});
	});

	// apply Y axis options to both single and multi y axes
	options.yAxis = map(splat(options.yAxis || {}), function (yAxisOptions) {
		opposite = yAxisOptions.opposite;
		return merge({ // defaults
			labels: {
				align: opposite ? 'right' : 'left',
				x: opposite ? -2 : 2,
				y: -2
			},
			showLastLabel: false,
			title: {
				text: null
			}
		}, yAxisOptions // user options
		);
	});

	options.series = null;

	options = merge({
		chart: {
			panning: true
		},
		navigator: {
			enabled: true
		},
		scrollbar: {
			enabled: true
		},
		rangeSelector: {
			enabled: true
		},
		title: {
			text: null
		},
		tooltip: {
			shared: true,
			crosshairs: true
		},
		legend: {
			enabled: false
		},

		plotOptions: {
			line: lineOptions,
			spline: lineOptions,
			area: lineOptions,
			areaspline: lineOptions,
			column: {
				shadow: false,
				borderWidth: 0,
				dataGrouping: {
					enabled: true
				}
			}
		}

	},
	options, // user's options

	{ // forced options
		chart: {
			inverted: false
		}
	});

	options.series = seriesOptions;


	return new Chart(options, callback);
};


/* ****************************************************************************
 * Start value compare logic                                                  *
 *****************************************************************************/
 
var seriesInit = seriesProto.init, 
	seriesProcessData = seriesProto.processData,
	pointTooltipFormatter = Point.prototype.tooltipFormatter;
	
/**
 * Extend series.init by adding a method to modify the y value used for plotting
 * on the y axis. This method is called both from the axis when finding dataMin
 * and dataMax, and from the series.translate method.
 */
seriesProto.init = function () {
	
	// call base method
	seriesInit.apply(this, arguments);
	
	// local variables
	var series = this,
		compare = series.options.compare;
	
	if (compare) {
		series.modifyValue = function (value, point) {
			var compareValue = this.compareValue;
			
			// get the modified value
			value = compare === 'value' ? 
				value - compareValue : // compare value
				value = 100 * (value / compareValue) - 100; // compare percent
				
			// record for tooltip etc.
			if (point) {
				point.change = value;
			}
			
			return value;
		};
	}	
};

/**
 * Extend series.processData by finding the first y value in the plot area,
 * used for comparing the following values 
 */
seriesProto.processData = function () {
	var series = this;
	
	// call base method
	seriesProcessData.apply(this, arguments);
	
	if (series.options.compare) {
		
		// local variables
		var i = 0,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			length = processedYData.length,
			min = series.xAxis.getExtremes().min;
		
		// find the first value for comparison
		for (; i < length; i++) {
			if (typeof processedYData[i] === NUMBER && processedXData[i] >= min) {
				series.compareValue = processedYData[i];
				break;
			}
		}
	}
};

/**
 * Extend the tooltip formatter by adding support for the point.change variable
 * as well as the changeDecimals option
 */
Point.prototype.tooltipFormatter = function (pointFormat) {
	var point = this;
	
	pointFormat = pointFormat.replace(
		'{point.change}',
		(point.change > 0 ? '+' : '') + numberFormat(point.change, point.series.tooltipOptions.changeDecimals || 2)
	); 
	
	return pointTooltipFormatter.apply(this, [pointFormat]);
};

/* ****************************************************************************
 * End value compare logic                                                    *
 *****************************************************************************/

/* ****************************************************************************
 * Start ordinal axis logic                                                   *
 *****************************************************************************/

(function () {
	var baseInit = seriesProto.init,
		baseGetSegments = seriesProto.getSegments;
		
	seriesProto.init = function () {
		var series = this,
			chart,
			xAxis;
		
		// call base method
		baseInit.apply(series, arguments);
		
		// chart and xAxis are set in base init
		chart = series.chart;
		xAxis = series.xAxis;
		
		// Destroy the extended ordinal index on updated data
		if (xAxis && xAxis.options.ordinal) {
			addEvent(series, 'updatedData', function () {
				delete xAxis.ordinalIndex;
			});
		}
		
		/**
		 * Extend the ordinal axis object. If we rewrite the axis object to a prototype model,
		 * we should add these properties to the prototype instead.
		 */
		if (xAxis && xAxis.options.ordinal && !xAxis.hasOrdinalExtension) {
				
			xAxis.hasOrdinalExtension = true;
		
			/**
			 * Calculate the ordinal positions before tick positions are calculated. 
			 * TODO: When we rewrite Axis to use a prototype model, this should be implemented
			 * as a method extension to avoid overhead in the core.
			 */
			xAxis.beforeSetTickPositions = function () {
				var axis = this,
					len,
					ordinalPositions = [],
					useOrdinal = false,
					dist,
					extremes = axis.getExtremes(),
					min = extremes.min,
					max = extremes.max,
					minIndex,
					maxIndex,
					slope,
					i;
				
				// apply the ordinal logic
				if (axis.options.ordinal) {
					
					each(axis.series, function (series, i) {
						
						if (series.visible !== false) {
							
							// concatenate the processed X data into the existing positions, or the empty array 
							ordinalPositions = ordinalPositions.concat(series.processedXData);
							len = ordinalPositions.length;
							
							// if we're dealing with more than one series, remove duplicates
							if (i && len) {
							
								ordinalPositions.sort(function (a, b) {
									return a - b; // without a custom function it is sorted as strings
								});
							
								i = len - 1;
								while (i--) {
									if (ordinalPositions[i] === ordinalPositions[i + 1]) {
										ordinalPositions.splice(i, 1);
									}
								}
							}
						}
						
					});
					
					// cache the length
					len = ordinalPositions.length;					
					
					// Check if we really need the overhead of mapping axis data against the ordinal positions.
					// If the series consist of evenly spaced data any way, we don't need any ordinal logic.
					if (len > 2) { // two points have equal distance by default
						dist = ordinalPositions[1] - ordinalPositions[0]; 
						i = len - 1;
						while (i-- && !useOrdinal) {
							if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
								useOrdinal = true;
							}
						}
					}
					
					// Record the slope and offset to compute the linear values from the array index.
					// Since the ordinal positions may exceed the current range, get the start and 
					// end positions within it (#719, #665b)
					if (useOrdinal) {
						
						// Register
						axis.ordinalPositions = ordinalPositions;
						
						// This relies on the ordinalPositions being set
						minIndex = xAxis.val2lin(min, true);
						maxIndex = xAxis.val2lin(max, true);
				
						// Set the slope and offset of the values compared to the indices in the ordinal positions
						axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);
						axis.ordinalOffset = min - (minIndex * slope);
						
					} else {
						axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = UNDEFINED;
					}
				}
			};
			
			/**
			 * Translate from a linear axis value to the corresponding ordinal axis position. If there
			 * are no gaps in the ordinal axis this will be the same. The translated value is the value
			 * that the point would have if the axis were linear, using the same min and max.
			 * 
			 * @param Number val The axis value
			 * @param Boolean toIndex Whether to return the index in the ordinalPositions or the new value
			 */
			xAxis.val2lin = function (val, toIndex) {
				
				var axis = this,
					ordinalPositions = axis.ordinalPositions;
				
				if (!ordinalPositions) {
					return val;
				
				} else {
				
					var ordinalLength = ordinalPositions.length,
						i,
						distance,
						ordinalIndex;
						
					// first look for an exact match in the ordinalpositions array
					i = ordinalLength;
					while (i--) {
						if (ordinalPositions[i] === val) {
							ordinalIndex = i;
							break;
						}
					}
					
					// if that failed, find the intermediate position between the two nearest values
					i = ordinalLength - 1;
					while (i--) {
						if (val > ordinalPositions[i] || i === 0) { // interpolate
							distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]); // something between 0 and 1
							ordinalIndex = i + distance;
							break;
						}
					}
					return toIndex ?
						ordinalIndex :
						axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;
				}
			};
			
			/**
			 * Translate from linear (internal) to axis value
			 * 
			 * @param Number val The linear abstracted value
			 * @param Boolean fromIndex Translate from an index in the ordinal positions rather than a value
			 */
			xAxis.lin2val = function (val, fromIndex) {
				var axis = this,
					ordinalPositions = axis.ordinalPositions;
				
				if (!ordinalPositions) { // the visible range contains only equally spaced values
					return val;
				
				} else {
				
					var ordinalSlope = axis.ordinalSlope,
						ordinalOffset = axis.ordinalOffset,
						i = ordinalPositions.length - 1,
						linearEquivalentLeft,
						linearEquivalentRight,
						distance;
						
					
					// Handle the case where we translate from the index directly, used only 
					// when panning an ordinal axis
					if (fromIndex) {
						
						if (val < 0) { // out of range, in effect panning to the left
							val = ordinalPositions[0];
						} else if (val > i) { // out of range, panning to the right
							val = ordinalPositions[i];
						} else { // split it up
							i = mathFloor(val);
							distance = val - i; // the decimal
						}
						
					// Loop down along the ordinal positions. When the linear equivalent of i matches
					// an ordinal position, interpolate between the left and right values.
					} else {
						while (i--) {
							linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;
							if (val >= linearEquivalentLeft) {
								linearEquivalentRight = (ordinalSlope * (i + 1)) + ordinalOffset;
								distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft); // something between 0 and 1
								break;
							}
						}
					}
					
					// If the index is within the range of the ordinal positions, return the associated
					// or interpolated value. If not, just return the value
					return distance !== UNDEFINED && ordinalPositions[i] !== UNDEFINED ?
						ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) : 
						val;
				}
			};
			
			/**
			 * Get the ordinal positions for the entire data set. This is necessary in chart panning
			 * because we need to find out what points or data groups are available outside the 
			 * visible range. When a panning operation starts, if an index for the given grouping
			 * does not exists, it is created and cached. This index is deleted on updated data, so
			 * it will be regenerated the next time a panning operation starts.
			 */
			xAxis.getExtendedPositions = function () {
				var grouping = xAxis.series[0].currentDataGrouping,
					ordinalIndex = xAxis.ordinalIndex,
					key = grouping ? grouping.count + grouping.unitName : 'raw',
					extremes = xAxis.getExtremes(),
					fakeAxis,
					fakeSeries;
					
				// If this is the first time, or the ordinal index is deleted by updatedData,
				// create it.
				if (!ordinalIndex) {
					ordinalIndex = xAxis.ordinalIndex = {};
				}
				
				
				if (!ordinalIndex[key]) {
					
					// Create a fake axis object where the extended ordinal positions are emulated
					fakeAxis = {
						series: [],
						getExtremes: function () {
							return {
								min: extremes.dataMin,
								max: extremes.dataMax
							};
						},
						options: {
							ordinal: true
						}
					};
					
					// Add the fake series to hold the full data, then apply processData to it
					each(xAxis.series, function (series) {
						fakeSeries = {
							xAxis: fakeAxis,
							xData: series.xData,
							chart: chart
						};
						fakeSeries.options = {
							dataGrouping : grouping ? {
								enabled: true,
								forced: true,
								approximation: 'open', // doesn't matter which, use the fastest
								units: [[grouping.unitName, [grouping.count]]]
							} : {
								enabled: false
							}
						};
						series.processData.apply(fakeSeries);
						
						fakeAxis.series.push(fakeSeries);
					});
					
					// Run beforeSetTickPositions to compute the ordinalPositions
					xAxis.beforeSetTickPositions.apply(fakeAxis);
					
					// Cache it
					ordinalIndex[key] = fakeAxis.ordinalPositions;
				}
				return ordinalIndex[key];
			};
			
			/**
			 * Find the factor to estimate how wide the plot area would have been if ordinal
			 * gaps were included. This value is used to compute an imagined plot width in order
			 * to establish the data grouping interval. 
			 * 
			 * A real world case is the intraday-candlestick
			 * example. Without this logic, it would show the correct data grouping when viewing
			 * a range within each day, but once moving the range to include the gap between two
			 * days, the interval would include the cut-away night hours and the data grouping
			 * would be wrong. So the below method tries to compensate by identifying the most
			 * common point interval, in this case days. 
			 * 
			 * An opposite case is presented in issue #718. We have a long array of daily data,
			 * then one point is appended one hour after the last point. We expect the data grouping
			 * not to change.
			 * 
			 * In the future, if we find cases where this estimation doesn't work optimally, we
			 * might need to add a second pass to the data grouping logic, where we do another run
			 * with a greater interval if the number of data groups is more than a certain fraction
			 * of the desired group count.
			 */
			xAxis.getGroupIntervalFactor = function (xMin, xMax, processedXData) {
				var i = 0,
					len = processedXData.length, 
					distances = [],
					median;
					
				// Register all the distances in an array
				for (; i < len - 1; i++) {
					distances[i] = processedXData[i + 1] - processedXData[i];
				}
				
				// Sort them and find the median
				distances.sort(function (a, b) {
					return a - b;
				});
				median = distances[mathFloor(len / 2)];
				
				// Return the factor needed for data grouping
				return (len * median) / (xMax - xMin);
			};
			
			/**
			 * Make the tick intervals closer because the ordinal gaps make the ticks spread out or cluster
			 */
			xAxis.postProcessTickInterval = function (tickInterval) {
				// TODO: http://jsfiddle.net/highcharts/FQm4E/1/
				// This is a case where this algorithm doesn't work optimally. In this case, the 
				// tick labels are spread out per week, but all the gaps reside within weeks. So 
				// we have a situation where the labels are courser than the ordinal gaps, and 
				// thus the tick interval should not be altered				
				var ordinalSlope = this.ordinalSlope;
				
				return ordinalSlope ? 
					tickInterval / (ordinalSlope / xAxis.closestPointRange) : 
					tickInterval;
			};
			
			/**
			 * In an ordinal axis, there might be areas with dense consentrations of points, then large
			 * gaps between some. Creating equally distributed ticks over this entire range
			 * may lead to a huge number of ticks that will later be removed. So instead, break the 
			 * positions up in segments, find the tick positions for each segment then concatenize them.
			 * This method is used from both data grouping logic and X axis tick position logic. 
			 */
			xAxis.getNonLinearTimeTicks = function (normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {
				
				var start = 0,
					end = 0,
					segmentPositions,
					higherRanks = {},
					hasCrossedHigherRank,
					info,
					posLength,
					outsideMax,
					groupPositions = [],
					tickPixelIntervalOption = xAxis.options.tickPixelInterval;
					
				// The positions are not always defined, for example for ordinal positions when data
				// has regular interval
				if (!positions || min === UNDEFINED) {
					return getTimeTicks(normalizedInterval, min, max, startOfWeek);
				}
				
				// Analyze the positions array to split it into segments on gaps larger than 5 times
				// the closest distance. The closest distance is already found at this point, so 
				// we reuse that instead of computing it again.
				posLength = positions.length;
				for (; end < posLength; end++) {
					
					outsideMax = end && positions[end - 1] > max;
					
					if (positions[end] < min) { // Set the last position before min
						start = end;						
					}
					
					if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {
						
						// For each segment, calculate the tick positions from the getTimeTicks utility
						// function. The interval will be the same regardless of how long the segment is.
						segmentPositions = getTimeTicks(normalizedInterval, positions[start], positions[end], startOfWeek);		
						
						groupPositions = groupPositions.concat(segmentPositions);
						
						// Set start of next segment
						start = end + 1;						
					}
					
					if (outsideMax) {
						break;
					}
				}
				
				// Get the grouping info from the last of the segments. The info is the same for
				// all segments.
				info = segmentPositions.info;
				
				// Optionally identify ticks with higher rank, for example when the ticks
				// have crossed midnight.
				if (findHigherRanks && info.unitRange <= timeUnits[HOUR]) {
					end = groupPositions.length - 1;
					
					// Compare points two by two
					for (start = 1; start < end; start++) {
						if (new Date(groupPositions[start])[getDate]() !== new Date(groupPositions[start - 1])[getDate]()) {
							higherRanks[groupPositions[start]] = DAY;
							hasCrossedHigherRank = true;
						}
					}
					
					// If the complete array has crossed midnight, we want to mark the first
					// positions also as higher rank
					if (hasCrossedHigherRank) {
						higherRanks[groupPositions[0]] = DAY;
					}
					info.higherRanks = higherRanks;
				}
				
				// Save the info
				groupPositions.info = info;
				
				
				
				// Don't show ticks within a gap in the ordinal axis, where the space between
				// two points is greater than a portion of the tick pixel interval
				if (findHigherRanks && defined(tickPixelIntervalOption)) { // check for squashed ticks
					
					var length = groupPositions.length,
						i = length,
						itemToRemove,
						translated,
						translatedArr = [],
						lastTranslated,
						medianDistance,
						distance,
						distances = [];
						
					// Find median pixel distance in order to keep a reasonably even distance between
					// ticks (#748)
					while (i--) {
						translated = xAxis.translate(groupPositions[i]);
						if (lastTranslated) {
							distances[i] = lastTranslated - translated;
						}
						translatedArr[i] = lastTranslated = translated; 
					}
					distances.sort();
					medianDistance = distances[mathFloor(distances.length / 2)];
					if (medianDistance < tickPixelIntervalOption * 0.6) {
						medianDistance = null;
					}
					
					// Now loop over again and remove ticks where needed
					i = groupPositions[length - 1] > max ? length - 1 : length; // #817
					lastTranslated = undefined;
					while (i--) {
						translated = translatedArr[i];
						distance = lastTranslated - translated;
	
						// Remove ticks that are closer than 0.6 times the pixel interval from the one to the right,
						// but not if it is close to the median distance (#748).
						if (lastTranslated && distance < tickPixelIntervalOption * 0.8 && 
								(medianDistance === null || distance < medianDistance * 0.8)) {
							
							// Is this a higher ranked position with a normal position to the right?
							if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {
								
								// Yes: remove the lower ranked neighbour to the right
								itemToRemove = i + 1;
								lastTranslated = translated; // #709
								
							} else {
								
								// No: remove this one
								itemToRemove = i;
							}
							
							groupPositions.splice(itemToRemove, 1);
							
						} else {
							lastTranslated = translated;
						}
					}
				}
				
				return groupPositions;
			};
			
			
			/**
			 * Overrride the chart.pan method for ordinal axes. 
			 */
			
			var baseChartPan = chart.pan;
			chart.pan = function (chartX) {
				var xAxis = chart.xAxis[0],
					runBase = false;
				if (xAxis.options.ordinal) {
					
					var mouseDownX = chart.mouseDownX,
						extremes = xAxis.getExtremes(),
						dataMax = extremes.dataMax,
						min = extremes.min,
						max = extremes.max,
						newMin,
						newMax,
						hoverPoints = chart.hoverPoints,
						closestPointRange = xAxis.closestPointRange,
						pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),
						movedUnits = (mouseDownX - chartX) / pointPixelWidth, // how many ordinal units did we move?
						extendedAxis = { ordinalPositions: xAxis.getExtendedPositions() }, // get index of all the chart's points
						ordinalPositions,
						searchAxisLeft,
						lin2val = xAxis.lin2val,
						val2lin = xAxis.val2lin,
						searchAxisRight;
					
					if (!extendedAxis.ordinalPositions) { // we have an ordinal axis, but the data is equally spaced
						runBase = true;
					
					} else if (mathAbs(movedUnits) > 1) {
						
						// Remove active points for shared tooltip
						if (hoverPoints) {
							each(hoverPoints, function (point) {
								point.setState();
							});
						}
						
						if (movedUnits < 0) {
							searchAxisLeft = extendedAxis;
							searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;
						} else {
							searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;
							searchAxisRight = extendedAxis;
						}
						
						// In grouped data series, the last ordinal position represents the grouped data, which is 
						// to the left of the real data max. If we don't compensate for this, we will be allowed
						// to pan grouped data series passed the right of the plot area. 
						ordinalPositions = searchAxisRight.ordinalPositions;
						if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
							ordinalPositions.push(dataMax);
						}
						
						// Get the new min and max values by getting the ordinal index for the current extreme, 
						// then add the moved units and translate back to values. This happens on the 
						// extended ordinal positions if the new position is out of range, else it happens
						// on the current x axis which is smaller and faster.
						newMin = lin2val.apply(searchAxisLeft, [
							val2lin.apply(searchAxisLeft, [min, true]) + movedUnits, // the new index 
							true // translate from index
						]);
						newMax = lin2val.apply(searchAxisRight, [
							val2lin.apply(searchAxisRight, [max, true]) + movedUnits, // the new index 
							true // translate from index
						]);
						
						// Apply it if it is within the available data range
						if (newMin > mathMin(extremes.dataMin, min) && newMax < mathMax(dataMax, max)) {
							xAxis.setExtremes(newMin, newMax, true, false);
						}
				
						chart.mouseDownX = chartX; // set new reference for next run
						css(chart.container, { cursor: 'move' });
					}
				
				} else {
					runBase = true;
				}
				
				// revert to the linear chart.pan version
				if (runBase) {
					baseChartPan.apply(chart, arguments);
				}
			}; 
		}
	};
			
	/**
	 * Extend getSegments by identifying gaps in the ordinal data so that we can draw a gap in the 
	 * line or area
	 */
	seriesProto.getSegments = function () {
		
		var series = this,
			segments,
			gapSize = series.options.gapSize;
	
		// call base method
		baseGetSegments.apply(series);
		
		if (series.xAxis.options.ordinal && gapSize) {
		
			// properties
			segments = series.segments;
			
			// extension for ordinal breaks
			each(segments, function (segment, no) {
				var i = segment.length - 1;
				while (i--) {
					if (segment[i + 1].x - segment[i].x > series.xAxis.closestPointRange * gapSize) {
						segments.splice( // insert after this one
							no + 1,
							0,
							segment.splice(i + 1, segment.length - i)
						);
					}
				}
			});
		}
	};
}());

/* ****************************************************************************
 * End ordinal axis logic                                                   *
 *****************************************************************************/
// global variables
extend(Highcharts, {
	Chart: Chart,
	dateFormat: dateFormat,
	pathAnim: pathAnim,
	getOptions: getOptions,
	hasBidiBug: hasBidiBug,
	numberFormat: numberFormat,
	Point: Point,
	Color: Color,
	Renderer: Renderer,
	SVGRenderer: SVGRenderer,
	VMLRenderer: VMLRenderer,
	CanVGRenderer: CanVGRenderer,
	seriesTypes: seriesTypes,
	setOptions: setOptions,
	Series: Series,

	// Expose utility funcitons for modules
	addEvent: addEvent,
	removeEvent: removeEvent,
	createElement: createElement,
	discardElement: discardElement,
	css: css,
	each: each,
	extend: extend,
	map: map,
	merge: merge,
	pick: pick,
	splat: splat,
	extendClass: extendClass,
	placeBox: placeBox,
	product: 'Highstock',
	version: '1.1.5'
});
}());

/**
 * ecui.ui.BeakerChart  
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           
 *           
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  ecui, highcharts
 */

(function() {

    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var util = core.util;
    var string = core.string;

    var blank = core.util.blank;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var children = dom.children;
    var formatDate = string.formatDate;
    var encodeHTML = string.encodeHTML;
    var attachEvent = util.attachEvent;
    var formatNumber = xutil.number.formatNumber;
    var extend = util.extend;
    var createDom = dom.create;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;

    /**
     * 
     *
     * @class
     * @extends {ecui.ui.Control}
     */
    var UI_BEAKER_CHART = ui.BeakerChart = 
        inheritsControl(
            UI_CONTROL,
            'ui-beaker-chart',
            function(el, options) {
                options.resizable = false;
            }
        );
    var UI_BEAKER_CHART_CLASS = UI_BEAKER_CHART.prototype;

    UI_BEAKER_CHART_CLASS.$setSize = blank;

    /** 
     * highcharts
     *
     * @type {Object}
     * @protected
     */
    UI_BEAKER_CHART_CLASS.CHART_OPTIONS = {
        global: {useUTC: false}
    };

    var BORDER_WIDTH = 4;
    var BORDER_WIDTH_HALF = 2;
    var BORDER_MARGIN = 5;
    var MAX_HEIGHT_PERCENT = 0.65;
    var WATER_RADIUS = 20;
    var LABEL_FONT_SIZE = '12px';
    var COUNT_FONT_SIZE = '30px';
    var COUNT_DESC_FONT_SIZE = '12px';
    var LEGEND_FONT_SIZE = '12px';
    var LEGEND_HEIGHT = 14;
    var TITLE_FONT_SIZE = '14px';

    var BEAKER_COLOR_A = ['#F88E32', '#66B2E4', '#97C644'];
    var BEAKER_COLOR_B = ['#999999', 'red', 'green'];    

    /**
     * @override
     */
    UI_BEAKER_CHART_CLASS.init = function() {
        Highcharts.setOptions(this.CHART_OPTIONS);
    };

    /**
     * @override
     */
    UI_BEAKER_CHART_CLASS.$dispose = function() {
        this.$disposeChart();
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 
     *
     * @private
     */
    UI_BEAKER_CHART_CLASS.$disposeChart = function() {
        if (this._oChart) {
            this._oChart.destroy();
            this._oChart = null;
        }
    };

    /**
     * 
     *
     * @public
     * @param {Object} dataWrap 
     * @param {Object} dataWrap.width 
     * @param {Object} dataWrap.height 
     * @param {Object} dataWrap.datasource 
     * @param {Object} dataWrap.datasource.title 
     * @param {Object} dataWrap.datasource.beakerA 
     * @param {Array.<Object>} dataWrap.datasource.beakerA.water 
     * @param {Object} dataWrap.datasource.beakerA.mark 
     * @param {Object} dataWrap.datasource.beakerB 
     * @param {Array.<Object>} dataWrap.datasource.beakerB.water 
     * @param {Object} dataWrap.datasource.beakerB.mark 
     * @param {Object} dataWrap.datasource.theRate 
     * @param {boolean=} isSilent false
     */
    UI_BEAKER_CHART_CLASS.setData = function(dataWrap, isSilent) {
        this._nWidth = 965; //  ...
        this._nHeight = dataWrap.height;
        this._oData = dataWrap.datasource;

        !isSilent && this.render();
    };

    /**
     * 
     *
     * @public
     */
    UI_BEAKER_CHART_CLASS.render = function() {
        this.$disposeChart();

        if (!this._oData) {
            this.$renderEmpty();
            return;
        }

        this.$createChart() ;
    };

    /**
     * 
     *
     * @private
     */
    UI_BEAKER_CHART_CLASS.$renderEmpty = function() {
        this.getMain().innerHTML = ' ';//'';
    };

    /**
     * 
     *
     * @private
     */
    UI_BEAKER_CHART_CLASS.$createChart = function() {
        var me = this;
        var options = {
            chart: {
                renderTo: this.getMain(),
                width: this._nWidth,
                height: this._nHeight,
                events: {
                    load: function(arguments) {
                        return customerRender.apply(
                            this,
                            [me._oData].concat(arguments)
                        );
                    }
                }
            },
            credits: { enabled: false },
            title: {
                text: ''
            }
        };
        
        this._oChart = new Highcharts.Chart(options);
    };

    /**
     * path
     */
    function getRightArrorPath(bodyLength, bodyWidth, headLength, headWidth) {
        var headDiff = Math.round((headWidth - bodyWidth) / 2);
        var sharp = Math.round(headWidth / 2);
        return [
            'M', 0, headDiff,
            'L', bodyLength, headDiff, 
            'L', bodyLength, 0,
            'L', bodyLength + headLength, sharp,
            'L', bodyLength, headWidth, 
            'L', bodyLength, headDiff + bodyWidth,
            'L', 0, headDiff + bodyWidth,
            'Z'
        ];
    }

    /** 
     * 
     */
    function drawArror(ren, pos) {
        var g = ren.g('arror').add();
        g.translate(pos.x, pos.y);

        ren.path(getRightArrorPath(40, 20, 30, 40))
            .attr({fill: '#92AE7E'})
            .add(g);
    }

    /**
     * 
     *  ...
     * 
     * @param {Object} options
     * @param {number=} options.scale scalescale
     * @param {Object} options.countColor 
     * @param {Object} options.countDesc 
     * @param {Object} ret
     *      ret.scale scale
     */
    function drawBeaker(ren, water, mark, pos, options) {
        water = water || [];
        var waterWidth = pos.width - 2 * BORDER_WIDTH - 2 * BORDER_MARGIN;
        var yBeakerStart = ren.fontMetrics(COUNT_FONT_SIZE).b
            + ren.fontMetrics(COUNT_DESC_FONT_SIZE).b + 10;
        var baseX = BORDER_WIDTH + BORDER_MARGIN;
        var baseY = pos.height - BORDER_WIDTH;

        var maxHeight = Math.round((pos.height - BORDER_WIDTH - yBeakerStart) * MAX_HEIGHT_PERCENT);
        var edgeWidth = pos.width - 2 * BORDER_MARGIN - BORDER_WIDTH;
        var edgeHeight = pos.height - yBeakerStart - BORDER_WIDTH_HALF;
        var edgeBaseX = BORDER_MARGIN + BORDER_WIDTH_HALF;
        var edgeRadius =  WATER_RADIUS + BORDER_WIDTH_HALF;

        var edgeUpWidth = pos.width;
        var edgeUpHeight = 12;//WATER_RADIUS;
        var edgeUpBaseX = 0;
        var edgeUpRadius = 6; //WATER_RADIUS;

        var i;
        var item;
        var currX;
        var currY;
        var fh;
        var val;

        // 
        var countValue = 0;
        for (i = 0; item = water[i]; i ++) {
            item.value = escapeIllegal(item.value, 0)
            countValue += item.value;
        }
        if (mark) {
            mark.value = escapeIllegal(mark.value, 0);
        }

        var maxValue = mark ? Math.max(countValue, mark.value) : countValue;
        var scale = options.scale || (maxValue != 0 ? (maxHeight / maxValue) : 0);
        var waterV = [];
        for (i = 0; item = water[i]; i ++) {
            waterV[i] = Math.min(Math.round(item.value * scale), maxHeight);
        }
        var countV = Math.round(countValue * scale);
        if (mark) {
            markV = Math.min(Math.round(mark.value * scale), maxHeight);
        }

        // g
        var gBeaker = ren.g('beaker').add();
        gBeaker.translate(pos.x, pos.y);

        // 
        currX = baseX;
        currY = baseY;
        for (i = 0; item = water[i]; i ++) {
            if (currY > baseY - WATER_RADIUS) {
                ren.rect(
                        currX - 2,
                        currY - waterV[i] - WATER_RADIUS * 2,
                        waterWidth + 4,
                        waterV[i] + WATER_RADIUS * 2,
                        WATER_RADIUS
                    )
                    .attr({ fill: item.color })
                    .add(gBeaker);                        
                ren.rect(
                        currX - 2,
                        currY - waterV[i] - WATER_RADIUS * 2 - 2,
                        waterWidth + 4,
                        WATER_RADIUS * 2 + 2,
                        (currY - waterV[i]) > (baseY - WATER_RADIUS)
                            ? WATER_RADIUS : void 0
                    )
                    .attr({ fill: 'white' })
                    .add(gBeaker);                        
            }
            else {
                ren.rect(
                        currX,
                        currY - waterV[i],
                        waterWidth,
                        waterV[i]
                    )
                    .attr({ fill: item.color })
                    .add(gBeaker);                        
            }
            currY = currY - waterV[i];
        }

        // 
        ren.rect(
                edgeBaseX,
                yBeakerStart,
                edgeWidth,
                edgeHeight,
                edgeRadius
            )
            .attr({ 
                stroke: '#7A9461',
                'stroke-width': BORDER_WIDTH
                // fill: 'white'
            })
            .add(gBeaker);                        

        // 
        ren.rect(
                BORDER_MARGIN,
                yBeakerStart - BORDER_WIDTH,
                waterWidth + BORDER_WIDTH * 2,
                WATER_RADIUS
            )
            .attr({ 
                'stroke-width': 0,
                fill: 'white'
            })
            .add(gBeaker); 
        ren.rect(
                edgeUpBaseX + 2,
                yBeakerStart - BORDER_WIDTH + WATER_RADIUS + 3 - edgeUpHeight,
                edgeUpWidth - 4,
                edgeUpHeight,
                edgeUpRadius
            )
            .attr({ 
                stroke: '#7A9461',
                'stroke-width': BORDER_WIDTH,
                fill: 'white'
            })
            .add(gBeaker);
        ren.rect(
                BORDER_MARGIN + BORDER_WIDTH,
                yBeakerStart - BORDER_WIDTH + WATER_RADIUS + 3 - BORDER_WIDTH,
                waterWidth,
                BORDER_WIDTH * 2
            )
            .attr({ 
                'stroke-width': 0,
                fill: 'white'
            })
            .add(gBeaker); 

        // 
        currX = baseX;
        currY = baseY;
        if (mark) {
            ren.path(ren.crispLine(
                    [
                        'M', 
                        currX, 
                        currY - markV, 
                        'L', 
                        currX + waterWidth, 
                        currY - markV
                    ],
                    3
                ))
                .attr({
                    'stroke-width': 2,
                    stroke: mark.color
                })
                .add(gBeaker);                        

            // marklabel
            var diff = countValue - mark.value;
            var diffColor = diff < 0 ? '#FF2300' : 'green';
            diff = diff > 0 ? '+' + diff : diff;
            ren.label(
                    '' + escapeIllegal(mark.value, 0) 
                        + '<br /><span style="font-weight:bold;color:' 
                        + diffColor + '">' + escapeIllegal(diff, 0) + '</span>',
                    currX + waterWidth + 10,
                    currY - markV - 20
                )
                .attr({
                    fill: 'white',
                    stroke: mark.color,
                    'stroke-width': 2,
                    padding: 5,
                    r: 5
                })
                .css({
                    fontFamily: ', Arial'
                })
                .add(gBeaker)
                .shadow(true);                            
        }

        // label
        currX = baseX;
        currY = baseY;
        fh = Math.round(ren.fontMetrics(LABEL_FONT_SIZE).b / 2);
        for (i = 0; item = water[i]; i ++) {
            val = escapeIllegal(item.value, 0);
            val > 0 && ren.text(
                    val,
                    currX + Math.round(waterWidth / 2),
                    currY - Math.round(waterV[i] / 2) + fh
                )
                .attr({
                    align: 'center'
                })
                .css({
                    fontSize: LABEL_FONT_SIZE
                })
                .add(gBeaker);                        
            currY = currY - waterV[i];
        }

        // label
        currX = baseX + Math.round(waterWidth / 2);
        currY = ren.fontMetrics(COUNT_FONT_SIZE).b;
        ren.text(
                countValue,
                currX,
                currY
            )
            .attr({
                align: 'center'
            })
            .css({
                fontSize: COUNT_FONT_SIZE,
                fontWeight: 'bold',
                fontFamily: ', Times',
                color: options.countColor
            })
            .add(gBeaker);     
        currY += ren.fontMetrics(COUNT_DESC_FONT_SIZE).b + 3;

        ren.text(
                options.countDesc,
                currX,
                currY
            )
            .attr({
                align: 'center'
            })
            .css({
                fontSize: COUNT_DESC_FONT_SIZE,
                fontWeight: 'bold',
                fontFamily: ', Times',
                color: '#999'
            })
            .add(gBeaker);

        return { scale: scale };
    }

    /**
     * 
     */
    function drawLegend(ren, pos, dataLegend) {
        var g = ren.g('legend').add();
        var i;
        var item;
        var currX = 0;
        var currY = 0;
        var bl = Math.round(
            (LEGEND_HEIGHT - ren.fontMetrics(LEGEND_FONT_SIZE).b) / 2
        );
        var textEl;

        for (i = 0; item = dataLegend[i]; i ++) {
            ren.rect(
                    currX,
                    currY,
                    LEGEND_HEIGHT,
                    LEGEND_HEIGHT
                )
                .attr({ fill: item.color })
                .add(g);
            currX += LEGEND_HEIGHT + 5;

            textEl = ren.text(
                    escapeIllegal(item.text),
                    currX,
                    currY + LEGEND_HEIGHT - bl
                )
                .css({ 
                    fontFamily: ', Arial', 
                    fontSize: LEGEND_FONT_SIZE,
                    color: '#222'
                })
                .add(g);

            currX += textEl.getBBox().width + 15;
        }

        g.translate(pos.x, pos.y);
    }

    /**
     * 
     */
    function drawTitle(ren, title, pos) {
        ren.text(
                escapeIllegal(title, ''),
                pos.x,
                pos.y
            )
            .css({
                color: '#555',
                fontSize: TITLE_FONT_SIZE, 
                fontFamily: ', Arial',
                fontWeight: 'bold'
            })
            .add();
    }

    /**
     * 
     */
    function drawTheRate(ren, theRate, pos) {
        theRate = theRate || {};
        ren.label(
                escapeIllegal(theRate.text) + '<br />' 
                    + '<span style="color:#7493CB">' 
                    + escapeIllegal(theRate.value),
                pos.x,
                pos.y
            )
            .attr({
                fill: '#CCC',
                r: 4
            })
            .css({
                fontFamily: ', Arial',
                fontSize: '14px'
            })
            .add();
    }

    /** 
     * 
     */
    function customerRender(data) {
        var ren = this.renderer;
        var dataBeakerA = data.beakerA || {};
        var dataBeakerB = data.beakerB || {};
        var i;
        var item;
        var dataLegend = [];

        // 
        for (i = 0; item = (dataBeakerA.water || [])[i]; i ++) {
            item.color = item.color || BEAKER_COLOR_A[i];
            dataLegend.push(item);
        }
        for (i = 0; item = (dataBeakerB.water || [])[i]; i ++) {
            item.color = item.color || BEAKER_COLOR_B[i];
            dataLegend.push(item);
        }
        if (dataBeakerA.mark) {
            dataBeakerA.mark.color = dataBeakerA.mark.color || '#C0504D';
        }
        if (dataBeakerB.mark) {
            dataBeakerB.mark.color = dataBeakerB.mark.color || '#C0504D';
        }

        // 
        var posA = {
            x: 150, 
            y: 50, 
            width: 180, 
            height: 280
        };
        var retA = drawBeaker(
            ren,
            dataBeakerA.water,
            dataBeakerA.mark,
            posA,
            { 
                countColor: '#326600',
                countDesc: ''
            }
        );

        // 
        var posB = { 
            x: posA.x + posA.width + 210,
            y: posA.y + posA.height - 185,
            width: 120,
            height: 180
        };
        drawBeaker(
            ren,
            dataBeakerB.water,
            dataBeakerB.mark,
            posB,
            { 
                countColor: '#676767',
                countDesc: '12',
                scale: retA.scale
            }
        );

        // 
        drawArror(ren, {x : 60, y : posA.y + 180});
        drawArror(ren, {x : 430, y : posA.y + 180});

        // 
        drawLegend(ren, {x: 350, y: 10}, dataLegend);

        // 
        drawTitle(ren, data.title, { x: 20, y: 10 + LEGEND_HEIGHT });

        // 
        if (data.theRate) {
            drawTheRate(
                ren,
                data.theRate,
                { x: posB.x + 180, y: posB.y + posB.height - 55}
            )
        }
    }

    /**
     * undefinednullNaN
     */
    function escapeIllegal(v, defaultValue) {
        if (defaultValue == null) {
            defaultValue = ' - ';
        }
        if (v == null 
            || (Object.prototype.toString.call(v) != '[object String]' 
                && isNaN(v)
            )
        ) {
            return defaultValue;
        }
        return v;
    }

})();

/**
 * ecui.ui.HButton
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   button
 * @author: sushuang(sushuang@baidu.com)
 */

 (function () {
    
    var inheritsControl = ecui.inherits;
    var UI_BUTTON = ecui.ui.Button;
    var moveElements = ecui.dom.moveElements;
    var createDom = ecui.dom.create;
    var addClass = ecui.dom.addClass;

    /**
     * button
     *
     * @class
     * @param {Object} options 
     * @param {string} options.skin css
     * @param {string} options.text 
     */
    var UI_H_BUTTON = ecui.ui.HButton =
        inheritsControl(
            UI_BUTTON,
            null,
            function (el, options) {
                if (options.skin) {
                    addClass(el, options.skin);
                    options.primary = options.skin;
                }
            },
            function (el, options) {
                var type = this.getType();

                var o = createDom(type + '-text', '', 'span');
                this.$setBody(o);
                moveElements(el, o, true);

                el.appendChild(createDom(type + '-inner', ''));
                el.firstChild.appendChild(createDom(type + '-left', '', 'span'));
                el.firstChild.appendChild(o);
                el.firstChild.appendChild(createDom(type + '-right', '', 'span'));
            }
        );

    var UI_H_BUTTON_CLASS = UI_H_BUTTON.prototype;

 }) ();
/**
 * ecui.ui.SwitchButton
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   button
 * @author: sushuang(sushuang@baidu.com)
 */

 (function () {
    
    var inheritsControl = ecui.inherits;
    var UI_H_BUTTON = ecui.ui.HButton;
    var moveElements = ecui.dom.moveElements;
    var createDom = ecui.dom.create;
    var triggerEvent = ecui.triggerEvent;
    var addClass = ecui.dom.addClass;
    var extend = ecui.util.extend;

    /**
     * button
     *
     * @class
     * @extends {ecui.ui.Control}
     * @param {Array.<Object>} statusList
     *       text ... value ...
     * @param {number} status
     */
    var UI_SWITCH_BUTTON = ecui.ui.SwitchButton =
        inheritsControl(
            UI_H_BUTTON,
            null,
            null,
            function (el, options) {
                var type = this.getType();
                this._aStatusList = options.statusList || [];
                var index;
                for (var i = 0, o; o = this._aStatusList[i]; i ++) {
                    if (o.value == options.status) {
                        index = i;
                        break;
                    }
                }
                this.$switchStatus(index);
            }
        );

    var UI_SWITCH_BUTTON_CLASS = UI_SWITCH_BUTTON.prototype;

    UI_SWITCH_BUTTON_CLASS.$click = function () {
        UI_SWITCH_BUTTON.superClass.$click.apply(this, arguments);
        this.$switchStatus();
        triggerEvent(this, 'change');
    };

    UI_SWITCH_BUTTON_CLASS.$switchStatus = function (index) {
        var statusList = this._aStatusList;
        if (statusList.length == 0) {
            return;
        }

        var nextIndex = index != null 
            ? index
            : (
                this._nIndex == null
                ? 0
                : (this._nIndex + 1) % statusList.length
            );
        this._nIndex = nextIndex;

        this.setText(statusList[this._nIndex].text);
    };

    UI_SWITCH_BUTTON_CLASS.getValue = function () {
        return this._aStatusList[this._nIndex].value;
    };

 }) ();

/**
 * ecui.ui.OlapTable
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   
 *         
 * @author: sushuang(sushuang@baidu.com)
 */

 (function() {
    
    var core = ecui;
    var dom = core.dom;
    var array = core.array;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;
    var q = xutil.dom.q;
    var xajax = xutil.ajax;
    //var URL = di.config.URL;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var disposeControl = core.dispose;
    var createDom = dom.create;
    var addClass = dom.addClass;
    var setStyle = dom.setStyle;
    var removeClass = dom.removeClass;
    var getMouseX = core.getMouseX;
    var toNumber = util.toNumber;
    var getParent = dom.getParent;
    var getStyle = dom.getStyle;
    var sliceByte = string.sliceByte;
    var moveElements = dom.moveElements;
    var getAttribute = dom.getAttribute;
    var getPosition = dom.getPosition;
    var encodeHTML = string.encodeHTML;
    var remove = array.remove;
    var getView = util.getView;
    var extend = util.extend;
    var repaint = core.repaint;
    var attachEvent = util.attachEvent;
    var detachEvent = util.detachEvent;
    var pushArray = Array.prototype.push;
    // 
    var formatNumber = xutil.number.formatNumber;

    var MATH = Math;
    var MIN = MATH.min;
    var WINDOW = window;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_LOCKED_TABLE = ui.SlowLockedTable;
    var UI_LOCKED_TABLE_CLASS = UI_LOCKED_TABLE.prototype;

    /**
     * OLAP 
     *
     * @class
     * @extends {ecui.ui.LockedTable}
     */
    var UI_OLAP_TABLE = ui.OlapTable =
        inheritsControl(
            UI_LOCKED_TABLE,
            'ui-table',
            function(el, options) {
                this.$setOptions(options);
                this.$renderHTML(el);
            }
        );
    var UI_OLAP_TABLE_CLASS = UI_OLAP_TABLE.prototype;

    var UI_OLAP_TABLE_CELL_CLASS = (
            UI_OLAP_TABLE_CLASS.Cell = inheritsControl(
                UI_LOCKED_TABLE_CLASS.Cell
            )
        ).prototype;

    var UI_TABLE_HCELL_CLASS = UI_OLAP_TABLE_CLASS.HCell.prototype;

    /**
     * 
     *
     * @type {string}
     * @private
     */
    var INVALID_TEXT = '';
    /**
     * 
     *
     * @type {number}
     * @private
     */
    var TREE_INDENT = 15;

    //--------------------------------------------------
    // 
    //--------------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} condFmtDef 
     * @param {string} ctrlCssBase css base
     * @return {Object} cssstyle
     */
    function getCondFmt(condFmtDef, ctrlCssBase) {
        var ret = { 
            text: { css: [], style: [] },
            outer: { css: [], style: [] },
            left: { css: [], style: [] },
            right: { css: [], style: [] }
        };

        if (!condFmtDef) { return null; }

        // 
        if (condFmtDef.arr) {
            ret.right.css.push(
                ctrlCssBase + '-condfmt-arr',
                ctrlCssBase + '-condfmt-arr-' + condFmtDef.arr
            );
        }
        
        // 
        if (condFmtDef.bg) {
            if (condFmtDef.bg.indexOf('#') >= 0) {
                ret.outer.style.push('background-color:' + condFmtDef.bg + ';');
            }
            else {
                ret.outer.css.push(ctrlCssBase + '-condfmt-bg-' + condFmtDef.bg);
            }
        }

        // 
        if (condFmtDef.tx) {
            if (condFmtDef.tx.indexOf('#') >= 0) {
                ret.text.style.push('color:' + condFmtDef.tx + ';');
            }
            else {
                ret.text.css.push(ctrlCssBase + '-condfmt-tx-' + condFmtDef.tx);
            }
        }

        // 
        if (condFmtDef.wt) {
            ret.text.style.push('font-weight:bold;');
        }

        return ret;
    }

    //--------------------------------------------------
    // UI_OLAP_TABLE 
    //--------------------------------------------------

    /**
     * @override
     */
    UI_OLAP_TABLE_CLASS.init = function() {
        UI_OLAP_TABLE.superClass.init.call(this);
        this.$initRowChecked();
    };

    /**
     * 
     * 
     * @protected
     * @param {Object} options 
     * @param {Array.<Object>} options.datasource 
     *      {Object} stylegetCondFmt
     * @param {Array.<Object>} options.colFields 
     * @param {Array.<Object>} options.colDefine 
     *      {string} orderby'asc', 'desc', 'none'
     *      {number} width
     * @param {Array.<Object>} options.rowHeadFields 
     *      {number} indent0, 1, 2, 3 
     *      {boolean} drillByLink
     *      expand/collapse{boolean} expand
     *          trueexpand
     *          falsecollapse
     * @param {Array.<Object>} options.rowDefine 
     * @param {string} options.emptyHTML 
     * @param {number=} options.rowHCellCut ...title
     * @param {number=} options.cCellCut ...title
     * @param {number=} options.hCellCut ...title
     * @param {boolean=} options.rowCheckMode 
     *      'SELECT', 'CHECK', 
     * @param {Array=} options.rowChecked 
     * @param {Array=} options.rowCheckMax 
     * @param {Array=} options.rowCheckMin 
     * @param {string=} options.defaultCCellAlign align
     *      leftright, left, center
     * @param {boolean} options.vScroll false
     * @param {boolean} options.hScroll true
     */
    UI_OLAP_TABLE_CLASS.$setOptions = function(options) {
        this._sEmptyHTML = options.emptyHTML;

        this._aData = options.datasource || [];
        this._aColFields = options.colFields || [];
        this._aColDefine = options.colDefine || [];
        this._reportTemplateId = options.reportTemplateId;
        this._aRowHeadFields = options.rowHeadFields || [];
        this._aRowDefine = options.rowDefine || [];

        // 
        this._oRowCheck = {
            rowCheckMode: options.rowCheckMode,
            rowChecked: options.rowChecked || [],
            rowCheckMax: options.rowCheckMax || Number.MAX_VALUE,
            rowCheckMin: options.rowCheckMin || Number.MIN_VALUE,
            rowCheckCount: 0
        };
        // selected
        for (var i = 0, o; o = this._aRowDefine[i]; i ++) {
            o.selected && this._oRowCheck.rowChecked.push(i);
        }

        // 
        this._oCut = {
            ROWHCELL: options.rowHCellCut,
            CCELL: options.cCellCut,
            HCELL: options.hCellCut
        };

        // 
        this._oStyle = {
            defaultCCellAlign: options.defaultCCellAlign
        };

        // this.$validate();

        this._nLeftLock = options.leftLock = 
            this._bInvalid 
                ? 0 
                : (
                    this._aRowHeadFields.length
                        ? this._aRowHeadFields[0].length : 0
                );

        this._nRightLock = options.rightLock = 0;

        options.vScroll == null && (options.vScroll = false);
        options.hScroll == null && (options.hScroll = true);
    };

    /**
     * 
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$validate = function() {
        this._bInvalid = false;
        
        var colCount = validateLength.call(this, this._aColFields);
        var rowHeadColCount = validateLength.call(this, this._aRowHeadFields);
        var dataCount = validateLength.call(this, this._aData);

        if (this._aColDefine.length != colCount) {
            this._bInvalid = true;
        }
        if (rowHeadColCount + dataCount != colCount) {
            this._bInvalid = true;
        } 
        if (this._aRowHeadFields.length != this._aData.length) {
            this._bInvalid = true;
        }
    };

    /**
     * colspanrowspan
     * 
     * @private
     * @this {ui.OlapTable} 
     * @return {number} length
     */
    function validateLength(matrix) {
        // // TODO 
        // // colspanrowspan
        // var baseCount = 0; // 
        // var rowMaxArr = []; // rowspan
        // var colCount;

        // for (var i = 0, line; i < matrix.length; i ++) {
        //     line = matrix[i];

        //     if (!line) {
        //         this._bInvalid = true;
        //         return baseCount;
        //     } 

        //     colCount = 0;
        //     itemJ = 0;
        //     for (var j = 0, item; ; j ++) {
        //         item = line[itemJ ++];
        //         rowMaxArr[colCount] == null && (rowMaxArr[colCount] = -1);

        //         if (rowMaxArr[colCount] >= i) {
        //             colCount ++;
        //             continue;
        //         }
        //         else {
        //             if (item === Object(item)) {
        //                 if (item.rowspan > 1) {
        //                     rowMaxArr[colCount] = i + item.rowspan - 1;
        //                 }
        //                 else if (item.colspan > 1) {
        //                     colCount += item.colspan;
        //                     rowMaxArr[colCount] = i;
        //                 }
        //             }
        //             else {
        //                 colCount ++;
        //                 rowMaxArr[colCount] = i;
        //             }
        //         }
        //     }

        //     if (!baseCount) {
        //         baseCount = colCount;
        //     }
        //     else if (baseCount != colCount) {
        //         this._bInvalid = true;
        //         return baseCount;
        //     }
        // }
        // return baseCount;
    };

    /**
     * 
     *
     * @public
     * @param {string} options setOptions
     */
    UI_OLAP_TABLE_CLASS.setData = function(options) {

        // ===========================
        // var ttt = new Date();

        // ===========================
        // var ddd = new Date();

        detachEvent(WINDOW, 'resize', repaint);

        
        // ===================== ch 1200
        this.$disposeInner();

        // console.log('=================== olap-table setData start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        var el = this.getOuter();
        el.innerHTML = '';
        this.$setBody(el);

        // console.log('=================== olap-table setData 1] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        this.$resize();

        // console.log('=================== olap-table setData 2] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        // ==================== ch 518
        UI_OLAP_TABLE.client.call(
            this, 
            el, 
            extend(
                { uid: this._sUID, primary: this._sPrimary }, 
                options
            )
        );
        this._bCreated = false;

        // console.log('=================== olap-table setData 3 (into)] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        // =================== ch 370
        this.cache(true, true);

        // console.log('=================== olap-table setData 4] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        // =================== ch 1102
        this.init();

        // console.log('=================== olap-table setData 51] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        // this.$resize();

        this.$bindCellLink();

        attachEvent(WINDOW, 'resize', repaint);

        // console.log('=================== olap-table setData 6] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        // 
        // this.resize();

        // =================== ch resize318 locked-table.$setSize, 315
        // console.log('=================== olap-table setData last] ' + ((new Date()).getTime() - ddd));

        // console.log('=================== olap-table setData total] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * 
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$disposeInner = function() {
        var disposeFunc = this.$dispose;
        this.$dispose = new Function();
        disposeControl(this);
        this.$dispose = disposeFunc;
    }    

    /**
     * HTML
     * 
     * @protected
     * @param {HTMLElement} el 
     */
    UI_OLAP_TABLE_CLASS.$renderHTML = function(el) {

        // =================================
        // var ttt = new Date();
        // var ddd = new Date();

        var type = this.getTypes()[0];
        var datasource = this._aData || [];
        var colFields = this._aColFields || [];
        var colDefine = this._aColDefine || [];
        var reportTemplateId = this._reportTemplateId;
        
        var rowHeadFields = this._aRowHeadFields || [];
        var rowDefine = this._aRowDefine || [];
        var leftLock = this._nLeftLock;
        var html = [];
        var i;
        var j;
        var line;
        var wrap;

        setStyle(el, 'width', 'auto');
        setStyle(el, 'display', 'block');
        html.push('<table>');

        // 
        if (this._bInvalid) {
            html.push('<thead><tr><th class="' + type +'-hcell-empty">&nbsp;</th></tr></thead>');
            html.push('<tbody><tr><td>' + INVALID_TEXT + '</td></tr></tbody>');
        }

        // 
        else {
            // 
            html.push('<thead>');
            if (!colFields.length) {
                html.push('<tr><th class="' + type + '-hcell-empty">&nbsp;</th></tr>');
            }
            else {
                for (i = 0; line = colFields[i]; i ++) {
                    html.push('<tr>');
                    for (j = 0; j < line.length; j ++) {
                        if (isPlaceholder(wrap = line[j])) {
                            continue;
                        }
                        this.$renderHCell(
                            html,
                            // colField
                            i == colFields.length - 1 ? colDefine[j] : null,
                            wrap,
                            j < this._nLeftLock ? j : (j - this._nLeftLock),
                            i
                        );
                    }
                    html.push('</tr>');
                }
            }
            html.push('</thead>');


            

            // 
            html.push('<tbody>');
            if (this._bInvalid || !datasource.length) {
                html.push(
                    '<tr>',
                        '<td class="', type, '-cell-empty" align="middle" colspan="',
                            colFields.length, '">',
                            this._sEmptyHTML,
                        '</td>',
                    '</tr>'
                );
            }
            else {
                for (i = 0; line = datasource[i]; i ++) {
                    html.push('<tr class="'+ type +'-row">')
                    // 
                    if (leftLock) {
                        for (j = 0; j < rowHeadFields[i].length; j ++) {
                            if (isPlaceholder(wrap = rowHeadFields[i][j])) {
                                continue;
                            }
                            this.$renderRowHCell(
                                html,
                                colDefine[j], 
                                wrap,
                                j,
                                i
                            );
                        }
                    }
                    // 
                    for (j = 0; j < line.length; j ++) {
                        wrap = line[j];
                        this.$renderCell(
                            html, 
                            colDefine[leftLock + j], 
                            rowDefine[i],
                            wrap,
                            j, 
                            i
                        );
                    }
                    html.push('</tr>')
                }
            }
        }

        html.push('</tbody></table>');

        // ==========================push ch 144
        // console.log('=================== olap-table html.push] ' + html.length + ' ' + ((new Date()).getTime() - ddd));

        // ====================================
        // ddd = new Date();

        html = html.join('');

        // console.log('=================== olap-table html.join("")] ' + html.length + ' ' + ((new Date()).getTime() - ddd));

        // ====================================
        // ddd = new Date();
        
        // ============================= ch 293 
        el.innerHTML = html;

        // console.log('=================== olap-table renderHTML el.innerHTLM=...] ' + ((new Date()).getTime() - ddd));

        // console.log('=================== olap-table renderHTML total] ' + ((new Date()).getTime() - ttt));
        // ddd = new Date();


        return el;
    };

    function UI_TIP_HANDLER(event) {
        var e = event || window.event,
            con;
        el = e.target || e.srcElement;
        con = el.parentNode.getControl();
        //el.title = el.mal;
        //con.getInput().focus();
    }

    /**
    * olaptdtitle
    */
    UI_OLAP_TABLE_CLASS.$setMeasureDes4Table = function(data){
        var el = this.getOuter();
        var type = this.getTypes()[0];
        var tableHeaders = q(type + '-olap-ind-describe', el);
        for (var i = 0; i < tableHeaders.length; i++) {
                 var header = tableHeaders[i];
                 if(header.getAttribute('uniquename')){
                    var uniquename = header.getAttribute('uniquename');
                    if(data.descriptions[uniquename]){
                        header.title = data.descriptions[uniquename]; 
                    }
                 }
            };
    }
    /**
     * 
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderHCell = function(
        // colField
        html, colDefItem, wrap, x, y
    ) {
        var type = this.getType();
        var classStr = [type + '-hcell'];
        var styleStr = [];
        var attrStr = [];
        var span = [];
        var innerStr;

        wrap = objWrap(wrap);

        span.push(wrap.colspan ? ' colspan="' + wrap.colspan + '" ' : '');
        span.push(wrap.rowspan ? ' rowspan="' + wrap.rowspan + '" ' : '');

        if (colDefItem && colDefItem.width) {
            //styleStr.push('width:' + colDefItem.width + 'px;');
        }
        if (colDefItem && colDefItem.orderby) {
            classStr.push(type + '-hcell-sort-' + colDefItem.orderby);
            attrStr.push('data-orderby="' + colDefItem.orderby + '"');
        }
        classStr.push(type + '-olap-ind-describe');
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');

        if(colDefItem && colDefItem.uniqueName){
            attrStr.push('uniqueName="' + colDefItem.uniqueName + '"');
        }
        //attrStr.push('title='+"'title'");
        innerStr = this.$renderCellInner('HCELL', null, wrap, attrStr, classStr, styleStr);
        //ie8innerCelldivmargin
        //
        var useBag = dom.ieVersion < 8;
        html.push(
            '<th ', 
                span.join(' '), ' ',
                attrStr.join(' '), ' ',
                ' class="', classStr.join(' '), 
                '" style="', styleStr.join(' '), 
            '">',
                useBag ? ('<div class="' + type + '-hcell-bag">') : '', 
                    innerStr, 
                useBag ? '</div>' : '',
            '</th>'
        );
    }; 

    /**
     * 
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderRowHCell = function(html, colDefItem, wrap, x, y) {
        var type = this.getType();
        var classStr = [type + '-rowhcell'];
        var styleStr = [];
        var attrStr = [];
        var span = [];
        var innerStr;

        wrap = objWrap(wrap);

        span.push(wrap.colspan ? ' colspan="' + wrap.colspan + '" ' : '');
        span.push(wrap.rowspan ? ' rowspan="' + wrap.rowspan + '" ' : '');

        if (colDefItem.width) {
            styleStr.push('width:' + colDefItem.width + 'px;');
            // styleStr.push('min-width:' + colDefItem.width + 'px;');
            // styleStr.push('max-width:' + colDefItem.width + 'px;');
        }
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');
        attrStr.push('data-row-h="1"'); // 
        innerStr = this.$renderCellInner('ROWHCELL', null, wrap, attrStr, classStr, styleStr);

        html.push(
            '<td ', 
                span.join(' '), ' ', 
                attrStr.join(' '), ' ',
                ' style="', styleStr.join(' '), 
                '" class="', classStr.join(' '), 
            '">',
                innerStr, 
            '</td>'
        );
    };

    /**
     * 
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderCell = function(html, colDefItem, rowDefItem, wrap, x, y) {
        var type = this.getType();
        var classStr = [type + '-ccell'];
        var styleStr = [];
        var attrStr = [];
        var innerStr;

        wrap = objWrap(wrap);

        var align = colDefItem.align || this._oStyle.defaultCCellAlign;
        if (align) {
            classStr.push(type + '-cell-align-' + align);
        }
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');
        attrStr.push('data-content="1"'); // 

        innerStr = this.$renderCellInner(
            'CCELL',
            colDefItem,
            wrap, 
            attrStr,
            classStr, 
            styleStr
        );

        html.push(
            '<td ', 
                attrStr.join(' '), ' ',
                ' style="', styleStr.join(' '), 
                '" class="', classStr.join(' '), 
            '">',
                innerStr, 
            '</td>'
        );
    };

    /**
     * 
     *
     * @private
     * @param {string} cellType 'ROWHCELL', 'HCELL', 'CCELL'
     * @param {Object=} defItem 
     * @param {Object} wrap 
     * @param {Array} attrStr 
     * @param {Array} classStr css class
     * @param {Array} styleStr css style
     * @return {string} html
     */
    UI_OLAP_TABLE_CLASS.$renderCellInner = function(
        cellType, defItem, wrap, attrStr, classStr, styleStr
    ) {
        var indentStyle = '';
        var clz = '';
        var type = this.getType();
        var value = getWrapValue.call(this, cellType, wrap, defItem && defItem.format);
        var prompt = value.prompt;
        value = value.value;

        if (prompt) {
            attrStr.push('title="' + prompt + '"');
        }

        if (wrap.indent) {
            // margin-leftindent
            attrStr.push('data-indent="' + wrap.indent + '"');
            indentStyle = 'margin-left:' + TREE_INDENT * wrap.indent + 'px;';
        }

        if (wrap.drillByLink) {
            attrStr.push('data-cell-link="true"');
            value = '<a href="#" class="' + type + '-cell-link" data-cell-link-drill-a="1">' + value + '</a>';
        } 
        // linkBridge
        else if (defItem && defItem.linkBridge && wrap.cellId && wrap.cellId.indexOf('[SUMMARY_NODE].[ALL]') < 0) {
            attrStr.push('data-cell-link="true"');
            value = '<a href="#" class="' + type + '-cell-link" data-cell-link-bridge-a="1">' + value + '</a>';
        }

        // 
        var condFmt = getCondFmt(wrap.style, type);
        if (condFmt) {
            value = (
                    condFmt.left.css.length > 0 || condFmt.left.style.length > 0
                        ? '<span class="' + condFmt.left.css.join(' ') 
                            + '" style="' + condFmt.left.style.join(' ') + '">' + '</span>'
                        : ''
                )
                + (
                    condFmt.text.css.length > 0 || condFmt.text.style.length > 0
                        ? '<span class="' + condFmt.text.css.join(' ')
                            + '" style="' + condFmt.text.style.join(' ') + '">' + value + '</span>'
                        : value
                )
                + (
                    condFmt.right.css.length > 0 || condFmt.right.style.length > 0
                        ? '<span class="' + condFmt.right.css.join(' ') 
                            + '" style="' + condFmt.right.style.join(' ') + '">' + '</span>'
                        : ''
                );

            if (condFmt.outer.css.length > 0 || condFmt.outer.style.length > 0) {
                classStr.push.apply(classStr, condFmt.outer.css);
                styleStr.push.apply(styleStr, condFmt.outer.style);
            }
        }

        if (wrap.expand != null) {
            attrStr.push(
                'data-e-c="' + (!wrap.expand ? 'expanded' : 'collapsed') + '"'
            );
            clz = type + '-e-c-icon ' + type
                + (!wrap.expand ? '-expanded-icon ' : '-collapsed-icon ');
            value = [
                '<div style="' + indentStyle + ' text-align:left;" class="'
                    + type + '-tree-item">',
                    '<div class="' + clz + '"></div>',
                    value,
                '</div>',
            ].join('');
        }
        else if (indentStyle) {
            value = '<div style="' + indentStyle 
                + 'text-align:left;">' + value + '</div>';
        }

        return value;
    };

    /**
     * tablesizechange
     *
     */
    UI_OLAP_TABLE_CLASS.$ready = function() {
        triggerEvent(this, 'sizechange');
    };

    /**
     * resize
     *
     * @override
     */
    UI_OLAP_TABLE_CLASS.$resize = function() {
        var me = this;
        UI_LOCKED_TABLE_CLASS.$resize.call(this);
        if (!this._bResizeTimeout) {
            this._bResizeTimeout = true;
            setTimeout(
                function() {
                    me._bResizeTimeout = false;
                    triggerEvent(me, 'sizechange');
                    me.$pagescroll();
                },
                100
            );
        }
    };

    /**
     * cell link
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$bindCellLink = function() {
        var me = this;
        var tds = this.getOuter().getElementsByTagName('td');
        for (
            var i = 0, tdEl, aEls, aEl, o, j; 
            tdEl = tds[i]; 
            i ++
        ) {
            if (tdEl.getAttribute('data-cell-link')) {
                aEls = tdEl.getElementsByTagName('a');

                o = getCellPosition(tdEl);
                for (j = 0; aEl = aEls[j]; j ++) {
                    if (aEl.getAttribute('data-cell-link-drill-a')) {
                        aEl.onclick = (function(wrap) {
                            return function() {
                                !me._bDisabled 
                                    && triggerEvent(
                                        me, 
                                        'celllinkdrill', 
                                        null, 
                                        [wrap]
                                    );
                                return false;
                            }
                        })(this._aRowHeadFields[o.y][o.x]);
                    }
                    else if (aEl.getAttribute('data-cell-link-bridge-a')) {
                        aEl.onclick = (function(colDefItem, rowDefItem) {
                            return function() {
                                !me._bDisabled 
                                    && triggerEvent(
                                        me, 
                                        'celllinkbridge', 
                                        null, 
                                        [colDefItem, rowDefItem]
                                    );
                                return false;
                            }
                        })(
                            this._aColDefine[this._nLeftLock + o.x], 
                            this._aRowDefine[o.y]
                        );
                    }
                }
            }
        }
    };

    /**
     * cellapi
     *
     * @public
     * @param {number} rowIndex 0
     * @param {number} colIndex 0
     */    
    // UI_OLAP_TABLE_CLASS.clickContentCell = function(rowIndex, colIndex) {
    //     var cell = this.getContentCell(rowIndex, colIndex);
    //     cell && cell.$handleCellClick();
    // };

    /**
     * 
     *
     * @public
     * @param {number} rowIndex 0
     * @param {number} colIndex 0
     * @return {ecui.ui.Table.Cell} 
     */
    UI_OLAP_TABLE_CLASS.getContentCell = function(rowIndex, colIndex) {
        rowIndex = this._aRows[rowIndex];
        return rowIndex && rowIndex.getCell(
            (this._nLeftLock || 0) + colIndex
        ) || null;
    };

    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    UI_OLAP_TABLE_CLASS.getValue = function() {
        var rowChecked = [];
        var rows = this._aRows || [];
        for (var i = 0, row; i < rows.length; i ++) {
            if ((row = rows[i]) && row._bRowChecked) {
                rowChecked.push({ value: this._aRowDefine[i], index: i });
            }
        }
        return {
            rowChecked: rowChecked,
            rowDefine: (this._aRowDefine || []).slice(),
            colDefine: (this._aColDefine || []).slice()
            // value
        }
    };

    /**
     * row
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$getContentRow = function(rowIndex) {
        // LockedTablerow
        var row;
        var cell;
        return (row = this._aRows[rowIndex])
            && (cell = row.getCell(this._nLeftLock || 0))
            && cell.getParent()
            || null;
    };

    /**
     * 
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$initRowChecked = function() {
        var rowCheck = this._oRowCheck;
        for (
            var i = 0, rowCtrl; 
            i < (rowCheck.rowChecked || []).length; 
            i ++
        ) {
            // LockedTablerow
            if (rowCtrl = this.$getContentRow(rowCheck.rowChecked[i])) {
                this.$setRowChecked(rowCtrl, true);
            }
        }
    };

    /**
     * 
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$setRowChecked = function(rowCtrl, checked) {
        var type = this.getType();
        var rowCheck = this._oRowCheck;

        var rowCheckMode = this._oRowCheck.rowCheckMode;
        // 
        if (rowCheckMode == 'CHECK') {
            if (checked
                && !rowCtrl._bRowChecked
                && rowCheck.rowCheckCount < rowCheck.rowCheckMax
            ) {
                rowCtrl._bRowChecked = true;
                addClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount ++;
                return true;
            }

            if (!checked 
                && rowCtrl._bRowChecked
                && rowCheck.rowCheckCount > rowCheck.rowCheckMin
            ) {
                rowCtrl._bRowChecked = false;
                removeClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount --;
                return true;
            }
        }
        // 
        else if (rowCheckMode == 'SELECT') {
            var rows = this._aRows || [];
            for (var i = 0, row, cell; i < rows.length; i ++) {
                if ((row = rows[i]) && row._bRowChecked) {
                    row._bRowChecked = false;
                    removeClass(row.getMain(), type + '-row-selected');
                }
            }
            rowCtrl._bRowChecked = true;
            addClass(rowCtrl.getMain(), type + '-row-selected');
            rowCheck.rowCheckCount = 1;
        }

        return false;
    };

    /**
     * 
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$isRowChecked = function(rowCtrl) {
        return !!rowCtrl._bRowChecked;
    };

    /**
     * 
     * 
     * @param {ecui.ui.CustomTable} con
     */
    function setFloatHScroll(con) {
        var el;

        el = con._eBrowser ? con._eBrowser : con._uHScrollbar.getOuter();
        el.style.top = MIN(
            getView().bottom - getPosition(con.getOuter()).top 
                - el.offsetHeight,
            con.getHeight() - el.offsetHeight
        ) + 'px';

        setStyle(el, 'zIndex', 1);
    }

    /**
     * 
     *
     * @private
     * @param {string} cellType 'ROWHCELL', 'HCELL', 'CCELL'
     * @param {Object} wrap 
     * @param {Object=} format 
     * @return {Object} valueprompt
     */
    function getWrapValue(cellType, wrap, format) {
        var value = wrap.str
            // strv
            ? wrap.str
            : String(
                wrap.v == null 
                    ? ' - '
                    : format
                        ? formatNumber(wrap.v, format, void 0, void 0, true)
                        : wrap.v
            );
        var prompt;
        var cut = this._oCut[cellType];
        if (cut) {
            prompt = value;
            value = sliceByte(value, cut, 'gbk');
            if (value.length < prompt.length) {
                value += '...';
            }
            /* ie7 ie7titleprompt */
            else if (!(dom.ieVersion < 8 && cellType == 'ROWHCELL')){
                prompt = null;
            }
        }
        return { 
            value: encodeHTML(value), 
            prompt: prompt && encodeHTML(prompt) 
        };
    }

    /**
     * wrap
     *
     * @private 
     * @param {*} wrap 
     */
    function objWrap(wrap) {
        if (wrap !== Object(wrap)) {
            wrap = { v: wrap };
        }
        return wrap;
    }    

    /**
     * cell
     * 
     * @protected
     * @return {Object} {x: 4, y: 5}
     */    
    function getCellPosition(el) {
        var pos = el.getAttribute('data-cell-pos');
        if (pos) {
            pos = pos.split('-');
            return { x: toNumber(pos[0]), y: toNumber(pos[1]) };
        }
        else {
            return null;
        }
    }

    /**
     * placeholderplaceholder
     */
    function isPlaceholder(o) {
        if (o !== Object(o)) {
            return false;
        }
        for (var i in o) {
            return false;
        }
        return true;
    }

    //--------------------------------------------------
    // UI_OLAP_TABLE_HCELL 
    //--------------------------------------------------

    UI_TABLE_HCELL_CLASS.$click = function () {
        var orderby;
        var tableCtrl = this.getParent();

        UI_CONTROL_CLASS.$click(this);

        if (orderby = this.getOuter().getAttribute('data-orderby')) {
            var pos = getCellPosition(this.getOuter());
            triggerEvent(
                tableCtrl, 
                'sort', 
                null, 
                [tableCtrl._aColDefine[(tableCtrl._nLeftLock || 0) + pos.x]]
            );
        }
    };

    //--------------------------------------------------
    // UI_OLAP_TABLE_CELL 
    //--------------------------------------------------

    /**
     * 
     * 
     * @event
     * @protected
     */
    UI_OLAP_TABLE_CELL_CLASS.$click = function(event) {
        UI_OLAP_TABLE_CLASS.Cell.superClass.$click.call(this, event);

        // handleCellClick
        if (!event.target 
            || !(
                event.target.getAttribute('data-cell-link-drill-a')
                || event.target.getAttribute('data-cell-link-bridge-a')
            )
        ) {
            this.$handleCellClick();
        }
    };

    /**
     * cell
     * 
     * @protected
     */    
    UI_OLAP_TABLE_CELL_CLASS.$handleCellClick = function() {
        var el = this.getOuter();
        var tableCtrl = this.getParent().getParent();
        var ec;

        // 
        if (el.getAttribute('data-row-h') && (ec = el.getAttribute('data-e-c'))) {
            if (getMouseX(this) <= 
                    toNumber(getStyle(el.firstChild, 'marginLeft')) 
                    + toNumber(getStyle(el.firstChild, 'paddingLeft'))
            ) {
                var pos;
                var cellWrap;
                var rowWrap;
                if (pos = getCellPosition(this.getOuter())) {
                    cellWrap = tableCtrl._aRowHeadFields[pos.y][pos.x];
                    rowWrap = tableCtrl._aRowDefine[pos.y];
                }
                triggerEvent(
                    tableCtrl,
                    (ec == 'expanded' ? 'collapse' : 'expand'), 
                    null,
                    [cellWrap, rowWrap]
                );
            }
        }

        // 
        if (el.getAttribute('data-content')) {
            var rowDefItem;
            if (pos = getCellPosition(this.getOuter())) {
                rowDefItem = tableCtrl._aRowDefine[pos.y];
            }
            // line
            triggerEvent(tableCtrl, 'rowclick', null, [rowDefItem]);

            var rowCtrl = this.getParent();

            var rowCheckMode = tableCtrl._oRowCheck.rowCheckMode;
            if (rowCheckMode) {
                var rowChecked = tableCtrl.$isRowChecked(rowCtrl);
                var eventName;

                if (rowCheckMode == 'SELECT') {
                    tableCtrl.$setRowChecked(rowCtrl, true);
                    eventName = 'rowselect';
                }
                else if (rowCheckMode == 'CHECK') {
                    if (rowChecked && tableCtrl.$setRowChecked(rowCtrl, false)) {
                        eventName = 'rowuncheck';
                    }
                    else if (!rowChecked && tableCtrl.$setRowChecked(rowCtrl, true)) {
                        eventName = 'rowcheck';
                    }
                }

                var callback = function (checked) {
                    tableCtrl.$setRowChecked(rowCtrl, checked);
                }

                eventName && triggerEvent(
                    tableCtrl,
                    eventName,
                    null,
                    [rowDefItem, callback]
                );
            }
        }
    };
 }) ();
/**
 * custom-table.js
 * Copyright 2012 Baidu Inc. All rights reserved *
 * desc: tablerender,
 * author: hades(denghongqi@baidu.com)
 */

 (function () {
    var core = ecui,
        dom = core.dom,
        array = core.array,
        ui = core.ui,
        string = core.string,
        util = core.util,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        disposeControl = core.dispose,
        $disposeControl = core.$dispose,
        createDom = dom.create,
        first = dom.first,
        last = dom.last,
        children = dom.children,
        addClass = dom.addClass,
        setStyle = dom.setStyle,
        setText = dom.setText,
        getText = dom.getText,
        removeClass = dom.removeClass,
        toNumber = util.toNumber,
        getParent = dom.getParent,
        moveElements = dom.moveElements,
        getAttribute = dom.getAttribute,
        getPosition = dom.getPosition,
        encodeHTML = xutil.string.encodeHTML,
        remove = array.remove,
        getView = util.getView,
        extend = util.extend,
        repaint = core.repaint,
        attachEvent = util.attachEvent,
        detachEvent = util.detachEvent,

        // 
        formatNumber = xutil.number.formatNumber;

        MATH = Math,
        MIN = MATH.min,
        WINDOW = window,

        UI_LOCKED_TABLE = ui.SlowLockedTable,
        UI_LOCKED_TABLE_CLASS = UI_LOCKED_TABLE.prototype;

    var UI_CUSTOM_TABLE = ui.CustomTable =
        inheritsControl(
            UI_LOCKED_TABLE,
            'ui-table',
            function(el, options) {
                this._oOptions = options;
                this._aHeader = options.header;
                this._sSortby = options.sortby;
                this._sOrderby = options.orderby;
                if (!options.datasource) {
                    this._nLeftLock = options.leftLock || 0;
                    this._nRightLock = options.rightLock || 0;
                }

                var type = this.getTypes()[0];

                // 
                this._oRowCheck = {
                    rowCheckMode: options.rowCheckMode,
                    rowChecked: options.rowChecked || [],
                    rowCheckMax: options.rowCheckMax || Number.MAX_VALUE,
                    rowCheckMin: options.rowCheckMin || Number.MIN_VALUE,
                    rowCheckCount: 0
                };
                // selected
                for (var i = 0, o; o = (options.datasource || [])[i]; i ++) {
                    o.selected && this._oRowCheck.rowChecked.push(i);
                }

                var html = [];
                html.push('<table><thead>');

                options.leftLock = options.leftLock || 0;
                options.rightLock = options.rightLock || 0;
                var lockedTotal = options.leftLock + options.rightLock;

                if (!options.datasource) {
                    setStyle(el, 'width', '100%');
                }
                else {
                    setStyle(el, 'width', 'auto');
                    setStyle(el, 'display', 'block');
                }

                if (!options.datasource) {
                    html.push('<tr>');
                    var i;
                    for (var i = 0; i <= lockedTotal; i++) {
                        html.push('<th></th>');
                    }
                    html.push('</tr>');
                }
                else {
                    //
                    if ('[object Array]' == Object.prototype.toString.call(options.fields[0])) {
                        var flag = 0;    
                        var i;
                        for (i = 0; i < options.fields.length; i++) {
                            var o = options.fields[i];
                            html.push(createHeadRow(o, this, options.fields));
                        }
                        this._aColumns = [];
                        for (var i = 0, o; o = options.fields[0][i]; i++) {
                            if (o.colspan) {
                                for (var j = 0; j < o.colspan; j++) {
                                    this._aColumns.push(extend({}, options.fields[1][flag++]));
                                }
                            }
                            else {
                                this._aColumns.push(extend({}, o));
                            }
                        }
                    }
                    else {
                        html.push(createHeadRow(options.fields, this));
                        this._aColumns = copyArray(options.fields);
                    }
                }

                html.push('</thead><tbody>');

                if(!options.datasource)  {
                    html.push('<tr>');
                    var i;
                    html.push('<td></td>');
                    html.push('</tr>');
                    options.leftLock = 0;
                    options.rightLock = 0;
                }
                else {
                    this._aData = options.datasource;

                    if (!this._aData.length) {
                        html.push('<tr>');
                        html.push(
                            '<td class="' + type + '-empty-cell'
                            + '" align="middle" colspan="'
                            + this._aColumns.length
                            + '">'
                        );
                        html.push(
                            options.errorMsg 
                            ? options.errorMsg
                            : ''
                        );
                        html.push('</td>');
                        html.push('</tr>');
                    }
                    else {
                        var i;
                        for (i = 0; i < options.datasource.length; i++) {
                            var item = options.datasource[i];
                            html.push('<tr>');
                            var j;
                            for (j = 0; j < this._aColumns.length; j++) {
                                var o = this._aColumns[j];
                                html.push('<td data-content="1" data-cell-pos="' + j + '-' + i + '" class="ui-table-ccell"');

                                o.align && html.push(
                                    ' align="' + o.align + '"'
                                );

                                html.push('>');

                                var content = o.content || o.field;

                                if (typeof content == 'function') {
                                    var e = content.call(null, item, i);
                                    if (Object.prototype.toString.call(e) == '[object String]') {
                                        /*
                                        if (o.autoEllipsis) {
                                            html.push('<span title="');
                                            html.push()
                                        }
                                        */
                                    	 /*
                                        if (o.maxlength 
                                            && e
                                            && e.length > o.maxlength
                                        ) {
                                            html.push('<span class="');
                                            html.push(type + '-cell-limited"');
                                            html.push(' title="' + e + '">');
                                            html.push(encodeHTML(e.substring(0, o.maxlength)));
                                            html.push('...');
                                            html.push('</span>');
                                        }
                                        else {
                                            html.push(e);
                                        }
                                        */
                            			//update by lizhantong 2014-04-04 19:24:10
                                    	//tdtitle
                                    	html.push('<span ');
       									html.push(' title="' + encodeHTML(e) + '">');
       									html.push(encodeHTML(e));
       									html.push('</span>');
                                    }
                                    else {
                                        var div = createDom();
                                        div.appendChild(e);
                                        html.push(div.innerHTML);
                                    }
                                }
                                else {
                                    if (o.checkbox) {
                                        html.push('<input type="checkbox"');
                                        html.push(
                                            ' class="' + type + '-checkbox"'
                                        );
                                        html.push(
                                            ' data-rownum="' + i + '"'
                                        );
                                        html.push(' />');
                                    }
                                    else {
                                        var vc = item[content];
                                        // add by majun 2014-3-20 15:05:15
                                        // -
                                        if(vc == null || vc == ''){
                                            vc = '-';
                                        }else if (o.format) {
                                            vc = formatNumber(vc, o.format, void 0, void 0, true);
                                        }
                                        /*
                                        if (o.maxlength 
                                            && vc
                                            && vc.length > o.maxlength
                                        ) {
                                            html.push('<span class="');
                                            html.push(type + '-cell-limited"');
                                            html.push(' title="' + encodeHTML(vc) + '">');
                                            html.push(encodeHTML(vc.substring(0, o.maxlength)));
                                            html.push('...');
                                            html.push('</span>');
                                        }
                                        else {
                                            html.push(encodeHTML(vc));
                                        }
                                        */
                                        //update by lizhantong 2014-04-04 19:26:10
                                    	//tdtitle
                                    	//html.push('<span ');
                                    	html.push('<span class="');
                                        html.push(type + '-cell-limited"');
       									html.push(' title="' + encodeHTML(vc) + '">');
       									html.push(encodeHTML(vc));
       									html.push('</span>');
                                    }

                                    if (o.detail) {
                                        html.push('<span ecui="type:tip;asyn:true;id:');
                                        html.push('tip-' + item[o.idField] + '"');
                                    }
                                }

                                html.push('</td>');
                            }
                            html.push('</tr>');
                        }
                    }
                }

                html.push('</tbody></table>');

                el.innerHTML = html.join('');

                return el;
            },
            function(el, options) {
                //ecui.init(el);
                if (options.fields && options.datasource) {
                    initEmbedControlEvent(options.fields, options.datasource);
                }

                this.$bindCheckbox();
                return el;
            }
        ),
        UI_CUSTOM_TABLE_CLASS = UI_CUSTOM_TABLE.prototype,

        UI_CUSTOM_TABLE_CELL_CLASS = (
            UI_CUSTOM_TABLE_CLASS.Cell = inheritsControl(
                UI_LOCKED_TABLE_CLASS.Cell,
                null,
                function (el, options) {
                    options.primary = 'ui-table-cell';
                }
            )
        ).prototype,

        DELEGATE_EVENTS = ['click', 'mouseup', 'mousedown'],

        // 
        DEFAULT_EVENTS = {
            
            'click th.ui-table-hcell-sort': function (event, control) {
                var field = this.getAttribute('data-field'),
                    orderby;

                if (this.className.indexOf('-sort-desc') >= 0) {
                    orderby = 'asc';
                }
                else if (this.className.indexOf('-sort-asc') >= 0) {
                    orderby = 'desc'
                }
                else {
                    orderby = this.getAttribute('data-orderby') || 'desc';
                }

                triggerEvent(control, 'sort', null, [field, orderby]);
            },
            'click input.ui-table-checkbox-all': function (event, control) {
                control.$refreshCheckbox(this.checked);
            },
            'click input.ui-table-checkbox': function (event, control) {
                control.$refreshCheckbox();
            }
        };      

    /** 
     * 
     * 
     * @param {Array} headrow 
     * @param {ecui.ui.CustomTable} con
     * @param {Array} opt_head 
     * @return {string} html
     */
    function createHeadRow(headrow, con, opt_head) {
        var type = con.getTypes()[0];

        var html = [];
        html.push('<tr>');

        var flag = 0;
        var i = 0;
        for (i = 0; i < headrow.length; i++) {
            var o = headrow[i];
            html.push('<th ');
            html.push('data-field="');

            if (Object.prototype.toString.call(o.field) == '[object String]') {
                html.push(o.field);
            }

            if (o.width) {
                html.push(
                    '" style="width:' + o.width + 'px;'
                    + 'min-width:' + o.width + 'px'
                );
            }

            if (o.rowspan) {
                html.push(
                    '" rowspan="' + o.rowspan
                );
            }
            if (o.colspan) {
                html.push(
                    '" colspan="' + o.colspan
                );

                var j;
                var width = 0;
                for (j = flag; j < flag + o.colspan; j++) {
                    width += opt_head[1][j].width;
                }

                html.push(
                    '" width="' + width
                );

                flag += o.colspan;
            }
            if (o.sortable) {
                html.push(
                    '" class="' + type + '-hcell-sort'
                );
                if (o.field && o.field == con._sSortby) {
                    html.push(
                        ' ' + type + '-hcell-sort-' + con._sOrderby
                    );
                }
                if (o.order) {
                    html.push(
                        '" data-orderby="' + o.order
                    );
                }
            }
            html.push('">');

            if (o.title) {
                 //html.push(o.title);
                 //ie8innerCelldivmargin
                //
                var useBag = dom.ieVersion < 8;
                var isLastColumn = i == headrow.length - 1;
                html.push(
                        useBag ? ('<div class="ui-plane-table-hcell-bag ') : '', 
                        useBag && isLastColumn ? ('ui-plane-table-hcell-bag-lastcolumn') : '',
                        useBag ? ('">') : '', 
                            o.title, 
                        useBag ? '</div>' : ''
                );
            }

            if (o.checkbox) {
                html.push(
                    '<input type="checkbox" class="'
                    + type + '-checkbox-all"'
                    + ' />'
                );
            }

            if (o.tip && o.tip.length) {
                html.push('<span ecui="type:tip; id:tip-');
                html.push(o.field);
                html.push('; message:');
                html.push(o.tip);
                html.push('"></span>');
            }

            html.push('</th>');
        }
        html.push('</tr>');

        return html.join('');
    }

    /**
     * 
     *
     * @param {Array} header 
     * @param {Array} datasource 
     */
    function initEmbedControlEvent(header, datasource) {
        var i = 0;
        for (i = 0; i < datasource.length; i++) {
            var item = datasource[i];
            for (var j = 0; j < header.length; j++) {
                var o = header[j];
                if (o.detail) {
                    var controlId = 'tip-' + item[o.idField];
                    if (ecui.get(controlId)) {
                        ecui.get(controlId).onloadData = (function (item, o) {
                            return function (handler) {
                                o.loadData(item, handler);
                            }
                        }) (item, o);
                    }
                }
            }
        }
    }

    UI_CUSTOM_TABLE_CLASS.getData = function () {
        return this._aData;
    };

    UI_CUSTOM_TABLE_CLASS.$createHeadRow = function (headrow) {
        var type = this.getTypes()[0];

        var tr = createDom('', '', 'tr');

        for (var i = 0, o; o = headrow[i]; i++) {
            var th = createDom('', '', 'th');
            tr.appendChild(th);
            o.title && setText(th, o.title);
            if (o.tip && o.tip.length) {
                var tipEl = createDom('', '', 'span');
                tipEl.innerHTML = '';
                tipEl.setAttribute(
                    'ecui', 
                    'type:tip; id:' + o.field + '-tip; message:' + o.tip
                );
                th.appendChild(tipEl);
                ecui.init(tipEl);
            }
            //o.width && setStyle(th, 'width', o.width + 'px');
            //o.width && th.setAttribute('width', o.width + 'px');
            o.width && setStyle(th, 'minWidth', o.width + 'px');

            o.field && th.setAttribute('data-field', o.field);

            o.rowspan && th.setAttribute('rowSpan', o.rowspan);
            o.colspan && th.setAttribute('colSpan', o.colspan);

            if (o.sortable) {
                addClass(th, type + '-hcell-sort');

                if (o.field && o.field == this._sSortby) {
                    addClass(th, type + '-hcell-sort-' + this._sOrderby);
                }
            }

            if (o.checkbox) {
                var checkboxAll = createDom('', '', 'input');
                checkboxAll.setAttribute('type', 'checkbox');
                addClass(checkboxAll, type + '-checkbox-all');
                th.appendChild(checkboxAll);
            }
        }

        return tr;
    };

    /**
     * 
     * @public
     *
     * @return {Array} 
     */
    UI_CUSTOM_TABLE_CLASS.getFields = function() {
        return this._aColumns;
    };

    /**
     * 
     * @public
     *
     * @param {Array} fields 
     * @param {Array} datasource 
     * @param {Object} sortinfo 
     * @param {Object} options 
     * @param {string} errorMsg 
     */
    UI_CUSTOM_TABLE_CLASS.render = function(
        fields, datasource, sortinfo, options, errorMsg
    ) {
        var options = extend({}, options);
        options = extend(options, this._oOptions);
        options.leftLock = this._nLeftLock;
        options.rightLock = this._nRightLock;
        options.fields = fields;
        options.datasource = datasource || [];
        var sortinfo = sortinfo || {};
        options.sortby = sortinfo.sortby;
        options.orderby = sortinfo.orderby;
        options.errorMsg = errorMsg;

        if (!datasource.length) {
            options.leftLock = 0;
            options.rightLock = 0;
        }

        this.$refresh(options);
    };

    /**
     * 
     * @private
     */
    UI_CUSTOM_TABLE_CLASS.$bindCheckbox = function () {
        var inputs = this.getBody().getElementsByTagName('input'),
            i, item, type = this.getTypes()[0];

        this._aCheckboxs = [];
        this._eCheckboxAll = null;

        for (i = 0; item = inputs[i]; i++) {
            if (item.type == 'checkbox' 
                    && item.className.indexOf(type + '-checkbox-all') >= 0
            ) {
                this._eCheckboxAll = item;
            }
            else if (item.type == 'checkbox' && item.className.indexOf(type + '-checkbox') >= 0) {
                this._aCheckboxs.push(item);
            }
        }
    };

    /**
     * 
     * @private
     *
     * @param {Boolean} checked / 
     */
    UI_CUSTOM_TABLE_CLASS.$refreshCheckbox = function (checked) {
        var i, item, newChecked = true, tr;

        for (i = 0; item = this._aCheckboxs[i]; i++) {
            tr = item.parentNode.parentNode;
            if (checked !== undefined) {
                item.checked = checked;
            }
            else {
                newChecked = item.checked && newChecked;
            }

            if (item.checked && this._bCheckedHighlight) {
                tr.className += ' highlight';
            }
            else if (this._bCheckedHighlight) {
                tr.className = tr.className.replace(/\s+highlight/g, '');
            }
        }

        if (this._eCheckboxAll) {
            this._eCheckboxAll.checked = checked !== undefined ? checked : newChecked;
        }
    };

    /**
     * tablesizechange
     *
     */
    UI_CUSTOM_TABLE_CLASS.$ready = function() {
        triggerEvent(this, 'sizechange');
    };


    /**
     * resize
     *
     * @override
     */
    UI_CUSTOM_TABLE_CLASS.$resize = function() {
        var me = this;
        UI_LOCKED_TABLE_CLASS.$resize.call(this);
        triggerEvent(this, 'sizechange');
        setTimeout(
            function() {
                me.$pagescroll();
            },
            500
        );
    };

    /**
     * 
     *
     * @override
     */
    UI_CUSTOM_TABLE_CLASS.$pagescroll = function() {
        UI_LOCKED_TABLE_CLASS.$pagescroll.call(this);

        if (this._uHScrollbar) {
            // iframeDI
            // setFloatHScroll(this);
        }
    };

    UI_CUSTOM_TABLE_CLASS.getSelection = function () {
        if (!this._aCheckboxs || !this._aCheckboxs.length) {
            return [];
        }

        var res = [];

        for (var i = 0, o; o = this._aCheckboxs[i++]; ) {
            if (o.checked) {
                var index = getAttribute(o, 'data-rownum') - 0;
                res.push(extend({}, this._aData[index]));
            }
        }
        return res;
    };

    /**
     * @override
     */
    UI_CUSTOM_TABLE_CLASS.init = function () {
        var i, item, ele = this.getOuter(),
            control = this;

        UI_LOCKED_TABLE_CLASS.init.call(this);

        // 
        // click mousedown mouseup
        if (!this.eventAdded) {
            for (i = 0; item = DELEGATE_EVENTS[i]; i++) {
                attachEvent(ele, item, (function (name) {
                    return function (event) {
                        var e = event || window.event;
                        e.targetElement = e.target || e.srcElement;
                        control.$fireEventHandler(name, e);
                    }
                })(item));
            }
            this.eventAdded = true;
        }

        // 
        this.$initRowChecked();
    };

    /**
     * events
     * @private
     *
     * @param {String} eventType 
     * @param {Event} nativeEvent 
     */
    UI_CUSTOM_TABLE_CLASS.$fireEventHandler = function (eventType, nativeEvent) {
        var events = getHandlerByType(this.events, eventType),
            i, item, target = nativeEvent.targetElement, selector;

        for (i = 0; item = events[i]; i++) {
            if (checkElementBySelector(target, item.selector)) {
                item.handler.call(target, nativeEvent, this);
            }
        }
    }

    UI_CUSTOM_TABLE_CLASS.$refresh = function (options) {
        detachEvent(WINDOW, 'resize', repaint);

        this.$disposeInner();

        var el = this.getOuter();
        el.innerHTML = '';
        this.$setBody(el);
        this.$resize();

        // FIXME
        // getOuterwidth
        // resize()
        // =====================================

        UI_CUSTOM_TABLE.client.call(
            this, 
            el, 
            extend(
                { uid: this._sUID, primary: this._sPrimary }, 
                options
            )
        );
        this._bCreated = false;
        this.cache(true, true);
        UI_LOCKED_TABLE_CLASS.init.call(this);

        this.init();
        // TODO
        // this.$bindCellLink();

        attachEvent(WINDOW, 'resize', repaint);
    };

    /**
     * 
     * 
     * @protected
     */
    UI_CUSTOM_TABLE_CLASS.$disposeInner = function() {
        var disposeFunc = this.$dispose;
        this.$dispose = new Function();
        disposeControl(this);
        this.$dispose = disposeFunc;
    };

    /**
     * row
     *
     * @protected
     */
    UI_CUSTOM_TABLE_CLASS.$getContentRow = function(rowIndex) {
        // LockedTablerow
        var row;
        var cell;
        return (row = this._aRows[rowIndex])
            && (cell = row.getCell(this._nLeftLock || 0))
            && cell.getParent()
            || null;
    };

    /**
     * 
     *
     * @private
     */
    UI_CUSTOM_TABLE_CLASS.$initRowChecked = function() {
        var rowCheck = this._oRowCheck;
        for (
            var i = 0, rowCtrl; 
            i < (rowCheck.rowChecked || []).length; 
            i ++
        ) {
            // LockedTablerow
            if (rowCtrl = this.$getContentRow(rowCheck.rowChecked[i])) {
                this.$setRowChecked(rowCtrl, true);
            }
        }
    };    

    /**
     * 
     *
     * @private
     */
    UI_CUSTOM_TABLE_CLASS.$setRowChecked = function(rowCtrl, checked) {
        var type = this.getType();
        var rowCheck = this._oRowCheck;

        var rowCheckMode = this._oRowCheck.rowCheckMode;
        // 
        if (rowCheckMode == 'CHECK') {
            if (checked
                && !rowCtrl._bRowChecked
                && rowCheck.rowCheckCount < rowCheck.rowCheckMax
            ) {
                rowCtrl._bRowChecked = true;
                addClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount ++;
                return true;
            }

            if (!checked 
                && rowCtrl._bRowChecked
                && rowCheck.rowCheckCount > rowCheck.rowCheckMin
            ) {
                rowCtrl._bRowChecked = false;
                removeClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount --;
                return true;
            }
        }
        // 
        else if (rowCheckMode == 'SELECT') {
            var rows = this._aRows || [];
            for (var i = 0, row, cell; i < rows.length; i ++) {
                if ((row = rows[i]) && row._bRowChecked) {
                    row._bRowChecked = false;
                    removeClass(row.getMain(), type + '-row-selected');
                }
            }
            rowCtrl._bRowChecked = true;
            addClass(rowCtrl.getMain(), type + '-row-selected');
            rowCheck.rowCheckCount = 1;
        }

        return false;
    };

    /**
     * 
     *
     * @private
     */
    UI_CUSTOM_TABLE_CLASS.$isRowChecked = function(rowCtrl) {
        return !!rowCtrl._bRowChecked;
    };

    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    UI_CUSTOM_TABLE_CLASS.getValue = function() {
        var rowChecked = [];
        var rows = this._aRows || [];
        for (var i = 0, row; i < rows.length; i ++) {
            if ((row = rows[i]) && row._bRowChecked) {
                rowChecked.push({ value: this._aData[i], index: i });
            }
        }
        return {
            rowChecked: rowChecked,
            data: (this._aData || []).slice()
        }
    };

    /**
     * 
     * 
     * @param {ecui.ui.CustomTable} con
     */
    function setFloatHScroll(con) {
        var el;

        el = con._eBrowser ? con._eBrowser : con._uHScrollbar.getOuter();
        el.style.top = MIN(
            getView().bottom - getPosition(con.getOuter()).top - el.offsetHeight,
            con.getHeight() - el.offsetHeight
        ) + 'px';

        setStyle(el, 'zIndex', 1);
    }

    function getHandlerByType(events, type) {
        var handlers = [], item;

        events = extend({}, events);
        events = extend(events, DEFAULT_EVENTS);

        for (var key in events) {
            item = {handler: events[key]};
            key = key.split(/\s+/);
            if (key[0] == type) {
                item.selector = key[1];
                handlers.push(item);
            }
        }

        return handlers;
    }

    function checkElementBySelector(ele, selector) {
        var tagName, value, type, res = true;

        if (!ele && !selector) {
            return false;
        }

        selector.replace(/^([^.#]*)([.#]?)(.*)$/, function ($0, $1, $2, $3) {
            tagName = $1;
            type = $2;
            value = $3;
        });

        if (tagName && ele.tagName.toLowerCase() != tagName) {
            res = false;
        }

        if (type == '.' && !new RegExp('(^|\\s+)' + value + '(\\s+|$)').test(ele.className)) {
            res = false;
        }

        if (type == '#' && ele.id != value) {
            res = false;
        }

        return res;
    }
    
    function copyArray(data) {
        var res = [];
        for (var i = 0, o; o = data[i++]; ) {
            res.push(extend({}, o));
        }
        return res;
    }

    /**
     * cell
     * 
     * @protected
     * @return {Object} {x: 4, y: 5}
     */    
    function getCellPosition(el) {
        var pos = el.getAttribute('data-cell-pos');
        if (pos) {
            pos = pos.split('-');
            return { x: toNumber(pos[0]), y: toNumber(pos[1]) };
        }
        else {
            return null;
        }
    } 

   //--------------------------------------------------
    // UI_TABLE_CELL 
    //--------------------------------------------------

    /**
     * 
     * 
     * @event
     * @protected
     */
    UI_CUSTOM_TABLE_CELL_CLASS.$click = function(event) {
        UI_CUSTOM_TABLE_CLASS.Cell.superClass.$click.call(this, event);

        // handleCellClick
        if (!event.target 
            || !(
                event.target.getAttribute('data-cell-link-drill-a')
                || event.target.getAttribute('data-cell-link-bridge-a')
            )
        ) {
            this.$handleCellClick();
        }
    };

    /**
     * cell
     * 
     * @protected
     */    
    UI_CUSTOM_TABLE_CELL_CLASS.$handleCellClick = function() {
        var el = this.getOuter();
        var tableCtrl = this.getParent().getParent();
        var ec;

        // 
        if (el.getAttribute('data-content')) {
            var rowDefItem;
            if (pos = getCellPosition(this.getOuter())) {
                rowDefItem = tableCtrl._aData[pos.y];
            }
            // line
            triggerEvent(tableCtrl, 'rowclick', null, [rowDefItem]);

            var rowCtrl = this.getParent();

            var rowCheckMode = tableCtrl._oRowCheck.rowCheckMode;
            if (rowCheckMode) {
                var rowChecked = tableCtrl.$isRowChecked(rowCtrl);
                var eventName;

                if (rowCheckMode == 'SELECT') {
                    tableCtrl.$setRowChecked(rowCtrl, true);
                    eventName = 'rowselect';
                }
                else if (rowCheckMode == 'CHECK') {
                    if (rowChecked && tableCtrl.$setRowChecked(rowCtrl, false)) {
                        eventName = 'rowuncheck';
                    }
                    else if (!rowChecked && tableCtrl.$setRowChecked(rowCtrl, true)) {
                        eventName = 'rowcheck';
                    }
                }

                var callback = function (checked) {
                    tableCtrl.$setRowChecked(rowCtrl, checked);
                }

                eventName && triggerEvent(
                    tableCtrl,
                    eventName,
                    null,
                    [rowDefItem, callback]
                );
            }
        }
    };

 })();
/*
Pager - 
change

HTML:
<div type="type:pager;pageSize:10;maxNum:40" class="ui-pager"></div>


nPage:      (1)
nPageSize:  
nTotal:     


change:     

*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        array = core.array,
        ui = core.ui,
        util = core.util,

        undefined,
        MATH = Math,

        createDom = dom.create,
        children = dom.children,
        extend = util.extend,
        blank = util.blank,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_BUTTON = ui.Button,
        UI_SELECT = ui.Select,
        UI_ITEM = ui.Item,
        UI_ITEMS = ui.Items,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_SELECT_CLASS = UI_SELECT.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_INPUT_CONTROL
    ///__gzip_original__UI_INPUT_CONTROL_CLASS
    /**
     * 
     * options 
     *      {Number} pageSize   
     *      {Number} total       
     *      {Number} page      
     *
     * @public
     *
     * @param {Object} options 
     */
    var UI_PAGER = ui.Pager =
        inheritsControl(
            UI_CONTROL,
            'ui-pager',
            function (el, options) {
                var type = this.getTypes()[0],
                    i, len, html = [];
                
                if (!options.showCount || options.showCount < 3) {
                    len = this._nShowCount = 7;
                }
                else {
                    len = this._nShowCount = options.showCount;
                }
                this._bOMSButton = options.omsButton !== false;
                html.push('<div class="' + type + '-button-prv ' + type + '-button"></div><div class="'+ type +'-items">');
                for (i = 0; i < len; i++) {
                    if (i == 1 || i == len - 1) {
                        html.push('<div class="'+ type +'-item-oms" ecui="disabled:true">...</div>');
                    }
                    html.push('<div class="'+ type +'-item"></div>');
                }
                html.push('</div><div class="' + type + '-button-nxt ' + type + '-button"></div>');

                el.innerHTML = html.join('');

            },
            function (el, options) {
                el = children(el);

                this._bResizable = false;
                this._nPage = options.page || 1;
                this._nPageSize = options.pageSize || 50;
                this._nTotal = options.total || 0;

                this._uPrvBtn = $fastCreate(this.Button, el[0], this);
                this.$setBody(el[1]);
                this._uNxtBtn = $fastCreate(this.Button, el[2], this);
                this.$initItems();
            }
        ),
        UI_PAGER_CLASS = UI_PAGER.prototype,
        UI_PAGER_BUTTON = UI_PAGER_CLASS.Button = 
        inheritsControl(
            UI_BUTTON, 
            'ui-pager-button', 
            function (el, options) {
                var type = this.getTypes()[0],
                    o = createDom(type + '-icon');

                el.insertBefore(o, el.firstChild);
            }
        ),
        UI_PAGER_BUTTON_CLASS = UI_PAGER_BUTTON.prototype,
        UI_PAGER_ITEM_CLASS = (UI_PAGER_CLASS.Item = inheritsControl(UI_ITEM, 'ui-pager-item', function (el, options) {
            options.resizeable = false; 
        })).prototype;
//{else}//

    extend(UI_PAGER_CLASS, UI_ITEMS);
    
    /**
     * 
     * step
     * @private
     */
    function UI_PAGER_BTN_CLICK(event){
        var par = this.getParent(),
            curIndex = par._nPage,
            maxNum = par.getMaxPage(),
            n = this.getStep();

        UI_CONTROL_CLASS.$click.call(this);

        if (n.charAt(0) == '+') {
            curIndex += parseInt(n.substring(1), 10);
            //+0 
            if (curIndex == par._nPage) {
                curIndex = maxNum;
            }
            else if (curIndex > maxNum) {
                curIndex = par._nPage;
            }
        }
        else if (n.charAt(0) == '-') {
            curIndex -= parseInt(n.substring(1), 10);
            //-0 
            if (curIndex == par._nPage) {
                curIndex = 1;
            }
            else if (curIndex < 1) {
                curIndex = par._nPage;
            }
        }
        else {
            curIndex = parseInt(n, 10);
        }

        if (par._nPage != curIndex) {
            triggerEvent(par, 'change', null, [curIndex]);
        }
    }

    /**
     * 
     * 
     * @private
     */
    function UI_PAGER_REFRESH(con) {
        var items = con._aPageBtn,
            max = con.getMaxPage(),
            idx = con._nPage,
            showCount = con._nShowCount,
            nHfNum = parseInt(showCount / 2, 10),
            start = idx - nHfNum > 0 ? idx - nHfNum : 1,
            end, i, item;

        if (idx == 1) {
            con._uPrvBtn.disable();
        }
        else {
            con._uPrvBtn.enable();
        }

        if (idx == max || max == 0) {
            con._uNxtBtn.disable();
        }
        else {
            con._uNxtBtn.enable();
        }

        if (start + showCount - 1 > max && max - showCount >= 0) {
            start = max - showCount + 1;
        }
        for (i = 0; item = items[i]; i++) {
            end = start + i;
            item.setContent(end);
            item.setStep(end);
            item.setSelected(idx == end);
            if (end > max) {
                item.hide();
            }
            else {
                item.show();
            }
        }

        UI_PAGER_OMS_REFRESH(con);
    }
   
    /**
     * more
     * @private
     */
    function UI_PAGER_OMS_REFRESH(con) {
        var items = con._aPageBtn,
            omsBtn = con._aOMSBtn,
            max = con.getMaxPage(),
            item;

        if (!con._bOMSButton) {
            return;
        }
        
        if (items[0].getContent() != '1') {
            items[0].setContent(1);
            items[0].setStep(1);
            omsBtn[0].show();
        }
        else {
            omsBtn[0].hide();
        }

        item = items[items.length - 1];
        if (item.isShow() && item.getContent() != max) {
            item.setContent(max);
            item.setStep(max);
            omsBtn[1].show();
        }
        else {
            omsBtn[1].hide();
        }
    }

    UI_PAGER_ITEM_CLASS.$setSize = blank;

    /**
     * 
     * @public
     *
     * @param {Boolean} flag 
     */
    UI_PAGER_ITEM_CLASS.setSelected = function (flag) {
        this.alterClass((flag ? '+' : '-') + 'selected');
    };

    /**
     * 
     * +/-n /n
     * +0  -0 
     * @public
     *
     * @param {String} n 
     */
    UI_PAGER_BUTTON_CLASS.setStep = UI_PAGER_ITEM_CLASS.setStep = function (n) {
        this._sStep = n + '';
    };

    /**
     * 
     * @public
     *
     * @return {String} 
     */
    UI_PAGER_BUTTON_CLASS.getStep = UI_PAGER_ITEM_CLASS.getStep = function () {
        return this._sStep;
    };

    /**
     * @override
     */
    UI_PAGER_BUTTON_CLASS.$click = UI_PAGER_ITEM_CLASS.$click = UI_PAGER_BTN_CLICK;

    /**
     * 
     * @public
     *
     * @return {Number} 
     */
    UI_PAGER_CLASS.getMaxPage = function () {
        return MATH.ceil(this._nTotal / this._nPageSize);
    };

    /**
     * 
     * @public
     *
     * @return {Number} 
     */
    UI_PAGER_CLASS.getTotal = function () {
        return this._nTotal;
    };

    /**
     * 
     * @public
     *
     * @return {Number} 
     */
    UI_PAGER_CLASS.getTotal = function () {
        return this._nTotal;
    };

    /**
     * 
     * 
     * @public
     *
     * @param {Number} i 
     */
    UI_PAGER_CLASS.go = function (i) {
        this._nPage = i;
        UI_PAGER_REFRESH(this); 
    };

    /**
     * 
     * @public
     *
     * @param {Number} num 
     */
    UI_PAGER_CLASS.setPageSize = function (num) {
        this._nPageSize = num;
        this._nPage = 1;
        UI_PAGER_REFRESH(this); 
    };

    /**
     * 
     * @public
     *
     * @param {Number} num 
     */
    UI_PAGER_CLASS.setTotal = function (num) {
        this._nTotal = num;
        this._nPage = 1;
        UI_PAGER_REFRESH(this); 
    };

    /**
     * 
     * 
     *
     * @override
     */
    UI_PAGER_CLASS.init = function () {
        var i, item, items = this.getItems();

        this._uPrvBtn.setStep('-1');
        this._uNxtBtn.setStep('+1');
        this._aOMSBtn = [];
        this._aPageBtn = [];
        UI_CONTROL_CLASS.init.call(this);
        for (i = 0; item = items[i]; i++) {
            item.init();
            if (i == 1 || i == items.length - 2) {
                this._aOMSBtn.push(item);
                item.hide();
            }
            else {
                this._aPageBtn.push(item);
            }
        }
        UI_PAGER_REFRESH(this);
    };

    /**
     * override
     */
    UI_PAGER_CLASS.$setSize = blank;

//{/if}//
//{if 0}//
})();
//{/if}//

/*
Pager - 
change

HTML:
<div type="type:pager;pageSize:10;maxNum:40" class="ui-pager"></div>


nPage:      (1)
nPageSize:  
nTotal:     


change:     

*/
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        array = core.array,
        ui = core.ui,
        util = core.util,

        undefined,
        MATH = Math,

        createDom = dom.create,
        children = dom.children,
        extend = util.extend,
        blank = util.blank,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_PAGER = ui.Pager,
        UI_SELECT = ui.Select,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_PAGER_CLASS = UI_PAGER.prototype;
    /**
     * 
     * options 
     *      {Number} pageSize   
     *      {Number} total       
     *      {Number} page      
     *
     * @public
     *
     * @param {Object} options 
     */
    var UI_EXT_PAGER = ui.ExtPager =
        inheritsControl(
            UI_CONTROL,
            'ui-ext-pager',
            function (el, options) {
                var type = this.getTypes()[0],
                    i, len, html = [];
                
                html.push('<div class="'+ type +'-sum"><em></em></div>');
                html.push('<div class="ui-pager"></div>');
                html.push('<div class="'+ type +'-pagesize"><span class="' + type + '-text"></span><select class="ui-select" style="width:40px">');
                for (i = 0, len = UI_EXT_PAGER.PAGE_SIZE.length; i < len; i++) {
                    html.push('<option value="'+ UI_EXT_PAGER.PAGE_SIZE[i] +'">' + UI_EXT_PAGER.PAGE_SIZE[i] + '</option>');
                }
                html.push('</select><span class="' + type + '-text"></span>')
                el.innerHTML = html.join('');

                //pageSize
                options.pageSize = options.pageSize || DEFAULT_PAGE_SIZE;
                for (i = 0, len = UI_EXT_PAGER.PAGE_SIZE.length; i < len; i++) {
                    if (UI_EXT_PAGER.PAGE_SIZE[i] == options.pageSize) {
                        break;
                    }
                }
                
                if (i >= len) {
                    options.pageSize = DEFAULT_PAGE_SIZE;
                }
            },
            function (el, options) {
                var el = children(el),
                    me = this;

                this._bResizable = false;
                this._eTotalNum = el[0].getElementsByTagName('em')[0];
                this._uPager = $fastCreate(UI_PAGER, el[1], this, extend({}, options));
                this._uPager.$change = function (value) {
                    triggerEvent(me, 'change', null, [value, me._uPager._nPageSize]);
                }
                this._uSelect = $fastCreate(UI_SELECT, el[2].getElementsByTagName('select')[0], this);
                this._uSelect.$change = function () {
                    triggerEvent(me, 'pagesizechange', null, [this.getValue()]);
                }
            }
        ),

        UI_EXT_PAGER_CLASS = UI_EXT_PAGER.prototype,

        DEFAULT_PAGE_SIZE = 50;
        

    UI_EXT_PAGER.PAGE_SIZE = [20, 50, 80];

    UI_EXT_PAGER_CLASS.init = function () {
        this._uPager.init();
        this._uSelect.init();
        this._eTotalNum.innerHTML = this._uPager._nTotal || 0;
        this._uSelect.setValue(this._uPager._nPageSize);
    }

    UI_EXT_PAGER_CLASS.render = function (page, total, pageSize) {
        var item = this._uPager;

        this._uSelect.setValue(pageSize);
        if (total || total == 0) {
            this._eTotalNum.innerHTML = total;
            item._nTotal = total
        }
        else {
            this._eTotalNum.innerHTML = item._nTotal || 0;
            item._nTotal = item._nTotal || 0;
        }
        item._nPageSize = pageSize || item._nPageSize;
        item.go(page);
    };

    UI_EXT_PAGER_CLASS.getPageSize = function () {
        return this._uPager._nPageSize;
    };

    UI_EXT_PAGER_CLASS.getPage = function () {
        return this._uPager._nPage;
    };

    UI_EXT_PAGER_CLASS.getTotal = function () {
        return this._uPager._nTotal;
    };
    
    /**
     * override
     */
    UI_EXT_PAGER_CLASS.$setSize = blank;

})();

/**
 * ecui.ui.Breadcrumb
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   
 * @author: sushuang(sushuang@baidu.com)
 */

 (function() {
    
    var core = ecui;
    var ui = core.ui;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var disposeControl = core.dispose;
    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;

    /**
     * 
     *
     * @class
     * @extends {ecui.ui.Control}
     */
    var UI_BREADCRUMB = ui.Breadcrumb =
        inheritsControl(
            UI_CONTROL,
            'ui-breadcrumb',
            null,
            function(el, options) {
                this.$setOptions(options);
            }
        );
    var UI_BREADCRUMB_CLASS = UI_BREADCRUMB.prototype;

    //--------------------------------------------------
    // UI_BREADCRUMB 
    //--------------------------------------------------

    UI_BREADCRUMB_CLASS.$setSize = new Function();
    
    /**
     * 
     * 
     * @protected
     * @param {Object} options 
     * @parma {number=} options.maxShow 
     *      '...'
     * @param {number=} options.hidePosPercent maxShow
     *      ...
     *      010.550%
     * @param {Array.<Object>} options.datasource 
     *      
     *          {string} text 
     *          {number} value 
     *          {boolean} disabled 
     *          {string=} url url
     *              change
     */
    UI_BREADCRUMB_CLASS.$setOptions = function(options) {
        this._oOptions = options || {};
        this._aDatasource = this._oOptions.datasource || [];
    };

    /**
     * 
     *
     * @public
     * @param {string} data setOptions
     */
    UI_BREADCRUMB_CLASS.setData = function(data) {
        this.$setOptions(data);

        this.$disposeInner();

        this.$renderHTML();

        this.$bindEvent();
    };

    /**
     * HTML
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$renderHTML = function() {
        var type = this.getType();
        var html = [];

        // 
        var hidePos = this.$calculateHide();

        // 
        var hidePushed = false;
        for (var i = 0, item, url; item = this._aDatasource[i]; i ++) {
            url = item.url || '#';
            if (i >= hidePos.start && i <= hidePos.end) {
                if (!hidePushed) {
                    html.push('<span class="' + type + '-hide-item">...<span>');
                    hidePushed = true;
                }
            }
            else if (item.disabled) {
                html.push('<span class="' + type + '-text-item">' + item.text + '<span>');
            }
            else {
                html.push(
                    '<a href="' + url + '" class="' + type + '-link-item" data-breadcrumb-index="' + i +'">' + item.text + '</a>'
                );
            }
        }
        var sepHTML = '<span class="' + type + '-sep">&gt;</span>';
        this.getBody().innerHTML = html.join(sepHTML);
    };

    /**
     * 
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$calculateHide = function() {
        var hidePos = {};
        var maxShow = this._oOptions.maxShow;
        var dataLength = this._aDatasource.length;

        if (dataLength > maxShow) {
            if (maxShow == 1) {
                hidePos.start = 0;
                hidePos.end = dataLength - 2;
            }
            else if (maxShow > 1) {
                var per = this._oOptions.hidePosPercent;
                if (per == null || per < 0 || per > 1) {
                    per = 0.5;
                }
                var anchor = Math.floor((maxShow - 1) * per);
                hidePos.start = anchor;
                hidePos.end = dataLength - (maxShow - anchor) - 1;
            }
        }

        return hidePos;
    };

    /**
     * 
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$bindEvent = function() {
        var me = this;
        var aEls = this.getBody().getElementsByTagName('a');
        for (var i = 0, aEl; aEl = aEls[i]; i ++) {
            if (aEl.getAttribute('data-breadcrumb-index') && aEl.href != '#') {
                aEl.onclick = function() {
                    if (!me._bDisabled) {
                        var ii = this.getAttribute('data-breadcrumb-index');
                        triggerEvent(me, 'change', null, [me._aDatasource[ii]]);
                    }
                    return false;
                }
            }
        }
    };

    /**
     * 
     * 
     * @protected
     */
    UI_BREADCRUMB_CLASS.$disposeInner = function() {
        this.getBody().innerHTML = '';
    };

 }) ();
/**
 * @file ecui.ui.TreeView
 * @author hades(denghongqi@baidu.com)
 */
(function() {
    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var util = core.util;

    var WINDOW = window;
    var DOCUMENT = document;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_ITEMS = ui.Items;
    var UI_ITEM = ui.Item;
    var UI_ITEM_CLASS = UI_ITEM.prototype;

    ui.IndTree = core.inherits(
        ui.Control,
        'ui-indtree',
        function(el, options) {
            this._oOptions = options;
        },
        function(el, options) {
            this._bExpandSelected = options.expandSelected !== false;
            if (!dom.first(el)) {
                return el;
            }

            var o = dom.create(
                'ui-indtree-pop', 
                'display: none; position: absolute; z-index: 32767', 
                'div'
            );
            DOCUMENT.body.appendChild(o);
            this._cPop = core.$fastCreate(this.Pop, o, this, {});

            this.root = createNodeCon(dom.first(el), this, true);

            var o = dom.create('ui-indtree-all');
            dom.insertBefore(o, dom.first(el));
            this._cAll = core.$fastCreate(
                this.All, 
                o, 
                this, 
                {
                    level : getMaxLevel(this.root),
                    data : this._oLevalData
                }
            );

            flushNodeState(this.root, this._bExpandSelected);

            var list = this._cAll.getItems();
            var i;
            for (i = 0; i < list.length; i++) {
                if (list[i]._bChecked) {
                    setLevelSelected(this.root, list[i]._nLevel);
                }
            }
        }
    );

    var UI_IND_TREE = ui.IndTree;
    var UI_IND_TREE_CLASS = UI_IND_TREE.prototype;

    //$setSize
    UI_IND_TREE_CLASS.$setSize = util.blank;

    /**
     * 
     * @public
     * @return {Array}
     */
    UI_IND_TREE_CLASS.getSelected = function(opt_control) {
        var control = opt_control || this.root;
        var res = [];
        if (control.isSelect()) {
            res.push(control.getValue());
        }
        if (control._aChildren && control._aChildren.length) {
            var i;
            for (i = 0; i < control._aChildren.length; i++) {
                res = res.concat(this.getSelected(control._aChildren[i]))
            }
        }
        return res;
    };

    /**
     * checkbox
     * @public
     * @return {Array} checkboxvalue
     */
    UI_IND_TREE_CLASS.getLevelSelected = function() {
        var all = this._cAll;
        var list = all.getItems();
        var res = [];
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i].isSelect()) {
                res.push(list[i].getValue());
            }
        }
        return res;
    };

    /**
     * 
     */
    UI_IND_TREE_CLASS.Node = core.inherits(
        ui.Control,
        'ui-indtree-node',
        function(el, options) {
            options.userSelect = false;
            el.style.position = 'relative';
            var o = dom.create('ui-indtree-node-text', '', 'div');
            dom.moveElements(el, o, true);
            el.appendChild(o);

            /*
            if (!options.selectAllBtn) {
                var o = dom.create('ui-indtree-node-btn', '', 'div');
                o.appendChild(dom.create('', '', 'b'));
                el.appendChild(o);
            }
            */
        },
        function(el, options) {
            this._sValue = options.value || '';
            this._bSelected = options.selected || false;
            this._nLevel = options.level;
            options.selectAllBtn && (this._bSelectAllBtn = options.selectAllBtn);
            /*
            if (!this._bSelectAllBtn) {
                this._cPopBtn = core.$fastCreate(
                    this.PopBtn,
                    dom.last(el),
                    this,
                    {}
                );
            }
            */
        }
    );
    var UI_IND_TREE_NODE = UI_IND_TREE_CLASS.Node;
    var UI_IND_TREE_NODE_CLASS = UI_IND_TREE_NODE.prototype;

    /**
     * 
     * @private
     */
    UI_IND_TREE_NODE_CLASS.$collapse = function() {
        setNodeCollapse(this, true);
    }

    /**
     * 
     * @private
     */
    UI_IND_TREE_NODE_CLASS.$expand = function() {
        setNodeCollapse(this, false);
    };

    /**
     * /
     * @override
     */
    UI_IND_TREE_NODE_CLASS.$click = function(event) {
        if (this._bSelected) {
            setNodeSelected(this, false);
            var all = this._cTopPar._cAll;
            var i;
            var list = all.getItems();
            for (i = 0; i < list.length; i++) {
                if (list[i]._nLevel == this._nLevel) {
                    list[i].setChecked(false);
                }
            }
        }
        else {
            setNodeSelected(this, true);
        }

        event.stopPropagation();
    }

    /**
     * mouseover
     * @override
     */
    UI_IND_TREE_NODE_CLASS.$mouseover = function(event) {
        UI_CONTROL_CLASS.$mouseover.call(this);
        event.stopPropagation()
    };

    /**
     * mouseout
     * @override
     */
    UI_IND_TREE_NODE_CLASS.$mouseout = function(event) {
        UI_CONTROL_CLASS.$mouseout.call(this);
        event.stopPropagation();
    };

    /**
     * 
     * @public
     */
    UI_IND_TREE_NODE_CLASS.isSelect = function() {
        return this._bSelected || false;
    };

    /**
     * 
     */
    UI_IND_TREE_NODE_CLASS.getValue = function() {
        return this._sValue;
    }

    /**
     * 
     */
    UI_IND_TREE_NODE_CLASS.Icon = core.inherits(
        ui.Control,
        'ui-indtree-icon',
        function(el, options) {},
        function(el, options) {}
    );
    var UI_IND_TREE_NODE_ICON = UI_IND_TREE_NODE_CLASS.Icon;
    var UI_IND_TREE_NODE_ICON_CLASS = UI_IND_TREE_NODE_ICON.prototype;

    /**
     * /
     * @override
     */
    UI_IND_TREE_NODE_ICON_CLASS.$click = function(event) {
        UI_CONTROL_CLASS.$click.call(this);
        var par = this.getParent();
        if (par._bCollapse) {
            par.$expand();
        }
        else {
            par.$collapse();
        }

        event.stopPropagation();
    };


    /**
     * 
     */
    UI_IND_TREE_NODE_CLASS.PopBtn = core.inherits(
        ui.Control,
        'ui-indtree-btn',
        function(el, options) {},
        function(el, options) {
        }
    );
    var UI_IND_TREE_NODE_POPBTN = UI_IND_TREE_NODE_CLASS.PopBtn;
    var UI_IND_TREE_NODE_POPBTN_CLASS = UI_IND_TREE_NODE_POPBTN.prototype;

    /**
     * PopBtn
     * @override
     */
    UI_IND_TREE_NODE_POPBTN_CLASS.$mouseover = function(event) {
        UI_CONTROL_CLASS.$mouseover.call(this);
        var par = this.getParent();
        par._cPop.setParent(this);
        DOCUMENT.body.appendChild(par._cPop.getOuter());
        par._cPop.$render();
        par._cPop.$show();
    };

    /**
     * PopBtn
     * @override
     */
    UI_IND_TREE_NODE_CLASS.$mouseout = function(event) {
        UI_CONTROL_CLASS.$mouseout.call(this);
        //var par = this.getParent();
        this._cPop.$hide();
    };

    /**
     * 
     */
    UI_IND_TREE_CLASS.Pop = core.inherits(
        ui.Control,
        'ui-indtree-pop',
        function(el, options) {
        },
        function(el, options) {}
    );
    var UI_IND_TREE_POP = UI_IND_TREE_CLASS.Pop;
    var UI_IND_TREE_POP_CLASS = UI_IND_TREE_POP.prototype;

    /**
     * 
     * @private
     */
    UI_IND_TREE_POP_CLASS.$render = function() {
        var btn = this.getParent();
        var node = btn.getParent();
        var el = this.getOuter();
        dom.removeClass(el, 'ui-indtree-pop-selected');
        if (node.isSelect()) {
            dom.addClass(el, 'ui-indtree-pop-selected');
        }
    };

    /**
     * 
     * @override
     */
    UI_IND_TREE_POP_CLASS.$show = function(event) {
        var btn = this.getParent();
        var node = btn.getParent();
        var view = util.getView();
        var pos = dom.getPosition(node.getOuter());
        var width = this.getWidth();
        var height = this.getHeight();
        var nodeWidth = node.getWidth();
        var nodeHeight = node.getHeight();
        var x;
        var y;

        if (pos.left + nodeWidth - width >= view.left) {
            x = pos.left + nodeWidth - width;
        }
        else {
            x = pos.left;
        }

        if (pos.top + nodeHeight + height <= view.bottom) {
            y = pos.top + nodeHeight;
        }
        else {
            y = pos.top - height;
        }

        this.setPosition(x, y);

        UI_CONTROL_CLASS.$show.call(this);
    };

    /**
     * 
     */
    UI_IND_TREE_CLASS.All = core.inherits(
        ui.Control,
        'ui-indtree-all',
        function(el, options) {
            var level = options.level || 0;
            var i;
            for (i = 0; i < level; i++) {
                var o = dom.create();
                var ecuiAttr = 'level:' + (i + 1) + ';';
                ecuiAttr += 'value:' + options.data[i].uniqName + ';';
                if (options.data[i].selected) {
                    ecuiAttr += 'checked:true;';
                }
                o.setAttribute('ecui', ecuiAttr);
                var e = dom.create('', '', 'label');
                e.innerHTML = '<span title="'
                    + options.data[i].caption
                    + '" class="ui-indtree-all-text">'
                    + options.data[i].caption
                    + '</span>';
                o.appendChild(e);
                if (i == 0) {
                    o.style.visibility = 'hidden';
                }
                el.appendChild(o);
            }
        },
        function(el, options) {
            this.$setBody(el);
            this.$initItems();
        }
    );
    var UI_IND_TREE_ALL = UI_IND_TREE_CLASS.All;
    var UI_IND_TREE_ALL_CLASS = UI_IND_TREE_ALL.prototype;

    util.extend(UI_IND_TREE_ALL_CLASS, UI_ITEMS);

    /**
     * item
     */
    UI_IND_TREE_ALL_CLASS.Item = core.inherits(
        ui.Control,
        'ui-indtree-all-item',
        function(el, options) {
            var o = dom.create('', '', 'input');
            o.setAttribute('type', 'checkbox');
            dom.insertBefore(o, dom.first(dom.first(el)));
        },
        function(el, options) {
            this._bChecked = options.checked === true;
            this._eCheckbox = dom.first(dom.first(el));
            this._nLevel = options.level;
            this._sValue = options.value;
            if (options.checked) {
                this._eCheckbox.checked = true;
            }
        }
    );
    var UI_IND_TREE_ALL_ITEM = UI_IND_TREE_ALL_CLASS.Item;
    var UI_IND_TREE_ALL_ITEM_CLASS = UI_IND_TREE_ALL_ITEM.prototype;

    /**
     * itemclick 
     */
    UI_IND_TREE_ALL_ITEM_CLASS.$click = function(event) {
        this._bChecked = !this._bChecked;
        if (this._bChecked) {
            var tree = this.getParent().getParent().root;
            setLevelSelected(tree, this._nLevel);
        }
    };

    UI_IND_TREE_ALL_ITEM_CLASS.setChecked = function(checked) {
        var checked = checked || false;
        this._bChecked = checked;
        if (checked) {
            this._eCheckbox.checked = true;
            var tree = this.getParent().getParent().root;
            setLevelSelected(tree, this._nLevel);
        }
        else {
            this._eCheckbox.checked = false;
        }
    };

    /**
     * checkbox
     * @public
     * @return {boolean}
     */
    UI_IND_TREE_ALL_ITEM_CLASS.isSelect = function() {
        return this._bChecked || false;
    };

    /**
     * itemvalue
     * @public
     * @return {string}
     */
    UI_IND_TREE_ALL_ITEM_CLASS.getValue = function() {
        return this._sValue;
    };

    /**
     * 
     * @param {HTML DOM} el 
     * @param {Object} parent 
     * @param {boolean=} opt_isRoot 
     */
    function createNodeCon(el, parent, opt_isRoot) {
        var nodeEl = dom.first(el);
        dom.addClass(el, 'ui-indtree-wrap');

        var parNode = dom.getParent(el);
        if (parNode && !opt_isRoot) {
            if (dom.first(parNode) == dom.last(parNode)) {
                dom.addClass(el, 'ui-indtree-single');
            }
            else {
                if (dom.first(parNode) == el) {
                    dom.addClass(el, 'ui-indtree-first');
                }
                else if (dom.last(parNode) == el) {
                    dom.addClass(el, 'ui-indtree-last');
                }
                else {
                    dom.addClass(el, 'ui-indtree-middle');
                }
            }
        }

        dom.addClass(nodeEl, 'ui-indtree-node');
        var options = core.getOptions(nodeEl);
        options.level = opt_isRoot ? 1 : parent._nLevel + 1;
        var nodeCon = core.$fastCreate(
            UI_IND_TREE_CLASS.Node,
            nodeEl,
            parent,
            options
        );

        var par = nodeCon.getParent();
        nodeCon._cPop = par._cPop;
        if (opt_isRoot) {
            nodeCon._cTopPar = par;
        }
        else {
            nodeCon._cTopPar = par._cTopPar;
        }

        if (options.selectAllBtn) {
            par._cSelectAllBtn = nodeCon;
        }

        var childrenEl = dom.children(el)[1];
        if (!childrenEl || dom.children(childrenEl).length == 0) {
            return nodeCon;
        }

        var iconEl = dom.create('ui-indtree-icon ui-indtree-icon-collapse', '', 'div');
        dom.insertAfter(iconEl, nodeEl);

        nodeCon._cIcon = core.$fastCreate(
            UI_IND_TREE_NODE_CLASS.Icon,
            iconEl,
            nodeCon,
            {}
        );

        dom.addClass(childrenEl, 'ui-indtree-children');
        childrenEl.style.display = 'none';
        nodeCon._eChildren = childrenEl;
        nodeCon._aChildren = [];

        var o = dom.children(childrenEl);
        for (var i = 0; i < o.length; i++) {
            nodeCon._aChildren.push(createNodeCon(o[i], nodeCon));
        }

        return nodeCon;
    };

    /**
     * 
     * @param {ecui.ui.indTree.prototype.Node} control 
     * @param {boolean} expandSelected 
     */
    function flushNodeState(control) {
        var par = control.getParent();
        control._bExpandSelected = par._bExpandSelected;
        setNodeSelected(control, control._bSelected);
        if (control._aChildren && control._aChildren.length) {
            var i;
            for (i = 0; i < control._aChildren.length; i++) {
                flushNodeState(control._aChildren[i]);
            }
        }
    };

    /**
     * 
     * @param {ecui.ui.indTree.prototype.Node} control 
     * @param {boolean} isCollapse 
     */
    function setNodeCollapse(control, isCollapse) {
        if (!control._eChildren) {
            return ;
        }

        var iconEl = control._cIcon.getOuter();
        dom.removeClass(iconEl, 'ui-indtree-icon-expand');
        dom.removeClass(iconEl, 'ui-indtree-icon-collapse');

        if (isCollapse) {
            control._eChildren.style.display = 'none';
            dom.addClass(iconEl, 'ui-indtree-icon-collapse');
        }
        else {
            control._eChildren.style.display = '';
            dom.addClass(iconEl, 'ui-indtree-icon-expand');
        }
        control._bCollapse = isCollapse;

        var all = control._cTopPar._cAll;
        var maxLevel = getMaxLevel(control._cTopPar, true);
        //
        flushAllState(all, maxLevel);
    };

    /**
     * 
     * @param {ecui.ui.indTree.prototype.Node} control 
     * @param {boolean} selected 
     * @param {boolean=} expandSelected 
     */
    function setNodeSelected(control, selected) {
        var el = control.getOuter();
        if (selected) {
            dom.removeClass(el, 'ui-indtree-node-selected');
            dom.addClass(el, 'ui-indtree-node-selected');
            if (control._bExpandSelected) {
                control.$expand();
            }
            // TODO
            // 
            // 
            // if (control._bSelectAllBtn) {
            //     var par = control.getParent();
            //     var i;
            //     var list = par._aChildren;
            //     for (i = 0; i < list.length; i++) {
            //         if (!list[i]._bSelectAllBtn && !list[i]._bSelected) {
            //             setNodeSelected(list[i], true);
            //         }
            //     }
            // }
        }
        else {
            dom.removeClass(el, 'ui-indtree-node-selected');
            // TODO
            // 
            // 
            // if (!control._bSelectAllBtn) {
            //     var par = control.getParent();
            //     if (par._cSelectAllBtn) {
            //         setNodeSelected(par._cSelectAllBtn, false);
            //     }
            // }
        }

        control._bSelected = selected;
    };

    /**
     * tree
     * @param {ecui.ui.IndTree} control
     * @param {number=} opt_isOnlyShow 
     * @return {number} tree
     */
    function getMaxLevel(control, opt_isOnlyShow) {
        if (!control._nLevel) {
            control = control.root;
        }
        var level = control._nLevel;

        if (
            control._aChildren 
            && control._aChildren.length 
            && (!opt_isOnlyShow || !control._bCollapse)
        ) {
            var i;
            for (i = 0; i < control._aChildren.length; i++) {
                var n = getMaxLevel(control._aChildren[i], opt_isOnlyShow);
                if (n > level) {
                    level = n;
                }
            }
        }

        return level;
    };

    /**
     * 
     * @param {ecui.ui.IndTree.prototype.All} control 
     * @param {number} maxLevel 
     */
    function flushAllState(control, maxLevel) {
        var list = control.getItems();
        var i;
        for (i = 0; i < maxLevel; i++) {
            list[i].show();
        }
        for (i = maxLevel; i < list.length; i++) {
            list[i].hide();
        }
    };

    /**
     * 
     */
    function setLevelSelected(control, level) {
        if (control._nLevel == level) {
            setNodeSelected(control, true);
        }
        if (control._aChildren && control._aChildren.length) {
            var i;
            for (i = 0; i < control._aChildren.length; i++) {
                setLevelSelected(control._aChildren[i], level);
            }
        }
    };

    /**
     * 
     * @param {Object} datasource 
     */
    UI_IND_TREE_CLASS.render = function(datasource) {
        var root = datasource.tree;
        this._oLevalData = datasource.level;
        this._oLevalData.unshift({});
        var el = this.getOuter();

        util.detachEvent(WINDOW, 'resize', core.repaint);
        this.root && this.root.dispose();
        this._cAll && this._cAll.dispose();
        this._cPop && this._cPop.dispose();

        el.innerHTML = '';
        el.appendChild(createTreeView(root));

        this.$setBody(el);
        this.$resize();
        UI_IND_TREE.client.call(this, el, this._oOptions);
        this._bCreated = false;
        this.cache(true, true);
        //UI_CONTROL_CLASS.init.call(this);

        util.attachEvent(WINDOW, 'resize', util.repaint);
        this.resize();
    };

    /**
     * DOM
     * @param {Object} obj
     * @param {HTML DOM=} opt_parent 
     */
    function createTreeView(obj, opt_parent) {
        var wraper = dom.create();
        var node = dom.create();
        wraper.appendChild(node);

        var ecuiAttr = 'value:' + (obj.uniqName || obj.caption) + ';';
        if (obj.selected) {
            ecuiAttr += 'selected:true;';
        }
        if (/^all\$/.test(obj.uniqName)) {
            ecuiAttr += 'selectAllBtn:true;';
        }
        node.setAttribute('ecui', ecuiAttr);
        node.innerHTML = obj.caption;

        if (opt_parent) {
            opt_parent.appendChild(wraper)
        }

        if (!obj.children) {
            return wraper;
        }

        var children = dom.create();
        wraper.appendChild(children);
        var i = 0;
        for (i = 0; i < obj.children.length; i++) {
            createTreeView(obj.children[i], children);
        }

        return wraper;
    };
}) ();
/**
 * input
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    count-input.js
 * desc:    (inputtextarea)
 * author:  cxl(chenxinle@baidu.com)
 *          modified by sushuang(sushuang@baidu.com) 
 * date:    2012/03/12
 */
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        attachEvent = util.attachEvent,
        createDom = dom.create,
        addClass = dom.addClass,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        insertAfter = dom.insertAfter,
        trim = string.trim,
        setFocused = core.setFocused,
        blank = util.blank,
        triggerEvent = core.triggerEvent,
        inheritsControl = core.inherits,
        getByteLength = string.getByteLength,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,


        UI_INPUT = ui.Input = inheritsControl(
            UI_INPUT_CONTROL,
            'ui-input',
            function (el, options) {
                options.resizable = false;
                this._bPromptDisabled = options.promptDisabled == null 
                    ? true : options.promptDisabled;
            },
            function (el, options) {
                var o, type = this.getType();
                
                this.getInput().style.border = '';

                if(options.maxLength){
                    this._sMaxLength = options.maxLength;
                }

                if (options.tip) {
                    o = createDom(type + '-tip', 'display:none');
                    o.innerHTML = options.tip;
                    this.getBody().appendChild(o);
                    this._eTip = o;
                    attachEvent(this._eTip, 'keypressdown', UI_INPUT_TIP_HANDLER);
                }
            }
        ),
        UI_INPUT_CLASS = UI_INPUT.prototype,

        UI_TEXTAREA = ui.Textarea = inheritsControl(
            UI_INPUT,
            'ui-textarea',
            function (el, options) {
                options.inputType = 'textarea';
                this._bCountDisabled = options.countDisabled;
            }
        ),
        UI_TEXTAREA_CLASS = UI_TEXTAREA.prototype;

    var COUNT_NORMAL_TPL = '$',
        COUNT_OVERFLOW_TPL = '$',
        CHAR_SET = 'gbk';

    function UI_INPUT_TIP_HANDLER(event) {
        var e = event || window.event,
            con;
        e = e.target || e.srcElement;
        con = e.parentNode.getControl();
        con.getInput().focus();
    }

    function UI_INPUT_TIP_DISPLAY(con, show) {
        if (con._eTip) {
            con._eTip.style.display = show ? '' : 'none';
        }
    }

    UI_INPUT_CLASS.$keydown = function () {
        UI_INPUT_TIP_DISPLAY(this, false);
    };

    UI_INPUT_CLASS.$keyup = function () {
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }        
    };

    UI_INPUT_CLASS.$change = function () {
        this.$updateCount();
    };

    UI_INPUT_CLASS.$updateCount = function () {
        var value = this.getValue(),
            type = this.getType(),
            byteLength,
            remain;
        
        if (this._sMaxLength && this._eCount){
            byteLength = getByteLength(value, CHAR_SET);

            if (byteLength > this._sMaxLength){
                remain = [
                    '<span class="', type, '-count-overflow">',
                        Math.ceil((byteLength - this._sMaxLength) / 2),
                    '</span>'
                ].join('');
                this._eCount.innerHTML = COUNT_OVERFLOW_TPL.replace('$', remain);
            }
            else {
                remain = [
                    '<span class="', type, '-count-normal">',
                        Math.floor((this._sMaxLength - byteLength) / 2),
                    '</span>'
                ].join('');
                this._eCount.innerHTML = COUNT_NORMAL_TPL.replace('$', remain);
            }
        }
    };

    UI_INPUT_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }
    };

    UI_INPUT_CLASS.$focus = function () {
        UI_CONTROL_CLASS.$focus.call(this);
        UI_INPUT_TIP_DISPLAY(this, false);
    };

    UI_INPUT_CLASS.$setSize = blank;

    UI_INPUT_CLASS.setValue = function (value) {
        UI_INPUT_CONTROL_CLASS.setValue.call(this, value);
        UI_INPUT_TIP_DISPLAY(this, value ? false : true);
        this.$updateCount();
    };

    UI_INPUT_CLASS.init = function () {
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }
        var type = this.getType();
        if (!this._bPromptDisabled) {
            if (!this._eBar) {
                this._eBar = createDom(type + '-bar');
                insertAfter(this._eBar, this.getOuter());
            }
            this._eBar.appendChild(
                this._ePrompt = createDom(type + '-prompt')
            );
        }
        UI_INPUT_CONTROL_CLASS.init.call(this);
    };

    /**
     * 
     *
     * @public
     * @param {boolean} error truefalse
     * @prompt {string} 
     */
    UI_INPUT_CLASS.setErrorView = function (error, prompt) {
        if (error) {
            addClass(this.getOuter(), this.getType() + '-error');
        } 
        else {
            removeClass(this.getOuter(), this.getType() + '-error');
        }
        if (this._ePrompt) {
            this._ePrompt.innerHTML = prompt == null ? '' : prompt
        }
    };

    UI_TEXTAREA_CLASS.init = function () {
        var type = this.getType();
        if (this._sMaxLength && !this._bCountDisabled) {
            if (!this._eBar) {
                this._eBar = createDom(type + '-bar');
                insertAfter(this._eBar, this.getOuter());
            }            
            this._eBar.appendChild(
                this._eCount = createDom(type + '-count')
            );
            this.$updateCount();
        }
        UI_TEXTAREA.superClass.init.call(this);
    };

    UI_TEXTAREA_CLASS.$dispose = function () {
        this._eBar && removeDom(this._eBar);
        this._eBar = null;
        this._eCount = null;
        this._ePrompt = null;

        UI_TEXTAREA.superClass.$dispose.call(this);
    }

})();

/**
 * input tree
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    input-tree.js
 * desc:    
 * author:  cxl(chenxinle@baidu.com)
 * date:    2012/03/12
 */
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        setFocused = core.setFocused,
        disposeControl = core.dispose,
        createDom = dom.create,
        addClass = dom.addClass,
        children = dom.children,
        encodeHTML = string.encodeHTML,
        moveElements = dom.moveElements,
        getPosition  = dom.getPosition,
        inheritsControl = core.inherits,
        getView = util.getView,
        extend = util.extend,
        blank = util.blank,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;

        var UI_INPUT_TREE = ui.InputTree = 
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-input-tree',
            function (el, options) {
                var type = this.getTypes()[0],
                    o = createDom();
                
                o.innerHTML = '<div class="'+ type +'-layer" ' 
                    + ' style="position:absolute;display:none; z-index:65535; height:230px; width:250px">'
                    + '<div class="'
                    + UI_DATA_TREE.types[0] +'"></div></div>';

                o = o.firstChild;

                moveElements(el, o.lastChild, true);
                options._eLayer = document.body.appendChild(o);
                
                el.innerHTML = ''
                    + '<span class="'+ type +'-text"></span>'
                    + '<span class="'+ type +'-cancel"></span>' 
                    + '<span class="'+ type +'-button"></span>'
                    + '<input type="hidden name="'+ (options.name || '') +'" />';

                options.hidden = true;
                if (options.value) {
                    options.value += '';
                }
            },
            function (el, options) {
                var childs;
                
                if (options.value) {
                    UI_INPUT_CONTROL_CLASS.setValue.call(this, options.value);
                }

                childs = children(el);

                this._eText = childs[0];
                this._uCancel = $fastCreate(this.Cancel, childs[1], this);
                this._uLayer = $fastCreate(this.Layer, options._eLayer, this, {asyn : options.asyn});
                options._eLayer = null;
                delete options._eLayer;

                if (options.hideCancel === true) {
                    this._bHideCancel = true;
                    this._uCancel.$hide();
                }
            }
        ),

        UI_INPUT_TREE_CLASS = UI_INPUT_TREE.prototype,

        UI_INPUT_TREE_LAYER = UI_INPUT_TREE_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-input-tree-layer',
            null,
            function (el, options) {
                el.style.position = 'absolute';
                // setData
                // this._uTree = $fastCreate(this.Tree, el.firstChild, this, {collapsed:true, asyn: options.asyn});
            }
        ),
        UI_INPUT_TREE_LAYER_CLASS = UI_INPUT_TREE_LAYER.prototype,
        
        UI_DATA_TREE = ui.DataTree,
        
        UI_INPUT_TREE_CANCEL_CLASS = (UI_INPUT_TREE_CLASS.Cancel = inheritsControl(UI_CONTROL)).prototype,
        UI_INPUT_TREE_LAYER_TREE_CLASS = (UI_INPUT_TREE_LAYER_CLASS.Tree = inheritsControl(UI_DATA_TREE)).prototype;

    function UI_INPUT_TREE_FLUSH(con) {
        if (con.getValue() == '') {
            con._uCancel.hide();
        }
        else if (!con._bHideCancel) {
            con._uCancel.show();
        }
    }

    //////////////////////////
    /**
     * 
     *
     * @public
     * @param {Object} data 
     * @param {Object} data.root 
     *      
     *          {string} text
     *          {string} value
     *          {boolean} isLeaf
     * @param {string} data.selected 
     */
    UI_INPUT_TREE_CLASS.setData = function (data, options) {
        options = options || {};

        if (!data || !data.root) {
            return;
        }

        var html = [];

        function travelTree(node, isRoot) {
            var children = node.children || [];

            if (children.length == 0) {
                html.push(
                    '<div ecui="value:', encodeHTML(String(node.value)), ';isLeaf:', !!node.isLeaf, '">',
                         encodeHTML(node.text),
                    '</div>'
                );
            }
            else {
                html.push(
                    '<div>',
                        '<label ecui="value:', encodeHTML(String(node.value)), ';isLeaf:', !!node.isLeaf, '">',
                             encodeHTML(node.text),
                        '</label>'
                );
                for (var i = 0, child; child = children[i]; i ++) {
                    travelTree(child);
                }
                html.push('</div>');
            }
        }

        travelTree(data.root);

        var layer = this._uLayer;
        var o = layer.getBody();
        o.innerHTML = html.join('');
        addClass(o.firstChild, UI_DATA_TREE.types[0]);
        
        layer._uTree = $fastCreate(
            layer.Tree, 
            o.firstChild,
            layer, 
            extend(
                { 
                    collapsed: true, 
                    value: String(data.root.value),
                    isLeaf: data.root.isLeaf
                }, 
                options
            )
        );

        layer._uTree.init();
        
        if (data.selected != null ) {
            this.setValue(String(data.selected));
        }
    }

    UI_INPUT_TREE_CLASS.$activate = function () {
        this._uLayer.show();
    }
    UI_INPUT_TREE_CLASS.getValue = function () {
    
        var text = this._eText.innerHTML;
        var value = this._eInput.value;
        return {
            text: text,
            value: value
        }
    }

    UI_INPUT_TREE_CLASS.init = function () {
        var value = this.getValue();

        this.setValue(value);
        this._uLayer.init();
        UI_INPUT_CONTROL_CLASS.init.call(this);
    }

    UI_INPUT_TREE_CLASS.$setText = function (value) {
        if (value && value.length > 15) {
            value = value.substring(0, 15) + '...';
        }
        this._eText.innerHTML = value;
    }

    UI_INPUT_TREE_CLASS.setValue = function (value) {
        var tree = this._uLayer._uTree;
        if (!tree) { return; }

        if ('[object Object]' == Object.prototype.toString.call(value)) {
            UI_INPUT_CONTROL_CLASS.setValue.call(this, value.value);
            tree.clearSelected();
            tree.setValues([value.value]);
            this.$setText(tree.getSelectedText());
            UI_INPUT_TREE_FLUSH(this);
        }
        else {
            //
            value = value + '';
            UI_INPUT_CONTROL_CLASS.setValue.call(this, value);
            tree.clearSelected();
            tree.setValues([value]);
            this.$setText(tree.getSelectedText());
            UI_INPUT_TREE_FLUSH(this);
        }
    }

    UI_INPUT_TREE_CLASS.clear = function () {
        var tree = this._uLayer._uTree;

        tree.clearSelected();
        UI_INPUT_CONTROL_CLASS.setValue.call(this, '');
        this.$setText('');
        UI_INPUT_TREE_FLUSH(this);
    }

    /**
     * input-tree,
     * @public
     */
    UI_INPUT_TREE_CLASS.clearState = function() {
        var tree = this._uLayer._uTree;
        collapseTree(tree);

        function collapseTree(tree) {
            tree.collapse();
            var children = tree.getChildren();
            if (children && children.length) {
                for (var i = 0; i < children.length; i++) {
                    collapseTree(children[i]);
                }
            }
        };
    };

    /**
     * value
     * @public
     * @param {string} value 
     */
    UI_INPUT_TREE_CLASS.getTreeNodeByValue = function(value) {
        return this._uLayer.getTreeNodeByValue(value);
    };

    /**
     * 
     * @public
     * @param {string} text
     */
    UI_INPUT_TREE_CLASS.setText = function(text) {
        this.$setText(text);
    };

    UI_INPUT_TREE_CLASS.expand = function (value, callback) {
        var me = this;

        this._uLayer.expand(value, function () {
            callback.call(me);
        });
    }

    UI_INPUT_TREE_CLASS.selectParent = function (value) {
        var node = this._uLayer.getTreeNodeByValue(value);

        if (node != node.getRoot()) {
            node = node.getParent();
        }
        
        this.setValue(node.getValue());
    }

    UI_INPUT_TREE_LAYER_CLASS.init = function () {
        this._uTree && this._uTree.init();
        UI_CONTROL_CLASS.init.call(this);
    }

    UI_INPUT_TREE_LAYER_CLASS.$blur = function () {
        this.hide();
    }

    UI_INPUT_TREE_LAYER_CLASS.expand = function (value, callback) {
        var tree = this._uTree,
            node = tree.getItemByValue(value);
        if (node) {
            node.expand();
            tree.onexpand(node, callback);
        }
    }

    UI_INPUT_TREE_LAYER_CLASS.getTreeNodeByValue = function (value) {
        return this._uTree.getItemByValue(value);
    }

    UI_INPUT_TREE_LAYER_CLASS.show = function () {
        var par = this.getParent(), pos, o, view;

        UI_CONTROL_CLASS.show.call(this);

        if (par) {
            pos = getPosition(par.getOuter());
            view = getView();
            o = pos.top;
            /*
            if (o + par.getHeight() + this.getHeight() > view.bottom) {
                if (o - view.top > this.getHeight()) {
                    pos.top = o - this.getHeight();
                }
            }
            else {
                pos.top = o + par.getHeight();
            }
            */

            pos.top = o + par.getHeight();

            o = pos.left;
            if (o + this.getWidth() > view.right) {
                pos.left = o + par.getWidth() - this.getWidth();
            }
            else {
                pos.left = o;
            }
            this.setPosition(pos.left, pos.top);
            setFocused(this);
        }
    }

    UI_INPUT_TREE_CANCEL_CLASS.$click = function () {
        var par = this.getParent();
        UI_CONTROL_CLASS.$click.call(this);

        par.$setText('');
        UI_INPUT_CONTROL_CLASS.setValue.call(par, '');
        par._uLayer._uTree.clearSelected();
        UI_INPUT_TREE_FLUSH(par);
    }

    UI_INPUT_TREE_CANCEL_CLASS.$activate = UI_BUTTON_CLASS.$activate;

    UI_INPUT_TREE_LAYER_TREE_CLASS.onselect = function (con, added) {
        var superObj = this.getParent().getParent();
        UI_INPUT_CONTROL_CLASS.setValue.call(superObj, con.getValue());
        superObj.$setText(con.getText());
        UI_INPUT_TREE_FLUSH(superObj);
        this.getParent().hide();
    }

    UI_INPUT_TREE_LAYER_TREE_CLASS.onexpand = function (item, callback) {
        var superObj = this.getParent().getParent(),
            callback = callback || blank;
        
        var layer =  superObj._uLayer.getOuter(),
            scrollHeight = layer.scrollTop;
        var setScroll = function() {
           layer.scrollTop = scrollHeight ;
           layer = null;
        }
        if (item._bNeedAsyn) {
            triggerEvent(superObj, 'loadtree', null, [item.getValue(), function (data) {
                item.load(data); 
                callback.call(null);
                setScroll();
            }]);
            item._bNeedAsyn = false;
        }
        else {
            callback.call(null);
            setScroll();
        }
    }

    UI_INPUT_TREE_LAYER_TREE_CLASS.load = function (datasource) {
        var i, item, text;

        for (i = 0; item = this._aChildren[i]; i++) {
            disposeControl(item);
        }
        this._aChildren = [];
        this._eChildren.innerHTML = '';

        if (!datasource || datasource.length <= 0) {
            this.setClass(this.getPrimary());
            return;
        }

        for (i = 0; item = datasource[i]; i++) {
            text = item.text;
            item = extend({asyn: this._bAsyn}, item);
            delete item.text;
            this.add(text, null, item).init();
        }
        
    }
})();

/*
Suggest - 
 SelectElement 

HTML:

<div ecui="type:suggest;">

</div>


_nOptionSize  - 
_cSelected    - 
_uText        - suggest
_uOptions     - 
*/
//{if 0}//
;
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,
        trim = string.trim,
        undefined,
        DOCUMENT = document,
        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getText = dom.getText,
        insertAfter = dom.insertAfter,
        insertBefore = dom.insertBefore,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        encodeHTML = string.encodeHTML,
        extend = util.extend,
        getView = util.getView,
        setDefault = util.setDefault,

        $fastCreate = core.$fastCreate,
        getAttributeName = core.getAttributeName,
        getFocused = core.getFocused,
        inheritsControl = core.inherits,
        intercept = core.intercept,
        mask = core.mask,
        restore = core.restore,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_SCROLLBAR = ui.Scrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SELECT
    ///__gzip_original__UI_SUGGEST_CLASS
    /**
     * 
     * options 
     * browser        
     * optionSize     10
     * optionsElement 
     * @public
     *
     * @param {Object} options 
     */
    var UI_SUGGEST = ui.Suggest =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-suggest',
            function (el, options) {
                var me = this;
                var name = el.name || options.name || '',
                    type = this.getType(),

                    id = options.id || 'id_notset',
                    optionsEl = createDom(
                        type + '-options' + this.Options.TYPES,
                        'position:absolute;z-index:65535;display:none'
                    );

                optionsEl.setAttribute('ecui_id', id);
                   
                setDefault(options, 'hidden', true);

                
                moveElements(el, optionsEl);

                el.innerHTML =
                '<span class="ui-input"></span><input name="' + name + '" value="' +
                        encodeHTML(options.value || '') + '">';

                el.appendChild(optionsEl);
                //400msquery
                this._nTimeout = 400;
                //
                this._nTimeoutHandler = null;
                return el;
            },
            function (el, options) {
                if (options.timeout) {
                    this._nTimeout =  options.timeout;
                }
                if (options.hide) {
                    this.getOuter().style.display = 'none'; 
                }
                el = children(el);
                var me = this;
                //
                this._nLastText = '';
                this._uText = $fastCreate(UI_INPUT_CONTROL, el[0], this, {capturable: false});


                this._uOptions = $fastCreate(
                    this.Options,
                    removeDom(el[2]),
                    this,
                    {hScroll: false, browser: options.browser}
                );

                this.$setBody(this._uOptions.getBody());
                // 
                this._nOptionSize = options.optionSize || 10;

                this.$initItems();

                //change
                this._uText.$change = EVENT_TEXT_CHANGE;
                //
                //this._uText.$mousewheel = function() {};
                
            }
        ),
        UI_SUGGEST_CLASS = UI_SUGGEST.prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_SUGGEST_OPTIONS_CLASS = (UI_SUGGEST_CLASS.Options = inheritsControl(UI_PANEL)).prototype,

        /**
         * 
         * @public
         *
         * @param {Object} options 
         */
        UI_SUGGEST_ITEM_CLASS =
            (UI_SUGGEST_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    this._sValue = options.value === undefined ? getText(el) : '' + options.value;
                }
            )).prototype;

    /**
    * 
    * @event inputonchange
    */
    function EVENT_TEXT_CHANGE() {
        var par = this.getParent(); 
        var value = par.getValue(); 
        
        //onchange
        triggerEvent(par, 'change', value); 
        var txt= par.getText();
        var lastTxt = par._nLastText;
        //trim 
        if (trim(txt) == '') {
            return; 
        }
        // value
        if (trim(txt) != trim(lastTxt)) {

            par._eInput.value = '';
        } 
        //
        //onquery
        if (par._nTimeoutHandler) {
            //
            clearTimeout(par._nTimeoutHandler); 
        }
        //onquery
        par._nTimeoutHandler = setTimeout(function() {
            //
            par._nTimeoutHandler = null;      
            triggerEvent(par, 'query', value);
            
        }, par._nTimeout);
            
    }
    /**
    * value
    *  id,sugguest 
    * @param {ecui{Object}} suggest
    * @param {array[Object]} suggest
    * @param {string} suggesttext
    */
    function  AUTO_FILL_VALUE(ele, list, text) {
        list = list || [];
        var value = null;
        for (var i = 0, item; item = list[i++];) {
            if (item.text == text) {
                value = item.value; 
                break;
            }
        
        }
        //
        if (value != null) {
            ele._eInput.value = value;
            //onslect
            triggerEvent(ele, 'select', {value: value, text:text}); 
        }
     
    }
//{else}//
    /**
     * 
     * @private
     *
     * @param {ecui.ui.Select} control 
     */
    function UI_SUGGEST_FLUSH(control) {
        var options = control._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            el = options.getOuter(),
            pos = getPosition(control.getOuter()),
            selected = control._cSelected,
            optionTop = pos.top + control.getHeight();

        if (!getParent(el)) {
            //  DOM 
            DOCUMENT.body.appendChild(el);
            control.cache(false, true);
            control.$alterItems();
        }
        else {

            control.cache(false, true);
            control.$alterItems();
        }

        if (options.isShow()) {
            if (selected) {
                //setFocused(selected);
            }
            scrollbar.setValue(scrollbar.getStep() * indexOf(control.getItems(), selected));

            // controloptionHeight
            control = options.getHeight();

            // 
            options.setPosition(
                pos.left,
                optionTop + control <= getView().bottom ? optionTop : pos.top - control
            );
        }
    }

    /**
     * 
     * @private
     * @param {ecui.ui.Select} control 
     * @param {ecui.ui.Select.Item} item 
     */
    function UI_SUGGEST_CHANGE_SELECTED(control, item) {
        if (item !== control._cSelected) {

            UI_INPUT_CONTROL_CLASS.setValue.call(control, item ? item._sValue : '');
            var text = item ? item.getBody().innerHTML : '';
            control._uText.setValue(text);
            //FIX: setValue
            control._cSelected = item;
            if (control._uOptions.isShow()) {
                setFocused(item);
            }
            //
            if (item && item._sValue) {


                //suggest
                //
                //
                triggerEvent(control, 'select', {value: item._sValue, text:text}); 
                triggerEvent(control, item._sValue);
                //
                //bugfix ie
                setFocused(control);
                control.setFocusToEnd();
            }
        }
    }

    extend(UI_SUGGEST_CLASS, UI_ITEMS);

    /**
     * 
     * @override
     */
    UI_SUGGEST_OPTIONS_CLASS.$dispose = function () {
        this.hide();
        UI_PANEL_CLASS.$dispose.call(this);
    };

    /**
     * 
     * @override
     */
    UI_SUGGEST_OPTIONS_CLASS.$hide = function () {
        UI_PANEL_CLASS.$hide.call(this);
        mask();
        restore();
    };

    /**
     * 
     * @override
     */
    UI_SUGGEST_ITEM_CLASS.$mouseover = function (event) {
        UI_ITEM_CLASS.$mouseover.call(this, event);
        setFocused(this);
    };

  
    /**
     * 
     * getValue 
     * @public
     *
     * @return {string} 
     */
    UI_SUGGEST_ITEM_CLASS.getValue = function () {
       
        return this._sValue;
    };
    /**
     * 
     * getText 
     * @public
     *
     * @return {string} 
     */
    UI_SUGGEST_ITEM_CLASS.getText = function () {
       
        return this._eBody.innerHTML;
    };
    /**
     * 
     * setValue 
     * @public
     *
     * @param {string} value 
     */
    UI_SUGGEST_ITEM_CLASS.setValue = function (value) {
        var parent = this.getParent();
        this._sValue = value;
        if (parent && this == parent._cSelected) {
            // 
            UI_INPUT_CONTROL_CLASS.setValue.call(parent, value);
        }
    };

    /**
     *  DOM 
     * @override
     */
    UI_SUGGEST_CLASS.$activate = function (event) {
        if (!(event.getControl() instanceof UI_SCROLLBAR)) {
            UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
            // 
            return;
            this._uOptions.show();
            // 
            intercept(this);
            mask(0, 65534);
            UI_SUGGEST_FLUSH(this);
            event.stopPropagation();
        }
    };

    /**
     * 
     *   /
     * @protected
     */
    UI_SUGGEST_CLASS.$alterItems = function () {
        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            step = this.getBodyHeight(),
            width = this.getWidth(),
            itemLength = this.getItems().length;

        if (getParent(options.getOuter())) {
            // 
            scrollbar.setStep(step);

            // , 
            this.setItemSize(
                width - options.getMinimumWidth() - (itemLength > optionSize ? scrollbar.getWidth() : 0),
                step
            );

            // options
            options.$$mainHeight = itemLength * step + options.$$bodyHeightRevise;
            options.$setSize(width, (MIN(itemLength, optionSize) || 1) * step + options.getMinimumHeight());
        }
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$cache = function (style, cacheSize) {
        (getParent(this._uOptions.getOuter()) ? UI_ITEMS : UI_INPUT_CONTROL_CLASS)
            .$cache.call(this, style, cacheSize);
        this._uText.cache(false, true);
        this._uOptions.cache(false, true);
    };
    /**
     * 
     * @override
     */
    UI_SUGGEST_CLASS.$intercept = function (event) {
        //__transform__control_o
        this._uOptions.hide();
        for (var control = event.getControl(); control; control = control.getParent()) {
            if (control instanceof this.Item) {
                if (control != this._cSelected) {
                    // 
                    UI_SUGGEST_CHANGE_SELECTED(this, control);
                    //onchange 
                    var obj = {
                        text: control.getText(),
                        value: control._sValue
                    };
                    triggerEvent(this, 'change', obj);
                    //
                    //bugfix ie
                    // 
                    //setFocused(this);
                    //this.setFocusToEnd();
                }
                break;
            }
        }
        event.exit();
    };

    /**
     * /ESC
     * @override
     */
    UI_SUGGEST_CLASS.$keydown = UI_SUGGEST_CLASS.$keypress = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type](event);

        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            which = event.which,
            list = this.getItems(),
            length = list.length,
            focus = getFocused();

        if (this.isFocused()) {

            // 
            if (which == 40 || which == 38) {
                //bugfix
                //shift + 40   shift + 38  &
                if (event && event._oNative.shiftKey) {
                    return true; 
                }
                if (length) {

                    if (options.isShow()) {
                        var uFocus = list[which = MIN(MAX(0, indexOf(list, focus) + which - 39), length - 1)];
                        setFocused(uFocus);
                        which -= scrollbar.getValue() / scrollbar.getStep();
                        scrollbar.skip(which < 0 ? which : which >= optionSize ? which - optionSize + 1 : 0);
                        event.cancelBubble = true;
                    }
                    else {
                        //item
                        return false;
                        
                        //this.setSelectedIndex(MIN(MAX(0, indexOf(list, this._cSelected) + which - 39), length - 1));
                    }

                }
                return false;
            }
            else if (which == 27 || which == 13 && options.isShow()) {
                // ESC
                options.hide();
                if (which == 13) {
                    if (focus instanceof this.Item) {
                        UI_SUGGEST_CHANGE_SELECTED(this, focus);
                        //onchange 
                        var obj = {
                            text: focus.getText(),
                            value: focus._sValue
                        };
                        //change
                        triggerEvent(this, 'change', obj);
                    }
                }
                return false;
            }
            else {
                //
                //bugfix: bugkeypresskeydownwhich0 firefox item
                if (which != 0) {
                        
                    setFocused(this._uText); 
                }

            }

        }
        
    };

    /**
     * 
     * @override
     */
    UI_SUGGEST_CLASS.$mousewheel = function (event) {
        if (this.isFocused()) {
            var options = this._uOptions,
                list = this.getItems(),
                length = list.length;

            if (options.isShow()) {
                options.$mousewheel(event);
            }
            else {
                //optionsindex
                options = indexOf(list, this._cSelected) + (event.detail > 0 ? 1 : -1);
                this.setSelectedIndex(
                    length ?
                        MIN(MAX(0, options), length - 1) : null
                );
                if (options >= 0 && options < length) {
                    //change
                    //triggerEvent(this, 'change');
                }
            }

            event.exit();
        }
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$ready = function () {
        this.setValue(this.getValue());
    };

    /**
     * 
     * @override
     */
    UI_SUGGEST_CLASS.remove = function (item) {
        if ('number' == typeof item) {
            item = this.getItems()[item];
        }
        if (item == this._cSelected) {
            //UI_SUGGEST_CHANGE_SELECTED(this);
        }
        return UI_ITEMS.remove.call(this, item);
    };

    /**
     * cache
     * @override
     */
    UI_SUGGEST_CLASS.add = function (item, index, options) {
        item = UI_ITEMS.add.call(this, item, index, options);
        if (getParent(this._uOptions.getOuter())) {
            item.cache(true, true);
        }
        return item;
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$setSize = function (width, height) {
        UI_INPUT_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
        height = this.getBodyHeight();

        //   height
        // bugfix:  select 
        this._uText.$setSize(width = this.getBodyWidth(), height);
        //this._uText.$setSize(width = this.getBodyWidth() - height, height);

        
    };

    /**
     * 
     * @public
     *
     * @return {ecui.ui.Item} 
     */
    UI_SUGGEST_CLASS.getSelected = function () {
        return this._cSelected || null;
    };
    /**
    * 
    * @return {string} 
    */
    UI_SUGGEST_CLASS.getText = function () {
        var txt = this._uText.getValue(); 
        return txt;
    };

    /**
    * 
    * @param {string} 
    * @return {string} 
    */
    UI_SUGGEST_CLASS.setText = function (txt) {
        this._uText.setValue(txt); 
    };
    /**
    * suggest
    */
    UI_SUGGEST_CLASS.getValue = function () {
        var value = this._eInput.value;
        var text = this.getText();
        var obj = {
            value: value,
            text: text
        };
        return obj; 
    };
    /**
     * 
     * 
     * @public
     *
     * @param {number} value  1
     */
    UI_SUGGEST_CLASS.setOptionSize = function (value) {
        this._nOptionSize = value;
        this.$alterItems();
        UI_SUGGEST_FLUSH(this);
    };

    /**
     * 
     * @public
     *
     * @param {number} index 
     */
    UI_SUGGEST_CLASS.setSelectedIndex = function (index) {
        UI_SUGGEST_CHANGE_SELECTED(this, this.getItems()[index]);
    };

    /**
     * 
     * setValue  getValue 
     * @public
     *
     * @param {string} value 
     */
    UI_SUGGEST_CLASS.setValue = function (oValue) {

        //{text:XX,value:XX}
        var value = oValue;
        if ('[object Object]' == Object.prototype.toString.call(oValue)) {
            value = oValue.value; 
        }
        
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            if (o._sValue == value) {
                UI_SUGGEST_CHANGE_SELECTED(this, o);
                //text
                this._nLastText = Ovalue.text || o.getBody().innerHTML;
                return;
            }
        }

        // 
        UI_SUGGEST_CHANGE_SELECTED(this);
    };
    /**
    * suggest
    */
    UI_SUGGEST_CLASS.clear = function () {
        var items = this.getItems() || [],
            len = items.length;
        while ( len-- > 0 ) {
            this.remove(0);
        }

        this._uOptions.reset();
    };
     /**
    * suggest
    * @param {Array[Object]} 
    */
    UI_SUGGEST_CLASS.update = function (list) {
        //    
        this.clear();
        var item = null;
        var el = null;
        var control = this;
        for (var i = 0, o; o = list[i++];) {
          
            item = this.add(o.text, null, {value: o.value});  
            //title
            if (true) {
                item.getOuter().title = o.text;
            }
        }
        if (!this._uOptions.isShow()) {
            this._uOptions.show();
            // 
            intercept(this);
            mask(0, 65534);
            UI_SUGGEST_FLUSH(this);
        }
        else {
            
            control.$alterItems();
        }
        //id
        var txt = this.getText(txt);
        AUTO_FILL_VALUE(this, list, txt); 
        //updaefocus
        setFocused(control._uText);
        //event.stopPropagation();
    };
    //
    UI_SUGGEST_CLASS.setFocusToEnd = function() {
        var input = this._uText;  
        core.setFocused(input);
        input = input._eInput;
        var len = input.value.length;
        if (document.selection) {
            var sel = input.createTextRange();
            sel.moveStart('character', len);
            sel.collapse();
            sel.select();
        } 
        else if (typeof input.selectionStart == 'number'
                && typeof input.selectionEnd == 'number') {
            input.selectionStart = input.selectionEnd = len;
        }
        
        
    };
    UI_SUGGEST_CLASS.$mousewheel = function() {};
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * @file items
 * @author hades(denghongqi@gmail.com)
 */

(function() {
    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var util = core.util;

    var WINDOW = window;
    var DOCUMENT = document;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_ITEMS = ui.Items;
    var UI_ITEM = ui.Item;
    var UI_ITEM_CLASS = UI_ITEM.prototype;

    ui.DraggableList = core.inherits(
        ui.Control,
        'ui-draggable-list',
        function(el, options) {
        },
        function(el, options) {
            this._bDisableSelected = options.disableSelected === true;
            options.targets = options.targets || '';
            this._aTargetIds = options.targets.split(',') || [];
            this._sClazz = options.clazz;
            this.$setBody(el);
            this.$initItems();

            var list = this.getItems();
            for (var i = 0; i < list.length; i++) {
                var o = list[i];
                o.$setState(o._sState);
            }
        }
    );

    var UI_DRAGGABLE_LIST = ui.DraggableList;
    var UI_DRAGGABLE_LIST_CLASS = UI_DRAGGABLE_LIST.prototype;

    /**
     * $setSize
     */
    UI_DRAGGABLE_LIST_CLASS.$setSize = util.blank;

    /**
     * target
     * @param {string} id
     */
    UI_DRAGGABLE_LIST_CLASS.addTarget = function(id) {
        this._aTargetIds.push(id);
    };

    UI_DRAGGABLE_LIST_CLASS.Item = core.inherits(
        UI_ITEM,
        null,
        function(el, options) {
            options.userSelect = false;
        },
        function(el, options) {
            this._sValue = options.value;
            this._sText = el.innerHTML;
            this._sState = options.state || 'normal';
            this._sClazz = options.clazz;
            this._bFixed = options.fixed;
            this._sAlign = options.align;
            this._bConfigBtn = options.configBtn;
            this._sCalcColumnRefInd = options.calcColumnRefInd;
            if (this._sClazz == 'DIM') {
                dom.addClass(el, 'ui-draggable-list-item-dim');
            }
            else if (this._sClazz == 'IND') {
                dom.addClass(el, 'ui-draggable-list-item-ind');
            }
        }
    );
    var UI_DRAGGABLE_LIST_ITEM_CLASS = UI_DRAGGABLE_LIST_CLASS.Item.prototype;

    util.extend(UI_DRAGGABLE_LIST_CLASS, UI_ITEMS);

    /**
     * dispose
     * @protected
     */
    UI_DRAGGABLE_LIST_CLASS.$dispose = function() {
        delete UI_ITEMS[this.getUID()];
        this.getOuter().innerHTML = '';
        util.callSuper(this, '$dispose');
    };
    

    UI_DRAGGABLE_LIST_CLASS.$alterItems = function() {
    };

    /**
     * item
     * @public
     * @param {Object} data
     * @param {string} data.value
     * @param {string} data.text
     * @param {string} data.clazz
     * @param {boolean=} data.fixed
     * @param {boolean=} data.align
     * @param {number=} opt_index
     */
    UI_DRAGGABLE_LIST_CLASS.addItem = function(data, opt_index) {
        var el = dom.create();
        el.innerHTML = data.text;
        this.getOuter().appendChild(el);
        this.add(el, opt_index, data);
    };

    /**
     * item
     * @public
     * @param {string} value
     */
    UI_DRAGGABLE_LIST_CLASS.removeItem = function(value) {
        this.remove(this.getItemByValue(value));
    };

    /**
     * clazz
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * 
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this, event);

        core.drag(this, event);
    };

    /**
     * 
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragstart = function() {
        var el = this.getOuter();
        el.style.zIndex = 32768;
        var par = this.getParent();
        var list = par.getItems();
        var index = 0;
        var i = 0;
        while(list[i] && list[i++] != this) {
            index = i;
        }

        if (!par._cPlacehold) {
            var el = dom.create('ui-draggable-list-placehold');
            par._cPlacehold = par.add(el, index, {});
            par._cPlacehold.setSize(this.getWidth(), this.getHeight());
        }
    };

    /**
     * 
     * @param {ecui.Event} event
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragmove = function(event) {
        var el = this.getOuter();
        var par = this.getParent();
        var targetEl;
        var targetCon;

        for (var i = 0; i < par._aTargetIds.length; i++) {
            if (
                core.get(par._aTargetIds[i])
                && intersect(el, core.get(par._aTargetIds[i]).getOuter())
            ) {
                targetCon = core.get(par._aTargetIds[i]);
                targetEl = targetCon.getOuter();
                break;
            }
        }

        if (par._cCurDrop && targetCon != par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'dragout', event, [this]);
        }
        par._cCurDrop = targetCon;

        if (!targetEl) {
            return ;
        }
        core.triggerEvent(targetCon, 'dragover', event, [this]);
    };

    /**
     * 
     * ecui
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragend = function(event) {
        var el  = this.getOuter();
        el.style.position = 'relative';
        el.style.zIndex = 0;
        this.setPosition(0, 0);

        var par = this.getParent();

        if (par._cPlacehold == null) {
            return;
        }

        par.remove(par._cPlacehold);
        par._cPlacehold = null;

        if (par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'drop', event, [this]);
            // this.setSelected(true);
        }

        par._cCurDrop = null;
    };

    /**
     * item
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getValue = function() {
        return this._sValue;
    };

    /**
     * 
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getText = function() {
        return this._sText;
    };

    /**
     * clazz
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * 
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getWrap = function() {
        return {
            value : this._sValue,
            text : this._sText,
            clazz : this._sClazz,
            fixed: this._bFixed,
            align: this._sAlign,
            configBtn: this._bConfigBtn,
            calcColumnRefInd: this._sCalcColumnRefInd
        };
    };

    /**
     * item
     * @public
     * @param {boolean} state truefalse
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.setSelected = function(state) {
        var el = this.getOuter();
        dom.removeClass(el, 'ui-draggable-list-item-selected');
        if (state) {
            dom.addClass(el, 'ui-draggable-list-item-selected');
            this._sState = 'selected';
            var par = this.getParent();
            if (par._bDisableSelected) {
                this.disable();
                dom.removeClass(el, 'ui-draggable-list-item-disabled');
                dom.removeClass(el, 'ui-item-disabled');
            }
        }

        this._bSelected = state;
    };

    /**
     * 
     * @private
     * @param {string} state
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$setState = function(state) {
        if (state == 'disable') {
            this.disable();
            this._sState = 'disable';
        }
        else if (state == 'selected') {
            this.setSelected(true);
        }
        else {
            this.enable();
            this.setSelected(false);
            this._sState = 'normal';
        }
    };

    /**
     * item
     * @public
     * @param {Object} obj
     */
    UI_DRAGGABLE_LIST_CLASS.setState = function(obj) {
        for (var i = 0, len = this.getItems().length; i < len; i++) {
            this.getItems()[i].$setState('normal');
        }
        if (obj['disable'] && obj['disable'].length) {
            for (var i = 0; i < obj['disable'].length; i++) {
                this.getItemByValue(obj['disable'][i]).$setState('disable');
            }
        }
        if (obj['selected'] && obj['selected'].length) {
            for (var i = 0; i < obj['selected'].length; i++) {
                this.getItemByValue(obj['selected'][i]).$setState('selected');
            }
        }
    };

    /**
     * valueitem
     * @public
     * @param {value}
     * @return {ecui.ui.Control}
     */
    UI_DRAGGABLE_LIST_CLASS.getItemByValue = function(value) {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            if (list[i].getValue() == value) {
                return list[i];
            }
        }

        return null;
    };

    /**
     * disableitem
     * @public
     */
    UI_DRAGGABLE_LIST_CLASS.disableAll = function() {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            list[i].disable();
        }
    };

    /**
     * 
     * @param {HTML element} element1 
     * @param {HTML element} element2 
     * @return {boolean} 
     */
    function intersect(element1, element2) {
        var pos1 = ecui.dom.getPosition(element1);
        var pos2 = ecui.dom.getPosition(element2);

        var maxLeft = Math.max(pos1.left, pos2.left);
        var minRight = Math.min(
            pos1.left + element1.offsetWidth, 
            pos2.left + element2.offsetWidth
        );
        var maxTop = Math.max(pos1.top, pos2.top);
        var minBottom = Math.min(
            pos1.top + element1.offsetHeight,
            pos2.top + element2.offsetHeight
        );

        return maxLeft <= minRight && maxTop <= minBottom;
    };

}) ();
/**
 * @file items
 * @author hades(denghongqi@baidu.com)
 */

(function() {
    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var array = core.array;
    var util = core.util;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_ITEMS = ui.Items;
    var UI_ITEM = ui.Item;
    var UI_ITEM_CLASS = UI_ITEM.prototype;

    ui.DroppableList = core.inherits(
        UI_CONTROL,
        'ui-droppable-list',
        function(el, options) {
        },
        function(el, options) {
            this._sName = options.name;
            options.targets = options.targets ||'';
            this._aTargetIds = options.targets.split(',') || [];
            options.source = options.source || '';
            this._aSourceIds = options.source.split(',') || [];
            this._bConfigBtn = options.configBtn;
            this.$setBody(el);
            this.$initItems();
        }
    );

    var UI_DROPPABLE_LIST = ui.DroppableList;
    var UI_DROPPABLE_LIST_CLASS = UI_DROPPABLE_LIST.prototype;

    util.extend(UI_DROPPABLE_LIST_CLASS, UI_ITEMS);

    UI_DROPPABLE_LIST_CLASS.$alterItems = util.blank;

    /**
     * $setSize
     * @override
     */
    UI_DROPPABLE_LIST_CLASS.$setSize = util.blank;

    UI_DROPPABLE_LIST_CLASS.add = function (item, index, options) {
        options = options;
        options.configBtn = options.configBtn == null 
            ? this._bConfigBtn : options.configBtn;
        return UI_ITEMS.add.call(this, item, index, options);
    };

    /**
     * dispose
     * @protected
     */
    UI_DROPPABLE_LIST_CLASS.$dispose = function() {
        delete UI_ITEMS[this.getUID()];
        this.getOuter().innerHTML = '';
        util.callSuper(this, '$dispose');
    };

    /**
     * @override
     */
    UI_DROPPABLE_LIST_CLASS.$mouseover = function() {
        UI_CONTROL_CLASS.$mouseover.call(this);
    };

    /**
     * drop
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} drop
     */
    UI_DROPPABLE_LIST_CLASS.$dragover = function(event, control) {
        if (this._cPlacehold) {
            this.remove(this._cPlacehold);
        }

        var index = getInsertIndex(this, event,control);

        // drop
        if (core.triggerEvent(
                this,
                'checkdroppable',
                null, 
                [control.getWrap(), index, this._sName]
            ) === false
        ) {
            this._cPlacehold = null;
            return;
        }

        var o = dom.create('ui-droppable-list-placehold');
        this.getBody().appendChild(o);
        this._cPlacehold = this.add(o, index, {placehold : true});
        this._cPlacehold.setSize(control.getWidth(), control.getHeight());
    };

    /**
     * 
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} control drop
     */
    UI_DROPPABLE_LIST_CLASS.$dragout = function(event, control) {
        if (!this._cPlacehold) {
            return ;
        }
        this.remove(this._cPlacehold);
        this._cPlacehold = null;
    };

    /**
     * drop
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} kedrop
     */
    UI_DROPPABLE_LIST_CLASS.$drop = function(event, control, listOfCon) {
        if (!this._cPlacehold) {
            return false; 
        }

        var index = getInsertIndex(this, event,control);
        if (this._cPlacehold) {
            this.remove(this._cPlacehold);
        }

        this._cNewAdd = this.addByItem(control, index);

        //this._cNewAdd.setSize(control.getWidth(), control.getHeight());

        if (this == listOfCon && control._nOriginIndex == index) {
            return;
        }

        for (var i = 0, con; i < this._aSourceIds.length; i++) {
            con = core.get(this._aSourceIds[i]);
            if (con && con.getClazz() == control.getClazz()) {
                core.triggerEvent(
                    con, 
                    'change', 
                    null, 
                    [
                        control.getWrap(), 
                        index, 
                        this._sName, 
                        control._nOriginIndex, 
                        control._sOriginParName
                    ]
                );
            }
        }        
    };

    /**
     * throw
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} kedrop
     */
    UI_DROPPABLE_LIST_CLASS.$throw = function(event, control, listOfCon) {
        for (var i = 0, con; i < this._aSourceIds.length; i++) {
            con = core.get(this._aSourceIds[i]);
            if (con && con.getClazz() == control.getClazz()) {
                core.triggerEvent(
                    con, 
                    'change', 
                    null,
                    [
                        control.getWrap(), 
                        null, 
                        this._sName,
                        control._nOriginIndex, 
                        control._sOriginParName
                    ]
                );
            }
        }        
    };

    /**
     * item
     *
     * @public
     * @return {number} item
     */
    UI_DROPPABLE_LIST_CLASS.count = function() {
        return UI_ITEMS[this.getUID()].length;
    }

    /**
     * item
     *
     * @public
     * @param {Item} item
     * @return {boolean} 
     */
    UI_DROPPABLE_LIST_CLASS.contains = function(item) {
        return array.indexOf(UI_ITEMS[this.getUID()], item) >= 0;
    }

    /**
     * item
     * @public
     * @param {Object} data
     * @param {string} data.value
     * @param {string} data.text
     * @param {string} data.clazz
     * @param {boolean=} data.fixed
     * @param {string=} data.align
     * @param {number=} opt_index
     */
    UI_DROPPABLE_LIST_CLASS.addItem = function(data, opt_index) {
        var el = dom.create();
        el.innerHTML = data.text;
        this.getOuter().appendChild(el);
        this.add(el, opt_index, data);
    };

    /**
     * target
     * @param {string} id
     */
    UI_DROPPABLE_LIST_CLASS.addTarget = function(id) {
        this._aTargetIds.push(id);
    };

    /**
     * item
     * @public
     * @param {string} value
     */
    UI_DROPPABLE_LIST_CLASS.removeItem = function(value) {
        this.remove(this.getItemByValue(value));
    };

    /**
     * valueitem
     * @public
     * @param {string} value
     * @return {ecui.ui.Control}
     */
    UI_DROPPABLE_LIST_CLASS.getItemByValue = function(value) {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            if (value == list[i].getValue()) {
                return list[i];
            }
        }

        return null;
    };

    /**
     * drop
     * @public
     * @return {Array}
     */
    UI_DROPPABLE_LIST_CLASS.getValue = function() {
        var list = this.getItems();
        var res = [];
        for (var i = 0; i < list.length; i++) {
            res.push(list[i].getValue());
        }

        return res;
    };    

    /**
     * drop
     * @public
     * @return {Array}
     */
    UI_DROPPABLE_LIST_CLASS.getWrap = function() {
        var list = this.getItems();
        var res = [];
        for (var i = 0; i < list.length; i++) {
            res.push(list[i].getWrap());
        }

        return res;
    };

    /**
     * 
     * 
     * @public
     * @param {Item} 
     * @param {number} 
     * @return {Item} 
     */
    UI_DROPPABLE_LIST_CLASS.addByItem = function(srcCtrl, index) {
        var o = dom.create();
        o.innerHTML = srcCtrl.getText();
        this.getBody().appendChild(o);

        return this.add(o, index, srcCtrl.getWrap());
    };


    UI_DROPPABLE_LIST_CLASS.Item = core.inherits(
        UI_ITEM,
        null,
        function(el, options) {
            options.userSelect = false;
            this._sText = el.innerHTML;
            if (!options.placehold && options.configBtn) {
                var o = dom.create('ui-droppable-list-item-icon');
                this._bConfigBtn = options.configBtn;
                el.appendChild(o);
            }
        },
        function(el, options) {
            this._sValue = options.value;
            this._sClazz = options.clazz;
            this._bFixed = options.fixed;
            this._sAlign = options.align;
            this._sCalcColumnRefInd = options.calcColumnRefInd;
            if (this._sClazz == 'DIM') {
                dom.addClass(el, 'ui-droppable-list-item-dim');
            }
            else if (this._sClazz == 'IND') {
                dom.addClass(el, 'ui-droppable-list-item-ind');
            }
            if (!options.placehold && options.configBtn) {
                this._cIcon = core.$fastCreate(this.Icon, dom.last(el), this, {});
            }
        }
    );
    var UI_DROPPABLE_LIST_ITEM = UI_DROPPABLE_LIST_CLASS.Item;
    var UI_DROPPABLE_LIST_ITEM_CLASS = UI_DROPPABLE_LIST_ITEM.prototype;

    /**
     * item
     * @public
     * @param {string} value
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.setValue = function(value) {
        this._sValue = value;
    };

    /**
     * item
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getValue = function() {
        return this._sValue;
    };

    /**
     * item
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getText = function() {
        return this._sText;
    };

    /**
     * itemclazz
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * item
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getWrap = function() {
        return {
            value : this._sValue,
            text : this._sText,
            clazz : this._sClazz,
            fixed: this._bFixed,
            align: this._sAlign,
            configBtn: this._bConfigBtn,
            calcColumnRefInd: this._sCalcColumnRefInd
        };
    };

    /**
     * 
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this, event);

        var par = this.getParent();
        var originIndex = array.indexOf(UI_ITEMS[par.getUID()], this);

        if (core.triggerEvent(
                par, 
                'checkdraggable', 
                null, 
                [
                    this.getWrap(), 
                    originIndex, 
                    par._sName
                ]
            ) !== false
        ) {
            this._sOriginParName = par._sName; // 
            this._nOriginIndex = originIndex; // index
            core.drag(this, event);
        }
    };

    /**
     * 
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragstart = function(event) {
    };

    /**
     * 
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragmove = function(event) {
        this._bDragging = true;

        var par = this.getParent();
        var conArr = [];
        conArr.push(par);
        for (var i = 0; i < par._aTargetIds.length; i++) {
            if (core.get(par._aTargetIds[i])) {
                conArr.push(core.get(par._aTargetIds[i]));
            }
        }

        var el = this.getOuter();
        var targetCon;
        var targetEl;
        for (var i = 0; i < conArr.length; i++) {
            if (intersect(el, conArr[i].getOuter())) {
                targetCon = conArr[i];
                targetEl = targetCon.getOuter();
                break;
            }
        }

        if (par._cCurDrop && targetCon != par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'dragout', event, [this]);
        }
        par._cCurDrop = targetCon;

        if (!targetEl) {
            return ;
        }
        core.triggerEvent(targetCon, 'dragover', event, [this]);
    };

    /**
     * 
     * ecui
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragend = function(event) {
        var par = this.getParent();

        if (!par) { return; }

        if (!par._cCurDrop) {
            if (
                event.pageX >= dom.getPosition(par.getOuter()).left
                && event.pageX <= dom.getPosition(par.getOuter()).left + par.getWidth()
                && event.pageY >= dom.getPosition(par.getOuter()).top
                && event.pageY <= dom.getPosition(par.getOuter()).top + par.getHeight()
            ) {
                par._cCurDrop = par;
            }
        }
        par.remove(this);
        if (par._cCurDrop) {
            if (core.triggerEvent(par._cCurDrop, 'drop', event, [this, par]) == false) {
                // dropdrop
                par.addByItem(this, this._nOriginIndex);           
            }
        }
        else {
            core.triggerEvent(par, 'throw', event, [this, par]);
        }
        par._cCurDrop = null;
        this._bDragging = false;
        this._nOriginIndex = null;

        core.triggerEvent(par, 'deactivate', event);
        core.triggerEvent(par, 'blur', event);
    };

    /**
     * item
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.Icon = core.inherits(
        UI_CONTROL,
        'ui-droppable-list-item-icon',
        null,
        null
    );
    var UI_DROPPABLE_LIST_ITEM_ICON = UI_DROPPABLE_LIST_ITEM_CLASS.Icon;
    var UI_DROPPABLE_LIST_ITEM_ICON_CLASS = UI_DROPPABLE_LIST_ITEM_ICON.prototype;

    /**
     * click
     */
    UI_DROPPABLE_LIST_ITEM_ICON_CLASS.$click = function(event) {
        UI_CONTROL_CLASS.$click.call(this);
        var item = this.getParent();
        var itemData = item.getWrap();
        core.triggerEvent(item.getParent(), 'itemclick', event, [itemData]);

        event.stopPropagation();
    };

    /**
     * activate
     */
    UI_DROPPABLE_LIST_ITEM_ICON_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this);

        event.stopPropagation();
    };

    /**
     * 
     * @param {HTML element} element1 
     * @param {HTML element} element2 
     * @return {boolean} 
     */
    function intersect(element1, element2) {
        var pos1 = ecui.dom.getPosition(element1);
        var pos2 = ecui.dom.getPosition(element2);

        var maxLeft = Math.max(pos1.left, pos2.left);
        var minRight = Math.min(
            pos1.left + element1.offsetWidth, 
            pos2.left + element2.offsetWidth
        );
        var maxTop = Math.max(pos1.top, pos2.top);
        var minBottom = Math.min(
            pos1.top + element1.offsetHeight,
            pos2.top + element2.offsetHeight
        );

        return maxLeft <= minRight && maxTop <= minBottom;
    };

    /**
     * index
     * @param {ecui.ui.Items} control
     * @param {ecui.Event} event
     */
    function getInsertIndex(control, event,ctrl) {
        var list = control.getItems();
        var flag;
        for (index = 0; index < list.length; index++) {
            var item = list[index];
            var el = item.getOuter();
            // item
            // index0
            if(ctrl._sAlign == 'LEFT'){
                flag = 0;
                break;
            }
            // 
            if(ctrl._sClazz == 'DIM' && control._sName == 'COLUMN'){
                flag = 0;
                break;
            }
            // 
            if(ctrl._sClazz == 'IND' && control._sName == 'COLUMN' && item._sClazz == 'DIM'){
                continue;
            }

            if (
                event.pageX <= dom.getPosition(el).left + item.getWidth()
                && event.pageY <= dom.getPosition(el).top + item.getHeight()
                && !item._bDragging
            ) {
                flag = index;
                break;
            }
        }
        return flag;
    };

}) ();
/**
 * xui-ui
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    ui
 *           uiuiui
 * @author:  sushuang(sushuang@baidu.com)
 */

/**
 * @namespace
 */
xui.ui = {};

/**
 * xui.ui.HChart  
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    highchartsjs
 *           (pl-charts.js by cxl(chenxinle@baidu.com))
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, highcharts
 */

(function () {

    var ieVersion = xutil.dom.ieVersion;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var inheritsObject = xutil.object.inheritsObject;
    var formatNumber = xutil.number.formatNumber;
    var getQuarterBegin = xutil.date.getQuarterBegin;
    var dateToString = xutil.date.dateToString;
    var stringToDate = xutil.date.stringToDate;
    var getQuarter = xutil.date.getQuarter;
    var getWeekend = xutil.date.getWeekend;
    var getWorkday = xutil.date.getWorkday;
    var getQuarterBegin = xutil.date.getQuarterBegin;
    var encodeHTML = xutil.string.encodeHTML;
    var extend = xutil.object.extend;
    var bind = xutil.fn.bind;
    var XOBJECT = xui.XObject;

    var DI_ATTR_PREFIX = '\x06diA^_^';
    /**
     * highchartsJS
     *
     * @class
     * @extends {xui.ui.Control}
     */
    var UI_H_CHART = xui.ui.HChart = 
        inheritsObject(
            XOBJECT,
            function (options) {
                var el = options.el;
                this._sType = 'xui-h-chart';
                addClass(el, this._sType);

                options.resizable = false;
                Highcharts.setOptions(this.CHART_OPTIONS);

                var type = this._sType;
                el.innerHTML = [
                    '<div class="' + type + '-header">',
                        '<div class="' + type + '-legend"></div>',
                    '</div>',
                    '<div class="' + type + '-content"></div>'
                ].join('');

                this._eLegend = el.childNodes[0].firstChild;
                this._eContent = el.childNodes[1];
            }
        );
    var UI_H_CHART_CLASS = UI_H_CHART.prototype;

    /** 
     * highcharts
     *
     * @type {Object}
     * @protected
     */
    UI_H_CHART_CLASS.CHART_OPTIONS = {
        colors: [
            '#e98282', 
            '#81c1e9', 
            '#a6e340', 
            '#f6ab1a', 
            '#88d915', 
            '#0380ea', 
            '#3c2dc9', 
            '#8e45e9', 
            '#f44dce', 
            '#e21d3d',
            '#56b3c9', 
            '#e26237', 
            '#08a267', 
            '#faa616', 
            '#85d111', 
            '#0887e1', 
            '#3927c3', 
            '#894aec', 
            '#fa46c9', 
            '#e7193a'
        ],
        global: { useUTC: false }
    };

    /** 
     * 
     *
     * @type {Array}
     * @private
     */
    var STR_WEEKDAY = [
        '', '', '', '', '', '', ''
    ];

    /**
     * 
     */
    var DAY_MILL = 1000 * 60 * 60 * 24;

    /**
     * margin
     */
    var CHART_MARGIN_RIGHT = 35;

    /**
     * rangeSelector
     * by
     * 'max'
     * 'current'
     *
     * @type {Object}
     * @protected
     */
    UI_H_CHART_CLASS.EXT_RANGE_SELECTOR_TYPE = {
        thisMonth: function (btn) {
            btn.type = function (options) {
                var now = new Date(options.newMax);
                return {
                    newMin: new Date(
                            now.getFullYear(), 
                            now.getMonth(), 
                            1
                        ).getTime()
                }
            };
        },
        thisQuarter: function (btn) {
            btn.type = function (options) {
                return {
                    newMin: getQuarterBegin(
                            new Date(options.newMax)
                        ).getTime()
                }
            };
        },
        thisYear: function (btn) {
            btn.type = function (options) {
                var now = new Date(options.newMax);
                return {
                    newMin: new Date(now.getFullYear(), 0, 1).getTime()
                }
            };
        },
        // highchartsmonthxMonth
        // xMonthbtn.count == 1thisMonth
        xMonth: function (btn) {
            btn.type = function (options) {
                var now = new Date(options.newMax);
                return {
                    newMin: new Date(
                            now.getFullYear(), 
                            now.getMonth() - btn.count + 1,
                            1
                        ).getTime()
                }
            };
        },
        // xQuarterbtn.count == 1thisQuarter
        xQuarter: function (btn) {
            btn.type = function (options) {
                var quarterBegin = getQuarterBegin(new Date(options.newMax));
                quarterBegin.setMonth(
                    quarterBegin.getMonth() - (btn.count - 1) * 3
                );
                return {
                    newMin: quarterBegin.getTime()
                }
            };
        }
    };

    /** 
     * 
     *
     * @type {Object}
     * @protected
     */
    var efmt = UI_H_CHART_CLASS.EXT_AXIS_FORMAT = {};

    /**
     * date 
     */
    efmt.date = {
        parse: function (dateStr) {
            return dateStr != null
                ? stringToDate(dateStr, 'yyyy-MM-dd').getTime()
                : void 0;
        },
        format: function (timestamp) {
            return dateToString(new Date(timestamp), 'yyyy-MM-dd');
        },
        formatTooltip: function (timestamp) {
            var date = new Date(timestamp);
            return dateToString(date, 'yyyy-MM-dd') 
                + ' (' + STR_WEEKDAY[date.getDay()] + ')';
        },
        inputFormat: '%Y-%m-%d',
        minRange: 2 * 24 * 60 * 60 * 1000
    };

    /**
     * week 
     */
    efmt.week = {
        parse: efmt.date.parse,
        format: function (timestamp, options) {
            var date = new Date(timestamp);
            var range = (options || {}).range;

            return dateToString(
                    fixByDateRange(getWorkday(date), range), 
                    'yyyy-MM-dd'
                ) 
                + '<br>' 
                + dateToString(
                    fixByDateRange(getWeekend(date), range), 
                    'yyyy-MM-dd'
                );
        },
        formatTooltip: function (timestamp, options) {
            var date = new Date(timestamp);
            var range = (options || {}).range;
            var workday = fixByDateRange(getWorkday(date), range);
            var weekend = fixByDateRange(getWeekend(date), range);
            return dateToString(workday, 'yyyy-MM-dd') 
                + ' (' + STR_WEEKDAY[workday.getDay()] + ')'
                + ' ~ ' 
                + dateToString(weekend, 'yyyy-MM-dd')
                + ' (' + STR_WEEKDAY[weekend.getDay()] + ')';
        },
        formatNavigator: function (timestamp, options) {
            var range = (options || {}).range;
            return dateToString(
                fixByDateRange(getWorkday(new Date(timestamp)), range), 
                'yyyy-MM-dd'
            );
        },
        inputFormat: '%Y-%m-%d',
        minRange: 2 * 7 * 24 * 60 * 60 * 1000
    };

    /**
     * month 
     */
    efmt.month = {
        parse: function (dateStr) {
            return dateStr != null 
                ? stringToDate(dateStr, 'yyyy-MM').getTime()
                : void 0;
        },
        format: function (timestamp) {
            return dateToString(new Date(timestamp), 'yyyy-MM');
        },
        inputFormat: '%Y-%m',
        minRange: 2 * 31 * 24 * 60 * 60 * 1000
    };

    /**
     * quarter 
     */
    efmt.quarter = {
        parse: parseQuarter,
        format: function (timestamp) {
            var date = new Date(timestamp);
            return String(
                date.getFullYear() + '-Q' + getQuarter(date)
            );
        },
        inputFormat: '%Y-%q',
        minRange: 2 * 3 * 31 * 24 * 60 * 60 * 1000
    };

    /**
     * year 
     */
    efmt.year = {
        parse: function (dateStr) {
            return dateStr != null 
                ? new Date(
                    parseInt(dateStr, 10), 0, 1
                ).getTime()
                : void 0;
        },
        format: function (timestamp) {
            return new Date(timestamp).getFullYear();
        },
        inputFormat: '%Y',
        minRange: 2 * 366 * 24 * 60 * 60 * 1000
    };

    /**
     * 
     */
    function parseQuarter(dateStr) {
        if (dateStr == null) {
            return null;
        }
        var par = [0, 0, 3, 6, 9];
        dateStr = dateStr.split('-Q');
        return new Date(
            parseInt(dateStr[0], 10), 
            par[parseInt(dateStr[1], 10)], 
            1
        ).getTime();
    }

    /**
     * 
     */
    UI_H_CHART_CLASS.init = function () {
    };

    /**
     * 
     *
     * @public
     * @param {Object} dataWrap 
     * @param {boolean=} isSilent false
     */
    UI_H_CHART_CLASS.setData = function (dataWrap, isSilent) {
        dataWrap = dataWrap || {};

        // this._sChartType = fixChartType(dataWrap.chartType, 'line');
        this._bSeriesHasValue = null;
        this._nWidth = dataWrap.width;
        this._nHeight = dataWrap.height;
        /**
         * x
         * 
         *  xAxis: [
         *      {
         *          type: 'quarter', // 'category', 'date', 'month'EXT_AXIS_FORMAT
         *          data: ['2012-Q1', '2012-Q2']
         *      }
         *  ];
         */
        this._aXAxis = dataWrap.xAxis || [];
        /**
         * y
         * 
         *  xAxis: [
         *      {
         *          format: 'I,III.DD%', // 
         *          title: 'y'
         *      }
         *  ];
         */
        this._aYAxis = dataWrap.yAxis || [];   
        /**
         * 
         * 
         *  series: [
         *      {
         *          name: '1',
         *          data: [1234.1234, 12344.333, 57655]
         *      },
         *      {
         *          name: '2',
         *          data: [566.1234, 565, 9987]
         *      }
         *  ];
         */
        this._aSeries = dataWrap.series || [];
        /**
         * rangeselector
         * 
         *  rangeSelector: {
         *      byAxisType: {
         *          date: {
         *              buttons: [
         *                  { type: 'thisMonth', text: '', by: 'max' },
         *                  { type: 'all', text: '' }
         *              ],
         *              selected: 0
         *          }
         *      }
         *  }
         */
        this._oRangeSelector = dataWrap.rangeSelector;
        /**
         * legend+
         * 
         *  legend: { 
         *      xMode: 'pl' // PLlegend
         *  }
         */
        this._oLegend = dataWrap.legend || {};
        /**
         * html
         */
        this._sEmptyHTML = dataWrap.emptyHTML || '';
             
        !isSilent && this.render();
    };

    /**
     * 
     *
     * @protected
     */
    UI_H_CHART_CLASS.$setupSeries = function (options) {
        var series = [];
        var xAxis = this._aXAxis[0];

        for (var i = 0, ser, serDef; serDef = this._aSeries[i]; i ++) {
            ser = { data: [] };
            ser.name = serDef.name || '';
            ser.yAxis = serDef.yAxisIndex || 0;
            ser.color = serDef.color || void 0;
            ser.format = serDef.format || void 0;
            ser.type = fixChartType(serDef.type);
            serDef.id !== null && (ser.id = serDef.id);

            if (xAxis.type in this.EXT_AXIS_FORMAT && !this._bHasPie) {
                // series[x, y]
                ser.data = [];
                for (var j = 0; j < serDef.data.length; j ++) {
                    var val = this.EXT_AXIS_FORMAT[xAxis.type].parse(xAxis.data[j]);
                    ser.data.push([val, serDef.data[j]]);
                }
            }
            else {
                ser.data = serDef.data;
            }

            series.push(ser);
        }

        // 
        // series
        if (this._bHasPie) {
            for (var k = 0, kser; kser = series[k]; ) {
                kser.type !== 'pie'
                    ? series.splice(k, 1)
                    : k ++;
            }
            // 
            series.length > 1 && series.splice(1, series.length - 1);
        }
        options.series = series;
    }
    
    /**
     * 
     *
     * @protected
     */
    UI_H_CHART_CLASS.$setupTooptip = function (options) {
        // x
        var xAxis = this._aXAxis[0];
        var type = xAxis.type; 
        var callback = xAxis.tipCallback;
        var aSeries = this._aSeries;
        var needShowYAxisName = this._aYAxis.length > 1;

        var fmt = this.EXT_AXIS_FORMAT[xAxis.type];
        fmt = fmt 
            && (fmt.formatTooltip || fmt.format) 
            || function (o) { return o };

        // 
        if (this._bHasPie) {
            options.tooltip = {
                formatter: callback || function () {
                    var xKey = this.series.chart.xAxis[0].categories[this.point.x];
                    return [
                        '<b>', xKey, '</b><br />',
                        '<b>', this.series.name,  '</b>: ',
                        formatNumber(
                            this.y, 
                            this.series.options.format, 
                            null, 
                            null, 
                            true
                        ),
                        ' (',
                        formatNumber(this.percentage, 'I,III.DD%'),
                        ')'
                    ].join('');
                },
                useHTML: false,
                shared: false//,
                // borderColor: "#11A4F2"
            };
        } 

        // 
        else {
            options.tooltip = {
                useHTML: false,
                shared: true,
                borderColor: '#c6c6c6',
                borderWidth: 1,

                formatter: callback || function () {
                    var htmlArr = [];
                    htmlArr.push(
                        '<span style="color:#4770A7;line-height:20px;font-size:13px;font-weight:bold;font-family:\"\",Arial">',
                            fmt(this.x, { range: xAxis.range }),
                        '</span><br />'
                    );

                    for (var i = 0, o; o = this.points[i]; i ++) {

                        if (o.series.name != null) {
                            sFormat = null;
                            // pointsaSeries
                            // _serie.nameformat
                            for (var j = 0; j < aSeries.length; j++) {
                                var _serie = aSeries[j];
                                if(_serie.name == o.series.name){
                                    sFormat = aSeries[j].format;
                                    break;
                                } 
                            };
                            
                            var yOpt = o.series.yAxis.options;
                            needShowYAxisName && htmlArr.push(
                                '<span style="color:', yOpt.lineColor, '">',
                                    yOpt.index == 0 ? '[] ' : '[] ',
                                '</span>'
                            );
                            htmlArr.push(
                                '<span style="color:' + o.series.color + ';font-size:12px;font-weight:bold">',
                                o.series.name + ': ',
                                '</span>',
                                '<span style="text-align:right;color:#000;font-size:12px;font-family:Arial">',
                                sFormat != null ? formatNumber(o.y, sFormat, null, null, true) : o.y,
                                '</span>'
                            );
                        }
                        if (i < this.points.length - 1) {
                            htmlArr.push('<br>');
                        }
                    }
                    return htmlArr.join('');
                }
            }
        }
    }

    /**
     * x
     *
     * @private
     */
    UI_H_CHART_CLASS.$setupXAxis = function (options) {
        var me = this;
        var axisList = [];

        for (
            var axisIndex = 0, xAxisDef, fmt, data; 
            xAxisDef = this._aXAxis[axisIndex]; 
            axisIndex ++
        ) {
            data = xAxisDef.data;

            // range
            if ((fmt = this.EXT_AXIS_FORMAT[xAxisDef.type]) 
                && data 
                && data.length > 0
                && xAxisDef.range
            ) {
                xAxisDef.range = [
                    xAxisDef.range[0] ? fmt.parse(xAxisDef.range[0]) : null,
                    xAxisDef.range[1] ? fmt.parse(xAxisDef.range[1]) : null
                ];
            }

            var xAxis = {
                gridLineWidth: 0,
                gridLineColor: '#DBDBDB',
                tickPosition: 'inside',
                tickLength: 5,
                // startOnTicktrue
                // highstock-1.1.5bugtruenavigator
                // 
                // bug
                startOnTick: false,
                lineColor: xAxisDef.color || '#8CA5C9',
                lineWidth: 2,
                endOnTick: false,
                maxPadding: 0.002,
                minRange: (this.EXT_AXIS_FORMAT[xAxisDef.type] || {}).minRange,
                tickPositioner: (function (
                            me, axisType, isExtAxisType, useYearMonthAdjust
                        ) {
                        return function (min, max) {
                            return tickPositioner.call(
                                this, me, axisType, isExtAxisType, 
                                useYearMonthAdjust, min, max
                            );
                        }
                    })(
                        me, 
                        xAxisDef.type, 
                        xAxisDef.type in this.EXT_AXIS_FORMAT, 
                        xAxisDef.useYearMonthAdjust
                    ),                
                tickPixelInterval: xAxisDef.tickPixelInterval != null 
                    ? xAxisDef.tickPixelInterval
                    : void 0,
                title: this._aXAxis[axisIndex].title != null
                    ? {
                        enabled: true,
                        text: this._aXAxis[axisIndex].title,
                        align: 'high',
                        rotation: 0,
                        tickInterval: 1,
                        offset: 0,
                        y: -12,
                        x: 10
                    }
                    : void 0,
                labels: { 
                    overflow: void 0,
                    formatter: (function (extFormat, xAxisDef) {
                            return function () {
                                var fun = extFormat[xAxisDef.type];
                                return fun 
                                    ? fun.format.call(
                                        null, 
                                        this.value, 
                                        { range: xAxisDef.range }
                                    )
                                    : this.value;
                            }
                        })(this.EXT_AXIS_FORMAT, xAxisDef),
                    style: {
                        fontFamily: 'Arial,Serif,Times', 
                        fontSize: '12px', 
                        color: '#6B6B6B'
                    }
                }
            };

            if (data 
                && (
                    !(this._aXAxis[axisIndex].type in this.EXT_AXIS_FORMAT)
                    || this._bHasPie
                )
            ) {
                xAxis.categories = data;
            }

            if (this._aXAxis[axisIndex].plotLines != null) {
                xAxis.plotLines = [];

                for (
                    var i = 0, o, before, after; 
                    o = this._aXAxis[axisIndex].plotLines[i]; 
                    i ++
                ) {
                    if (o.value != null) {
                        o.value = this.EXT_AXIS_FORMAT[
                            this._aXAxis[axisIndex].type
                        ].parse(o.value);
                        xAxis.plotLines.push(o);
                    } 

                    else if (
                        o.valueBefore != null || o.valueAfter != null
                    ) {

                        before = o.valueBefore != null 
                            ? o.valueBefore : o.valueAfter;
                        after = o.valueAfter != null 
                            ? o.valueAfter : o.valueBefore;

                        o.value = Math.round(
                            (
                                this.EXT_AXIS_FORMAT[
                                    this._aXAxis[axisIndex].type
                                ].parse(before)
                                + this.EXT_AXIS_FORMAT[
                                    this._aXAxis[axisIndex].type
                                ].parse(after)
                            ) / 2
                        );
                        xAxis.plotLines.push(o);
                    }
                }
            }

            axisList.push(xAxis);
        }

        options.xAxis = !axisList.length 
            ? void 0 
            : (axisList.length > 1 ? axisList : axisList[0]);
    }

    /**
     * y
     * 
     *
     * @private
     */
    UI_H_CHART_CLASS.$setupYAxis = function (options) {
        var yas = []
        var align = ['right', 'left'];
        var opposite = [false, true];
        var labelOffset = [-7, 5];
        var lineColors = ['#6F8B9E', '#86C1C9'];
        var defaultLineColor = '#8CA5C9';
        var titleOffset = [30, -17];
        var isDoubleYAxis = this._aYAxis.length > 1;

        for (var i = 0, yAxisDef, o; yAxisDef = this._aYAxis[i]; i++) {
            o = {
                gridLineWidth: 1,
                gridLineColor: '#DBDBDB',                
                lineColor: !isDoubleYAxis 
                    ? (yAxisDef.color || defaultLineColor)
                    : lineColors[i % 2],
                lineWidth: 2,
                tickPosition: 'inside',
                tickmarkPlacement: 'on',
                labels: {
                    align: align[i % 2],
                    x: labelOffset[i % 2],
                    style: {
                        fontFamily: 'Arial,Serif,Times', 
                        fontSize: '11px', 
                        color: '#6B6B6B'
                    },
                    formatter: yAxisDef.format
                        ? (typeof yAxisDef.format == 'string'
                            ? (function (formatStr) {
                                return function () { 
                                    return formatNumber(this.value, formatStr, null, null, true) 
                                }
                            })(yAxisDef.format)
                            : yAxisDef.format
                        )
                        : void 0
                },
                opposite: opposite[i % 2],
                title: (yAxisDef.title != null && this.$seriesHasValue())
                    ? extend(
                        {
                            enabled: true,
                            align: 'high',
                            rotation: 0,
                            x: titleOffset[i % 2],
                            y: -10
                        },
                        yAxisDef.title
                    )
                    : void 0
            };

            // if (this._sChartType == 'bar') {
            //     o.tickPixelInterval = 210;        
            //     o.min = yAxisDef.min; // 
            // }

            yas.push(o);
        }

        options.yAxis = !yas.length 
            ? {} 
            : (yas.length > 1 ? yas : yas[0]);
    };

    /**
     * 
     *
     * @private
     */
    UI_H_CHART_CLASS.$seriesHasValue = function () {
        if (this._bSeriesHasValue != null) {
            //
            return this._bSeriesHasValue;
        }

        for (var i = 0, ser; i < this._aSeries.length; i ++) {
            if ((ser = this._aSeries[i]) && ser.data && ser.data.length) {
                var lineHasValue = false;
                for (var j = 0; j < ser.data.length; j ++) {
                    if (ser.data[j] != null) {
                        lineHasValue = true;
                    }
                }
                if (lineHasValue) {
                    return this._bSeriesHasValue = true;
                }
            }
        }
        return this._bSeriesHasValue = false;
    }

    /**
     * 
     *
     * @protected
     */
    UI_H_CHART_CLASS.$setupPlotOptions = function (options) {
        // if (this._sChartType == 'bar') {
        //     options.plotOptions = {
        //         bar: {
        //             minPointLength: 2,
        //             borderWidth: 0,
        //             dataLabels: {
        //                 enabled: true,
        //                 color: '#4770A7',
        //                 style: {
        //                     fontWeight: 'bold', 
        //                     fontFamily: 'Arial', 
        //                     fontSize: '14px'
        //                 },
        //                 formatter: function () {
        //                     if (this.point.config[3] != null) {
        //                         return this.point.config[3]; 
        //                     } 
        //                     else {
        //                         return '';
        //                     }
        //                 }
        //             }
        //         }
        //     };
        // }
        var plotOptions = options.plotOptions = options.plotOptions || {};
        var seriesOpt = plotOptions.series = plotOptions.series || {};
        var columnOpt = plotOptions.column = plotOptions.column || {};
        var pieOpt = plotOptions.pie = plotOptions.pie || {};

        if (!ieVersion) {
            columnOpt.shadow = true;
            columnOpt.borderWidth = 1;
        }

        var useStack = false;
        for (var i = 0, serDef; serDef = this._aSeries[i]; i ++) {
            serDef.stack && (useStack = true);
        }
        useStack && (seriesOpt.stacking = 'normal');

        // 
        this._bHasPie && extend(
            pieOpt, 
            {
                allowPointSelect: true,
                cursor: 'pointer',
                dataLabels: {
                    enabled: true,
                    color: '#000000',
                    connectorColor: '#000000',
                    // FIXME
                    formatter: function () {
                        // return "asdf";
                        var xKey = this.series.chart.xAxis[0].categories[this.point.x];
                        return '<b>' + xKey + '</b>' + ': ' + formatNumber(
                            this.y, 
                            this.series.options.format, 
                            null, 
                            null, 
                            true
                        );
                    }
                }
            }
        );
    }

    /**
     * 
     *
     * @protected
     */
    UI_H_CHART_CLASS.$setupLegend = function (options) {
        // legend
        if (this._bHasPie) {
            options.legend = { enabled: false };
        }
        // pllegend
        else if (this._oLegend.xMode == 'pl') {
            var type = this._sType;
            var colors = this.CHART_OPTIONS.colors;

            this._eLegend.style.marginRight = CHART_MARGIN_RIGHT + 'px';

            // legend
            for (var i = 0, o, ser, color; ser = this._aSeries[i]; i ++) {
                o = document.createElement('span');
                addClass(o, type + '-legend-item');
                color = ser.color || colors[i % colors.length];
                o.style.backgroundColor = color;
                o.setAttribute('rel', color);
                o.innerHTML = encodeHTML(ser.name)
                    + '<span class="' + type + '-legend-item-icon"></span>';
                this._eLegend.appendChild(o);

                // 
                o.onclick = bind(this.$handleLegendClick, this, i, o);
            }

            // legend
            options.legend = { enabled: false };
        }
        // legend
        else {
            options.legend = {
                enabled: true,
                align: 'center',
                borderColor: '#FFF',
                verticalAlign: 'top',
                margin: 15
            };
        }
    }

    /**
     * 
     *
     * @protected
     */
    UI_H_CHART_CLASS.$handleLegendClick = function (index, el) {
        var visibleCount = 0;
        var type = this._sType;
        
        this.$foreachSeries(function (ser, index) {
            if (ser && ser.visible) { visibleCount ++; }
        });
        
        // highchartsindex
        var serie = this._oChart.series[index];
        if (!serie) { return; }
        
        if (serie.visible) {
            if (visibleCount <= 1) {
                return;
            }
            else {
                serie.hide();
                addClass(el, type + '-legend-item-hidden');
                el.style.background = '#B9B9B9';
            }
        }
        else {
            serie.show();
            removeClass(el, type + '-legend-item-hidden');
            el.style.background = el.getAttribute('rel');
        }
    };

    /**
     * 
     * @protected
     */
    UI_H_CHART_CLASS.$setupZoom = function (options) {
        var xAxis = this._aXAxis[0];
        var axisType = xAxis.type;

        options.chart = options.chart || {};
        options.navigator = options.navigator || {};

        // zoomnavigator
        if (axisType in this.EXT_AXIS_FORMAT && !this._bHasPie) {
            options.navigator.enabled = true;
            options.scrollbar = { enabled: true };
            options.chart.zoomType = 'x';
            setupRangeSelector.call(this, options, true);
        } 
        else {
            options.navigator.enabled = false;
            options.chart.zoomType = '';
            options.scrollbar = { enabled: false };
            setupRangeSelector.call(this, options, false);
        } 
        
        // navigator
        if (options.navigator.enabled) {
            options.navigator.height = 30;
            options.navigator.series = { 
                dataGrouping: { smoothed: false } 
            };
            var fmt = this.EXT_AXIS_FORMAT[xAxis.type];
            fmt = fmt && fmt.formatNavigator || fmt.format;
            options.navigator.xAxis = { 
                labels: {
                    formatter: function () {
                        return fmt
                            ? fmt.call(null, this.value, { range: xAxis.range })
                            : this.value;
                    },
                    style: { fontFamily: 'Arial', fontSize: '11px' }
                }
            };
        }
    }

    /**
     * 
     *
     * @private
     */
    function setupRangeSelector(options, enabled) {
        var buttons;
        var selected;
        var axisType = this._aXAxis[0].type;
        
        // rangeselector
        if (!enabled) {
            options.rangeSelector = { enabled: false };
            return;
        }

        var rSele = this._oRangeSelector;
        var rSeleDef = rSele
            && (rSele.byAxisType
                // axisTypebuttons
                ? rSele.byAxisType[axisType]
                // buttons
                : rSele
            );
            
        // rangeSelector
        if (rSeleDef) {
            buttons = [];
            for (var i = 0, btn, extFn; i < rSeleDef.buttons.length; i ++) {
                buttons.push(btn = extend({}, rSeleDef.buttons[i]));
                // 
                if (extFn = this.EXT_RANGE_SELECTOR_TYPE[btn.type]) {
                    extFn(btn);
                }
            }
            selected = rSeleDef.selected;
        }
        // rangeSelector
        else {
            if (axisType == 'date') {
                buttons = [
                    { type: 'month', count: 1, text: '1' }, 
                    { type: 'month', count: 3, text: '3' }, 
                    { type: 'month', count: 6, text: '6' }, 
                    { type: 'year', count: 1, text: '1' },
                    { type: 'all', text: '' }
                ];
                selected = 4;
            } 
            else if (axisType == 'month') {
                buttons = [
                    { type: 'month', count: 6, text: '6' }, 
                    { type: 'year', count: 1, text: '1' },
                    { type: 'all', text: '' }
                ];
                selected = 2;
            }
            else {
                buttons = [{ type: 'all', text: '' }];
                selected = 0;
            }
        }

        options.rangeSelector = {
            enabled: true,
            buttons: buttons,
            selected: selected,
            buttonTheme: {
                fill: 'none',
                stroke: 'none',
                style: { 
                    color: '#282828', 
                    fontFamily: ', Arial' 
                },
                states: {
                    hover: { 
                        fill: 'white', 
                        stroke: '#50bfc6'
                    },
                    select: { 
                        fill: '#d7ebf6', 
                        stroke: '#50bfc6'
                    }
                }
            },
            inputEnabled: true,
            inputDateFormat: this.EXT_AXIS_FORMAT[axisType].inputFormat,
            inputEditDateFormat: this.EXT_AXIS_FORMAT[axisType].inputFormat,
            inputStyle: {
                color: '#3784b7',
                fontWeight: 'bold'
            },
            labelStyle: {
                color: '#b0b0b0',
                fontWeight: 'bold'
            }
        };
    }

    /**
     * x
     *  
     * 
     *
     * @private
     */
    function tickPositioner(
        control, axisType, isExtAxisType, useYearMonthAdjust, min, max
    ) {
        var axis = this;
        var tickPositions = [];

        // series
        var firstSeries = axis.series[0];
        if( !firstSeries) {
            return [min, max];
        }

        var ordinalPositions = firstSeries.processedXData;

        // 
        var tmin;
        var tmax;
        var winIndexStart;
        var winIndexEnd;
        var winIndexLength;
        for (
            var i = 0, item, len = ordinalPositions.length;
            i < len; 
            i ++
        ) {
            item = ordinalPositions[i];
            if(item == null) { continue; }

            if (item >= min 
                && (item - min < tmin || typeof tmin == 'undefined')
            ) { 
                winIndexStart = i; 
                tmin = item - min; 
            }
            if (item <= max 
                && (max - item < tmax || typeof tmax == 'undefined')
            ) { 
                winIndexEnd = i; 
                tmax = max - item; 
            }
        }
        if (typeof winIndexEnd == 'undefined' 
            || typeof winIndexStart == 'undefined'
        ) { 
            return [min, max]; 
        }
        winIndexLength = winIndexEnd - winIndexStart + 1;

        // tick
        if (useYearMonthAdjust 
            && axisType == 'date' 
            && (winIndexLength == 365 || winIndexLength == 366)
        ) {
            // 
            // tickdatasource
            // 
            // 0
            var month30 = { '4': 1, '6': 1, '9': 1, '11': 1 }; 
            var d = new Date(ordinalPositions[winIndexEnd]);
            
            var date = d.getDate();
            var month = d.getMonth();
            var year = d.getFullYear();

            while (true) {
                if (month + 1 == 2 && date >= 29) {
                    d = new Date(year, month, 29);
                    if(d.getMonth() + 1 != 2) {
                        d = new Date(year, month, 28);
                    }
                } 
                else if (month + 1 in month30 && date >= 31) {
                    d = new Date(year, month, 30);
                } 
                else {
                    d = new Date(year, month, date);
                }
                if (d.getTime() < ordinalPositions[winIndexStart]) {
                    break;
                }
                tickPositions.splice(0, 0, d.getTime()); 
                (month <= 0) ? (( month = 11) && (year --)) : (month --);
            }
        } 
        else {
            // 
            var splitNumber = control._aXAxis[0].splitNumber == null 
                    ? (isExtAxisType ? 5 : winIndexLength)
                    : control._aXAxis[0].splitNumber;
            var indexInterval = Math.ceil(winIndexLength / splitNumber);

            for (i = winIndexEnd; i >= winIndexStart; i -= indexInterval) {
                tickPositions.splice(0, 0, ordinalPositions[i]);
            }
        }

        return tickPositions;
    };

    function fixByDateRange(date, range) {
        if (!range || !date) { return date; }
        var timestamp = date.getTime();
        if (timestamp < range[0]) {
            return new Date(range[0]);
        }
        else if (range[1] < timestamp) {
            return new Date(range[1]);
        }
        return date;
    }

    function fixChartType(rawType, defaultType) {
        if (rawType == 'bar') {
            // ecom
            return 'column';
        }
        return rawType || defaultType || 'line';
    }

    /**
     * Tooltip
     *
     * @private
     * @param {Array} points 
     * @returns {Array} 
     */
    UI_H_CHART_CLASS.sortPoints = function (points) {
        if (!points) { return null; }

        var newPoints = [];
        
        for (var i = 0, l = points.length; i < l; i++) {
            newPoints.push(points[i]);
        }
        
        return newPoints.sort(
            function (pa, pb) {
                if (!pa) { return -1; }
                if (!pb) { return 1; }
                
                if (pa.y > pb.y) { return -1; }
                else if (pa.y < pb.y) { return 1; }
                else { return 0; }
            }
        );
    };

    /**
     * series
     * _oChart.seriesflagnavigatorseries
     * _aSeriesseries
     * _aSeries.length_oChart.series[i]
     *
     * @protected
     */
    UI_H_CHART_CLASS.$foreachSeries = function (callback) {
        for(var i = 0, len = this._aSeries.length; i < len; i ++) {
            callback(this._oChart.series[i], i);
        }
    };

    /**
     * 
     *
     * @public
     */
    UI_H_CHART_CLASS.render = function () {
        /*
         *  HChart 
         *  HChart   
         * 
         *  HChart 
         *    $createChart 
         *  HChart    
         * 
         * DI_ATTR_PREFIX debugthisdom
         * \x06 di-factory.js 
         *      by xlst(x_l_st@126.com)
         */
        //  hChartOutWrap  HChart  xui-h-chart-header  xui-h-chart-content 
        //  hChartOutWrap 
        var hChartOutWrap = this[DI_ATTR_PREFIX + 'el'];    //  DI_ATTR_PREFIX = '\x06diA^_^'
        if (hChartOutWrap) {    //  
            //  0 min-height 
            hChartOutWrap.style.minHeight = hChartOutWrap.offsetHeight + 'px';
        }
        //    $createChart 
        
        this.$disposeChart();

        if (!this._aSeries || this._aSeries.length == 0) {
            this._eContent.innerHTML = '' 
                + '<div class="' + this._sType + '-empty">' 
                    + this._sEmptyHTML 
                + '</div>';
            return;
        }

        this.$createChart(this.$initOptions()) ;
        
        //   
        if (hChartOutWrap) {
            //   
            hChartOutWrap.style.minHeight = '';
        }
    };

    /**
     * 
     *
     * @public
     */
    UI_H_CHART_CLASS.$createChart = function (options) {
        if (this._aXAxis[0].type in this.EXT_AXIS_FORMAT && !this._bHasPie) {
            // stockchart
            this._oChart = new Highcharts.StockChart(options);
        }
        else {
            this._oChart = new Highcharts.Chart(options);
        }
    };

    /**
     * 
     *
     * @private
     */
    UI_H_CHART_CLASS.$initOptions = function () {
        var options = {
            chart: {
                // type: this._sChartType,
                renderTo: this._eContent,
                zoomType: 'x',
                width: this._nWidth,
                height: this._nHeight
            },
            credits: { enabled: false },
            title: { text: '' }
        };
        if (this._aYAxis.length > 0) {
            options.chart.marginRight = CHART_MARGIN_RIGHT;
        }

        // 
        this._bHasPie = false;
        for (var i = 0, ser; ser = this._aSeries[i]; i ++) {
            if (fixChartType(ser.type) == 'pie') {
                this._bHasPie = true;
            }
        }

        this.$setupSeries(options);
        this.$setupPlotOptions(options);
        this.$setupXAxis(options);
        this.$setupYAxis(options);
        this.$setupTooptip(options);
        this.$setupLegend(options);
        this.$setupZoom(options);
        
        return options;
    };

    /**
     * 
     *
     * @private
     */
    UI_H_CHART_CLASS.$disposeChart = function () {
        if (this._oChart) {
            this._oChart.destroy();
            this._oChart = null;
        }
        this._eContent && (this._eContent.innerHTML = '');
        this._eLegend && (this._eLegend.innerHTML = '');
    };

    /**
     * @override
     */
    UI_H_CHART_CLASS.dispose = function () {
        this.$disposeChart();
        UI_H_CHART.superClass.dispose.call(this);
    };

})();

/**
 * configuration of xutil.ajax
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight (consoleproduct)ajax
 *          
 *          
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil.ajax, di.config.lang
 */

$namespace('di.config');

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var XAJAX = xutil.ajax;
    var isFunction = xutil.lang.isFunction;
    var LANG;
    var DIALOG;
    
    $link(function () {
        LANG = di.config.Lang;
        DIALOG = di.helper.Dialog;
    });

    //--------------------------------
    // 
    //--------------------------------

    var AJAX = $namespace().Ajax = function() {};

    /**
     * 
     */
    AJAX.ERROR_RTPL_ID = 10011; // reportTemplateId 
    AJAX.ERROR_SESSION_TIMEOUT = 10001; // session 
    AJAX.ERROR_PARAM = 20001; // olap

    /**
     * 
     */
    var DEFAULT_OPTIONS = {
        showWaiting: true // ajaxwaiting
    };

    /**
     * ajax
     * 
     * @public
     * @param {number} status ajax
     * @param {Object|string} ejsonObj e-json
     * @param {Function} defaultCase 
     */
    AJAX.handleDefaultFailure = function(status, ejsonObj, defaultCase) {
        switch (status) {
            case 100: // 
            case 201: 
            case 301: // 
            case 302: // 
            case 99999: // 302 ...
                DIALOG.alert(LANG.SAD_FACE + LANG.RE_LOGIN, null, true);
                break;
            case 333: //
                DIALOG.alert(LANG.SAD_FACE + LANG.NO_AUTH_SYSTEM);
                break;
            case 20003: // 
                var dimName = ejsonObj.data.dimName;
                var dimCapture = ejsonObj.data.dimCapture;
                var missedMember = ejsonObj.data.missedMember;
                DIALOG.alert(LANG.SAD_FACE + " "+dimCapture+"("+dimName+"): "+missedMember);
                break;
            case 20004: // 
                var statusInfo = ejsonObj.statusInfo;
                DIALOG.alert(LANG.SAD_FACE + statusInfo);
                break;
            case 1: // html
            case 403: // 403
            case 404: // 404
            case 405: // 405
            case 500: // 500
                DIALOG.alert(LANG.SAD_FACE + LANG.ERROR);
                break;
            default:
                if (isFunction(defaultCase)) {
                    defaultCase(status, ejsonObj);
                } 
                else {
                    DIALOG.alert(LANG.SAD_FACE + LANG.ERROR);
                }
        }
    }

    /**
     * 
     *
     * @protected
     */
    // AJAX.reload = function() {
    //     try {
    //         window.top.location.reload();
    //     } 
    //     catch (e) {
    //         window.location.reload();
    //     }
    // }

    /**
     * timeout
     *
     * @public
     */
    AJAX.handleDefaultTimeout = function() {
        DIALOG.hidePrompt();
    }
    
    /**
     * 
     *
     * @public
     * @return {string} a=5&a=2&b=xxx
     */
    AJAX.getDefaultParam = function() {
        var date = new Date(), paramArr = [];
        paramArr.push('_cltime=' + date.getTime()); // log
        paramArr.push('_cltimezone=' + date.getTimezoneOffset()); // log
        return paramArr.join('&');
    }
    
    /**
     * 
     *
     * @public
     */
    AJAX.showWaiting = function() {
        DIALOG.waitingPrompt(LANG.AJAX_WAITING);
    }
    
    /**
     * 
     *
     * @public
     */
    AJAX.hideWaiting = function() {
        DIALOG.hidePrompt();
    }
        
    /**
     * 
     */
    XAJAX.DEFAULT_FAILURE_HANDLER = AJAX.handleDefaultFailure;
    XAJAX.DEFAULT_ONTIMEOUT = AJAX.handleDefaultTimeout;
    XAJAX.DEFAULT_PARAM =AJAX.getDefaultParam;
    XAJAX.SHOW_WAITING_HANDLER = AJAX.showWaiting;
    XAJAX.HIDE_WAITING_HANDLER = AJAX.hideWaiting;
    XAJAX.DEFAULT_OPTIONS = DEFAULT_OPTIONS;    

})();
/**
 * di.config.Dict
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight (consoleproduct)ajax
 * @author:  xxx(xxx@baidu.com)
 */

$namespace('di.config');

(function() {

    /**
     * DICTrepo-dict.js
     */
    var DICT = $namespace().Dict = function () {
        if (!initialized) {
            // 
            DICT.CLZ = {};
            for (var i = 0, clzDef; clzDef = DICT.CLZ_DEFS[i]; i ++) {
                if (clzDef.clzKey in DICT.CLZ) {
                    throw new Error("dupicate clzKey: " + clzDef.clzKey);
                }
                DICT.CLZ[clzDef.clzKey] = clzDef;
            }
            initialized = true;
        }
        return DICT;
    };

    var initialized = false;

    DICT.DOM_FLAG_BEGIN = '<!-- DI_BEGIN^_^DONT_MODIFY_ME -->';
    DICT.DOM_FLAG_END = '<!-- DI_END^_^DONT_MODIFY_ME -->';
    DICT.RTPL_VIRTUAL = 'RTPL_VIRTUAL';
    DICT.RTPL_VIRTUAL_ID = 'RTPL_VIRTUAL_ID';

    /**
     * 
     */
    DICT.GRAPH_DEFS = [
        { name: 'line', text: '', yAxisNameSet: ['left', 'right'] },
        { name: 'bar', text: '', yAxisNameSet: ['left', 'right'] },
        { name: 'pie', text: '', yAxisNameSet: [] },
        { name: 'beaker', text: '', yAxisNameSet: []}
    ];
    DICT.getGraphByType = function (type) {
        for (var i = 0, o; o = DICT.GRAPH_DEFS[i]; i ++) {
            if (o.name == type) { return o; }
        }
    }

    /** 
     *  reportTemplateType
     */
    DICT.REPORT_TYPE = {
        RTPL_OLAP_TABLE: 1,
        RTPL_OLAP_CHART: 1,
        RTPL_PLANE_TABLE: 1,
        RTPL_VIRTUAL: 1
    };

    /**
     * cssconsole, di.css
     */
    DICT.FLAG_CSS = [
        'di-o_o-body', 
        'di-o_o-block', 
        'di-o_o-line', 
        'di-o_o-item', 
        'di-o_o-space-l1'
    ];

    /**
     * DI 
     */ 
    DICT.PARAM_PREFIX = 'DI_P_';

    /**
     * 
     */
    DICT.VTPL_ROOT = 'asset-d';

    /**
     * 
     */
    DICT.MOLD_PATH = 'asset-d/-com-/mold';

    /**
     * 
     */
    DICT.DEFAULT_MASK_OPACITY = 0.5;

    /**
     * di snippetattr
     */
    DICT.DI_ATTR = 'data-o_o-di';

    /**
     * id
     */
    DICT.TEST_ATTR = 'data-o_o-di-test';

    /**
     * 
     */
    DICT.META_STATUS = {
        DISABLED: 0,
        NORMAL: 1,
        SELECTED: 2
    };

})();
/**
 * di.config.Lang
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight (consoleproduct)
 * @author:  xxx(xxx@baidu.com)
 */

$namespace('di.config');

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var LANG = $namespace().Lang = {};
    var template = xutil.string.template;

    /**
     * ajax
     */
    LANG.AJAX_FAILURE = function (status) {
        return status + ' SERVER ERROR';
    };

    LANG.AJAX_TIMEOUT = '';
    LANG.AJAX_WAITING = '...';
    
    LANG.SMILE_FACE = '&nbsp;<div class="global-smile-face"></div>&nbsp;&nbsp;&nbsp;';
    LANG.SAD_FACE = '&nbsp;<div class="global-sad-face"></div>&nbsp;&nbsp;&nbsp;';
    
    LANG.OTHER_EDITING = function (otherEditing) {
        var stl = ' style="color: blue; font-weight: bold;" ';
        var tpl = [
            '<p></p>',
            '<p>#{0}</p>',
            '<p><span ', stl, '></span></p>'
        ];
        return template(
            tpl.join(''),
            ' "<span ' + stl + '>' + otherEditing.join('</span>", "<span ' + stl + '>') + '</span>" '
        );
    };
    LANG.SOME_ERROR = '';
    LANG.NEED_CREATE = '';
    LANG.OPT_SUCCESS = '';
    LANG.NO_SEL = '';
    LANG.NO_DATA = '';
    LANG.NO_AUTH = '';
    LANG.NO_AUTH_OPERATION = '';
    LANG.NO_AUTH_SYSTEM = '';
    LANG.ERROR = '';
    LANG.DATA_ERROR = '';
    LANG.ERROR_RTPL_ID = 'reportTemplateId';
    LANG.RE_LOGIN = '';
    LANG.EMPTY_TEXT = '';
    LANG.QUERY_ERROR_TEXT = '';
    LANG.SAVE_FAIL = '';
    LANG.SAVE_SUCCESS = '';
    LANG.PARAM_ERROR = '';
    LANG.FATAL_DATA_ERROR = '';
    
    LANG.INPUT_MANDATORY = '';
    LANG.INVALID_FORMAT = '';
    LANG.NUMBER_OVERFLOW = '';
    LANG.NUMBER_UNDERFLOW = '';
    LANG.TEXT_OVERFLOW = '';
    LANG.DOWNLOAD_FAIL = '';
    LANG.OFFLINE_DOWNLOAD_FAIL = '';
    LANG.DELETE_SUCCESS = '';

    LANG.GET_DIM_TREE_ERROR = '';
    LANG.NEED_DS_ALL_LINKED = '';

    LANG.CONFIRM_ADD_SHARE = '';
    LANG.CONFIRM_REMOVE_SHARE = '';
    LANG.CONFIRM_DELETE = '';

    LANG.DIM_MANDATORY = '';

    LANG.DESC_OVERFLOW = '';
    LANG.DESC_MANDATORY = '';
    LANG.PLAN_OVERFLOW = '';
    LANG.PLAN_MANDATORY = '';
    LANG.REASON_ADD_ERROR = '';

    LANG.DRILL_DIM_DATA_ERROR = '[]';

    LANG.WAITING_HTML = '<span class="waiting-icon"></span>&nbsp;<span class="waiting-text">...</span>';

    //----------------------------------------------
    // 
    //----------------------------------------------

    LANG.TIME_DESC = [
        '<div style="border: 1px solid #BBB; padding: 10px;margin-top: 10px; border-radius: 5px;">',
            '<div style="font-weight: bold">&nbsp;&nbsp;</div>',
            '<br />',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;["-1D"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;["-6D", "0D"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;["0MB", "0D"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;2013-09-20["0WE", "2013-09-20"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;["-1QB", "+1YE"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;["+2D", null, "+1M"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;[null, "-1D", "0MB"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<br />',
            '<br />',
            '<div style="font-weight: bold">&nbsp;&nbsp;</div>',
            '<br />',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;     </div>',
            '<div style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;["0YB"]  ["2012-12-12", "5Q"]  ["-5ME", null, "6D"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2012-12-12</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-5d</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;startend-4d</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startendrange</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startendrange</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startstart</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start+1MErange+5WB</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5</div>',
            '<br />',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<div style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YMDWQ</div>',
            '<div style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B/EB/E</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2012-05-09</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"+4D"42012-05-13 </div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-2M"22012-03-13</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"2Q"22012-11-13</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1W"12012-05-20</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1WB"12012-05-14</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-1WE"2012-05-06</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"0WE"2012-05-13</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;yyyy-MM-dd</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>',
            '<br />',
        '</div>'   
    ].join(''); 

    LANG.X_CALENDAR_DESC = template([
        '<div style="border: 1px solid #BBB; padding: 10px;margin-top: 10px; border-radius: 5px;">',
            '<div style="font-weight: bold">&nbsp;&nbsp;</div>',
            '<br />',
            '<div>#{0}{</div>',
            '<div>#{0}#{0}"forbidEmpty": false,</div>',
            '<div>#{0}#{0}"disableCancelBtn": false,</div>',
            '<div>#{0}#{0}"timeTypeList": [</div>',
            '<div>#{0}#{0}#{0}{ "value": "D", "text": "" },</div>',
            '<div>#{0}#{0}#{0}{ "value": "W", "text": "" },</div>',
            '<div>#{0}#{0}#{0}{ "value": "M", "text": "" },</div>',
            '<div>#{0}#{0}#{0}{ "value": "Q", "text": "" }</div>',
            '<div>#{0}#{0}],</div>',
            '<div>#{0}#{0}"timeTypeOpt": {</div>',
            '<div>#{0}#{0}#{0}"D": {</div>',
            '<div>#{0}#{0}#{0}#{0}"selMode": "SINGLE",</div>',
            '<div>#{0}#{0}#{0}#{0}"date": ["-31D", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"range": ["2011-01-01", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"selModeList": [</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "", "value": "SINGLE", "prompt": "" }</div>',
            '<div>#{0}#{0}#{0}#{0}]</div>',
            '<div>#{0}#{0}#{0}},</div>',
            '<div>#{0}#{0}#{0}"W": {</div>',
            '<div>#{0}#{0}#{0}#{0}"selMode": "RANGE",</div>',
            '<div>#{0}#{0}#{0}#{0}"date": ["-31D", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"range": ["2011-01-01", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"selModeList": [</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "", "value": "SINGLE", "prompt": "" },</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "", "value": "RANGE", "prompt": "" }</div>',
            '<div>#{0}#{0}#{0}#{0}]</div>',
            '<div>#{0}#{0}#{0}},</div>',
            '<div>#{0}#{0}#{0}"M": {</div>',
            '<div>#{0}#{0}#{0}#{0}"selMode": "MULTIPLE",</div>',
            '<div>#{0}#{0}#{0}#{0}"date": ["-31D", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"range": ["2011-01-01", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"selModeList": [</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "", "value": "SINGLE", "prompt": "" },</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "", "value": "RANGE", "prompt": "" }</div>',
            '<div>#{0}#{0}#{0}#{0}]</div>',
            '<div>#{0}#{0}#{0}},</div>',
            '<div>#{0}#{0}#{0}"Q": {</div>',
            '<div>#{0}#{0}#{0}#{0}"selMode": "SINGLE",</div>',
            '<div>#{0}#{0}#{0}#{0}"date": ["-31D", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"range": ["2011-01-01", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"selModeList": [</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "", "value": "SINGLE", "prompt": "" }</div>',
            '<div>#{0}#{0}#{0}#{0}]</div>',
            '<div>#{0}#{0}#{0}}</div>',
            '<div>#{0}#{0}}</div>',
            '<div>#{0}}</div>',
        '</div>'   
    ].join(''), Array(4).join('&nbsp;'));

})();
/**
 * repo dict
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    buidlfrontrepo.js
 * @author:  sushuang(sushuang@baidu.com)
 */

(function() {

    var DICT = $namespace('di.config').Dict;
    var extend = xutil.object.extend;
    var isArray = xutil.lang.isArray;

    var repoDict =

        //==[DI=BEGIN]==[NIGEB=ID]=========
        // 
        //=================================

        {
            /**
             * clzKey
             */
            "DEFAULT_CLZ_KEY": {
                "SNIPPET": "GENERAL_SNIPPET",
                "VCONTAINER": "GENERAL_VCONTAINER",
                "VPART": "GENERAL_VPART",
                "COMPONENT": "GENERAL_COMPONENT"
            },

            /**
             * 
             * 
             * (1") adapterMethod"di.shared.adapter."GeneralAdapterMethod"
             * (2) ""adapterPath"adapteradapterMethod"
             */
            "CLZ_DEFS": [

                //-------------------------------
                // SNIPPET
                //-------------------------------

                {
                    "clzKey": "GENERAL_SNIPPET",
                    "clzPath": "di.shared.ui.GeneralSnippet",
                    "clzType": "SNIPPET"
                },

                //-------------------------------
                // VPART
                //-------------------------------

                {
                    "clzKey": "GENERAL_VPART",
                    "clzPath": "di.shared.ui.GeneralVPart",
                    "clzType": "VPART"
                },

                //-------------------------------
                // COMPONENT
                //-------------------------------

                {
                    "clzKey": "GENERAL_COMPONENT",
                    "clzPath": "di.shared.ui.InteractEntity",
                    "clzType": "COMPONENT"
                },
                {
                    "clzKey": "DI_TABLE",
                    "clzPath": "di.shared.ui.DITable",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_TABLE"]
                },
                {
                    "clzKey": "DI_RTPLCLONE",
                    "clzPath": "di.shared.ui.DIRtplClone",
                    "clzType": "COMPONENT"
                },
                {
                    "clzKey": "DI_PLANE_TABLE",
                    "clzPath": "di.shared.ui.DIPlaneTable",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_PLANE_TABLE"]
                },
                {
                    "clzKey": "DI_CHART",
                    "clzPath": "di.shared.ui.DIChart",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_CHART"]
                },
                {
                    "clzKey": "DI_LITEOLAP_CHART",
                    "clzPath": "di.shared.ui.DILiteOlapChart",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_TABLE"]
                },
                {
                    "clzKey": "DI_FORM",
                    "clzPath": "di.shared.ui.DIForm",
                    "clzType": "COMPONENT",
                    "vuiRefCandidate": {
                        "input": [
                            "HIDDEN_INPUT", 
                            "DAY_POP_CALENDAR", 
                            "RANGE_POP_CALENDAR", 
                            "CALENDAR_PLUS", 
                            "X_CALENDAR", 
                            "ECUI_SELECT", 
                            "ECUI_MULTI_SELECT", 
                            "ECUI_INPUT_TREE", 
                            "ECUI_SUGGEST", 
                            "ECUI_INPUT",
                            "MULTI_CHECKBOX"
                        ],
                        "confirm": [
                            "BUTTON",
                            "H_BUTTON"
                        ]
                    }
                },
                {
                    "clzKey": "OLAP_META_CONFIG",
                    "clzPath": "di.shared.ui.OlapMetaConfig",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_TABLE", "RTPL_OLAP_CHART"]
                },
                {
                    "clzKey": "LITEOLAP_META_CONFIG",
                    "clzPath": "di.shared.ui.LiteOlapMetaConfig",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_TABLE", "RTPL_OLAP_CHART"]
                },

                //-------------------------------
                // VCONTAINER
                //-------------------------------

                {
                    "clzKey": "GENERAL_VCONTAINER",
                    "clzPath": "di.shared.ui.GeneralVContainer",
                    "clzType": "VCONTAINER"
                },
                {
                    "clzKey": "DI_TAB",
                    "clzPath": "di.shared.ui.DITab",
                    "clzType": "VCONTAINER"
                },
                {
                    "clzKey": "FOLD_PANEL",
                    "clzPath": "di.shared.ui.FoldPanel",
                    "clzType": "VCONTAINER"
                },

                //-------------------------------
                // VUI
                //-------------------------------

                {
                    "clzKey": "HIDDEN_INPUT",
                    "clzPath": "di.shared.vui.HiddenInput",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "clzType": "VUI",
                    "rtplParamHandler": [
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4SimpleTextImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4SuggestTextImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TreeImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4HttpTreeImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxTransferImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4HiddenPosImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeFromOutsideImpl"
                    ],
                    "caption": ""
                },
                {
                    "clzKey": "H_CHART",
                    "clzPath": "xui.ui.HChart",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "adapterPath": "di.shared.adapter.HChartVUIAdapter",
                    "clzType": "VUI",
                    "caption": ""
                },
                {
                    "clzKey": "OLAP_META_DRAGGER",
                    "clzPath": "di.shared.vui.OlapMetaDragger",
                    "clzType": "VUI",
                    "adapterPath": "di.shared.adapter.MetaConfigVUIAdapter",
                    "caption": "OLAP"
                },
                {
                    "clzKey": "TEXT_LABEL",
                    "clzPath": "di.shared.vui.TextLabel",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "caption": ""
                },
                {
                    "clzKey": "OLAP_META_IND_SELECT",
                    "clzPath": "di.shared.vui.OlapMetaSelect",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "adapterPath": "di.shared.adapter.MetaConfigVUIAdapter",
                    "dataOpt": {
                        "ctrlClz": "ecui.ui.Select",
                        "optionSize": 15
                    },
                    "caption": "OLAP"
                },
                {
                    "clzKey": "OLAP_META_IND_MULTI_SELECT",
                    "clzPath": "di.shared.vui.OlapMetaSelect",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "adapterPath": "di.shared.adapter.MetaConfigVUIAdapter",
                    "dataOpt": {
                        "ctrlClz": "ecui.ui.MultiSelect",
                        "optionSize": 15
                    },
                    "caption": "OLAP"
                },
                {
                    "clzKey": "DAY_POP_CALENDAR",
                    "clzPath": "ecui.ui.IstCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.IstCalendarVUIAdapter",
                    "dataOpt": {
                        "mode": "DAY",
                        "viewMode": "POP"
                    },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                    "caption": ""
                },
                {
                    "clzKey": "RANGE_POP_CALENDAR",
                    "clzPath": "ecui.ui.IstCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.IstCalendarVUIAdapter",
                    "dataOpt": {
                        "mode": "RANGE",
                        "viewMode": "POP"
                    },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                    "caption": ""
                },
                {
                    "clzKey": "CALENDAR_PLUS",
                    "clzPath": "ecui.ui.CalendarPlus",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.CalendarPlusVUIAdapter",
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                    "editorDisable": true,
                    "caption": ""
                },
                {
                    "clzKey": "X_CALENDAR",
                    "clzPath": "ecui.ui.XCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.XCalendarVUIAdapter",
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                    "caption": ""
                },
                {
                    "clzKey": "OLAP_TABLE",
                    "clzPath": "ecui.ui.OlapTable",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "dataOpt": { "defaultCCellAlign": "right" },
                    "caption": "/"
                },
                {
                    "clzKey": "BEAKER_CHART",
                    "clzPath": "ecui.ui.BeakerChart",
                    "clzType": "VUI",
                    "adapterPath": "di.shared.adapter.BeakerChartVUIAdapter",
                    "caption": ""
                },
                {
                    "clzKey": "BREADCRUMB",
                    "clzPath": "ecui.ui.Breadcrumb",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "caption": ""
                },
                {
                    "clzKey": "BUTTON",
                    "clzPath": "ecui.ui.Button",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "caption": ""
                },
                {
                    "clzKey": "H_BUTTON",
                    "clzPath": "ecui.ui.HButton",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "caption": ""
                },
                {
                    "clzKey": "OFFLINE_DOWNLOAD",
                    "clzPath": "di.shared.vui.OfflineDownload",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "dataOpt": {
                        "headText": "",
                        "confirmText": "",
                        "cancelText": "",
                        "text": "1"
                    },
                    "caption": ""
                },
                {
                    "clzKey": "SWITCH_BUTTON",
                    "clzPath": "ecui.ui.SwitchButton",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "caption": ""
                },
                {
                    "clzKey": "ECUI_SELECT",
                    "clzPath": "ecui.ui.Select",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiSelectVUIAdapter",
                    "dataOpt": {
                        "optionSize": 15
                    },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl",
                    "caption": ""
                },
                {
                    "clzKey": "ECUI_MULTI_SELECT",
                    "clzPath": "ecui.ui.MultiSelect",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiSelectVUIAdapter",
                    "dataOpt": {
                        "optionSize": 15
                    },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl",
                    "caption": ""
                },
                {
                    "clzKey": "ECUI_INPUT_TREE",
                    "clzPath": "ecui.ui.InputTree",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiInputTreeVUIAdapter",
                    "rtplParamHandler": [
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TreeImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4HttpTreeImpl"
                    ],
                    "caption": ""
                },
                {
                    "clzKey": "ECUI_SUGGEST",
                    "clzPath": "ecui.ui.Suggest",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiSuggestVUIAdapter",
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4SuggestTextImpl",
                    "caption": ""
                },
                {
                    "clzKey": "ECUI_INPUT",
                    "clzPath": "ecui.ui.Input",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4SimpleTextImpl",
                    "caption": ""
                },
                {
                    "clzKey": "MULTI_CHECKBOX",
                    "clzPath": "di.shared.vui.MultiCheckbox",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "clzType": "VUI",
                    "rtplParamHandler": [
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl"
                    ],
                    "caption": ""
                },
                {
                    "clzKey": "ECUI_SLOW_PLANE_TABLE",
                    "clzPath": "ecui.ui.CustomTable",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiCustomTableVUIAdapter",
                    "caption": ""
                },
                {
                    "clzKey": "ECUI_PAGER",
                    "clzPath": "ecui.ui.ExtPager",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiPagerVUIAdapter",
                    "caption": ""
                }
            ]

        }

        //==[DI=END]==[DNE=ID]=============
        // 
        //=================================

    ;
    extend(DICT, repoDict);

    /**
     * 
     */
    DICT.CLZ = {};
    for (var i = 0, clzDef; clzDef = DICT.CLZ_DEFS[i]; i ++) {
        if (clzDef.clzKey in DICT.CLZ) {
            throw new Error('dupicate clzKey: ' + clzDef.clzKey);
        }
        DICT.CLZ[clzDef.clzKey] = clzDef;
        
        // 
        var handlers = clzDef.rtplParamHandler = clzDef.rtplParamHandler || [];
        if (!isArray(handlers)) {
            clzDef.rtplParamHandler = [handlers];
        }
    }

    /**
     * @public
     */
    DICT.findClzDef = function (clzKey, clzType) {
        for (var i = 0, def; def = DICT.CLZ_DEFS[i]; i ++) {
            if (def.clzKey == clzKey && def.clzType == clzType) {
                return def;
            }
        }
    };

    /**
     * @public
     */
    DICT.hasReportTemplateType = function (clzKey, reportTemplateType) {
        var cmpt = DICT.findClzDef(clzKey, 'COMPONENT');
        if (!cmpt) {
            return false;
        }

        // reportTemplateType
        if (!cmpt.reportTemplateTypeCandidate) {
            return true;
        }

        for (var i = 0, type; type = cmpt.reportTemplateTypeCandidate[i]; i ++) {
            if (reportTemplateType == type) {
                return true;
            }
        }

        return false;
    };

})();
/**
 * di.config.URL
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight (consoleproduct)URL
 * @author:  sushuang(sushuang@baidu.com)
 */
$namespace('di.config');

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var xextend = xui.XDatasource.extend;

    //--------------------------------
    // 
    //--------------------------------

    /**
     * URLWEB_ROOT
     * web, _TMP_WEB_ROOT_
     *
     * @usage 
     *      kt.config.URL.SOME_TABLE_QUERY = '/some/table.action';
     *      url kt.config.URL('SOME_TABLE_QUERY'); 
     * @param {string} urlAttr url
     * @return {string} url
     */
    var URL = $namespace().URL = function(urlConst) {
        var url = URL_SET[urlConst];
        if (!url) {
            throw new Error('empty url!');
        }
        return URL.getWebRoot() + url;
    };

    URL.fn = function (urlConst) {
        return xutil.fn.bind(URL, null, urlConst);
    };

    var URL_SET = {};
    var webRoot;

    /**
     * web base
     * 
     * @public
     * @return {string} web base
     */
    URL.getWebRoot = function() {
        return webRoot || $getNamespaceBase().WEB_ROOT || '';
    };

    URL.setWebRoot = function(root) {
        webRoot = root;
    };

    /**
     * URL
     * 
     * @public
     * @param {string} URL
     */
    URL.addURL = function(name, url) {
        // 
        if (URL_SET[name]) {
            throw new Error('Duplicate URL! name=' + name + ' url=' + url);
        }

        // 
        URL_SET[name] = url;
    };

    URL.changeURL = function(name, url) {
        URL_SET[name] = url;
    };

    //--------------------------------
    // URL
    //--------------------------------  

    // 
    URL_SET.OLAP_REPORT_INIT = '/reportTemplate/initReportTemplate.action';
    URL_SET.CONSOLE_SAVE_TPL = '/manage/virtualTemplate/saveVirtualTemplate.action';
    URL_SET.CONSOLE_GET_COND = '/manage/virtualTemplate/getSelectableConditions.action';
    URL_SET.CONSOLE_EXIST_COND = '/manage/virtualTemplate/getSelectedConditions.action';    
    URL_SET.CONSOLE_VTPL_LIST = '/manage/virtualTemplate/getVirtualTemplateInfo.action';
//    URL_SET.CONSOLE_MOLD_LIST = '/manage/moldTemplate/getMoldTemplates.action';
    URL_SET.CONSOLE_DS_LIST = '/manage/virtualTemplate/getReportTemplates.action';
    URL_SET.CONSOLE_TO_PRE = '/manage/publish/publishToPre.action';
    URL_SET.CONSOLE_TO_RELEASE = '/manage/publish/publishToRelease.action';
    URL_SET.OLAP_SAVE = '/reportTemplate/save.action';


    // PlaneTable
    URL_SET.PLANE_TABLE_INIT = '/reportTemplate/planeTable/init.action';
    URL_SET.PLANE_TABLE_SQL_SAVE = '/reportTemplate/planeTable/create.action';
    URL_SET.PLANE_TABLE_COL_DATA = '/reportTemplate/planeTable/doMapColumns.action';
    URL_SET.PLANE_TABLE_COL_SAVE = '/reportTemplate/planeTable/saveColumns.action';
    URL_SET.PLANE_TABLE_COND_DATA = '/reportTemplate/planeTable/doMapConds.action';
    URL_SET.PLANE_TABLE_COND_SAVE = '/reportTemplate/planeTable/saveConds.action';
    URL_SET.PLANE_TABLE_PREVIEW_DATA = '/reportTemplate/planeTable/doMapPreview.action';
    // 
    // @param reportTemplateId
    // @param AAAfromURL=12345&BBBfromURL=67899&showColumns=AAAfromURL&showColumns=BBBfromURL& ...
    // @return {  }
    // URL_SET.PLANE_TABLE_DATA = '/reportTemplate/planeTable/preview.action';

    // cube tree
    URL_SET.CUBE_META = '/meta/getCubeTree.action';
    // plane table
    URL_SET.DATASOURCE_META = '/reportTemplate/planeTable/getDs.action';

    // 
    URL_SET.DIM_TREE_TABLE = '/reportTemplate/table/getDimTree.action';
    URL_SET.DIM_TREE_CHART = '/reportTemplate/chart/getDimTree.action';

    URL_SET.DIM_MULTISELECT_TABLE = '/reportTemplate/table/getDimMultiSelect.action';
    URL_SET.DIM_MULTISELECT_CHART = '/reportTemplate/chart/getDimMultiSelect.action';
    
    URL_SET.DIM_SELECT_SAVE_TABLE = '/reportTemplate/table/updateDimNodes.action';
    URL_SET.DIM_SELECT_SAVE_CHART = '/reportTemplate/chart/updateDimNodes.action';

    // 
    URL_SET.MEASURE_DES = '/reportTemplate/table/getMeasureDescription.action';
    URL_SET.META_CONDITION_IND_DIM_TABLE = '/reportTemplate/table/getMetaData.action';
    URL_SET.LITEOLAP_INDS_META_DATA = '/reportTemplate/liteolap/getCurrentAnalysisInds.action';
    URL_SET.META_CONDITION_IND_DIM_CHART = '/reportTemplate/chart/getMetaData.action';
    URL_SET.META_CONDITION_SELECT_TABLE = '/reportTemplate/table/dragAndDrop.action';
    URL_SET.META_CONDITION_SELECT_CHART = '/reportTemplate/chart/dragAndDrop.action';
    URL_SET.META_CONDITION_LIST_SELECT_CHART = '/reportTemplate/chart/selectInd.action'; // list
    URL_SET.META_CONDITION_LIST_SELECT_TABLE = '/reportTemplate/table/selectInd.action'; // list
    URL_SET.META_CONDITION_COL_CONFIG_GET = '/reportTemplate/table/COLCONFIGGET.action'; // list
    URL_SET.META_CONDITION_COL_CONFIG_SUBMIT = '/reportTemplate/table/COLCONFIGGET.action'; // list
    URL_SET.META_CONDITION_CANDIDATE_INIT = '/reportTemplate/configure/getTemplateMeta.action ';
    URL_SET.META_CONDITION_CANDIDATE_SUBMIT = '/reportTemplate/configure/setTemplateMeta.action ';
    URL_SET.META_CONDITION_ADD_SERIES_GROUP = '/reportTemplate/chart/addSeriesUnit.action';
    URL_SET.META_CONDITION_REMOVE_SERIES_GROUP = '/reportTemplate/chart/removeSeriesUnit.action';
    // 
    URL_SET.CONSOLE_CHART_CONFIG_INIT = '/reportTemplate/chart/getChartSettings.action';
    URL_SET.CONSOLE_CHART_CONFIG_SUBMIT = '/reportTemplate/chart/updateChartSettings.action';

    // 
    URL_SET.FORM_DATA = '/reportTemplate/initParams.action';
    URL_SET.FORM_ASYNC_DATA = '/reportTemplate/interactParam.action';

    // PIVOIT
    URL_SET.OLAP_TABLE_DATA = '/reportTemplate/table/transform.action';
    URL_SET.OLAP_TABLE_DRILL = '/reportTemplate/table/drill.action';
    URL_SET.OLAP_TABLE_LINK_DRILL = '/reportTemplate/table/drillByLink.action';
    URL_SET.OLAP_TABLE_SORT = '/reportTemplate/table/sort.action';
    URL_SET.OLAP_TABLE_CHECK = '/reportTemplate/table/checkRow.action';
    URL_SET.OLAP_TABLE_SELECT = '/reportTemplate/table/selectRow.action';
    URL_SET.OLAP_TABLE_DOWNLOAD = '/reportTemplate/table/download.action';
    URL_SET.OLAP_TABLE_OFFLINE_DOWNLOAD = '/reportTemplate/table/downloadOffLine.action';
    URL_SET.OLAP_TABLE_LINK_BRIDGE = '/reportTemplate/table/linkBridge.action';

    // PLANE
    URL_SET.PLANE_TABLE_DATA = '/reportTemplate/planeTable/transform.action';
    URL_SET.PLANE_TABLE_CHECK = '/reportTemplate/planeTable/checkRow.action';
    URL_SET.PLANE_TABLE_SELECT = '/reportTemplate/planeTable/selectRow.action';
    URL_SET.PLANE_TABLE_DOWNLOAD = '/reportTemplate/planeTable/download.action';
    URL_SET.PLANE_TABLE_DOWNLOADEXCEL = '/reportTemplate/planeTable/downloadExcel.action';
    URL_SET.PLANE_TABLE_OFFLINE_DOWNLOAD = '/reportTemplate/planeTable/downloadOffLine.action';
    URL_SET.PLANE_TABLE_LINK_BRIDGE = '/reportTemplate/planeTable/linkBridge.action';

    // 
    URL_SET.OLAP_CHART_DATA = '/reportTemplate/chart/transform.action';
    // liteOlap
    URL_SET.LITEOLAP_CHART_DATA = '/reportTemplate/liteolap/generateAnalysisChart.action';
    URL_SET.OLAP_CHART_X_DATA = '/reportTemplate/chart/reDraw.action';
    URL_SET.OLAP_CHART_S_DATA = '/reportTemplate/chart/reDrawSeries.action'; // 
    URL_SET.OLAP_CHART_S_ADD_DATA = '/reportTemplate/chart/addChartSeries.action'; // 
    URL_SET.OLAP_CHART_S_REMOVE_DATA = '/reportTemplate/chart/removeChartSeries.action'; // 
    URL_SET.OLAP_CHART_BASE_CONFIG_INIT = '/reportTemplate/chart/config.action';
    URL_SET.OLAP_CHART_BASE_CONFIG_SUBMIT = '/reportTemplate/chart/config.action';
    URL_SET.OLAP_CHART_DOWNLOAD = '/reportTemplate/chart/download.action';
    URL_SET.OLAP_CHART_OFFLINE_DOWNLOAD = '/reportTemplate/chart/downloadOffLine.action';

    // 
    URL_SET.REPORT_PREVIEW = '/reportTemplate/complex/generateReport.action';
    // URL_SET.REPORT_PREVIEW = '/asset-d/ditry/dev/try-standard.html';

    // 
    URL_SET.ROWHEAD_CONFIG_INIT = '/reportTemplate/table/rowHeadConfig/getDrillTypeConfig.action';
    URL_SET.ROWHEAD_CONFIG_SUBMIT = '/reportTemplate/table/rowHeadConfig/setRowHeadDrillTypes.action';

    // 
    URL_SET.DIMSHOW_CONFIG_INIT = '/reportTemplate/table/rowHeadConfig/getDimShowConfig.action';
    URL_SET.DIMSHOW_CONFIG_SUBMIT = '/reportTemplate/table/rowHeadConfig/setDimShowConfig.action';

	//KEY
    URL_SET.GET_TEMPLATE_INFO = '/reportTemplate/configure/getTemplateInfo.action';

    //
    URL_SET.DATA_FORMAT_SET = '/reportTemplate/data/setDataFormat.action';

    //RMkey
    URL_SET.REPORT_ROWMERGE_KEY_SUBMIT = '/reportTemplate/updateProperties.action';
    //url
    URL_SET.REPORT_QUERY = '/myview/queryReportList.action';
    //moldurl
    URL_SET.MOLD_QUERY = '/manage/moldTemplate/getMoldTemplates.action';
    //moldurl
    URL_SET.PAHNTOMJS_INFO = '/myview/getPhantomJsInfo.action';
    //url
    URL_SET.RTPL_CLONE_SAVE = '/image/delAndAddImage.action';
    URL_SET.RTPL_CLONE_GETDEFAULTIMAGENAME = '/image/getDefaultImageName.action';
    URL_SET.RTPL_CLONE_CLEAR = '/image/deleteImage.action';
})();
/**
 * di.helper.Dialog
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:     
 *           ( rigel.layertipprompt)
 * @author:  sushuang(sushuang@baidu.com)
 * @depends: ecui
 */

$namespace('di.helper');

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    // FIXME 
    // ecui
    var ui = ecui;
    var encodeHTML = xutil.string.encodeHTML;
    var LANG;
    var UTIL;
    var DICT;
    var DI_FACTORY;

    $link(function() {
        LANG = di.config.Lang;
        DICT = di.config.Dict;
        UTIL = di.helper.Util;
        DI_FACTORY = di.shared.model.DIFactory;
    });

    //--------------------------------
    // 
    //--------------------------------

    var DIALOG = $namespace().Dialog = {};
    
    var ePrompt = null;
    var bPromptMask = false;
    var promptTimer = null;
    //  iframe
    var bAdjustDialogPosition = false;
    bAdjustDialogPosition = true; //  TODO 

    DIALOG.prompt = function () {
        prompt.apply(this, arguments);
    };
    DIALOG.waitingPrompt = function () {
        waitingPrompt.apply(this, arguments);
    };
    DIALOG.hidePrompt = function () {
        hidePrompt.apply(this, arguments);
    };

    /**
     * prompt
     *
     * @public
     * @param {Object} def 
     * @param {string} def.anchor 
     *      'I'internaliframe
     *      'E'externaliframewindow
     * @param {string} diAgent stub
     */
    DIALOG.setPromptDef = function(def, diAgent) {
        if (diAgent == 'STUB' && def && def.anchor == 'E') {
            // 
            // FIXME
            prompt = getRemoteDelegation('prompt');
            hidePrompt = getRemoteDelegation('hideprompt');
            waitingPrompt = getRemoteDelegation('waitingprompt');
        }
    };

    /**
     * prompt
     *
     * @public
     */
    function getRemoteDelegation(eventName) {
        return function() {
            var eventChannel = DI_FACTORY().getEventChannel();
            if (eventChannel) {
                eventChannel.triggerEvent(eventName, arguments);
            }
        };
    };

    /**
     *  
     * setPromptDef by xlst
     * 
     * @public
     * @param {Object} def 
     * @param {string='I'} def.anchor 
     *      'I'internaliframe
     *      'E'externaliframewindow
     * @param {string} diAgent stub
     */
    DIALOG.setAdjustDialogPosition = function(def, diAgent) {
        if (diAgent == 'STUB') {
            
            //  bAdjustDialogPositionshowDialog
            if (def && def.anchor == 'E') {
                bAdjustDialogPosition = true;
            }
            else if (def && def.anchor == 'I') {
                bAdjustDialogPosition = false;
            }
        }
    };

    /**
     * 
     *
     * @public
     * @param {string} text 
     * @param {boolean} mask 
     * @param {number} timeout 
     */
    function prompt(text, mask, timeout) {
        var win;
        try {
            // win = window.top;
            win = window;
            // TODO
            // iframetopdomtop
        } 
        catch (e) {
        }
        
        var x = UTIL.getScrollLeft(win) + UTIL.getViewWidth(win) / 2;
        var y = 5;

        if(!ePrompt) {
            ePrompt = document.createElement('div');
            ePrompt.style.cssText = 'display:none;position:fixed;*position:absolute';
            ePrompt.className = 'global-prompt';
            document.body.appendChild(ePrompt);
        }

        clearPromptTimer();

        if(ePrompt.style.display == '') {
            return false;
        }

        ePrompt.innerHTML = text;
        ePrompt.style.display = '';
        ePrompt.style.left = x - ePrompt.offsetWidth / 2 + 'px';
        ePrompt.style.top = y + 'px';
        if(mask) {
            ui.mask(0);
            bPromptMask = true;
        }

        if (timeout) {
            promptTimer = setTimeout(
                function () {
                    DIALOG.hidePrompt();
                }, 
                timeout
            );
        }
        return true;        
    };

    /**
     * 
     *
     * @public
     * @param {string} text 
     * @param {boolean} mask 
     * @param {number} timeout 
     */
    function waitingPrompt(text) {
        if (text == null) {
            text = LANG.AJAX_WAITING;
        }
        text = [
            '<div class="global-prompt-waiting"></div>',
            '<div class="global-prompt-waiting-text">', text, '</div>'
        ].join('');
        DIALOG.prompt(text);
    }
    
    /**
     * 
     *
     * @public
     * @param {string} messag 
     * @param {boolean} 
     * @param {number} timeout 
     */
    function hidePrompt() {
        clearPromptTimer();
        ePrompt.style.display = 'none';
        if(bPromptMask) {
            bPromptMask = false;
            ui.mask();
        }
    };
        
    function clearPromptTimer() {
        if (promptTimer) {
            clearTimeout(promptTimer);
            promptTimer = null;
        }
    }

    /**
     * 
     *
     * @public
     * @param {string} text 
     * @param {string} title 
     * @param {Array.<Object>} buttons 
     *      {string} text 
     *      {string} className cssClassName
     *      {Function} action 
     * @param {number=} mask mask
     */
    DIALOG.showDialog = function(text, title, buttons, mask) {
        ui.$messagebox(text, title, buttons, mask);
        
        //   setAdjustDialogPosition  ui-messagebox 
        if (bAdjustDialogPosition) {
            var dialogElement = xutil.dom.q('ui-messagebox')[0];
            
            if (dialogElement) {
                DIALOG.adjustDialogPosition(dialogElement);
            }
        }
    };
    
    /**
     * 
     *
     * @public
     * @param {HTMLElement} dialogElement html
     */
    DIALOG.adjustDialogPosition = function (dialogElement) {
        //  try-catch
        try {
            //  window
            window.frameElement.getBoundingClientRect();
        }
        catch (e) {
            //   
            return;
        }
        
        /*
         * 
         * dialogElement.style.top =
         *     window.parent.scrollY
         *     - (window.frameElement.getBoundingClientRect().top + window.parent.scrollY)
         *     + (window.parent.innerHeight-dialogElement.offsetHeight) / 2
         * 
         * window.parent.scrollY 
         * window.frameElement.getBoundingClientRect().top + window.parent.scrollY
         *   iframedi-stub
         * (window.parent.innerHeight-dialogElement.offsetHeight) / 2
         *    top
         * 
         * top (iframe)   
         */
        var win = window;
        //   iframe
        var actualScrollHeight = -win.frameElement.getBoundingClientRect().top;
        //   
        var viewportHeight = UTIL.getViewHeight(win.parent);
        //  
        var dialogElementHeight = dialogElement.offsetHeight;
        
        //  top
        var viewportTop = (viewportHeight - dialogElementHeight) / 2;
        //  topMath.max top
        var styleTop = actualScrollHeight + Math.max(viewportTop, 0);
        
        //   0  
        //       styleTop 0
        dialogElement.style.top = Math.max(styleTop, 0) + 'px';
    };

    /**
     * 
     *
     * @public
     * @param {String} text 
     * @param {Function} onconfirm 
     * @param {boolean} noBtn btn
     */
    DIALOG.alert = function(text, onconfirm, noBtn) {
        DIALOG.showDialog(
            text, 
            '', 
            noBtn
                ? []
                : [
                    { 
                        text: '', 
                        className: 'ui-button-g', 
                        action: onconfirm 
                    }
                ], 
            DICT.DEFAULT_MASK_OPACITY
        );
    };

    /**
     * 
     *
     * @public
     * @param {String} text 
     * @param {Function} ok 
     * @param {Function} cancel 
     */
    DIALOG.confirm = function(text, onconfirm, oncancel) {
        DIALOG.showDialog(
            text, 
            '', 
            [
                { 
                    text: '', 
                    className: 'ui-button-g', 
                    action: onconfirm 
                },
                { 
                    text: '', 
                    action: oncancel 
                }
            ], 
            DICT.DEFAULT_MASK_OPACITY
        );
    };
    
    /**
     * 
     *
     * @public
     * @param {string} title 
     * @param {string} message 
     * @param {Array.<Object>} buttons 
     *          {string} text 
     *          {string} className 
     *          {Function} action 
     */
    DIALOG.dialog = function(title, message, buttons) {
        var html;
        buttons = buttons || [];
        
        html.push(
            '<div class="ui-messagebox-icon"></div>', 
            '<div class="ui-messagebox-content">',
                '<div class="ui-messagebox-text">', 
                    encodeHTML(message), 
                '</div>',
            '</div>'
        );

        DIALOG.showDialog(
            html.join(''), 
            title, 
            buttons, 
            DICT.DEFAULT_MASK_OPACITY
        );     
    };

    /**
     * alert
     *
     * @public
     */
    DIALOG.errorAlert = function() {
        DIALOG.alert(LANG.ERROR);
    };

})();
/**
 * di.helper.Formatter
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 */

$namespace('di.helper');
 
(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var xlang = xutil.lang;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var hasValue = xlang.hasValue;
    var hasValueNotBlank = xlang.hasValueNotBlank;
    var encodeHTML = xutil.string.encodeHTML;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var formatNumber = xutil.number.formatNumber;
    var arraySlice = Array.prototype.slice;
    var DICT;

    $link(function() {
        DICT = di.config.Dict;
    });
    
    /**
     * formatterdata
     * formatter
     * kt.helper.Formatter('SOME_FORMATTER')
     * kt.helper.Formatter('SOME_FORMATTER', true, 'asdf', ...)
     * formatter
     * formatterthis
     *
     * @param {string} formatterName 
     * @param {Any...} formatter
     * @return {Function} formatter
     */
    var FORMATTER = $namespace().Formatter = function(formatterName) {
        var args = arraySlice.call(arguments, 1);
        return function(data) {
            var argsInput = arraySlice.call(arguments, 1);
            return FORMATTER[formatterName].apply(
                this, 
                [data].concat(args, argsInput)
            );
        }
    };

    /**
     * 
     */
    FORMATTER.DEFAULT_RATE_FORMAT = 'I,III.DD%';

    /**
     * ecuiformatter
     * formatter
     * tableFormatter('SOME_FORMATTER')
     * tableFormatter('SOME_FORMATTER', true, 'asdf', ...)
     * formatter
     * 
     * @param {(string|Object)} field 
     *              Obejct
     *              {string} data 
     *              {string} link 
     * @param {string} formatterName 
     * @param {Any...} formatter
     * @return {Function} formatter
     */
    FORMATTER.tableFormatter = function(field, formatterName) {
        var args = arraySlice.call(arguments, 2);
        var dataField; 
        var linkField;

        if (isString(field)) {
            dataField = field;
        } 
        else {
            dataField = field.data;
            linkField = field.link;
        }   

        return function(item) {
            var text = FORMATTER[formatterName].apply(
                item, 
                [item[dataField]].concat(args)
            );
            return prepareLink(item, text, linkField);
        };
    }

    /**
     * encodeHTML
     * 
     * @public
     * @param {Any} data 
     * @param {string} needEncodeHTML true
     * @return {string} 
     */
    FORMATTER.SIMPLE_TEXT = function(data, needEncodeHTML) {    
        needEncodeHTML = hasValue(needEncodeHTML) ? needEncodeHTML : true;
        data = hasValueNotBlank(data) ? data : '-';
        data = needEncodeHTML ? encodeHTML(data) : data;
        return data;
    }
    
    /**
     * HTMLtitle
     * 
     * @public
     * @param {Any} data 
     * @param {number} length 
     * @param {string} needEncodeHTML true
     * @param {string} color 
     * @param {string} classNames classNames
     * @return {string} 
     */
    FORMATTER.CUT_TEXT = function(
        data, length, needEncodeHTML, color, classNames
    ) {
        var shortText = '', isCut, colorStyle = '',
        needEncodeHTML = hasValue(needEncodeHTML) ? needEncodeHTML : true;
        data = hasValueNotBlank(data) ? data : '-';

        if (textLength(data) > length) {
            shortText = textSubstr(data, 0, length - 2) + '..';
            isCut = true;
        } 
        else {
            shortText = data;
            isCut = false;
        }

        shortText = needEncodeHTML ? encodeHTML(shortText) : shortText;
        if (isCut && hasValue(color)) {
            colorStyle = 'color:' + color + '';
        }
        data = needEncodeHTML ? encodeHTML(data) : data;
        return '<span class="' + classNames + '" style="' + colorStyle + '" title="' + data + '" >' + shortText + '&nbsp;</span>'; 
    }

    /**
     * 
     * 
     * @public
     * @param {Any} data 
     * @param {string} format 'I,III.DD%'
     * @return {string} 
     */
    FORMATTER.SIMPLE_RATE = function(data, format) {
        var text, flagClass;
        if (!hasValueNotBlank(data)) {
            return '-';
        }
        format = format || FORMATTER.DEFAULT_RATE_FORMAT;
        text = formatNumber(data, format);
        return text;
    }

    /**
     * 
     * 
     * @public
     * @param {Any} data 
     * @param {string} format 
     * @return {string} 
     */
    FORMATTER.SIMPLE_NUMBER = function(data, format) {
        data = hasValueNotBlank(data) 
            ? (!format ? data : formatNumber(data, format)) 
            : '-';
        return data;
    }

    /**
     * 
     * 
     * @public
     * @param {Any} data 
     * @param {string} format 
     * @param {string} positiveColor 'red'
     * @param {string} nagetiveColor 'green'
     * @return {string} 
     */
    FORMATTER.COLORED_NUMBER = function(
        data, format, positiveColor, nagetiveColor
    ) {    
        var style, text = '-';
        positiveColor = positiveColor || 'red';
        nagetiveColor = nagetiveColor || 'green';
        if (hasValueNotBlank(data)) {
            style = 'style="color:' + (data < 0 ? nagetiveColor : positiveColor) + '" ';
            text = '<span ' + style + '>' + (!format ? data : formatNumber(data, format)) + '</span>';
        }
        return text;
    }


    /**
     * @private
     */
    function prepareLink (item, text, linkField, dontTargetBlank) {
        var href;
        if (hasValueNotBlank(linkField)) {
            href = item[linkField];
        }
        if (!hasValueNotBlank(href) || !hasValueNotBlank(text)) { 
            return text;
        }
        var targetBlank = dontTargetBlank ? '' : ' target="_blank" ';
        return '<a ' + targetBlank + ' href="' + href + '">' + text + '</a>';
    }

})();
/**
 * di.helper.SnippetParser
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    html
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 */

$namespace('di.helper');
 
(function () {
    
    //--------------------------------
    // 
    //--------------------------------

    var setByPath = xutil.object.setByPath;
    var getByPath = xutil.object.getByPath;
    var getParent = xutil.dom.getParent;
    var merge = xutil.object.merge;
    var DICT;
    var DIALOG;

    $link(function () {
        DICT = di.config.Dict;
        DIALOG = di.helper.Dialog;
    });

    /**
     * html
     *
     * @usage
     *      
     *      var unitFactory = di.helper.SnippetParser();
     */
    $namespace().SnippetParser = function () {
        return instance = instance || {
            parseProdSnippet: parseProdSnippet,
            setupEventChannel: setupEventChannel
        };
    };

    var instance;

    var DEFAULT_DOM_ATTR_NAME = 'data-o_o-di';
    var STUB_EVENT_CHANNEL_ANCHOR = 'BODY';
    var STUB_EVENT_CHANNEL_OUTWARD = 'data-d-outward-d-atad';
    var STUB_EVENT_CHANNEL_INWARD = 'data-d-inward-d-atad';
    var ID_DELIMITER = '.';

    function setupEventChannel(el, prodDef, diFactory) {
        var els = getAllEls(el);
        var domAttrName = prodDef.domAttrName || DEFAULT_DOM_ATTR_NAME;

        // dom
        for (var i = 0, eo, attr; eo = els[i]; i ++) {
            // 
            attr = eo.getAttribute(domAttrName);
            if (attr == STUB_EVENT_CHANNEL_ANCHOR) {
                return createStubEventChannel(eo, diFactory);
            }
        }                
    }

    /**
     * snippet
     * 
     * @public
     * @param {HTMLElement} el html
     * @param {Object} depict 
     * @param {Object} prodDef 
     * @param {Object} diFactory 
     */
    function parseProdSnippet(el, depict, prodDef, diFactory) {    
        prodDef = prodDef || {};
        var domAttrName = prodDef.domAttrName || DEFAULT_DOM_ATTR_NAME;

        var els = getAllEls(el);
        var def;
        var attr;
        var ins;
        var clz;
        var clzType;
        var clzKey;
        var i;
        var j;
        var eo;

        // entityDef
        var entityDefs = depict.entityDefs || [];
        var entityDefMap = {};
        for (i = 0; i < entityDefs.length; i ++) {
            def = entityDefs[i];
            entityDefMap[def.id] = def;
        }

        // dom
        for (i = 0; eo = els[i]; i ++) {
            // 
            attr = eo.getAttribute(domAttrName);
            if (attr == STUB_EVENT_CHANNEL_ANCHOR) {
                // createStubEventChannel(eo, diFactory);
                continue;
            }

            // 
            if (attr) {
                def = entityDefMap[attr];
                checkId(def.id);
                
                // diFactory
                def.el = eo;
                diFactory.addEntity(def, 'DEF');
            }
        }

        // idcomponentsnippet
        // reportTemplateId
        // componentsnippet
        diFactory.forEachEntity(
            ['COMPONENT'], 
            function (def, ins, id) {
                // snippet
                var idArr = def.id.split(ID_DELIMITER);
                var snptDef = diFactory.getEntity(idArr[0], 'DEF');
                if (!snptDef) {
                    throw new Error(def.id + ' snippet');
                }
                setByPath('belong.snippet', snptDef.id, def);

                // snippet
                var el = def.el;
                var parentDef;
                var besnpt = getByPath('layout.parentSnippet', def);
                if (!besnpt) {
                    setByPath('layout.parentSnippet', besnpt = [], def);
                }
                while ((el = getParent(el)) && el != document) {
                    parentDef = diFactory.getEntity(
                        el.getAttribute(domAttrName), 
                        'DEF'
                    );

                    if (parentDef && parentDef.clzType == 'SNIPPET') {
                        besnpt.push(parentDef.id);
                    }
                }
            }
        );

        // domvpart
        // FIXME
        // vpartsnippet
        diFactory.forEachEntity(
            ['VPART'],
            function(def, ins, id) {
                var subEls = getAllEls(def.el);
                var index = { COMPONENT: 0, VUI: 0 };
                var refName = { COMPONENT: 'componentRef', VUI: 'vuiRef' };

                for (var i = 0, eo, subDef, clzType; eo = subEls[i]; i ++) {
                    subDef = diFactory.getEntity(
                        eo.getAttribute(domAttrName), 
                        'DEF'
                    );

                    if (!subDef) { continue; }

                    refName[clzType = subDef.clzType] && setByPath(
                        refName[clzType] + '.inner[' + (index[clzType] ++) + ']',
                        subDef.id, 
                        def
                    );
                }
            }
        );

        // snippet
        diFactory.rootSnippet(depict.rootSnippet); 
    }

    /**
     * 
     * 
     * @private
     */
    function createStubEventChannel(el, diFactory) {  

        // outward (di-stub)
        var triggerEvent = function(eventName, args) {
            var handler = el[STUB_EVENT_CHANNEL_OUTWARD];
            if (handler) {
                try {
                    handler(eventName, args);
                }
                catch (e) {
                    // TODO
                }
            }
        };
        
        // inward (di-stub)
        el[STUB_EVENT_CHANNEL_INWARD] = function(eventName, args) {
            var hList = listenerMap[eventName];
            if (hList) {
                for (var i = 0; i < hList.length; i ++) {
                    try {
                        hList[i] && hList[i].apply(null, args || []);
                    }
                    catch (e) {
                        // TODO
                    }
                }
            }
        };

        var listenerMap = {};

        var addEventListener = function(eventName, listener) {
            var hList = listenerMap[eventName];
            if (!hList) {
                hList = listenerMap[eventName] = [];
            }
            hList.push(listener);          
        }

        var eventChannel;
        diFactory.setEventChannel(
            eventChannel = {
                anchorEl: el,
                triggerEvent: triggerEvent,
                addEventListener: addEventListener
            }
        );

        return eventChannel;
    }

    /**
     * id
     *  1-9a-zA-Z
     *
     * @private
     * @param {string} id
     */
    function checkId(id) {
        if (!/[1-9a-zA-Z\-_\.]/.test(id)) {
            throw new Error('id is illegal: ' + id);
        }
    }

    /**
     * el
     * 
     * @private
     * @param {HTMLElement} el el
     * @return {Array} el
     */
    function getAllEls(el) {
        return el.all || el.getElementsByTagName('*');
    }

})();
/**
 * di.helper.Util
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil, tangram.ajax, tangram.json
 */

$namespace('di.helper');
 
(function () {
    
    //----------------------------------------
    // 
    //----------------------------------------

    var xlang = xutil.lang;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var stringToDate = xutil.date.stringToDate;
    var hasValue = xlang.hasValue;
    var hasValueNotBlank = xlang.hasValueNotBlank;
    var decodePercent = xutil.string.decodePercent;
    var sortList = xutil.collection.sortList;
    var dateToString = xutil.date.dateToString;
    var getWorkday = xutil.date.getWorkday;
    var getWeekend = xutil.date.getWeekend;
    var getQuarter = xutil.date.getQuarter;
    var getQuarterBegin = xutil.date.getQuarterBegin;
    var g = xutil.dom.g;
    var isDate = xutil.lang.isDate;
    var arraySlice = [].slice;
    var $fastCreate = ecui.$fastCreate;
    var stringify = baidu.json.stringify;
    var getByPath = xutil.object.getByPath;
    var DOCUMENT = document;
    var ECUI_CONTROL;
    var DIALOG;
    var LANG;
    var REGEXP = RegExp;

    $link(function () {
        ECUI_CONTROL = getByPath('ecui.ui.Control');
        DIALOG = di.helper.Dialog;
        LANG = di.config.Lang;
    });
        
    //----------------------------------------
    // 
    //----------------------------------------

    var UTIL = $namespace().Util = {};

    var DAY_MILLISEC = 1000 * 60 * 60 * 24; 
    
    //----------------------------------------
    // 
    //----------------------------------------

    /**
     * assert
     * 
     * @public
     * @param {boolean} cond 
     * @param {string} msg condfalse
     */
    UTIL.assert = function (cond, msg) {
        if (!cond) {
            throw new Error(msg || 'Assert fail!');
        }
    };

    /**
     * preprocess
     * $fastCreate
     * 
     * @public
     * @param {ecui.ui.Control} control 
     * @param {HTMLElement} el 
     * @param {Object} options 
     */
    UTIL.preInit = function (control, el, options) {
        options.primary = control.getType();
        el.className = control.getTypes().join(' ') + el.className;
    };
    
    /**
     * ecui
     * 
     * 
     * @public
     * @param {constructor} contorlClass ecui
     * @param {HTMLElement} el 
     * @param {ecui.ui.Control} parentControl 
     * @param {Object} options 
     * @return {ecui.ui.Control} 
     */
    UTIL.ecuiCreate = function (controlClass, el, parentControl, options) {
        var type = controlClass.types[0];
        options = options || {};
        !options.primary && (options.primary = type);
        el.className = [
            controlClass.TYPES,
            options.primary,
            el.className
        ].join(' ');
        return $fastCreate(controlClass, el, parentControl, options);
    };

    /**
     * "_u***"ecui
     * 
     * @public
     * @param {Object} container 
     */
    UTIL.disposeInnerControl = function (container) {
        for (var attr in container) {
            /_u\w+/.test(attr) 
                && container[attr]
                && UTIL.ecuiDispose(container[attr]);
        }
    };

    /**
     * dimSel
     *
     * @public
     * @param {string} dimSelStr 
     * @return {boolean} valid
     */
    UTIL.validDimSel = function (dimSelStr) {
        var i, o, oo, arr;
        if (!hasValueNotBlank(dimSelStr)) { return false; }

        arr = dimSelStr.split('|');
        for (i = 0; i < arr.length; i ++) {
            if (!hasValueNotBlank(o = arr[i])) {
                return false;
            }
            oo = o.split(':');
            if (!hasValueNotBlank(oo[0]) || !hasValueNotBlank(oo[1])) {
                return false;
            }
        }  
        return true;
    };

    /**
     * dimSel
     *
     * @public
     * @param {string} dimSelStr 
     * @param {Object} dimDatasourceMap O
     *                  key: dimId, 
     *                  value: { datasource: dimDatasource }
     * @return {string} dimSelStr
     */
    UTIL.completeDimSel = function (dimSelStr, dimDatasourceMap) {
        if (!hasValueNotBlank(dimSelStr)) { return false; }

        var dimSelObj = UTIL.parseDimSel(dimSelStr);
        var rootNode;
        for (var dimId in dimSelObj) {
            rootNode = dimDatasourceMap[dimId].datasource.rootNode;
            if (rootNode 
                && (!dimSelObj[dimId] || dimSelObj[dimId].length == 0)
            ) {
                dimSelObj[dimId] = [rootNode.dimNodeId];
            }
        }
        return UTIL.stringifyDimSel(dimSelObj);
    };    

    /**
     * dimSel
     *
     * @public
     * @param {string} dimSelStr 
     * @return {Object} dimSel
     *          {<dimId>: [<dimNodeId>, <dimNodeId>, ...], ...}
     */
    UTIL.parseDimSel = function (dimSelStr) {
        var i, o, oo, ooo, arr, ret = {};
        if (!hasValueNotBlank(dimSelStr)) { return null; }
        arr = dimSelStr.split('|');
        for (i = 0; i < arr.length; i ++) {
            if (!hasValueNotBlank(o = arr[i])) { continue; }
            oo = o.split(':');
            if (!hasValueNotBlank(oo[0])) { continue; }
            ret[oo[0]] = hasValueNotBlank(oo[1]) ? oo[1].split(',') : [];
        }
        return ret;
    };

    /**
     * dimSel
     *
     * @public
     * @param {Object} dimSelObj
     *          {<dimId>: [<dimNodeId>, <dimNodeId>, ...], ...}
     * @return {string} dimSel
     */
    UTIL.stringifyDimSel = function (dimSelObj) {
        var dimId, arr = [];
        if (!dimSelObj) {
            return '';
        }
        for (dimId in dimSelObj) {
            arr.push(dimId + ':' + (dimSelObj[dimId] || []).join(','));
        }
        return arr.join('|');
    };

    /**
     * eljson
     * 
     * 
     * @private
     * @param {HTMLElement} el dom
     * @param {string} attrName 
     * @return {Object} 
     */
    UTIL.getDomAttrJSON = function (el, attrName) {
        var attr = el.getAttribute(attrName);
        if (attr) {
            return (new Function('return (' + attr + ');'))();
        }
    };

    /**
     * dimSel
     *
     * @public
     * @param {string} dimSelStr1 dimSel1
     * @param {string} dimSelStr2 dimSel2
     * @param {Object} dimIdMap dimIdkeydimId
     * @return {boolean}  
     */
    UTIL.sameDimSel = function (dimSelStr1, dimSelStr2, dimIdMap) {
        var dimId, list1, list2, 
            dimSelObj1 = UTIL.parseDimSel(dimSelStr1), 
            dimSelObj2 = UTIL.parseDimSel(dimSelStr2);

        for (dimId in dimIdMap) {
            sortList((list1 = dimSelObj1[dimId]), null, '<', false);
            sortList((list2 = dimSelObj2[dimId]), null, '<', false);
            if (list1.join(',') !== list2.join(',')) {
                return false;
            }
        }
        return true;
    };

    /**
     * dim
     *
     * @public
     * @param {Array{string}} dimNodeIdArr1 dim1
     * @param {Array{string}} dimNodeIdArr2 dim2
     * @return {boolean}  
     */
    UTIL.sameDimNodeIdArr = function (dimNodeIdArr1, dimNodeIdArr2) {
        dimNodeIdArr1 = dimNodeIdArr1 || [];
        dimNodeIdArr2 = dimNodeIdArr2 || [];

        if (dimNodeIdArr1.length != dimNodeIdArr2.length) {
            return false;
        }

        sortList(dimNodeIdArr1, null, '<', false);
        sortList(dimNodeIdArr2, null, '<', false);

        for (var i = 0; i < dimNodeIdArr1.length; i ++) {
            if (dimNodeIdArr1[i] != dimNodeIdArr2[i]) {
                return false;
            }
        }
        return true;
    };

    /**
     * 
     * 
     * @public
     * @param {ecui.ui.LiteTable} tableCon table
     * @param {string} text 
     */
    UTIL.emptyTable = function (tableCon, text) {
        var oldText, html = '';

        if (hasValue(text)) {
            oldText = tableCon.getEmptyText();
            tableCon.setEmptyText(text);
        }

        tableCon.setData([]);

        if (hasValue(oldText)) {
            tableCon.setEmptyText(oldText);
        }
    };

    /**
     * 
     * 
     * @public
     * @param {ecui.ui.LiteTable} tableCon table
     */
    UTIL.waitingTable = function (tableCon) {
        UTIL.emptyTable(tableCon, LANG.WAITING_HTML);
    };    

    /**
     * wrap
     *
     * @public
     * @param {Object} wrap
     *          {Array.<Object>} list
     *              {string} text
     *              {*} value
     *          {*} selected
     */
    UTIL.getWrapSelected = function (wrap) {
        for (var i = 0; o = wrap.list[i]; i ++) {
            if (o.value == wrap.selected) {
                return o;
            }
        }
    };

    /**
     * 
     *
     * @public
     * @param {Error} e 
     */
    UTIL.logError = function (e) {
        try {
            if (console && console.log) {
                console.log(e);
                (e.message != null) && console.log(e.message);
                (e.stack != null) && console.log(e.stack);
            }
        } 
        catch (e) {
        }
    };

    /**
     * DI
     *
     * @public
     * @param {Date|number} date 
     * @param {string} config.granularity 'D', 'W', 'M', 'Q', 'Y'
     * @param {Object} options 
     * @param {boolean} options.firstWeekDay truefalse
     */
    UTIL.formatTime = function (date, granularity, options) {
        if (!date) { return; }
        if (!isDate(date)) { date = new Date(date); }
        options = options || {};

        switch (granularity) {
            case 'D': 
                return dateToString(date, 'yyyy-MM-dd');
            case 'W':
                return options.firstWeekDay 
                    // 
                    ? dateToString(getWorkday(date), 'yyyy-MM-dd')
                    // 
                    : dateToString(date, 'yyyy-MM-dd')
            case 'M':
                return dateToString(date, 'yyyy-MM');
            case 'Q':
                return date.getFullYear() + '-Q' + getQuarter(date);
            case 'Y':
                return String(date.getFullYear());
            default: 
                return '';
        }
    };

    /**
     * DIDate
     *
     * @public
     * @param {Date|string} date 
     */
    UTIL.parseTime = function (dateStr) {
        if (!dateStr) { return null; }
        if (isDate(dateStr)) { return dateStr; }

        if (dateStr.indexOf('-Q') >= 0) {
            var par = [0, 0, 3, 6, 9];
            dateStr = dateStr.split('-Q');
            return new Date(
                parseInt(dateStr[0], 10), 
                par[parseInt(dateStr[1], 10)], 
                1
            );
        }
        else {
            return stringToDate(dateStr);
        }
    };    

    /**
     * 
     * timeUtiltimeUnit
     *timeUtilparseTimeUtitDef
     * : 
     *      timeUnit: ['+1D', '+5W']  [null, '-1D', '-3MB']
     *      timeUnit: [['+1D', '+5W'], ['+5W', '+10Q'], ...]
     *
     * @param {(Array.<Array.<string>>|Array.<string>)} def 
     * @param {(Array.<string>|Array.<Date>)} ref 
     * @return {Array.<Object>} timeUnitList 
     *      parseTimeUnitDef
     */
    UTIL.parseTimeDef = function (def, ref) {
        var dArr = [];
        var retArr = [];
        if (isArray(def) && def.length) {
            var def0 = def[0];
            if (isArray(def0)) {
                dArr = def;
            }
            else {
                dArr = [def];
            }
            for (var i = 0, unit; i < dArr.length; i ++) {
                if (isArray(unit = dArr[i])) {
                    retArr.push(UTIL.parseTimeUnitDef(unit, ref));
                }
                else {
                    UTIL.assert('TimeDef illegal: ' + def);
                }
            }
        }

        return retArr;
    };

    /**
     * 
     * 
     * 
     *      [null, "-1D", "0MB"]
     * 
     * @param {Array.<string>} def 
     *      def.start
     *                      2012-12-12
     *                      -5d
     *      def.end 
     *      def.range startend-4d
     *                  startendrange
     *                  startendrange
     *                  startstart
     *                  start+1MErange+5WB
     *                  5
     * @param {(Array.<string>|Array.<Date>)} ref 
     *      
     * @return {Object} timeUnit 
     * @return {Date} timeUnit.start 
     * @return {Date} timeUnit.end 
     */
    UTIL.parseTimeUnitDef = function (def, ref) {
        if (!def || !def.length) {
            return null;
        }

        var ret = {};
        var start = def[0];
        var end = def[1];
        var interval = def[2];

        ret.start = UTIL.parseTimeOffset(ref[0], start);
        ret.end = UTIL.parseTimeOffset(ref[1], end);

        // range
        if ((!start || !end) && interval) {
            var from;
            var to;
            if (start) {
                from = 'start';
                to = 'end';
            }
            else {
                from = 'end';
                to = 'start';
            }
            ret[to] = UTIL.parseTimeOffset(ret[from], interval);
        }
        else if (!end && !interval) {
            ret.end = ret.start;
        }

        return ret;
    };

    /**
     * 
     *
     * @public
     * @param {(Date|string)} baseDate 
     *       {string} yyyy-MM-dd
     * @param {string} offset 
     *      
     *          YMDWQ
     *          B/EB/E
     *          
     *              baseDate2012-05-09
     *              '+4D'baseDate42012-05-13 
     *              '-2M'22012-03-13
     *              '2Q'22012-11-13
     *              '1W'12012-05-20
     *              '1WB'12012-05-14
     *              '-1WE'2012-05-06
     *              '0WE'2012-05-13
     *              
     *      yyyy-MM-dd
     *          
     *      
     * @return {Date} 
     */
    UTIL.parseTimeOffset = function (baseDate, offset) {
        if (offset == null) { return null; }
        if (!baseDate) { return baseDate; }
        
        if (isString(baseDate)) {
            baseDate = UTIL.parseTime(baseDate);
        }
        offset = offset.toUpperCase();
        
        var t = [
            baseDate.getFullYear(), 
            baseDate.getMonth(), 
            baseDate.getDate()
        ];
        var p = { Y: 0, M: 1, D: 2 };

        if (/^([-+]?)(\d+)([YMDWQ])([BE]?)$/.test(offset)) {
            var notMinus = !REGEXP.$1 || REGEXP.$1 == '+';
            var off = parseInt(REGEXP.$2);
            var timeType = REGEXP.$3;
            var beginEnd = REGEXP.$4;

            if ('YMD'.indexOf(timeType) >= 0) {
                t[p[timeType]] += notMinus ? (+ off) : (- off);
            }
            else if (timeType == 'W') {
                off = off * 7;
                t[p['D']] += notMinus ? (+ off) : (- off);
            }
            else if (timeType == 'Q') {
                off = off * 3;
                t[p['M']] += notMinus ? (+ off) : (- off);
            }
            var ret = new Date(t[0], t[1], t[2]);

            if (beginEnd) {
                if (timeType == 'Y') {
                    beginEnd == 'B'
                        ? (
                            ret.setMonth(0),
                            ret.setDate(1)
                        )
                        : (
                            ret.setFullYear(ret.getFullYear() + 1),
                            ret.setMonth(0),
                            ret.setDate(1),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
                else if (timeType == 'M') {
                    beginEnd == 'B'
                        ? ret.setDate(1)
                        : (
                            ret.setMonth(ret.getMonth() + 1),
                            ret.setDate(1),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
                else if (timeType == 'W') {
                    ret = (beginEnd == 'B' ? getWorkday : getWeekend)(ret);
                }
                else if (timeType == 'Q') {
                    (beginEnd == 'B') 
                        ? (ret = getQuarterBegin(ret))
                        : (
                            ret.setMonth(ret.getMonth() + 3),
                            ret = getQuarterBegin(ret),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
            }

            return ret;
        }
        else {
            return UTIL.parseTime(offset);
        }
    };

    /**
     * 2012-Q1
     *
     * @param {string} dateStr 
     * @return {Date} 
     */
    UTIL.parseQuarter = function (dateStr) {
        var par = [0, 0, 3, 6, 9];
        dateStr = dateStr.split('-Q'); 
        return new Date(
            parseInt(dateStr[0], 10), 
            par[parseInt(dateStr[1], 10)], 
            1
        );
    };

    /**
     * json stringify
     *
     * @param {Object} obj 
     * @return {string} json 
     */
    UTIL.jsonStringify = function (obj) {
        return obj ? stringify(obj) : '';
    };
    
    /**
     * ecui 
     * ecui
     *
     * @param {ecui.ui.Control} control ECUI 
     * @param {string} name 
     * @param {Object} event 
     * @param {Array} args 
     */
    UTIL.ecuiTriggerEvent = function (control, name, event, args) {
        if (!ecui) { return; }
        return ecui.triggerEvent(control, name, event, args);
    };  

    /**
     * ecui 
     * ecui
     *
     * @param {ecui.ui.Control} control ECUI 
     * @param {string} name 
     * @param {Function} caller 
     * @param {boolean=} once 
     */
    UTIL.ecuiAddEventListener = function (control, name, caller, once) {
        if (!ecui) { return; }

        var newCaller = once 
            ? function () {
                // 
                ecui.removeEventListener(control, name, arguments.callee);
                // caller
                return caller.apply(this, arguments);
            }
            : caller;

        return ecui.addEventListener(control, name, newCaller);
    };    

    /**
     * ecui 
     * ecui
     *
     * @param {ecui.ui.Control|HTMLElement} control 
     *       Element 
     */
    UTIL.ecuiDispose = function (control) {
        ecui && ecui.dispose(control);
    };

    /**
     * ecui
     *
     * @param {Object} obj 
     * @return {boolean} ecui
     */
    UTIL.isEcuiControl = function (obj) {
        return !!(ECUI_CONTROL && obj instanceof ECUI_CONTROL);
    };

    /**
     * GET
     * ie2000urlie
     * @see UTILdownload
     */
    UTIL.downloadByGet = function (url, onfailure, showDialog) {
        onfailure = onfailure || new Function();

        var failureHandler = showDialog 
            ? function () {
                DIALOG.alert(LANG.SAD_FACE + LANG.DOWNLOAD_FAIL, onfailure);
            }
            : onfailure;

        var elDownload = g(downloadIfrId);
        if (!elDownload) {
            elDownload = DOCUMENT.createElement('iframe');
            elDownload.id = downloadIfrId;
            elDownload.style.display = 'none';
            DOCUMENT.body.appendChild(elDownload);
        }

        elDownload.onload = function () {
            var doc = elDownload.contentWindow.document;
            
            if (doc.readyState == 'complete' || doc.readyState == 'loaded') {
                failureHandler();
            }

            elDownload.onload = null;
        };

        // 
        elDownload.src = url;
    };

    /**
     * POST
     * @see UTIL.download
     */
    UTIL.downloadByPost = function (url, onfailure, showDialog) {
        onfailure = onfailure || new Function();

        var failureHandler = showDialog 
            ? function () {
                DIALOG.alert(LANG.SAD_FACE + LANG.DOWNLOAD_FAIL, onfailure);
            }
            : onfailure;

        var elIfr = g(downloadIfrId);
        if (!elIfr) {
            elIfr = DOCUMENT.createElement('iframe');
            elIfr.id = downloadIfrId;
            //elIfr.name = downloadIfrName;
            elIfr.style.display = 'none';
            DOCUMENT.body.appendChild(elIfr);
            elIfr.contentWindow.name = downloadIfrName;
        }

        var elForm = g(downloadFormId);
        if (!elForm) {
            elForm = DOCUMENT.createElement('form');
            elForm.id = downloadFormId;
            elForm.method = 'POST';
            elForm.target = downloadIfrName;
            elForm.style.display = 'none';
            DOCUMENT.body.appendChild(elForm);
        }
        else {
            elForm.innerHTML = '';
        }

        // 
        var urla = url.split('?');
        var urlParams = urla[1];

        // Dirty solution by MENGRAN at 2013-12-31
        var rbk = "?_rbk=";
        if (urlParams) {
            urlParams = urlParams.split('&');

            for (var i = 0, pa, ipt; i < urlParams.length; i ++) {
                if (!urlParams[i]) { continue; }

                pa = urlParams[i].split('=');
                if (pa[0]) {
                    ipt = document.createElement('INPUT');
                    ipt.type = 'hidden';
                    ipt.value = decodePercent(pa[1]);
                    ipt.name = decodePercent(pa[0]);
                    elForm.appendChild(ipt);
                    if (pa[0] === "_rbk") {
                        rbk = rbk + pa[1];
                    }
                }
            }
        }
        elForm.action = urla[0] + rbk;

        // 
        elForm.submit();
    };

    /**
     * 
     * 
     * iframeonloadreadyStateonload
     * 
     *
     * @public
     * @param {Object} url 
     * @param {Function} onfailure 
     * @param {boolean} showDialog 
     */
    UTIL.download = UTIL.downloadByPost;

    /**
     * 
     *
     * @public
     * @param {string} url url
     */
    UTIL.targetBlank = function (url) {
        var doc = document;
        var body = doc.body;
        var el = doc.createElement('a');
        el.style.display = 'none';
        el.href = url || '#';
        el.target = '_blank';
        body.appendChild(el);
        el.click();
        body.removeChild(el);
    };

    // 
    UTIL.foreachDo = function (list, method, args) {
        $foreachDo.call(this, false, list, method, arraySlice.call(arguments, 2));
    };
    
    UTIL.foreachDoOri = function (list, method, args) {
        $foreachDo.call(this, true, list, method, arraySlice.call(arguments, 2));
    };

    /**
     * 
     *
     * @public
     * @param {Array} list 
     * @param {(string|Function)} method 
     * @param {boolean=} origin true$didi
     *      diFactoryfalse
     * @param {Array} args
     */
    function $foreachDo(origin, list, method, args) {
        for (var i = 0, o; i < list.length; i ++) {
            if (o = list[i]) {
                if (isFunction(method)) {
                    method(o);
                }
                else {
                    // origin true$didi
                    // diFactoryfalse
                    (!origin && o.$di) 
                        ? o.$di(method, 'apply', o, args)
                        : o[method].apply(o, args);
                }
            }
        }
    };

    var downloadIfrId = String(
        'download-iframe-' + Math.round(Math.random() * 10000000)
    );
    var downloadIfrName = downloadIfrId + 'NAME';
    var downloadFormId = String(
        'download-form-' + Math.round(Math.random() * 10000000)
    );

    function naming (attrName, prefix) {
        return prefix + attrName.charAt(0).toUpperCase() + attrName.slice(1);
    }
    
    function attrNaming (attrName, o) {
        var prefix = '';
        if (UTIL.isEcuiControl(o)) {
            prefix = '_u';
        } else if (isArray(o)) {
            prefix = '_a';
        } else if (isFunction(o)) {
            prefix = '_f';
        } else {
            prefix = '_m';
        }
        return naming(attrName, prefix);
    }

    //-------------------------------------------------------
    // 
    //-------------------------------------------------------

    /**
     * json
     * 
     * @public
     * @param {Object} jsonLogicExp 
     *      andornot
     *      atomCal
     *      
     *      array
     *      [
     *          'and',
     *           [ 
     *               'or',
     *               { someCustomerRule: 'asdf', someValue: 1234 },
     *               { someCustomerRule: 'asdf', someValue: 1234 },
     *               { someCustomerRule: 'asdf', someValue: 1234 }
     *           ],
     *           { someCustomerRule: 'zcvcxz', someValue: 32432 }
     *      ]
     *
     * @param {Function} atomCalFunc 
     *      {Object}
     *      {boolean}
     * @return {boolean} 
     */
    UTIL.evalJsonLogic = function (jsonLogicExp, atomCalFunc) {
        if (!jsonLogicExp || !atomCalFunc) {
            jsonLogicExpError(jsonLogicExp);
        }

        var operator;
        var i;
        var ret;

        // 
        if (isArray(jsonLogicExp)) {

            jsonLogicExp.length < 2 && jsonLogicExpError(jsonLogicExp);

            operator = jsonLogicExp[0];
            if (operator == 'and') {
                ret = true;
                for (i = 1; i < jsonLogicExp.length; i ++) {
                    ret = ret && UTIL.evalJsonLogic(
                        jsonLogicExp[i], atomCalFunc
                    );
                }
                return ret;
            }
            else if (operator == 'or') {
                ret = false;
                for (i = 1; i < jsonLogicExp.length; i ++) {
                    ret = ret || UTIL.evalJsonLogic(
                        jsonLogicExp[i], atomCalFunc
                    );
                }
                return ret;
            }
            else if (operator == 'not') {
                return !UTIL.evalJsonLogic(
                    jsonLogicExp[i], atomCalFunc
                );
            }
            else {
                jsonLogicExpError(jsonLogicExp);
            }
        }
        // 
        else {
            return atomCalFunc(jsonLogicExp);
        }
    };

    function jsonLogicExpError(jsonLogicExp, msg) {
        throw new Error(
            'Illegle json logic express, ' + (msg || '') 
            + '. ' + stringify(jsonLogicExp)
        );
    }

    //-------------------------------------------------------
    // dom (modified based on tangram and ecui)
    //-------------------------------------------------------

    /**
     * 
     * 
     * @public
     * @param {Window} win window
     * @return {number} 
     */
    UTIL.getScrollLeft = function (win) {
        win = win || window;
        var d = win.document;
        return win.pageXOffset || d.documentElement.scrollLeft || d.body.scrollLeft;
    };

    /**
     * 
     *
     * @public
     * @param {Window} win window
     * @return {number} 
     */
    UTIL.getScrollTop = function (win) {
        win = win || window;
        var d = win.document;
        return win.pageYOffset || d.documentElement.scrollTop || d.body.scrollTop;
    };

    /**
     * 
     *             
     * @public
     * @param {Window} win window
     * @return {number} 
     */
    UTIL.getViewWidth = function (win) {
        win = win || window;
        var doc = win.document;
        var client = doc.compatMode == 'BackCompat' ? doc.body : doc.documentElement;

        return client.clientWidth;
    };

    /**
     * 
     * 
     * @public
     * @param {Window} win window
     * @return {number} 
     */
    UTIL.getViewHeight = function (win) {
        win = win || window;
        var doc = win.document;
        var client = doc.compatMode == 'BackCompat' ? doc.body : doc.documentElement;

        return client.clientHeight;
    };

    /**
     * 
     *
     * @public
     * @param {Window} win window
     * @return {number} 
     */
    UTIL.getWidth = function (win) {
        win = win || window;
        var doc = win.document;
        var body = doc.body;
        var html = doc.documentElement;
        var client = doc.compatMode == 'BackCompat' ? body : doc.documentElement;

        return Math.max(html.scrollWidth, body.scrollWidth, client.clientWidth);
    };

    /**
     * 
     *             
     * @public
     * @param {Window} win window
     * @return {number} 
     */
    UTIL.getHeight = function (win) {
        win = win || window;
        var doc = win.document;
        var body = doc.body;
        var html = doc.documentElement;
        var client = doc.compatMode == 'BackCompat' ? body : doc.documentElement;

        return Math.max(html.scrollHeight, body.scrollHeight, client.clientHeight);
    };

    /**
     * 
     *
     * @public
     */
    UTIL.parseFileName = function (name) {
        if (!name) {
            return {};
        }

        var dotIndex = name.lastIndexOf('.');
        var fileName;
        var extName;

        if (dotIndex >= 0) {
            fileName = name.slice(0, dotIndex);
            extName = name.slice(dotIndex + 1);
        }
        else {
            fileName = name;
        }

        return { fileName: fileName, extName: extName, fullName: name };
    };

    //-------------------------------------------------
    // Deprecated
    //-------------------------------------------------

    /**
     * uimodel
     * 
     * @public 
     * @deprecated
     * @usage util.ref(container, 'abc', o); 
     *        containersetAbc
     *        
     *              
     *                  {ecui.ui.Control} => _uAbc
     *                  {Array} => _aAbc
     *                  {Function} => _fAbc
     *                  {others} => _mAbc
     * @param {Object} container 
     * @param {string} attrName 
     * @param {ecui.ui.Contorl|SomeModel|Array|Function} o 
     * @return {ecui.ui.Contorl|SomeModel|Array|Function} o 
     */
    UTIL.ref = function (container, attrName, o) {
        var f;
        if (isFunction(f = container[naming(attrName, 'set')])) {
            f.call(container, o);
        } else if (hasValue(f = attrNaming(attrName, o))){
            container[f] = o;
        }
        return o;
    };
    
    /**
     * model
     * 
     * @deprecated
     * @public 
     * @usage util.getModel(container, 'abc'); 
     *        containergetAbc
     *        container._mAbc
     * @param {Object} container 
     * @param {string} attrName 
     * @return {SomeModel} o 
     */
    UTIL.getModel = function (container, attrName) {
        var f;
        if (isFunction(f = container[naming(attrName, 'get')])) {
            return f.call(container);
        } else {
            return container[naming(attrName, '_m')];
        }
    };

    /**
     * "true" "false"true/false
     */
    UTIL.strToBoolean = function (str) {
        return str == 'true';
    };


})();
/**
 * configuration of xutil.ajax
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    consoleajax
 *           
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xutil.ajax, config.lang
 */

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var XAJAX = xutil.ajax;
    var isFunction = xutil.lang.isFunction;
    var AJAX = di.config.AJAX
    var LANG = di.config.Lang;
    var alert = di.helper.Dialog.alert;
    var confirm = di.helper.Dialog.confirm;
    var waitingPrompt = di.helper.Dialog.waitingPrompt;
    var hidePrompt = di.helper.Dialog.hidePrompt;
    
    //  ...

})();
/**
 * di.config.Dict
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    console
 * @author:  xxx(xxx@baidu.com)
 */

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var DICT = di.config.Dict;
    
    //  ...

})();
/**
 * di.config.Lang
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    console
 * @author:  xxx(xxx@baidu.com)
 */

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var LANG = di.config.Lang;

    //  ...        
    
})();
/**
 * configuration of xutil.ajax
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    consoleurl
 *           
 * @author:  xxx(xxx@baidu.com)
 */

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var URL = di.config.URL;
    
    // olap
    URL.addURL('CONSOLE_FRAME_INIT', '/xxx/xxxxxxxxx1.action');


	// TODO    
    // URL.addURL('CONSOLE_IND', '/xxx/xxxxxxxxx2.action');
    // URL.addURL('CONSOLE_DIM', '/xxx/xxxxxxxxx3.action');
    // URL.addURL('CONSOLE_CHART', '/xxx/xxxxxxxxx4.action');

})();
/**
 * di.helper.Dialog
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    console 
 * @author:  xxx(xxx@baidu.com)
 * @depend:  tangram.dom, tangram.page, ecui, xui
 */

(function() {
    
    //--------------------------------
    // 
    //--------------------------------

    var DIALOG = di.helper.Dialog;

    //  ...  
        
})();
/**
 * di.helper.Formatter
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    console
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xutil, tangram.ajax
 */

(function() {
    
    //----------------------------------------
    // 
    //----------------------------------------

    var FORMATTER = di.helper.Formatter;
        
    //  ...  

})();
/**
 * di.helper.Util
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    console
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xutil, tangram.ajax, jq.htmlClean
 */

(function() {

    var UTIL = di.helper.Util;
    var q = xutil.dom.q;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var isArray = xutil.lang.isArray;
    var isFunction = xutil.lang.isFunction;
    var isString = xutil.lang.isString;
    var encodeHTML = xutil.string.encodeHTML;
    var DICT;

    $link(function () {
        DICT = di.config.Dict;
    });

    /**
     * consolecomponent
     *
     * @public
     * @param {Object} diFactory
     * @param {Object} def
     * @param {HTMLElement} def.el
     * @param {string} def.clzKey
     * @param {Function} commonParamGetter
     * @return {Object} component
     */
    UTIL.cmptCreate4Console = function (diFactory, depict, commonParamGetter) {
        var cmpt;
        var i;
        var def;
        var ins;

        for (i = 0; def = depict[i]; i ++) {
            diFactory.addEntity(def, 'DEF');
            def = diFactory.getEntity(def.id, 'DEF');
            if (def.clzType === 'COMPONENT') {
                cmpt = def;
            }
        }

        cmpt = diFactory.createIns(
            cmpt,
            { tplMode: 'SELF', commonParamGetter: commonParamGetter } 
        );

        return cmpt;        
    };

    /**
     * consolecomponent
     *
     * @public
     * @param {Object} diFactory
     * @param {Object} cmptIns
     * @param {Object} data
     */
    UTIL.cmptSync4Console = function (diFactory, cmptIns, data) {
        // FIXME
        // producteditor
        // 
        var diEvent = diFactory.createDIEvent('editorfakeevent-query');

        diFactory.setInteractMemo(cmptIns, 'diEvent', diEvent);

        cmptIns.sync(data);

        diFactory.setInteractMemo(diFactory, 'diEvent', void 0);
    };

    /**
     * elDict.FLAG_CSSdom
     *
     * @public
     * @param {Object} el
     * @param {(string|Array)} flagCSS Dict.FLAG_CSS
     * @param {Function} callback 
     *          el, flagcss
     * @param {string} prefix 'c-'
     */
    UTIL.forEachCSSFlag = function (el, flagCSS, callback, prefix) {
        flagCSS = flagCSS || DICT.FLAG_CSS;
        !isArray(flagCSS) && (flagCSS = [flagCSS]);
        prefix = prefix || '';

        for (var j = 0, clz; clz = flagCSS[j]; j ++) {
            var els = q(prefix + clz, el);
            for (var i = 0, oi; oi = els[i]; i ++) {
                callback(oi, clz);
            }
        }
    };

    /**
     * eldom
     *
     * @public
     * @param {Object} el
     * @param {Function} callback 
     *          el
     */
    UTIL.forEachDom = function (el, callback) {
        var els = el.getElementsByTagName('*');
        for (var i = 0, el; el = els[i]; i ++) {
            callback(el);
        }
    };

    /**
     * consoleclassdi-o_o-xxx classc-di-o_o-xxx class
     *
     * @public
     * @param {Object} el
     */
    UTIL.addConsoleCSS = function (el, vtpl) {
        // var depictObj = vtpl.depict.obj;

        UTIL.forEachCSSFlag(
            el, 
            null,
            function (el, css) {
                addClass(el, 'c-' + css);
                if (css == 'di-o_o-item') {
                    var entityId = el.getAttribute(DICT.DI_ATTR);
                    if (!entityId) {
                        // FIXME
                        // cond
                        el.setAttribute('contentEditable', true);
                    }
                    else {
                        // vtpl.findEntityById(entityId).clzType
                        // FIXME
                        // conddepictform
                        addClass(el, 'c-di-o_o-cond-vui');
                    }
                }
            }
        );
    };

    /**
     * valuegetdom
     */
    UTIL.domData = function (el, attr, value) {
        if (value == null) {
            if (!el._data) {
                return;
            }
            return el._data[attr];
        }
        else {
            var data = el._data || (el._data = {});
            data[attr] = value;
        }
    };

    /**
     * consoleclassc-di-o_o-css class
     *
     * @public
     * @param {(HTMLElement|string)} html
     * @return {(HTMLElement|string)} html
     */
    UTIL.clearConsoleCSS = function (html) {
        if (isString(html)) {
            elTmp.innerHTML = html;
            html = elTmp;
        }
        var els = html.getElementsByTagName('*');

        for (var j = 0, eo; eo = els[j]; j ++) {
            var clz = eo.className.split(/\s+/).sort();
            var toRemove = [];
            for (var i = 0, cl; i < clz.length; i ++) {
                if ((cl = clz[i]) && cl.indexOf('c-di-o_o-') >= 0) {
                    toRemove.push(cl);
                }
            }
            removeClass(eo, toRemove.join(' '));
            eo.removeAttribute('contentEditable');
            delete eo._data;
        }

        return html.innerHTML;
    };
    var elTmp = document.createElement('div');

    /**
     * @public
     */
    UTIL.indexOf = function (arr, value) {
        for (var i = 0; i < arr.length; i ++) {
            if (arr[i] == value) {
                return i;
            }
        }
        return -1;
    };

    /**
     * select
     * 
     * @public
     */
    var SELECT = UTIL.select = {};

    /**
     * 
     * 
     * @public
     * @param {Array} html
     * @param {Obejct} options
     * @param {string} options.css
     * @param {Array.<Obejct>} options.datasource
     * @param {*|Function} options.selected
     * @param {Function} filter
     * @param {Object} attr
     * @param {string} options.textAttr
     * @param {string} options.valueAttr
     * @param {string} options.extraAttr
     * @param {Object} options.first 
     */
    SELECT.create = function (html, options) {
        var textAttr = options.textAttr || 'text';
        var valueAttr = options.valueAttr || 'value';
        var extraAttr = options.extraAttr || 'extra';
        html.push('<select class="', options.css || '', '" ');
        for (var key in options.attr) {
            html.push(' ', key, '="', encodeHTML(options.attr[key]), '" ');
        }
        html.push(' data-text-attr="', encodeHTML(textAttr), '" ');
        html.push(' data-value-attr="', encodeHTML(valueAttr), '" ');
        html.push(' data-extra-attr="', encodeHTML(extraAttr), '" ');
        html.push('>');
        createOptions(html, options);
        html.push('</select>');
        return html;
    };

    SELECT.createOptions = function (selEl, options) {
        var html = [];
        createOptions(html, options);
        selEl.innerHTML = html.join('');
    };

    /**
     * @public
     * @param {Object=} selEl
     * @param {Object=} datasource
     */
    SELECT.getSelected = function (selEl, datasource) {
        var opt = selEl.options[selEl.selectedIndex];
        var ret;
        var textAttr = selEl.getAttribute('data-text-attr');
        var valueAttr = selEl.getAttribute('data-value-attr');
        var extraAttr = selEl.getAttribute('data-extra-attr');

        if (opt) {
            ret = { index: selEl.selectedIndex };
            ret[textAttr] = opt.innerHTML;
            ret[extraAttr] = opt.getAttribute('data-simple-select-extra');
            var val = ret[valueAttr] = opt.getAttribute('data-simple-select');

            if (datasource) {
                for (var i = 0, o; i < datasource.length; i ++) {
                    if ((o = datasource[i]) && (o[valueAttr] == val)) {
                        return o;
                    }
                }
            }
        }
        return ret;
    };

    function createOptions(html, options) {
        var selFn = isFunction(options.selected)
            ? options.selected
            : function (o) { return o[options.valueAttr] == options.selected };
        var filterFn = options.filter 
            ? options.filter
            : function () { return true; };

        var first = options.first;
        var datasource = (first ? [first] : []).concat(options.datasource);
        
        for (var i = 0, o, sel; i < datasource.length; i ++) {
            if (o = datasource[i]) {
                sel = selFn(o) ? ' selected="selected" ' : '';
                (o === first || filterFn(o)) && html.push(
                    '<option ', sel, 
                        ' data-simple-select="', encodeHTML(getValue(o, options.valueAttr)), '" ', 
                        ' data-simple-select-extra="', encodeHTML(getValue(o, options.extraAttr)), '" ',
                    '>',
                        encodeHTML(getValue(o, options.textAttr)), 
                    '</option>'
                );
            }
        }

        return html;
    }

    function getValue(o, attr) {
        var v = isFunction(attr) ? attr(o) : o[attr];
        if (v == null) {
            return null;
        }
        return v;
    }

})();
/**
 * di.helper.ArgHandlerFactory
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xutil
 */

$namespace('di.shared.arg');
 
(function () {
    
    //--------------------------------
    // 
    //--------------------------------

    var isObject = xutil.lang.isObject;
    var extend = xutil.object.extend;
    var getByPath = xutil.object.getByPath;
    var setByPath = xutil.object.setByPath;
    var isArray = xutil.lang.isArray;
    var formatTime = di.helper.Util.formatTime;
    var parseTimeUnitDef = di.helper.Util.parseTimeUnitDef;
    var assign = xutil.object.assign;
    var merge = xutil.object.merge;
    var DI_FACTORY;

    $link(function () {
        DI_FACTORY = di.shared.model.DIFactory;
    });

    /**
     * 
     * parser
     *      thisscope
     *      
     *          {Array} tarArgs 
     *          {*...} 
     *
     * GeneralArgHandler
     * 
     *
     * argHandler
     *      var argHandler = di.helper.ArgHandlerFactory(
     *          [somObj1, 'handlerName1', 'asdf', 'zxcv', ...],
     *          [null, 'handlerName2', 'zxz', 1242, ...]
     *      );
     * argHandlerhandlerName1, handlerName2
     * handlerName1'asdf', 'zxcv', ... 
     * handlerName2
     *
     * @param {Array...} descs 
     *          Array
     *              scope
     *              
     *              tarArgs
     * @return {Function} 
     */
    $namespace().ArgHandlerFactory = function (descs) {
        // 
        if (arguments.length < 1) {
            return null;
        }

        var funcs = [];

        // check
        for (var i = 0, desc; i < arguments.length; i ++) {
            desc = arguments[i];
            funcs.push(
                [
                    desc[0], 
                    NS[desc[1]], 
                    desc.slice(2)
                ]
            );
            if (!funcs[funcs.length - 1][1]) {
                return null;
            }
        }

        return function (tarArgs) {
            // argHandler
            for (var i = 0, func; func = funcs[i]; i ++) {
                func[1].apply(
                    func[0], 
                    [tarArgs].concat(func[2])
                );
            }
            return tarArgs;
        }
    }

    var NS = {};

    /**
     * 
     * 
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {number=} index index
     */
    NS.clear = function (tarArgs, index) {
        if (index != null) {
            tarArgs[index] = void 0;
        }
        else {
            for (var i = 0; i < tarArgs.length; i ++) {
                tarArgs[i] = void 0;
            }
        }
    };

    /**
     * 
     * 'aaa.bbb[3][4].ccc.ddd'
     * 
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {string} srcPath null
     * @param {string} tarPath null
     * @param {number} index 0
     * @param {Object=} options xutil.object.setByPathoptions
     */
    NS.attr = function (tarArgs, srcPath, tarPath, index, options) {
        index = String(index || 0);
        var value = tarArgs[index];
        setByPath(
            !tarPath ? index : (index + '.' + tarPath),
            isObject(value) ? getByPath(srcPath, value, options) : value,
            tarArgs,
            options
        );
    };

    /**
     * arrPatharcPathtarPath
     * 'aaa.bbb[3][4].ccc.ddd'
     * 
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {string} arrPath nulltarArgs[0]
     * @param {string} srcPath null
     * @param {string} tarPath null
     * @param {Object=} options xutil.object.setByPathoptions
     */
    NS.attrArr = function (tarArgs, arrPath, srcPath, tarPath, options) {
        var value = tarArgs[0];
        var arr = isObject(value)
            ? (
                arrPath 
                    ? getByPath(arrPath, value, options) 
                    : value
            )
            : null;

        if (isArray(arr)) {
            for (var i = 0, itemA; i < arr.length; i ++) {
                NS.attr(arr, srcPath, tarPath, i, options);
            }
        }
    };

    /**
     * 
     * 
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {*} data 
     * @param {number} index 0
     */
    NS.setData = function (tarArgs, data, index) {
        tarArgs[index || 0] = data;
    };

    /**
     * merge
     * 
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {*} data 
     * @param {number} index 0
     */
    NS.mergeData = function (tarArgs, data, index) {
        merge(tarArgs[index || 0], data);
    };

    /**
     * diIdListiddigetValue
     * tarArgs
     *
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {string} diid
     * @param {string} srcPath 
     * @param {string} tarPath 
     * @param {Object=} options xutil.object.setByPathoptions
     */
    NS.getValue = function (tarArgs, diId, srcPath, tarPath, options) {
        var ins = DI_FACTORY().getEntity(diId, 'INS');
        var o = [];
        if (ins && ins.$di) {
            var value = ins.$di('getValue');
            setByPath(
                !tarPath ? '0' : ('0.' + tarPath), 
                isObject(value) ? getByPath(srcPath, value, options) : value,
                o,
                options
            );
            
            if (isObject(o[0])) {
                extend(tarArgs[0] || (tarArgs[0] = {}), o[0]);
            }
            else {
                tarArgs[0] = o[0];
            }
        }
    };

    /**
     * reportTemplateId
     * tarArgs
     *
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {string} diid
     */
    NS.sourceTemplateId = function (tarArgs, diId) {
        var ins = DI_FACTORY().getEntity(diId, 'INS');
        if (ins && ins.$di) {
            if (!isObject(tarArgs[0])) {
                tarArgs[0] = {};
            }
            tarArgs[0].sourceTemplateId = ins.$di('getReportTemplateId');
        }
    };

    /**
     * dimTagList
     * 
     * dimTagList/
     *
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {string} diid
     */
    NS.dimTagsList = function (tarArgs, diId) {
        var ins = DI_FACTORY().getEntity(diId, 'INS');
        if (ins && ins.$di) {
            if (!isObject(tarArgs[0])) {
                tarArgs[0] = {};
            }
            tarArgs[0].dimTagsList = ins.$di('getDimTagsList');
        }
    };

    /**
     * 
     * 
     *
     * @public
     * @this {Object} tarArgsscope
     * @param {Array} tarArgs
     * @param {string} attrName 
     * @param {Object.<Array.<string>>} timeUnitDefMap  
     *      { D: ['-1Y', '0D'], W: ['-1Y', '0D'], M: ['-24M', '0D'], Q: ['-2Y', '0D'] }
     */
    NS.patchTime = function (tarArgs, attrName, timeUnitDefMap) {
        var arg = tarArgs[0];
        if (isObject(arg) && isObject(arg = arg[attrName])) {
            var gran = arg.granularity || 'D';
            arg = parseTimeUnitDef(
                timeUnitDefMap[gran], 
                [arg.start, arg.end, arg.range]
            );
            arg.start = formatTime(arg.start, gran);
            arg.end = formatTime(arg.end, gran);
            extend(tarArgs[0][attrName], arg);
        }
    };

})();
/**
 * di.shared.vui.HiddenInput
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 
     */
    var HIDDEN_INPUT = $namespace().HiddenInput = 
            inheritsObject(XOBJECT, constructor);
    var HIDDEN_INPUT_CLASS = HIDDEN_INPUT.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        (this._eMain = options.el).style.display = 'none';
    };
    
    /**
     * 
     *
     * @public
     * @param {Object} data 
     * @param {(Object|Array}} data.datasource 
     * @param {*} data.value 
     */
    HIDDEN_INPUT_CLASS.setData = function (data) {
        this._oData = data;
    };

    /**
     * 
     *
     * @public
     * @return {*} 
     */
    HIDDEN_INPUT_CLASS.getValue = function () {
        return (this._oData || {}).value;
    };

})();
/**
 * di.shared.vui.MultiCheckbox
 * Copyright 2014 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  xuezhao(xuezhao@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 
     */
    var MULTI_CHECKBOX = $namespace().MultiCheckbox = 
            inheritsObject(XOBJECT, constructor);
    var MULTI_CHECKBOX_CLASS = MULTI_CHECKBOX.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     * @param {HTMLElement} options.el di
     * @param {string} options.id DOMdata-o_o-didi
     */
    function constructor(options) {
        this._eMain = options.el;
        
        this._eMain.innerHTML = '';
    };
    
    /**
     *  
     *
     * @param {Object} data 
     * @param {Array<Object>} data.datasource 
     */
    MULTI_CHECKBOX_CLASS.setData = function (data) {
        render.call(this, data.datasource || []);
    };

    /**
     * 
     *
     * @public
     * @return {Array.<string>} 
     */
    MULTI_CHECKBOX_CLASS.getValue = function () {
        var el = this._eMain;
        var inputs = el.getElementsByTagName('input');
        var checkedValues = [];
        
        for (var i = 0, input; input = inputs[i]; i++) {
            if (input.checked) {
                checkedValues.push(input.value);
            }
        }
        
        return checkedValues;
    };
    
    /**
     * 
     *
     * @public
     * @param {Array.<string>} values 
     */
    MULTI_CHECKBOX_CLASS.setValue = function (values) {
        values = values || [];
        
        var el = this._eMain;
        var inputs = el.getElementsByTagName('input');
        
        for (var i = 0, input; input = inputs[i]; i++) {
            //  forvaluechecked
            input.checked = false;
            
            for (var j = 0, len = values.length; j < len; j++) {
                if (input.value == String(values[j])) {
                    input.checked = true;
                    
                    break;
                }
            }
        }
    };
    
    /**
     * 
     * 
     * @param {Array.<Object>} data 
     * @private
     * data: [
     *      { text: '', value: 'xxx' },
     *      { text: '', value: 'xxx' },
     *      { text: '', value: 'xxx' },
     *      { text: '', value: 'xxx' },
     *      { text: '', value: 'xxx' }
     *  ]
     */
    function render(data) {
        data = data || [];
        
        var el = this._eMain;
        var html = [];
        
        for (var i = 0, len = data.length; i < len; i++) {
            html.push(
                '<label class="">',
                    '<input type="checkbox" value="', data[i].value, '" />',
                    
                    '<span class="">',
                        data[i].text,
                    '</span>',
                '</label>'
            );
        }
        
        el.innerHTML = html.join('');
    }
})();
/**
 * di.shared.vui.OfflineDownload
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var ecuiCreate = di.helper.Util.ecuiCreate;
    var isObject = xutil.lang.isObject;
    var isArray = xutil.lang.isArray;
    var template = xutil.string.template;
    var domChildren = xutil.dom.children;
    var domRemove = xutil.dom.remove;
    var getByPath = xutil.object.getByPath;
    var DICT = di.config.Dict;
    var XOBJECT = xui.XObject;
    var UI_BUTTON;
    var UI_FORM;

    $link(function () {
        UI_BUTTON = getByPath('ecui.ui.HButton');
        UI_FORM = getByPath('ecui.ui.Form');
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {string} options.skin css
     * @param {string} options.text ''
     * @param {string} options.confirmText ''
     * @param {string} options.cancelText ''
     * @param {string} options.headText ''
     * @param {string} options.inputInfo 
     */
    var OFFLINE_DOWNLOAD = $namespace().OfflineDownload = 
            inheritsObject(XOBJECT, constructor);
    var OFFLINE_DOWNLOAD_CLASS = OFFLINE_DOWNLOAD.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'offline-download');

        var eel;
        var html;

        eel = document.createElement('div');
        el.appendChild(eel);
        this._uBtn = ecuiCreate(
            UI_BUTTON, 
            eel, 
            null,
            {
                text: options.text || '',
                skin: options.skin
            }
        );

        // 
        if (!this._uDialog) {
            eel = document.createElement('div');
            html = [
                '<label></label>',
                '<span class="offline-download-head">' + (options.headText || '') + '</span>',
                '<input type="input" class="offline-download-input"/>',
                '<div></div>',
                '<div></div>'
            ];
            eel.innerHTML = html.join('');
            html = domChildren(eel);
            this._eInput = html[2];
            this._uDialog = ecuiCreate(UI_FORM, eel, null, { hide: true });
            this._uConfirmBtn = ecuiCreate(
                UI_BUTTON, 
                html[3],
                null,
                {
                    text: options.confirmText || '',
                    skin: options.skin
                }
            );
            this._uCancelBtn = ecuiCreate(
                UI_BUTTON, 
                html[4],
                null,
                {
                    text: options.cancelText || '',
                    skin: options.skin
                }
            );

            document.body.appendChild(eel);
        }
    };

    OFFLINE_DOWNLOAD_CLASS.init = function () {
        var me = this;

        this._uBtn.onclick = function () {
            me.$clear();
            me._uDialog.center();
            me._uDialog.showModal(DICT.DEFAULT_MASK_OPACITY);
        };

        this._uConfirmBtn.onclick = function () {
            me.notify('confirm', [me._eInput.value]);
            me._uDialog.hide();
        };

        this._uCancelBtn.onclick = function () {
            me._uDialog.hide();
        }

        this._uDialog.init();
        this._uBtn.init();
        this._uConfirmBtn.init();
        this._uCancelBtn.init();
    };   

    OFFLINE_DOWNLOAD_CLASS.$clear = function () {
        this._eInput.value = '';
    };

    OFFLINE_DOWNLOAD_CLASS.getValue = function () {
        return { email: this._eInput.value };
    };

    OFFLINE_DOWNLOAD_CLASS.dispose = function () {
        if (this._uDialog) {
            var el = this._uDialog.getOuter();
            this._uDialog.dispose();
            this._uBtn.dispose();
            this._uConfirmBtn.dispose();
            this._uCancelBtn.dispose();
            domRemove(el);
        }
    };       
    
})();
/**
 * di.shared.model.DimSelectModel  
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var extend = xutil.object.extend;
    var getByPath = xutil.object.getByPath;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var assign = xutil.object.assign;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var arrayProtoPush = Array.prototype.push;    
    var download = UTIL.download;
    var logError = UTIL.logError;
    var XDATASOURCE = xui.XDatasource;
        
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var MULTIDIM_SELECT_MODEL = 
            $namespace().MultiDimSelectModel = 
            inheritsObject(XDATASOURCE, constructor);
    var MULTIDIM_SELECT_MODEL_CLASS = 
    		MULTIDIM_SELECT_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {

        this._multiSelectData;
    }

    var URL_MAP = {
        MULTISELECT: {
            RTPL_OLAP_TABLE: URL.fn('DIM_MULTISELECT_TABLE'),
            RTPL_OLAP_CHART: URL.fn('DIM_MULTISELECT_CHART')
        },
        SAVE: {
            RTPL_OLAP_TABLE: URL.fn('DIM_SELECT_SAVE_TABLE'),
            RTPL_OLAP_CHART: URL.fn('DIM_SELECT_SAVE_CHART')
        }
    };

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    MULTIDIM_SELECT_MODEL_CLASS.url = function(options) {
        return URL_MAP[options.datasourceId][options.args.reportType]();
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    MULTIDIM_SELECT_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            // 
            TREE: function(options) {
                var paramArr = this.$createBaseParam(options);
                if (options.args.dimMode == 'TIME') {
                    paramArr.push('isTimeDim=true');
                }
                return paramArr.join('&');
            },

             // 
            MULTISELECT: function(options) {
                var paramArr = this.$createBaseParam(options);
                if (options.args.dimMode == 'TIME') {
                    paramArr.push('isTimeDim=true');
                }
                return paramArr.join('&');
            },

            // 
            SAVE: function(options) {
                var args = options.args;
                var paramArr = this.$createBaseParam(options);

                paramArr.push(
                    'selectedLevel=' + textParam(args.selectedLevel)
                );
                if(args.selectedDims){
                    for(var i = 0; i < args.selectedDims.length ; i ++){
                        paramArr.push(
                            'selectedNodes=' + textParam(args.selectedDims[i])
                        );  
                    }
                }
                
                return paramArr.join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    MULTIDIM_SELECT_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            MULTISELECT: function(data) {
                this._multiSelectData = data.dimValue;
            }
        }
    );

    MULTIDIM_SELECT_MODEL_CLASS.getMultiSelectData = function() {
        return this._multiSelectData;
    };


    /**
     * 
     * 
     * @protected
     * @param {Object} options sync
     * @return {Array.<string>} 
     */
    MULTIDIM_SELECT_MODEL_CLASS.$createBaseParam = function(options) {
        var args = options.args;
        var paramArr = [];

        if (args.commonParamGetter) {
            paramArr.push(args.commonParamGetter());
        }
        paramArr.push(
            'dimSelectName=' + textParam(args.uniqName)
        );
        paramArr.push(
            'from=' + textParam(args.selLineName)
        );

        return paramArr;
    };

})();


/**
 * ist.opanaly.fcanaly.ui.MultiDimSelectPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui
 */

$namespace('di.shared.ui');

(function() {
    
    //-----------------------------------
    // 
    //-----------------------------------
    
    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var ecuiCreate = UTIL.ecuiCreate;
    var template = xutil.string.template;
    var q = xutil.dom.q;
    var addClass = xutil.dom.addClass;
    var createSingleton = xutil.object.createSingleton;
    var hasValueNotBlank = xutil.lang.hasValueNotBlank;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var stringToDate = xutil.date.stringToDate;
    var trim = xutil.string.trim;
    var bind = xutil.fn.bind;
    var XVIEW = xui.XView;
    var UI_FORM = ecui.ui.Form;
    var UI_BUTTON = ecui.ui.Button;
    var UI_IND_TREE = ecui.ui.IndTree;
    var alert = di.helper.Dialog.alert;
    var DIM_SELECT_MODEL;

    $link(function() {
        MULTIDIM_SELECT_MODEL = di.shared.model.MultiDimSelectModel;
    });

    //-----------------------------------
    // 
    //-----------------------------------

    /**
     * 
     * MULTIDIM_SELECT_PANEL()
     * 
     * @class
     * @extends xui.XView
     */
    var MULTIDIM_SELECT_PANEL = 
        $namespace().MultiDimSelectPanel = createSingleton(
            XVIEW,
            MultiDimSelectPanelConstructor
        );
    var MULTIDIM_SELECT_PANEL_CLASS = MULTIDIM_SELECT_PANEL.prototype;

    /**
     * 
     *
     * @constructor
     * @param {Object} options 
     */
    function MultiDimSelectPanelConstructor(options) {
        createModel.call(this, options);
        createView.call(this, options);
        this.init();
    }
    // needLimitajax
    // handleTreeSuccess
    var needLimit = false ;
    var dimLimitedSize = 30; 
    var otherLimitedSize = 300;
    
    //-----------------------------------
    // 
    //-----------------------------------

    var TPL_MAIN = [
            '<div class="q-di-form">',
                '<label></label>',
                '<div class="q-di-dimlimited"></div>',
                '<div class="q-di-level"></div>',
                '<div class="di-dim-mutliselect-tree">',
                    '<div class="q-di-mutlidim"></div>',
                '</div>',
                '<div>',
                    '<div class="di-dim-select-btn">',
                        '<div class="ui-button-g ui-button q-di-submit"></div>',
                        '<div class="ui-button q-di-cancel"></div>',
                    '</div>',
                '<div>',
            '</div>'
        ].join('');

    //-----------------------------------
    // 
    //-----------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel() {
        this._mDimSelectModel = new MULTIDIM_SELECT_MODEL();
    };

    /**
     * 
     *
     * @private
     */
    function createView() {
        // dom
        var el = this._eMain = document.createElement('div');
        addClass(el, 'di-dim-mutliselect-panel');

        document.body.appendChild(el);
        el.innerHTML = TPL_MAIN;

        // 
        this._uForm = ecuiCreate(
            UI_FORM,
            q('q-di-form', el)[0],
            null,
            { hide: true }
        );


        this._uSubmitBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-submit', el)[0]
        );
        this._uCancelBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-cancel', el)[0]
        );
    };

    /**
     * @override
     */
    MULTIDIM_SELECT_PANEL_CLASS.init = function() {
        var me = this;

        // 
        this._mDimSelectModel.attach(
            ['sync.preprocess.MULTISELECT', this.disable, this],
            ['sync.result.MULTISELECT', this.$handleTreeSuccess, this],
            ['sync.error.MULTISELECT', this.$handleTreeError, this],
            ['sync.complete.MULTISELECT', this.enable, this]
        );
        this._mDimSelectModel.attach(
            ['sync.preprocess.SAVE', this.disable, this],
            ['sync.result.SAVE', this.$handleSubmitSuccess, this],
            ['sync.error.SAVE', this.$handleSubmitError, this],
            ['sync.complete.SAVE', this.enable, this]
        );
        this._uSubmitBtn.onclick = bind(this.$submitHandler, this);
        this._uCancelBtn.onclick = bind(this.$cancelHandler, this);

        // Init
        this._uForm.init();
        this._uSubmitBtn.init();
        this._uCancelBtn.init();

        // this._uForm.$resize();

        this.$resetInput();
    };
    
    /**
     * @override
     */
    MULTIDIM_SELECT_PANEL_CLASS.dispose = function() {
    	MULTIDIM_SELECT_PANEL.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     * @param {string} mode 
     *                       'VIEW': 
     *                       'EDIT': 
     * @param {Object} options 
     * @param {string=} options.uniqName
     * @param {string} options.selLineName
     * @param {Function} options.commonParamGetter
     * @param {string} options.reportType RTPL_OLAP_TABLERTPL_OLAP_CHART
     * @param {string=} options.dimMode 
     *      'NORMAL', 'TIME'
     */
    MULTIDIM_SELECT_PANEL_CLASS.open = function(mode, options) {
        this._sMode = mode;
        this._oOptions = options;

        this.$resetInput();

        // dom
        var levelDom = q('q-di-level', this._eMain)[0];
            levelDom.innerHTML='';
        var mutliDimDom = q('q-di-mutlidim', this._eMain)[0];
            mutliDimDom.innerHTML='';

        // 
        this._mDimSelectModel.sync(
            { 
                datasourceId: 'MULTISELECT', 
                args: this._oOptions
            }
        );
    };

    /**
     * 
     * 
     * @public
     */
    MULTIDIM_SELECT_PANEL_CLASS.$resetInput = function() {
        // 
        // clear prompt
        this.$clearPrompt();
    };

    /**
     * prompt
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$clearPrompt = function() {
        // TODO
    };

    /**
     * 
     *
     * @override
     * @public
     */
    MULTIDIM_SELECT_PANEL_CLASS.enable = function(enable) {
        if (this._bDisabled && this._sMode == 'EDIT') {
            this._uSubmitBtn.enable();
            this._uCancelBtn.enable();
        }
        MULTIDIM_SELECT_PANEL.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @override
     * @public
     */
    MULTIDIM_SELECT_PANEL_CLASS.disable = function(enable) {
        if (!this._bDisabled) {
            this._uSubmitBtn.disable();
            this._uCancelBtn.disable();
        }
        MULTIDIM_SELECT_PANEL.superClass.disable.call(this);
    };    

    /**
     * 
     *
     * @protected
     * @event
     */
    MULTIDIM_SELECT_PANEL_CLASS.$submitHandler = function() {
        var levelDom = q('di-level-radio', this._eMain);
        var mutliDimDom = q('di-mutlidim-checkbox', this._eMain);
        var selectedLevel;
        var selectedDims = [];
        for(var i = 0; i < levelDom.length ; i++){
           if(levelDom[i].checked == true){
                selectedLevel = levelDom[i].value;
           }
        }
        for(var j = 0; j < mutliDimDom.length ; j++){
           if(mutliDimDom[j].checked == true){
                selectedDims.push(mutliDimDom[j].value);
           }
        }

        if(selectedDims.length == 0){
            alert('');
            return ;
        }
        //limitedOverstepFlagtrue
        var limitedOverstepFlag = false;
        if(needLimit && selectedDims[0].indexOf('all$') == 0 && selectedDims.length > dimLimitedSize+1){
            limitedOverstepFlag = true;
        }else if(needLimit && selectedDims[0].indexOf('all$') < 0 && selectedDims.length > dimLimitedSize){
            limitedOverstepFlag = true;
        }
        //otherOverstepFlagtrue
        var otherOverstepFlag = false;
        if(selectedDims[0].indexOf('all$') == 0 && selectedDims.length > otherLimitedSize+1){
            otherOverstepFlag = true;
        }else if(selectedDims[0].indexOf('all$') < 0 && selectedDims.length > otherLimitedSize){
            otherOverstepFlag = true;
        }

        // 
        if(limitedOverstepFlag){
            alert(''+dimLimitedSize+'');
            return ;
        }else if(otherOverstepFlag){
            alert(''+otherLimitedSize+'');
            return ;
        }

        this._mDimSelectModel.sync(
            { 
                datasourceId: 'SAVE',
                args: extend(
                    {
                        selectedLevel: selectedLevel,
                        selectedDims: selectedDims
                    },
                    this._oOptions
                )
            }
        );
    };

    /**
     * 
     *
     * @protected
     * @event
     */
    MULTIDIM_SELECT_PANEL_CLASS.$cancelHandler = function() {
        this._uForm.hide();
    };

    /**
     * 
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$handleTreeSuccess = function() {
        try {
           var model = this._mDimSelectModel;
           // 
           var dimLimitedDiv = q('q-di-dimlimited', this._eMain)[0];
           dimLimitedDiv.innerHTML = '';
           this._uForm.showModal(DICT.DEFAULT_MASK_OPACITY);
           var levelDom = q('q-di-level', this._eMain)[0];
           var multiData = model.getMultiSelectData();
           var selectedLevel ;
            for (var i = 0 ; i < multiData.length ; i++) {
                // 
                
                    if(multiData[i].needLimit && i == 0){
                        dimLimitedDiv.innerHTML = ''+dimLimitedSize+'';
                        needLimit = true ;
                    }else if(!multiData[i].needLimit && i == 0){
                        needLimit = false ;
                    }
                var levelRadio = document.createElement("INPUT");  
                    levelRadio.type = "radio";  
                    levelRadio.name = "level";  
                    levelRadio.value = multiData[i].name; 
                    addClass(levelRadio, 'di-level-radio');
                var levelEl = document.createElement("span");
                    levelEl.innerHTML = " " + multiData[i].caption+" ";
                    levelDom.appendChild(levelRadio);
                    levelDom.appendChild(levelEl);
                    if(multiData[i].selected == true ){
                        selectedLevel = multiData[i];
                        levelRadio.checked = "checked";
                    }
                  //bind
                levelRadio.onclick = bind(
                    function (levelData){
                        var mutliDimDom = q('q-di-mutlidim', this._eMain)[0];
                        handleMutliDimSuccess(levelData,this._eMain);
                    },
                    this,
                    multiData[i]
                );
               
            };
            //html
            handleMutliDimSuccess(selectedLevel,this._eMain);
            this._uForm.center();
            
            //   di-stub iframe
            DIALOG.adjustDialogPosition(this._uForm.getMain());
        }
        catch (e) {
            // 
            // try catch
            this.$handleTreeError();
        }
    };

    // checkbox
    function handleMutliDimSuccess (selectedLevel,eMain){
        var mutliDimDom = q('q-di-mutlidim', eMain)[0];
            mutliDimDom.innerHTML = "";
            for (var j = 0 ; j < selectedLevel.children.length ; j++) {
                var dimData = selectedLevel.children[j];
                var dimCheckBox = document.createElement("INPUT");  
                    dimCheckBox.type = "checkbox";  
                    dimCheckBox.name = "selectedDims";  
                    dimCheckBox.value = dimData.name; 
                    addClass(dimCheckBox, 'di-mutlidim-checkbox'); 
                    dimCheckBox.onclick =bind(
                        function (dimData){
                            // var mutliDimDom = q('q-di-mutlidim', eMain)[0];
                            dimClickHandle(dimData,eMain);
                        },
                        this,
                        dimCheckBox
                );
                if(dimData.selected == true ){
                    dimCheckBox.checked = "checked";
                }
                var dimEl = document.createElement("span");
                dimEl.innerHTML = " " + dimData.caption;
                var dimDiv = document.createElement("div"); 
                dimDiv.appendChild(dimCheckBox);
                dimDiv.appendChild(dimEl);
                mutliDimDom.appendChild(dimDiv);
            }
        // 
        checkSelectedStatus(eMain);
    }

    //
    //
    function checkSelectedStatus(eMain){
        var firstDimDom = q('di-mutlidim-checkbox', eMain)[0];
        var dimDoms = q('di-mutlidim-checkbox', eMain);
        if (firstDimDom.checked == true){
            for (var i = 0 ;i < dimDoms.length ; i++){
                dimDoms[i].checked = true;
            }
        } else {
            var otherFlag = true;
            for (var i = 1 ;i < dimDoms.length ; i++){
               if (dimDoms[i].checked == false){
                   otherFlag = false; 
               } 
            } 
            if (otherFlag == true){
                firstDimDom.checked=true;
            }
        }
    }

    // checkbox
    function dimClickHandle(dimData,eMain){
        var firstDimDom = q('di-mutlidim-checkbox', eMain)[0];
        var dimDoms = q('di-mutlidim-checkbox', eMain);
        var flag = dimData.checked;
        // 
        if (dimData.value == firstDimDom.value){
            for (var i = 0 ;i < dimDoms.length ; i++){
                dimDoms[i].checked = flag;
            }
        } else{
            // 
            if (flag == false){
                firstDimDom.checked = false;
            } else {
                var otherFlag = true;
                for (var i = 1 ;i < dimDoms.length ; i++){
                   if (dimDoms[i].checked == false){
                       otherFlag = false; 
                   } 
                } 
                if (otherFlag == true){
                    firstDimDom.checked=true;
                }
            }
        }
    }
    /**
     * 
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$handleTreeError = function() {
        var me = this;
        // 
        DIALOG.alert(
            LANG.GET_DIM_TREE_ERROR,
            function() {
                me._uForm.hide();
            }
        );
    };

    /**
     * 
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$handleSubmitSuccess = function() {
        this._uForm.hide();
        /**
         * @event di.shared.ui.DimSelectPanel#submit.close
         */
        this.notify('submit.close');

        this._oOptions.onconfirm();
    };

    /**
     * 
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$handleSubmitError = function(status) {
        DIALOG.alert(LANG.SAVE_FAILURE);
    };

})();


/**
 * di.shared.model.DimSelectModel  
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var extend = xutil.object.extend;
    var getByPath = xutil.object.getByPath;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var assign = xutil.object.assign;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var arrayProtoPush = Array.prototype.push;    
    var download = UTIL.download;
    var logError = UTIL.logError;
    var XDATASOURCE = xui.XDatasource;
        
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var DIM_SELECT_MODEL = 
            $namespace().DimSelectModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DIM_SELECT_MODEL_CLASS = 
            DIM_SELECT_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * hierachy
         *
         * @type {Array.<Object>}
         * @private
         */
        this._oHierarchyRoot;
        /**
         * hierachy
         *
         * @type {Array.<Object>}
         * @private
         */
        this._oCurrDimTree;
        /**
         * 
         *
         * @type {string} 
         * @private
         */
        this._sDimName;
        /**
         * schema
         *
         * @type {string} 
         * @private
         */
        this._sSchemaName;
        /**
         * , 'TIME''NORMAL'
         *
         * @type {string} 
         * @private
         */
        this._sDimType;
        /**
         * hierarchy, keyhierarchyname
         *
         * @type {Map} 
         * @private
         */
        this._oLevelMap;
    }

    var URL_MAP = {
        TREE: {
            RTPL_OLAP_TABLE: URL.fn('DIM_TREE_TABLE'),
            RTPL_OLAP_CHART: URL.fn('DIM_TREE_CHART')
        },
        SAVE: {
            RTPL_OLAP_TABLE: URL.fn('DIM_SELECT_SAVE_TABLE'),
            RTPL_OLAP_CHART: URL.fn('DIM_SELECT_SAVE_CHART')
        }
    };

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.url = function(options) {
        return URL_MAP[options.datasourceId][options.args.reportType]();
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            // 
            TREE: function(options) {
                var paramArr = this.$createBaseParam(options);
                if (options.args.dimMode == 'TIME') {
                    paramArr.push('isTimeDim=true');
                }
                return paramArr.join('&');
            },

            // 
            SAVE: function(options) {
                var args = options.args;
                var paramArr = this.$createBaseParam(options);

                paramArr.push(
                    'hierarchyName=' + textParam(this._oCurrDimTree.name)
                );
                arrayProtoPush.apply(
                    paramArr,
                    wrapArrayParam(args.treeSelected, 'selectedNodes')
                );
                arrayProtoPush.apply(
                    paramArr,
                    wrapArrayParam(args.levelSelected, 'levelUniqueNames')
                );

                if (args.dimMode == 'TIME') {
                    // 
                    var start = args.timeSelect.start
                        ? dateToString(args.timeSelect.start) : '';
                    var end = args.timeSelect.end 
                        ? dateToString(args.timeSelect.end) : start;
                    paramArr.push('startDay=' + start);
                    paramArr.push('endDay=' + end);
                }
                
                return paramArr.join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            // 
            TREE: function(data, ejsonObj, options) {
                try {
                    // timeType. 0
                    var timeType = data['timeType'];
                    // 
                    this._oTimeSelect = data['timeSelects'] || {};

                    var dimTree = data['dimTree'];
                    var root = this._oHierarchyRoot = dimTree['dimTree'];
                    // hierarchyhierarchy
                    this._oCurrDimTree = root['children'][0];
                    this._oLevelMap = dimTree['hierarchyLevelUniqueNames'];
                    this._sDimName = dimTree['dimName'];
                    this._sSchemaName = dimTree['schemaName'];
                    this._sDimType = dimTree['isTimeDim'] ? 'TIME' : 'NORMAL';
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            }
        }
    );

    /**
     * 
     * 
     * @public
     * @return {Object} 
     */
    DIM_SELECT_MODEL_CLASS.getCurrDimTree = function() {
        return this._oCurrDimTree;
    };

    /**
     * 
     * 
     * @public
     * @return {Object} 
     */
    DIM_SELECT_MODEL_CLASS.getTimeSelect = function() {
        return this._oTimeSelect;
    };

    /**
     * 
     * 
     * @public
     * @return {Array.<Object>} 
     */
    DIM_SELECT_MODEL_CLASS.getCurrLevelList = function() {
        return (this._oLevelMap && this._oCurrDimTree)
            ? this._oLevelMap[this._oCurrDimTree.name]
            : null;
    };

    /**
     * 
     * 
     * @protected
     * @param {Object} options sync
     * @return {Array.<string>} 
     */
    DIM_SELECT_MODEL_CLASS.$createBaseParam = function(options) {
        var args = options.args;
        var paramArr = [];

        if (args.commonParamGetter) {
            paramArr.push(args.commonParamGetter());
        }
        paramArr.push(
            'dimSelectName=' + textParam(args.uniqName)
        );
        paramArr.push(
            'from=' + textParam(args.selLineName)
        );

        return paramArr;
    };

})();


/**
 * ist.opanaly.fcanaly.ui.DimSelectPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui
 */

$namespace('di.shared.ui');

(function() {
    
    //-----------------------------------
    // 
    //-----------------------------------
    
    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var ecuiCreate = UTIL.ecuiCreate;
    var template = xutil.string.template;
    var q = xutil.dom.q;
    var addClass = xutil.dom.addClass;
    var createSingleton = xutil.object.createSingleton;
    var hasValueNotBlank = xutil.lang.hasValueNotBlank;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var stringToDate = xutil.date.stringToDate;
    var trim = xutil.string.trim;
    var bind = xutil.fn.bind;
    var XVIEW = xui.XView;
    var UI_FORM = ecui.ui.Form;
    var UI_BUTTON = ecui.ui.Button;
    var UI_IND_TREE = ecui.ui.IndTree;
    var UI_CALENDAR = ecui.ui.IstCalendar;
    var DIM_SELECT_MODEL;

    $link(function() {
        DIM_SELECT_MODEL = di.shared.model.DimSelectModel;
    });

    //-----------------------------------
    // 
    //-----------------------------------

    /**
     * 
     * DIM_SELECT_PANEL()
     * 
     * @class
     * @extends xui.XView
     */
    var DIM_SELECT_PANEL = 
        $namespace().DimSelectPanel = createSingleton(
            XVIEW,
            dimSelectPanelConstructor
        );
    var DIM_SELECT_PANEL_CLASS = DIM_SELECT_PANEL.prototype;

    /**
     * 
     *
     * @constructor
     * @param {Object} options 
     */
    function dimSelectPanelConstructor(options) {
        createModel.call(this, options);
        createView.call(this, options);
        this.init();
    }

    //-----------------------------------
    // 
    //-----------------------------------

    var TPL_MAIN = [
            '<div class="q-di-form">',
                '<label></label>',
                '<div class="di-dim-select-tree">',
                    '<div class="q-di-tree"></div>',
                '</div>',
                '<div class="di-dim-select-cal">',
                    '<div class="q-calendar"></div>',
                '</div>',
                '<div>',
                    '<div class="di-dim-select-btn">',
                        '<div class="ui-button-g ui-button q-di-submit"></div>',
                        '<div class="ui-button q-di-cancel"></div>',
                    '</div>',
                '<div>',
            '</div>'
        ].join('');

    //-----------------------------------
    // 
    //-----------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel() {
        this._mDimSelectModel = new DIM_SELECT_MODEL();
    };

    /**
     * 
     *
     * @private
     */
    function createView() {
        // dom
        var el = this._eMain = document.createElement('div');
        addClass(el, 'di-dim-select-panel');

        document.body.appendChild(el);
        el.innerHTML = TPL_MAIN;

        // 
        this._uForm = ecuiCreate(
            UI_FORM,
            q('q-di-form', el)[0],
            null,
            { hide: true }
        );

        this._uDimTree = ecuiCreate(
            UI_IND_TREE,
            q('q-di-tree', el)[0]
        );

        this._uCalendar = ecuiCreate(
            UI_CALENDAR,
            q('q-calendar', el)[0],
            null, 
            {
                mode: 'RANGE',
                viewMode: 'FIX',
                shiftBtnDisabled: true
            }
        );

        this._uSubmitBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-submit', el)[0]
        );
        this._uCancelBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-cancel', el)[0]
        );
    };

    /**
     * @override
     */
    DIM_SELECT_PANEL_CLASS.init = function() {
        var me = this;

        // 
        this._mDimSelectModel.attach(
            ['sync.preprocess.TREE', this.disable, this],
            ['sync.result.TREE', this.$handleTreeSuccess, this],
            ['sync.error.TREE', this.$handleTreeError, this],
            ['sync.complete.TREE', this.enable, this]
        );
        this._mDimSelectModel.attach(
            ['sync.preprocess.SAVE', this.disable, this],
            ['sync.result.SAVE', this.$handleSubmitSuccess, this],
            ['sync.error.SAVE', this.$handleSubmitError, this],
            ['sync.complete.SAVE', this.enable, this]
        );
        this._uSubmitBtn.onclick = bind(this.$submitHandler, this);
        this._uCancelBtn.onclick = bind(this.$cancelHandler, this);

        // Init
        this._uForm.init();
        this._uDimTree.init();
        this._uSubmitBtn.init();
        this._uCancelBtn.init();
        this._uCalendar.init();

        this._uCalendar.hide();
        // this._uForm.$resize();

        this.$resetInput();
    };
    
    /**
     * @override
     */
    DIM_SELECT_PANEL_CLASS.dispose = function() {
        DIM_SELECT_PANEL.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     * @param {string} mode 
     *                       'VIEW': 
     *                       'EDIT': 
     * @param {Object} options 
     * @param {string=} options.uniqName
     * @param {string} options.selLineName
     * @param {Function} options.commonParamGetter
     * @param {string} options.reportType RTPL_OLAP_TABLERTPL_OLAP_CHART
     * @param {string=} options.dimMode 
     *      'NORMAL', 'TIME'
     */
    DIM_SELECT_PANEL_CLASS.open = function(mode, options) {
        this._sMode = mode;
        this._oOptions = options;

        this.$resetInput();

        // 
        this._mDimSelectModel.sync(
            { 
                datasourceId: 'TREE', 
                args: this._oOptions
            }
        );
    };

    /**
     * 
     * 
     * @public
     */
    DIM_SELECT_PANEL_CLASS.$resetInput = function() {
        // 
        // clear prompt
        this.$clearPrompt();
    };

    /**
     * prompt
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$clearPrompt = function() {
        // TODO
    };

    /**
     * 
     *
     * @override
     * @public
     */
    DIM_SELECT_PANEL_CLASS.enable = function(enable) {
        if (this._bDisabled && this._sMode == 'EDIT') {
            this._uSubmitBtn.enable();
            this._uCancelBtn.enable();
            this._uDimTree.enable(); // FIXME 
        }
        DIM_SELECT_PANEL.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @override
     * @public
     */
    DIM_SELECT_PANEL_CLASS.disable = function(enable) {
        if (!this._bDisabled) {
            this._uSubmitBtn.disable();
            this._uCancelBtn.disable();
            this._uDimTree.disable(); // FIXME 
        }
        DIM_SELECT_PANEL.superClass.disable.call(this);
    };    

    /**
     * 
     *
     * @protected
     * @event
     */
    DIM_SELECT_PANEL_CLASS.$submitHandler = function() {
        this._mDimSelectModel.sync(
            { 
                datasourceId: 'SAVE',
                args: extend(
                    {
                        treeSelected: this._uDimTree.getSelected(),
                        levelSelected: this._uDimTree.getLevelSelected(),
                        timeSelect: {
                            start: this._uCalendar.getDate(),
                            end: this._uCalendar.getDateEnd() 
                        }
                    },
                    this._oOptions
                )
            }
        );
    };

    /**
     * 
     *
     * @protected
     * @event
     */
    DIM_SELECT_PANEL_CLASS.$cancelHandler = function() {
        this._uForm.hide();
    };

    /**
     * 
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleTreeSuccess = function() {
        try {
            var model = this._mDimSelectModel;

            this._uForm.showModal(DICT.DEFAULT_MASK_OPACITY);

            // 
            this._uDimTree.render(
                {
                    tree: model.getCurrDimTree(),
                    level: model.getCurrLevelList()
                }
            );

            if (this._oOptions.dimMode == 'TIME') {
                this._uCalendar.show();
                var timeSelect = model.getTimeSelect();
                this._uCalendar.setDate(
                    stringToDate(timeSelect.start),
                    stringToDate(timeSelect.end)
                );
            }
            else {
                this._uCalendar.hide();
            }
            
            this._uForm.center();
        }
        catch (e) {
            // 
            // try catch
            this.$handleTreeError();
        }
    };

    /**
     * 
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleTreeError = function() {
        var me = this;
        // 
        DIALOG.alert(
            LANG.GET_DIM_TREE_ERROR,
            function() {
                me._uForm.hide();
            }
        );
    };

    /**
     * 
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleSubmitSuccess = function() {
        this._uForm.hide();
        /**
         * @event di.shared.ui.DimSelectPanel#submit.close
         */
        this.notify('submit.close');
    };

    /**
     * 
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleSubmitError = function(status) {
        DIALOG.alert(LANG.SAVE_FAILURE);
    };

})();


/**
 * di.shared.ui.OlapMetaDragger
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var getByPath = xutil.object.getByPath;
    var getUID = xutil.uid.getIncreasedUID;
    var XOBJECT = xui.XObject;
    var UI_DROPPABLE_LIST;
    var UI_DRAGPABLE_LIST;
    var MULTIDIM_SELECT_PANEL;
    var ecuiCreate = UTIL.ecuiCreate;
    var ecuiDispose = UTIL.ecuiDispose;

    $link(function () {
        UI_DROPPABLE_LIST = getByPath('ecui.ui.DroppableList');
        UI_DRAGPABLE_LIST = getByPath('ecui.ui.DraggableList');
        MULTIDIM_SELECT_PANEL = di.shared.ui.MultiDimSelectPanel;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 
     * @param {Object} options.reportType 
     *          TABLE()CHART
     * @param {Function=} options.commonParamGetter      
     */
    var OLAP_META_DRAGGER = $namespace().OlapMetaDragger = 
            inheritsObject(XOBJECT, constructor);
    var OLAP_META_DRAGGER_CLASS = OLAP_META_DRAGGER.prototype;
    
    //------------------------------------------
    //  
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="meta-condition-src">',
            '<div class="meta-condition-ind">',
                '<div class="meta-condition-head-text"></div>',
                '<div class="meta-condition-ind-line q-di-meta-ind"></div>',
            '</div>',
            '<div class="meta-condition-dim">',
                '<div class="meta-condition-head-text"></div>',
                '<div class="meta-condition-dim-line q-di-meta-dim"></div>',
            '</div>',
        '</div>',
        '<div class="meta-condition-tar q-di-meta-tar">',
        '</div>'
    ].join('');

    var TPL_SEL_LINE = [
        '<div class="meta-condition-sel">',
            '<div class="meta-condition-head-text">#{0}</div>',
            '<div class="meta-condition-sel-line q-di-meta-sel-line"></div>',
        '</div>'
    ].join('');

    var DEFAULT_SEL_LINE_TITLE = {
        ROW: '',
        FILTER: '',
        COLUMN: ''
    };


    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'meta-condition');

        // 
        el.innerHTML = TPL_MAIN;

        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        
        // /DOM
        this._eSelLineArea = q('q-di-meta-tar', el)[0];

        // selLinekeyselLineName
        this._oSelLineWrap = new LINKED_HASH_MAP();
        // selLineidkeyselLineName
        this._oSelLineIdWrap = {};
    };
    
    /**
     * 
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.init = function () {
    };

    /**
     * 
     *
     * @public
     * @param {Object} data 
     * @param {Object} data.inddim
     *      item 
     *      {string} uniqName value
     *      {string} caption text
     *      {string} clazz 'IND''DIM'
     *      {boolean} fixed 
     *      {string} align item'LEFT''RIGHT'
     * @param {Object} data.selLineDataWrap
     * @param {Object=} data.selLineTitleDef 
     *      { ROW: '', COLUMN: ', FITER: '' }
     *      
     * @param {Object=} data.rule 
     *      FIXME
     *      
     *      {Object=} data.rule.IND 
     *      {Object=} data.rule.DIM 
     *          
     *              {Array.<string>} dropPos null
     *                  'COL'\'ROW'\'FILTER'
     *      {Object=} data.rule.COL 
     *      {Object=} data.rule.ROW 
     *      {Object=} data.rule.FILTER 
     *          
     *              {boolean} canEmpty true
     *              {boolean} draggable true
     *              {boolean} selectable true
     * @param {boolean} isSilent
     */
    OLAP_META_DRAGGER_CLASS.setData = function (data, isSilent) {
        this._oData = data || {};
        this._mModel = data.model;
        this._oRule = data.rule || {};
        !isSilent && this.render();
    };

    /**
     * 
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.render = function () {
        var me = this;
        var el = this._eMain;
        var data = this._oData;

        // 
        this.$disposeInner();

        // 
        var sourceEcuiId = [
            '\x06_DI_META_COND_IND' + getUID('DI_META_COND'),
            '\x06_DI_META_COND_DIM' + getUID('DI_META_COND')
        ];
        var inddim = data.inddim;

        // 
        this._uIndSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-ind', el)[0],
            null,
            {
                id: sourceEcuiId[0],
                disableSelected: true, // 
                clazz: 'IND'
            }
        );
        inddim.indList.foreach(
            function (uniqName, item) {
                me._uIndSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align
                    }
                );
            }
        );

        // 
        this._uDimSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-dim', el)[0],
            null,
            {
                id: sourceEcuiId[1],
                disableSelected: true,
                clazz: 'DIM'
            }
        );
        inddim.dimList.foreach(
            function (uniqName, item) {
                me._uDimSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align,
                        configBtn: item.isConfig
                    }
                );
            }
        );

        // selLine
        data.selLineDataWrap.foreach(
            function (name, selLineData, index) {
                me.$addSelLine(
                    name,
                    (data.selLineTitleDef || DEFAULT_SEL_LINE_TITLE)[
                        name.split('_')[0]
                    ],
                    sourceEcuiId.join(','),
                    selLineData
                );
            }
        );

        // 
        this._uIndSrc.onchange = bind(this.$handleSelLineChange, this);
        this._uDimSrc.onchange = bind(this.$handleSelLineChange, this); 
        this._oSelLineWrap.foreach(
            function (selLineName, selLineCtrl) {
                selLineCtrl.onitemclick = bind(
                    me.$handleItemClick, 
                    me, 
                    selLineName
                );

                selLineCtrl.oncheckdroppable = bind(
                    me.$checkSelLineDroppable, me
                );
                selLineCtrl.oncheckdraggable = bind(
                    me.$checkSelLineDraggable, me
                );
            }
        );
    };

    /**
     * @override
     */
    OLAP_META_DRAGGER_CLASS.dispose = function () {
        this.$disposeInner();
        this._eSelLineArea = null;
        OLAP_META_DRAGGER.superClass.dispose.call(this);
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$disposeInner = function () {
        if (this._uIndSrc) {
            ecuiDispose(this._uIndSrc);
            this._uIndSrc = null;
        }
        if (this._uDimSrc) {
            ecuiDispose(this._uDimSrc);
            this._uDimSrc = null;
        }
        this._oSelLineWrap.foreach(
            function (name, item, index) {
                ecuiDispose(item);
            }
        );
        this._eSelLineArea.innerHTML = '';
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        this._oSelLineIdWrap = {};
    };

    /**
     * 
     * 
     * @protected
     * @param {string} selLineName selLine
     * @param {string} selLineTitle selLine
     * @param {string} source ecuiid
     * @param {xutil.LinkedHashMap=} selLineData selLine
     */
    OLAP_META_DRAGGER_CLASS.$addSelLine = function (
        selLineName, selLineTitle, source, selLineData
    ) {
        if (selLineName == null) {
            return;
        }
        var selLineWrap = this._oSelLineWrap;
        var selLineIdWrap = this._oSelLineIdWrap;

        // selLine
        var o = document.createElement('div');
        o.innerHTML = template(TPL_SEL_LINE, selLineTitle);
        this._eSelLineArea.appendChild(o = o.firstChild);

        selLineWrap.addLast(
            ecuiCreate(
                UI_DROPPABLE_LIST, 
                q('q-di-meta-sel-line', o)[0],
                null,
                {
                    id: selLineIdWrap[selLineName] = 
                        '\x06_DI_META_COND_SEL' + getUID('DI_META_COND'),
                    source: source,
                    name: selLineName,
                    configBtn: false
                }
            ),
            selLineName
        );

        // targetselLinetarget
        for (var name in selLineIdWrap) {
            if (name != selLineName) {
                selLineWrap.get(name).addTarget(selLineIdWrap[selLineName]);
            }
            selLineWrap.get(selLineName).addTarget(selLineIdWrap[name]);
        }
        this._uIndSrc.addTarget(selLineIdWrap[selLineName]);
        this._uDimSrc.addTarget(selLineIdWrap[selLineName]);

        // 
        if (selLineData) {
            selLineData.foreach( 
                function (uniqName, item, index) {
                    selLineWrap.get(selLineName).addItem(
                        {
                            value: item.uniqName, 
                            text: item.caption,
                            clazz: item.clazz,
                            fixed: item.fixed,
                            align: item.align,
                            configBtn: item.isConfig
                        }
                    );
                }
            );
        }
    };

    /**
     * 
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.refreshStatus = function (statusWrap) {
        if (statusWrap) {
            this._uIndSrc.setState(
                { 
                    disable: statusWrap.indMetas.disabledMetaNames,
                    selected: statusWrap.indMetas.selectedMetaNames
                }
            );
            this._uDimSrc.setState(
                { 
                    disable: statusWrap.dimMetas.disabledMetaNames,
                    selected: statusWrap.dimMetas.selectedMetaNames
                }
            );
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    OLAP_META_DRAGGER_CLASS.enable = function (key) {
        // TODO 
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            this._uIndSrc && this._uIndSrc.enable();
            this._uDimSrc && this._uDimSrc.enable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.enable();
                }
            );
            OLAP_META_DRAGGER.superClass.enable.call(this);
        }
    };    

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    OLAP_META_DRAGGER_CLASS.disable = function (key) {
        objKey.add(this, key);

        // TODO 
        if (!this._bDisabled) {
            this._uIndSrc && this._uIndSrc.disable();
            this._uDimSrc && this._uDimSrc.disable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.disable();
                }
            );
        }
        OLAP_META_DRAGGER.superClass.disable.call(this);
    };    

    /**
     * 
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$handleSelLineChange = function (
        itemData, itemIndex, selLineName, oriItemIndex, oriSelLineName
    ) {
        var wrap = {};
        this._oSelLineWrap.foreach(
            function (k, o, index) {
                wrap[k] = o.getValue();
            }
        );

        var changeWrap = {
            from: oriSelLineName,
            to: selLineName,
            toPosition: itemIndex,
            uniqNameList: [itemData.value]
        };

        // 
        // this.$fixSelLineChange(itemData, itemIndex, selLineName, changeWrap);

        /**
         * 
         *
         * @event
         */
        this.notify('sellinechange', [wrap, changeWrap]);
    };

    /**
     * selLine
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$handleItemClick = function (
        selLineName, event, itemData
    ) {
        var metaItem = 
            this._mModel.getMetaItem(itemData.value);

        // --
        if (metaItem && metaItem.clazz == 'DIM') {
            var me = this;
            var wrap = {};
                this._oSelLineWrap.foreach(
                    function (k, o, index) {
                        wrap[k] = o.getValue();
                    }
                );
            MULTIDIM_SELECT_PANEL().open(
                'EDIT',
                {
                    uniqName: itemData.value,
                    reportType: this._sReportType,
                    selLineName: selLineName,
                    dimMode: metaItem.isTimeDim ? 'TIME' : 'NORMAL',
                    onconfirm: function(){
                        me.notify('selitemchange',[wrap]);
                    },
                    commonParamGetter: this._mModel._fCommonParamGetter
                }
            );
        }
        // --
        else {
            // TODO
        }
    };

    /**
     * sellineitem
     *
     * @private
     * @param {string} clazz 'IND''DIM'
     * @param {string=} selLineName selLineName
     * @param {Item=} exclude 
     * @return {Array.<Object>} 
     *          itemitem
     *          selLineName
     *          indexitemindex
     */
    OLAP_META_DRAGGER_CLASS.$findItemFromSelLine = function(
        clazz, selLineName, exclude
    ) {
        var ret = [];

        function findInLine(selLineName, selLine) {
            var itemList = selLine.getItems();
            for (var i = 0, item; item = itemList[i]; i ++) {
                if (item != exclude && item.getClazz() == clazz) {
                    ret.push(
                        { 
                            item: item, 
                            selLineName: selLineName, 
                            index: i 
                        }
                    );
                }
            }
        }

        if (selLineName) {
            findInLine(selLineName, this._oSelLineWrap.get(selLineName));
        }
        else {
            this._oSelLineWrap.foreach(findInLine);
        }

        return ret;
    }


    //---------------------------------------------------
    // () FIXME
    //---------------------------------------------------

    /**
     * selLinedrop
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$checkSelLineDroppable = function (
        itemData, index, selLineName
    ) {
        var rule = this._oRule;
        // var ruleIND = rule.IND || {};
        // var ruleDIM = rule.DIM || {};

        //  FORBID_1
        if (itemData.clazz == 'IND' && selLineName.indexOf('COL') < 0) {
            return false;
        }

        //  FORBID_5
        // if (itemData.clazz == 'DIM' && selLineName.indexOf('COL') >= 0) {
        //     return false;
        // }

        //  FORBID_7filterdrop
        // if (selLineName.indexOf('FILTER') >= 0) {
        //     return false;
        // }

        var selLine = this._oSelLineWrap.get(selLineName);

        //  FORBID_4align
        // align
        var items = selLine.getItems();
        var item;
        if ((
                (item = items[index]) 
                && item.getWrap().align == 'LEFT'
            )
            || (
                (item = items[index - 1]) 
                && item.getWrap().align == 'RIGHT'
            )
        ) {
            return false;
        }

        return true;
    };
    
    /**
     * selLinedrag
     * 
     * @protected
     */    
    OLAP_META_DRAGGER_CLASS.$checkSelLineDraggable = function (
        itemData, index, selLineName
    ) {
        var rule = this._oRule;

        //  FORBID_2
        var selLine = this._oSelLineWrap.get(selLineName);
        if (selLine.count() <= 1) {
            if (rule.forbidColEmpty && selLineName.indexOf('COL') >= 0) {
                return false;
            }
            if (rule.forbidRowEmpty && selLineName.indexOf('ROW') >= 0) {
                return false;
            }
        }

        //  FORBID_3fixed
        if (itemData.fixed) {
            return false;
        }

        //  FORBID_6filter
        // if (selLineName.indexOf('FILTER') >= 0) {
        //     return false;
        // }

        return true;
    }

    /**
     * 
     * 
     * 
     * @protected
     * @deprecated
     */
    OLAP_META_DRAGGER_CLASS.$fixSelLineChange = function (
        itemData, itemIndex, selLineName, changeWrap
    ) {
        if (itemIndex == null) {
            // 
            return;
        }
        
        //  FIX_1
        //          

        //  FIX_2

        // 
        var isCal = (itemData.calcColumnRefInd || []).length > 0;
        var selLine = this._oSelLineWrap.get(selLineName);
        var selLineItems = selLine.getItems() || [];
        var dragItem = selLineItems[itemIndex];
        var prev = selLineItems[itemIndex - 1];
        var next = selLineItems[itemIndex + 1];
        var prevData = prev && prev.getWrap();
        var nextData = next && next.getWrap();
        var oList;
        var o;
        var des;
        var targetIndex;
        var i;

        // dragItem
        var side = { IND: [], DIM: [], WALL: [] };
        prevData 
            ? (side[prevData.clazz][0] = 1)
            : (side.WALL[0] = 1);
        nextData 
            ? (side[nextData.clazz][1] = 1)
            : (side.WALL[1] = 1);

        // IF dragItemdim
        if (itemData.clazz == 'DIM') {
            // IF dragItemdimTHEN do nothing

            // IF dragIteminddimTHEN do nothing

            // IF dragItemind 
            if (side.IND.length > 0 && side.WALL.length > 0) {
                // THEN diminddragItem
                oList = this.$findItemFromSelLine('DIM', selLineName, dragItem);                                
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, side.IND[0] ? (selLine.count() - 1) : 1);
                }
            }

            // IF dragItemind
            else if (side.IND[0] && side.IND[1]) {
                // THEN dimitemdimind
                // 
                des = selLineItems[0].getClazz() == 'DIM';
                for (
                    i = des ? 0 : (selLineItems.length - 1); 
                    o = selLineItems[i]; 
                    i += des ? 1 : -1
                ) {
                    if (o.getClazz() == 'IND') {
                        targetIndex = des ? i : (i + 1);
                        break;
                    }
                }
                selLine.remove(dragItem);
                selLine.add(
                    dragItem, 
                    targetIndex <= itemIndex ? targetIndex : targetIndex - 1
                );
            }
        }

        // IF dragItemind
        else if (itemData.clazz == 'IND') {
            // IF dragItemindTHEN do nothing

            // IF dragIteminddimTHEN do nothing

            // IF dragItemdim 
            if (side.DIM.length > 0 && side.WALL.length > 0) {
                // THEN inddimdragItem
                oList = this.$findItemFromSelLine('IND', null, dragItem);
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, side.DIM[0] ? (selLine.count() - 1) : 1);
                }
            }

            // IF dragItemdim
            else if (side.DIM[0] && side.DIM[1]) {
                // THEN dragItem
                des = itemIndex > (selLineItems.length - 1) / 2;
                selLine.remove(dragItem);
                selLine.add(dragItem, des ? selLine.count() : 0);
                
                // inddragItemdragItem
                oList = this.$findItemFromSelLine('IND', null, dragItem);
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, des ? (selLine.count() - 1) : 1);
                }
            }
        }

        // changeWraptoPosition
        selLineItems = selLine.getItems() || [];
        for (i = 0; o = selLineItems[i]; i ++) {
            if (o.getClazz == 'IND') {

            }
        }
    };

})();
/**
 * di.shared.vui.OlapMetaSelect
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           column
 *           
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var inheritsObject = xutil.object.inheritsObject;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var ecuiCreate = UTIL.ecuiCreate;
    var q = xutil.dom.q;
    var isArray = xutil.lang.isArray;
    var ecuiDispose = UTIL.ecuiDispose;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var getByPath = xutil.object.getByPath;
    var UI_SELECT = ecui.ui.Select;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 
     */
    var OLAP_META_SELECT = $namespace().OlapMetaSelect = 
            inheritsObject(XOBJECT, constructor);
    var OLAP_META_SELECT_CLASS = OLAP_META_SELECT.prototype;
    
    var TPL_SEL = [
        '<span>',
            '<span class="olap-meta-select-txt">#{colName}</span>',
            '<span class="olap-meta-select-sel"></span>',
        '</span>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        this._sels = {};
        this._el = options.el;
    };

    /**
     * 
     *
     * @public
     * @param {Object} data 
     */
    OLAP_META_SELECT_CLASS.setData = function (data) {
        // renderTyperenderTypeliteOlapsetLiteOlapData
        if(data['renderType'] && (data['renderType'] == 'liteOlap')){
            this.setLiteOlapData(data);
        }
        else {
            var me = this;
            var el = this._el;

            var indList = data.inddim.indList;
            var inds = [];
            indList && indList.foreach(
                function (k, item, index) {
                    if (item.status != DICT.META_STATUS.DISABLED) {
                        inds.push(
                            { 
                                text: item.caption, 
                                value: item.uniqName 
                            }
                        );
                    }
                }
            );

            // 
            this.$disposeInner();

            // 
            // selectmultiselectdataOpt
            var ctrlClz = getByPath(data.ctrlClz);
            var eo;
            // col
            var colNum = 0;
            data.selLineDataWrap.foreach(
                function (name, selLineData, index) {
                    if (name.indexOf('COLUMN') == 0) {
                        colNum ++;
                    }
                }
            );

            var seriesCfg = data.seriesCfg;
            data.selLineDataWrap.foreach(
                function (name, selLineData, index) {
                    // 
                    if (name.indexOf('COLUMN') < 0) {
                        return;
                    }

                    // 
                    var seriesType = (seriesCfg[name] || {}).type;
                    var desc = colNum <= 1 
                        ? '' 
                        : (
                            '' + name.split('_')[1] 
                            + (
                                seriesType 
                                    ? ('' + DICT.getGraphByType(seriesType).text + '')
                                    : ''
                            )
                        );
                    var ctrl = createCtrl(el, ctrlClz, data.ctrlClz, data, desc);
                    me._sels[name] = ctrl;

                    // 
                    ctrl.onchange = bind(handleChange, null, me, name);

                    // 
                    var selected = [];
                    selLineData.foreach(function (uniqName) {
                        selected.push(uniqName);
                    });

                    // 
                    setSelectData(ctrl, inds, selected);
                }
            );  
        }
        
    };


    /**
     * liteOlap
     *
     * @public
     * @param {Object} data 
     */
    OLAP_META_SELECT_CLASS.setLiteOlapData = function (data) {
        var me = this;
        var el = this._el;

        var indList = data.indList;
        var inds = [];
         // 
        var selected = [];
        for (var i = 0; i < indList.length; i++) {
            inds.push(
                        { 
                            text: indList[i].caption, 
                            value: indList[i].custIndName 
                        }
                    );
            // ,
            if(data.selectedInds.length > 0){
                for (var j = 0; j < data.selectedInds.length; j++) {
                    if(data.selectedInds[j] == indList[i].custIndName){
                        selected.push(
                        { 
                            text: indList[i].caption, 
                            value: indList[i].custIndName 
                        }
                    );
                    }
                };
            }else{
                selected.push(
                        { 
                            text: indList[0].caption, 
                            value: indList[0].custIndName 
                        }
                        )
            }
        };

        // 
        this.$disposeInner();

        // 
        // selectmultiselectdataOpt
        var ctrlClz = getByPath(data.ctrlClz);
        var ctrl = createCtrl(el, ctrlClz, data.ctrlClz, data, '');
        me._sels[data.selLineName] = ctrl;

        // 
        ctrl.onchange = bind(handleChange, null, me, name);

       
        // selLineData.foreach(function (uniqName) {
        //     selected.push(uniqName);
        // });

        // 
        setSelectData(ctrl, inds, selected);
    };
    function handleChange(me, selLineName, value) {
        // 
        var wrap = me.getValue();
        // changectrl
        // wrap[selLineName] = value;

        me.notify('change', [wrap]);
    }

    function createCtrl(el, ctrlClz, ctrlClzPath, data, colName) {
        var eo = document.createElement('DIV');
        // 
        eo.innerHTML = template(TPL_SEL, { colName: colName });
        var ctrl = ecuiCreate(
            ctrlClz, 
            q('olap-meta-select-sel', eo)[0],
            null,
            {
                primary: ctrlClzPath == 'ecui.ui.MultiSelect'
                    ? 'ui-multi-select' : 'ui-select',
                optionSize: data.optionSize 
            }
        )
        el.appendChild(eo.firstChild);
        // 
        ctrl.$mousewheel = new Function();
        // 
        ctrl.$__ctrlClzPath = trim(ctrlClzPath);
        ctrl.init();
        return ctrl;
    }

    function disposeSelect(ctrl) {
        ecuiDispose(ctrl);
    }
    function setSelectData(ctrl, datasource, selected) {
        // 
        for (var i = 0, o; o = datasource[i]; i++) {
            var txt = String(o.text != null ? o.text : '');
            ctrl.add(
                txt, 
                null,
                { value: o.value, prompt: txt }
            );
        }

        // 
        selected.length && ctrl.setValue(
            ctrl.$__ctrlClzPath == 'ecui.ui.MultiSelect'
                ? selected : selected[0]['value']
        ); 
    }

    /**
     * 
     */
    OLAP_META_SELECT_CLASS.$disposeInner = function () {
        for (var selLineName in this._sels) {
            disposeSelect(this._sels[selLineName]);
        }
        this._sels = {};
        this._el.innerHTML = '';
    };

    /**
     * 
     *
     * @public
     * @return {*} 
     */
    OLAP_META_SELECT_CLASS.getValue = function () {
        var wrap = {};
        for (var selLineName in this._sels) {
            var sel = this._sels[selLineName];
            var value;
            if (sel.$__ctrlClzPath == 'ecui.ui.Select') {
                var sl = sel.getSelected();
                value = sl ? sl.getValue() : null;
            }
            else {
                value = sel.getValue();
            }
            wrap[selLineName] = isArray(value) 
                ? value 
                : (value == null ? [] : [value]);
        }
        return wrap;
    };

})();
/**
 * di.shared.vui.TextLabel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var isObject = xutil.lang.isObject;
    var isArray = xutil.lang.isArray;
    var template = xutil.string.template;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * html
     * xutil.string.template
     * dom
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 
     */
    var TEXT_LABEL = $namespace().TextLabel = 
            inheritsObject(XOBJECT, constructor);
    var TEXT_LABEL_CLASS = TEXT_LABEL.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'vui-text-area');

        this._sInitTpl = el.innerHTML;
        el.innerHTML = '';

        this.setData(options);
    };
    
    /**
     * 
     *
     * @public
     * @param {Object} data 
     * @param {string} data.html html
     * @param {string} data.text 
     * @param {string} data.tpl 
     * @param {(Array|Object)} data.args 
     */
    TEXT_LABEL_CLASS.setData = function (data) {
        var el = this._eMain;
        data = data || {};

        if (data.html != null) {
            el.innerHTML = data.html;
        }
        else if (data.text != null) {
            el.innerHTML = encodeHTML(data.text);
        }
        else if (data.tpl != null) {
            renderTpl.call(this, data.tpl, data.args);
        }
        else if (this._sInitTpl != null) {
            renderTpl.call(this, this._sInitTpl, data.args);
        }
    };

    /**
     * 
     * 
     * @private
     */
    function renderTpl(tpl, args) {
        var el = this._eMain;

        if (isObject(args)) {
            el.innerHTML = template(tpl, args);
        }
        else if (isArray(args)) {
            el.innerHTML = template.apply(null, tpl, args);
        }
        else {
            el.innerHTML = template.tpl || '';
        }
    }

})();
/**
 * di.shared.adapter.GeneralAdapterMethod
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           di.config.DictadapterMethods
 *           
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var extend = xutil.object.extend;

    /**
     * 
     */
    $namespace().GeneralAdapterMethod = {
        ecuiCreate: ecuiCreate,
        ecuiDispose: ecuiDispose,
        xuiCreate: xuiCreate,
        xuiDispose: xuiDispose
    };

    /**
     * ecui
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @return {Object} 
     */
    function ecuiCreate(def, options) {
        return UTIL.ecuiCreate(def.clz, def.el, null, options);
    }

    /**
     * ecui
     *
     * @public
     * @this {Object} 
     */
    function ecuiDispose() {
        UTIL.ecuiDispose(this);
    }

    /**
     * xui-ui
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @return {Object} 
     */
    function xuiCreate(def, options) {
        return new def.clz(options);
    }

    /**
     * xui-ui
     *
     * @public
     * @this {Object} 
     */
    function xuiDispose() {
        this.dispose && this.dispose();
    }
    
    // ...

})();


/**
 * di.shared.model.AuthModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [] 
 * author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function () {
    
    /*  */
    var inheritsObject = xutil.object.inheritsObject;
    var XDATASOURCE = xui.XDatasource;
        
    /*  */
    var AUTH_MODEL = $namespace().AuthModel = inheritsObject(XDATASOURCE);
    var AUTH_MODEL_CLASS = AUTH_MODEL.prototype;
        
    /**
     * Id
     * @public
     * 
     * @return {string} id
     */
    AUTH_MODEL_CLASS.getUserId = function () {
        // TODO
    };    
    
})();


/**
 * di.shared.model.DateModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [] 
 * author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function() {
    
    /*  */
    var inheritsObject = xutil.object.inheritsObject; 
    var XDATASOURCE = xui.XDatasource;
        
    /*  */
    var DATE_MODEL = $namespace().DateModel = inheritsObject(XDATASOURCE);
    var DATE_MODEL_CLASS = DATE_MODEL.prototype;
        
    /**
     * 
     * @override
     */
    DATE_MODEL_CLASS.setData = function(data) {
        this.businessData = true;
        this._nInitServerTime = parseInt(data.serverTime) || new Date().getTime();
        this._nServerTimeOffset = this._nInitServerTime - (new Date).getTime();
    };
    
    /**
     * 
     * 
     * 1. 
     * 2. 
     * @public
     * 
     * @return {Date} 
     */
    DATE_MODEL_CLASS.now = function() {
        var date = new Date();
        date.setTime(date.getTime() + this._nServerTimeOffset);
        return date;
    };
    
})();


/**
 * di.shared.model.UserModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    [] 
 * @author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function () {
    
    /*  */
    var inheritsObject = xutil.object.inheritsObject;
    var XDATASOURCE = xui.XDatasource;
        
    /*  */
    var USER_MODEL = $namespace().UserModel = inheritsObject(XDATASOURCE);
    var USER_MODEL_CLASS = USER_MODEL.prototype;
        
    /**
     * Id
     * @public
     * 
     * @return {string} id
     */
    USER_MODEL_CLASS.getUserId = function () {
        // TODO
    };    
    
})();


/**
 * di.shared.model.GlobalModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [] 
 * author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

/**
 * @usage var g = di.shared.GlobalModel();
 */
(function() {
    
    /*  */
    var inherits = xutil.object.inherits;
    var USER_MODEL;
    var AUTH_MODEL;
    var DATE_MODEL;
    var GLOBAL_MENU_MANAGER;
    var XDATASOURCE = xui.XDatasource;
    
    $link(function() {
        var sharedNS = di.shared;
        USER_MODEL = sharedNS.model.UserModel;
        AUTH_MODEL = sharedNS.model.AuthModel;
        DATE_MODEL = sharedNS.model.DateModel;
        GLOBAL_MENU_MANAGER = sharedNS.model.GlobalMenuManager;
    });
    
    /*  */
    var GLOBAL_MODEL = $namespace().GlobalModel = function(options) {
            if (instance && options) {
                throw new Error('global model has been created');
            }
            if (!instance && !options) {
                throw new Error('global model creation needs options');
            }

            if (!instance) {
                (instance = new SINGLETON(options))
            }
            return instance;
        };
    var GLOBAL_MODEL_CLASS = inherits(GLOBAL_MODEL, XDATASOURCE);
        
    function SINGLETON(options) {
        XDATASOURCE.client.call(this);
        
        this._sBizKey = options.bizKey;

        // 
        this._mUserModel = new USER_MODEL();
        this._mAuthModel = new AUTH_MODEL();
        this._mDateModel = new DATE_MODEL();
        this._mDateModel.setData(options);

        this._sGlobalType = options.globalType;
        if (this._sGlobalType == 'CONSOLE') {
            this._mGlobalMenuManager = new GLOBAL_MENU_MANAGER(options)
        }
    };
    
    var instance;

    /**
     * DateModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getDateModel = function() {
        return this._mDateModel;
    };
    
    /**
     * UserModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getUserModel = function() {
        return this._mUserModel;
    };
    
    /**
     * AuthModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getAuthModel = function() {
        return this._mAuthModel;
    };
    
    /**
     * GlobalMenuManager
     * @public
     */
    GLOBAL_MODEL_CLASS.getGlobalMenuManager = function() {
        return this._mGlobalMenuManager;
    };

    /**
     * bizkey
     * @public
     */
    GLOBAL_MODEL_CLASS.getBizKey = function() {
        return this._sBizKey;
    };

    inherits(SINGLETON, GLOBAL_MODEL);
    
})();


/**
 * di.shared.model.CommonParamFactory
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function () {
    
    var clone = xutil.object.clone;
    var extend = xutil.object.extend;
    var textParam = xutil.url.textParam;
    var jsonStringify = di.helper.Util.jsonStringify;
    var isArray = xutil.lang.isArray;
    var isObject = xutil.lang.isObject;

    /** 
     * 
     * 
     * @class
     * @param {Object} options 
     * @param {Object} options.externalParam 
     */
    var COMMON_PARAM_FACTORY = $namespace().CommonParamFactory = 
        function (options) {
            // 
            // 
            this.externalParam = options 
                && clone(options.externalParam) 
                || {};
        };
    var COMMON_PARAM_FACTORY_CLASS = COMMON_PARAM_FACTORY.prototype;

    /**
     * json
     */
    var STRINGIFY_FLAG = 'diF\x06^_^jsonnosj^_^\x06';

    /**
     * 
     * http
     * stringifyjson
     * 
     *
     * @public
     * @static
     * @param {*} data json
     * @param {string} paramMode 'NORMAL''JSON'
     * @return 
     */
    COMMON_PARAM_FACTORY.markParamMode = function(data, paramMode) {
        if (isObject(data)) {
            if (!paramMode || paramMode == 'NORMAL') {
                delete data[STRINGIFY_FLAG];
            }
            else {
                data[STRINGIFY_FLAG] = paramMode;
            }
        }
        return data;
    };

    /**
     * getter
     *
     * @public
     * @param {Object} options 
     * @param {Object} options.reportTemplateId reportTemplateId
     */
    COMMON_PARAM_FACTORY_CLASS.getGetter = function(options) {
        options = options || {};

        var externalParam = this.externalParam;

        /**
         * reportTemplateId
         * reportTemplateIdsnippet
         * commonParamGetter.update(data)
         * snippetreportTemplateId
         * PERSISTENT***idDB
         * reportTemplateIdSESSION_LOADED***snippet
         * reportTemplateId
         * updatereportTemplateId
         */
        var reportTemplateId = options.reportTemplateId;

        /**
         * 'INIT'commonParamGetter
         * 'FORBIDDEN'
         * 
         * 'OPEN'
         */
        var loadValve = 'INIT';

        /**
         * 
         * encodeURIComponent
         *
         * @public
         * @param {Object=} paramObj 
         *      key
         *      value{string}{Array.<string>}
         * @param {string=} paramMode 
         *      'NORMAL'aa=2&aa=3&aa=5
         *      'JSON'json
         * @param {Object=} options 
         * @param {Array} options.excludes 
         * @return {string} 
         */
        function commonParamGetter(paramObj, options) {
            options = options || {};

            if (loadValve == 'INIT') {
                loadValve = 'FORBIDDEN';
            }
            else if (loadValve == 'FORBIDDEN') {
                throw new Error('' 
                    + 'snippet' 
                    + ''
                    + ''
                    + 'reportTempalteId'
                    + 'reportTempalteIdmetaconfigtable'
                    + ''
                );
            }

            var o = {};
            // externalParam
            extend(o, externalParam, paramObj);
            o.reportTemplateId = reportTemplateId;

            var excludes = options.excludes || [];
            for (var i = 0; i < excludes.length; i ++) {
                delete o[excludes[i]];
            }

            return stringifyParam(o, { paramMode: options.paramMode });
        };

        /** 
         * 
         *
         * @public
         * @return {Object} options 
         * @return {Object} options.reportTemplateId id
         */
        commonParamGetter.update = function (options) {
            // 
            // reprotTemplateId   
            var rTplId = options && options.reportTemplateId || null;
            if (rTplId) {
                loadValve = 'OPEN';
                reportTemplateId = rTplId;
            }
            else if (loadValve != 'OPEN') {
                loadValve = 'INIT';
            }
        };

        /** 
         * reportTemplateId
         *
         * @public
         * @return {string} reportTemplateId
         */
        commonParamGetter.getReportTemplateId = function () {
            return reportTemplateId;
        };

        /**
         * 
         */
        commonParamGetter.markParamMode = COMMON_PARAM_FACTORY.markParamMode;

        return commonParamGetter;
    };

    /**
     * string
     * nullundefined
     * urlencoding
     * 
     * @public
     * @param {Object} paramObj 
     *      key
     *      value{string}{Array.<string>}   
     * @param {Object=} options 
     * @param {string=} options.paramMode 
     *      'NORMAL'aa=2&aa=3&aa=5
     *      'JSON'json
     * @param {string=} options.suffix 
     * @return {Array.<string>} 
     */
    function stringifyParam(paramObj, options) {
        var paramArr = [];
        options = options || {};

        function pushParam(name, value) {
            paramArr.push(textParam(name) + '=' + textParam(value));
        }

        var name;
        var value;
        var i;

        for (name in paramObj) {
            value = paramObj[name];

            // paramMode'JSON'
            // json
            if (isObject(value) 
                && (options.paramMode == 'JSON' || value[STRINGIFY_FLAG] == 'JSON')
            ) {
                // json
                delete value[STRINGIFY_FLAG];

                // json
                pushParam(name, jsonStringify(value));

                // json
                value[STRINGIFY_FLAG] = 1;
            }
            // json
            else {
                if (isArray(value)) {
                    for (i = 0; i < value.length; i ++) {
                        pushParam(name, value[i]);
                    }
                }
                else {
                    pushParam(name, value);
                }
            }
        }

        return paramArr.join('&');
    };    

})();


/**
 * di.shared.model.DIFactory
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           
 *              
 *              
 *           
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {



    //-------------------------------------------------------
    //  
    //-------------------------------------------------------

    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var DIALOG = di.helper.Dialog;
    var xlang = xutil.lang;
    var xobject = xutil.object;
    var xurl = xutil.url;
    var isString = xlang.isString;
    var isArray = xlang.isArray;
    var isObject = xlang.isObject;
    var isFunction = xlang.isFunction;
    var isEmptyObj = xobject.isEmptyObj;
    var getByPath = xobject.getByPath;
    var objKey = xobject.objKey;
    var assign = xobject.assign;
    var extend = xobject.extend;
    var merge = xobject.merge;
    var clone = xobject.clone;
    var getUID = xutil.uid.getUID;
    var bind = xutil.fn.bind;
    var assert = UTIL.assert;
    var arraySlice = [].slice;
    var UNDEFINED;
    // FIXME
    // 
    var ecuiAddEventListener = UTIL.ecuiAddEventListener;
    var ecuiTriggerEvent = UTIL.ecuiTriggerEvent;
    var targetBlank = UTIL.targetBlank;
    var objProtoToString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var arrayPush = Array.prototype.push;
    var isEcuiControl = UTIL.isEcuiControl;
    var evalJsonLogic = UTIL.evalJsonLogic;
    var XOBJECT = xui.XObject;
    var COMMON_PARAM_FACTORY;
    var ARG_HANDLER_FACTORY;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

        



    //----------------------------------------------------------
    //  
    //----------------------------------------------------------

    /**
     * Unit
     * 
     * @usage
     *      
     *      var factory = di.shared.model.DIFactory();
     */
    $namespace().DIFactory = function () {
        if (!instance) {

            instance = {
                installClz: installClz,
                getClz: getClz,
                addEntity: addEntity,
                removeEntity: removeEntity,
                createIns: createIns,
                mountInteractions: mountInteractions,
                mountInteraction: mountInteraction,
                getDIMethod: getDIMethod,
                getEntity: function (id, mode) {
                    return getEntity(id, mode == 'RAW' ? 'DEF' : mode);
                },
                findEntity: findEntity,
                forEachEntity: forEachEntity,
                createDIEvent: createDIEvent,
                getRef: getRef,
                mergeOpt: mergeOpt,
                setGlobalTemp: setGlobalTemp,
                getGlobalTemp: getGlobalTemp,
                setEventChannel: setEventChannel,
                getEventChannel: getEventChannel,
                setInteractMemo: setInteractMemo,
                getInteractMemo: getInteractMemo,
                rootSnippet: rootSnippet,
                isDIEvent: isDIEvent,
                setFuncAuth: setFuncAuth,
                INIT_EVENT_NAME: INIT_EVENT_NAME,
                INIT_EVENT_AGENT_ID: INIT_EVENT_AGENT_ID
            };
        }
        return instance;
    };





    //----------------------------------------------------------
    // /
    //----------------------------------------------------------

    /**
     * 
     * 
     */
    var DI_ATTR_PREFIX = '\x06diA^_^';
    var DI_METHOD_PREFIX = '\x06diM^_^';
    var DI_ADAPTER_METHOD_PREFIX = '\x06diMAdpt^_^';
    var DI_DEF_TAG = '\x06diDef^_^';
    var DI_EVENT_AGENT_TAG = '\x06diEAgt^_^';
    var DI_EVENT_TAG = '\x06diEvt^_^';
    var DI_TMP_TAG = '\x06diTmp^_^';
    var DI_OPT_HOME_TAG = '\x06diOpt^_^';
    var DI_OPT_CACHE_TAG = '\x06diOpt_cache^_^';
    var DI_OPT_ID_TAG = '\x06diOpt_id^_^';
    var SEP = '\x06_';
    var INIT_EVENT_NAME = '\x06diEvt_init^_^';
    var INIT_EVENT_AGENT_ID = '\x06diEvtAgtId_init^_^';

    /**
     * clzType
     */
    var INS_CLZ_TYPE = [
        'SNIPPET',
        'COMPONENT',
        'VUI',   
        'VCONTAINER',
        'VPART'
    ];

    /**
     * vui adapter
     */
    var GENERAL_ADAPTER_METHOD_PATH = 'di.shared.adapter.GeneralAdapterMethod';
    var generalAdapterMethod;

    /**
     * DIFactory
     */
    var instance;

    /**
     * 
     */
    var repository = {
        // 
        CLZ: {},

        // 
        SNIPPET: {},
        SNIPPET_DEF: {},
        COMPONENT: {},
        COMPONENT_DEF: {},
        VUI: {},   
        VUI_DEF: {},   
        VCONTAINER: {},
        VCONTAINER_DEF: {},
        VPART: {},
        VPART_DEF: {}
    };

    /**
     * snippet
     */
    var rootSnippetId;

    /**
     * 
     */
    var eventChannel;

    /**
     * setGlobalTemp
     */
    var globalTempData = {};

    /**
     * key
     */
    var funcAuthKeys = {};



    //-----------------------------------------------------------------
    // 
    //-----------------------------------------------------------------

    /**
     * di
     * this.$di('someMethodName')
     * this.$di('someMethodName', arg1, arg2)
     * PS$di('someMethodName')(arg1, arg2)
     * this
     *
     * @param {string} methodName 
     * @param {*...} args 
     *      applycallmethodNameapplycall
     *      scopeapplycall
     *      some.$di('apply', this, [1234, 5214]);
     */
    var $di = {
        INS: function (methodName) {
            var scope;
            var args;
            var mk = arguments[1];

            if (mk == 'call') {
                scope = arguments[2];
                args = arraySlice.call(arguments, 3);
            }
            else if (mk == 'apply') {
                scope = arguments[2];
                args = arguments[3];
            }
            else {
                scope = this;
                args = arraySlice.call(arguments, 1);
            }

            return (
                // di
                this[DI_METHOD_PREFIX + methodName]
                // adapter
                || this[DI_ADAPTER_METHOD_PREFIX + methodName]
                // 
                || this[methodName]
            ).apply(scope, args);
        },
        DEF: function (methodName) {
            var scope;
            var args;
            var mk = arguments[1];

            if (mk == 'call') {
                scope = arguments[2];
                args = arraySlice.call(arguments, 3);
            }
            else if (mk == 'apply') {
                scope = arguments[2];
                args = arguments[3];
            }
            else {
                scope = this;
                args = arraySlice.call(arguments, 1);
            }

            return DEF_CONTRACT_METHOD[methodName]
                .apply(scope, args);
        }
    };

    /**
     * 
     */
    var COMMON_CONTRACT_METHOD = {
        /**
         * COMPONENT
         */
        start: function (options) {
            var opt = options[DI_TMP_TAG];
            this.$di('setId', opt.id);
            this.$di('setEl', opt.el);

            var def = getEntity(opt.id, 'DEF');
            if (opt.el && opt.el.style.display == 'none') {
                setDIAttr(this, 'styleDisplay', def.styleDisplay);
            }

            var func; 
            (func = getDIMethod(this, 'setTplMode')) 
                && func.call(this, opt.tplMode);
            (func = getDIMethod(this, 'setCommonParamGetter')) 
                && func.call(this, opt.commonParamGetter);
        },

        getDIFactory: function () {
            return instance;
        },

        getMethod: function (methodName) {
            return getDIMethod(this, methodName);
        },

        getDef: function () {
            return getEntity(
                COMMON_CONTRACT_METHOD.getId.call(this),
                'DEF'
            );
        },

        setId: function (id) {
            setDIAttr(this, 'id', id);
        },

        getId: function () {
            return getDIAttr(this, 'id');
            // return getAttrIncludeGlobal(this, 'id');
        },

        setEl: function (el) {
            setDIAttr(this, 'el', el);
        },

        getEl: function (id) {
            return getDIAttr(this, 'el');
        },

        diShow: function () {
            var def = this.$di('getDef');
            var el = this.$di('getEl');
            var styleDisplay = getDIAttr(this, 'styleDisplay');
            var hideByAuth = getDIAttr(this, 'hideByAuth');
            if (styleDisplay != null && !hideByAuth) {
                setDIAttr(this, 'styleDisplay', null);
                el.style.display = styleDisplay;
            }
        },

        diHide: function () {
            var el = this.$di('getEl');
            if (el && getDIAttr(this, 'styleDisplay') == null) {
                setDIAttr(this, 'styleDisplay', el.style.display);
                el.style.display = 'none';
            }
        },

        /**
         * 
         * 
         * @param {boolean} isDeaf 
         * @param {string=} key 
         */
        setDeaf: function (isDeaf, key) {
            var keyName = 'deaf';

            // objKey
            if (isDeaf) {
                objKey.add(this, key, keyName);
                setDIAttr(this, keyName, true);
            }
            // keykey
            else {
                objKey.remove(this, key, keyName);
                (key == null || objKey.size(this, keyName) == 0)
                    && setDIAttr(this, keyName, false);
            }
        },

        isDeaf: function () {
            return getDIAttr(this, 'deaf');
        },

        /**
         * getValue
         * 
         * @param {boolean} valueDisabled getValue
         * @param {string=} key 
         */
        setValueDisabled: function (valueDisabled, key) {
            var keyName = 'valueDisabled';

            // objKey
            if (valueDisabled) {
                objKey.add(this, key, keyName);
                setDIAttr(this, keyName, true);
            }
            // keykey
            else {
                objKey.remove(this, key, keyName);
                (key == null || objKey.size(this, keyName) == 0) 
                    && setDIAttr(this, keyName, false);
            }
        },

        isValueDisabled: function () {
            return getDIAttr(this, 'valueDisabled');
        },

        getClzType: 'placeholder',

        /**
         * 
         *
         * @protected
         * @param {string=} key 
         */
        disable: function (key) {
            objKey.add(this, key);

            if (!getDIAttr(this, 'disabled')) {
                setDIAttr(this, 'disabled', true);
                this.disable && this.disable();
            }
        },

        /**
         * 
         *
         * @protected
         * @param {string=} key 
         */
        enable: function (key) {
            objKey.remove(this, key);

            if (objKey.size(this) == 0 && getDIAttr(this, 'disabled')) {
                setDIAttr(this, 'disabled', false);
                this.enable && this.enable();
            }
        },

        /**
         * optopt
         *
         * @public
         * @param {string} optName cfgOptbaseOpt
         * @param {string=} attr opt
         * @return {Object} opt
         */
        getOpt: function (optName, attr) {
            var def = getEntity(this.$di('getId'), 'RAW');
            return getOpt(def, optName, attr, { clone: true });
        },

        /**
         * def
         *
         * @public
         * @param {string} optName cfgOptbaseOpt
         * @param {string} attr 
         * @param {*} value 
         */
        setOpt: function (optName, attr, value) {
            var def = getEntity(this.$di('getId'), 'RAW');
            setOpt(def, optName, attr, value);
        },

        /** 
         * @param {string} refName 'vuiRef''vpartRef'
         * @param {string} refPath 'someAttr.some[4][5].some'
         * @param {string=} modee 'DEF''INS'
         * @return {(Array.<Object>|Object)} ref
         *      vuiDef
         *      {string} vuiDef.id ID
         *      {Object} vuiDef.clz 
         *      {string} vuiDef.clzKey key
         *      {Object} vuiDef.initObject 
         */
        getRef: function (refName, refPath, mode) {
            return getRef(this, refName, refPath, mode);
        },

        /**
         * 
         * addEventListenerdispatch
         * vuiadapter
         * 
         *      changeDIadapter
         *      adapterchangeCOMPONENT
         *      adapter
         *          ctrl.$di('registerEventAgent', 'change');
         *      
         *          ctrl.onchange = function () { 
         *              // ...
         *              ctrl.$di('dispatchEvent', 'change');
         *          };
         *      eventAgentctrlctrl.$di('addEventListener', ...)
         *      eventAgentctrl
         *
         * @public
         * @param {string=} eventName event agent
         */
        registerEventAgent: function (eventName) {
            registerEventAgent(this, eventName);
        },

        /**
         * 
         * XObjectecui
         * 
         * @param {string} eventName 
         * @param {Function} handler 
         * @param {Object} scope handlerthis
         * @param {Object=} options 
         * @param {string=} options.interactionId interactid
         * @param {string=} options.dispatcherId eventdi insid
         * @param {Function=} options.argHandler 
         *       {Array} 
         *       {Array} 
         *      argHandler
         *      
         * @param {Array} options.bindArgs handler
         *      argHandler
         * @param {boolean=} options.once handler
         * @param {boolean=} options.dontClone clone
         *      clone
         *      
         *      ObjectArrayclone
         * @param {(Function|boolean)=} checkDeaf deafdeaf
         *      truefalsefunctionfunction
         * @param {string} options.viewDisableDef 
         * @param {(Array|Object)=} options.rule 
         */
        addEventListener: function (
            eventName, handler, scope, options
        ) {
            assert(
                eventName && handler && scope, 
                'Event listener can not be empty.'
            );

            options = options || {};
            var argHandler = options.argHandler;
            var dontClone = options.dontClone;
            var once = options.once;
            var checkDeaf = options.checkDeaf;
            var bindArgs = options.bindArgs || [];
            var id = options.id;
            var dispatcherId = options.dispatcherId;
            var interactionId = options.interactionId;
            var viewDisableDef = options.viewDisableDef;
            var rule = options.rule;
            var eventMatchMode = options.eventMatchMode;
            var eventAgent = getEventAgentByName(this, eventName) || this;

            var newHandler = function () {
                // 
                if (checkDeaf !== false
                    && (isFunction(checkDeaf)
                            ? checkDeaf(scope)
                            : (scope && scope.$di && scope.$di('isDeaf'))
                    )
                ) {
                    return;
                }

                // diEvent
                var diEvent = arguments[0];
                var args = Array.prototype.slice.call(
                    arguments,
                    isDIEvent(diEvent)
                        ? (
                            // diEventdispatch
                            //interactPath
                            diEvent = cloneEvent(diEvent),
                            1
                        )
                        : (
                            // diEvent
                            diEvent = createDIEvent(eventName),
                            0
                        )
                );
                // insdiId
                setEventAttr(diEvent, 'dispatcherId', dispatcherId, true),
                setEventAttr(diEvent, 'interactionId', interactionId, true),
                diEvent.viewDisableDef = viewDisableDef;

                // interactionRule
                if (rule && !evalJsonLogic(
                        rule, 
                        bind(evalRule, null, diEvent)
                    )
                ) {
                    return;
                }

                // 
                !dontClone && (args = argsClone(args));

                // arg handler
                args = argHandler ? argHandler.call(scope, args) : args;

                // interact memo
                scope.$di && setInteractMemo(scope, 'diEvent', diEvent);

                // action
                var ret = handler.apply(scope, bindArgs.concat(args));

                // interact memo
                scope.$di && setInteractMemo(scope, 'diEvent', UNDEFINED);

                return ret;
            };
            
            // FIXME 
            // 
            // ecuiecui
            // ecuielse            
            if (eventAgent instanceof XOBJECT) {
                eventAgent[once ? 'attachOnce' : 'attach'](eventName, newHandler);
            }
            else if (isEcuiControl(eventAgent)) {
                ecuiAddEventListener(eventAgent, eventName, newHandler, once);
            }

            options = null;
        },

        /**
         * 
         * XObjectecui
         * 
         * @param {(string|DIEvent)} eventName diEvent
         * @param {Array} args 
         */
        dispatchEvent: function (eventName, args, options) {
            options = options || {};

            var eventAgent = getEventAgentByName(this, eventName) || this;

            // diEventinteractPath
            if (isDIEvent(eventName)) {

                // diEventeventHandler$di('addEventListener')
                // diEvent$di('addEventListener')
                assert(
                    eventAgent != this,
                    'diEventregisterEventAgent'
                );

                // diEvent
                (args = args || []).splice(0, 0, eventName);
                eventName = eventName.getEventName();
            }

            // FIXME 
            // addEventListener            
            if (eventAgent instanceof XOBJECT) {
                eventAgent.notify(eventName, args);
            }
            else if (isEcuiControl(eventAgent)) {
                ecuiTriggerEvent(eventAgent, eventName, null, args);
            }
        }
    };

    var DEF_CONTRACT_METHOD = {
        getDIFactory: COMMON_CONTRACT_METHOD.getDIFactory,
        getMethod: function (methodName) {
            return DEF_CONTRACT_METHOD[methodName];
        },
        setId: function (id) {
            this.id = id;
        },
        getId: function () {
            return this.id;
        },
        getOpt: COMMON_CONTRACT_METHOD.getOpt,
        setOpt: COMMON_CONTRACT_METHOD.setOpt,
        getRef: COMMON_CONTRACT_METHOD.getRef
    };

    var COMPONENT_CONTRACT_METHOD = {
        setTplMode: function (tplMode) {
            setDIAttr(this, 'tplMode', tplMode);
        },

        getTplMode: function () {
            return getDIAttr(this, 'tplMode');
            // return getAttrIncludeGlobal(this, 'tplMode');
        },

        /** 
         * VUI
         * VUI
         * 
         *
         * componentvui
         *  vuiecui
         *  
         *  ecui$fastCreate
         *      var options = { myAttr1: 1, myAttr2: 'yyy' };
         *      this._uSomeControl = this.$di 
         *          && this.$di('create', ['theVUINameInTpl', 1], options)
         *          || ecui.$fastCreate(ecui.ui.MyControl, mainEl, null, options);
         *
         * @param {string} refPath 'someAttr.some[4][5].some'
         * @param {Object=} options 
         * @return {Object} vui
         */
        vuiCreate: function (refPath, options) {
            var def = this.$di('getRef', 'vuiRef', refPath, 'DEF');
            if (!def) { return null; }
            
            options = mergeOpt(
                def, 
                extend({}, options, { id: def.id, el: def.el }),
                'DATA_INIT'
            );

            // vuiSetcomponentvui
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiSetKey = makePathKey(refPath);

            assert(
                !vuiSet[vuiSetKey],
                'vui: refPath=' + refPath + ' vuiSetKey=' + vuiSetKey
            );

            // 
            if (getOpt(def, 'cfgOpt', 'paramMode') == null) {
                setOpt(def, 'cfgOpt', 'paramMode', 'NORMAL');
            }

            // 
            var adptMethod = def.adapterMethod || {};
            var adpt = def.adapter && def.adapter(def, options) || {};

            // 
            var ins;
            if (adpt['create']) {
                ins = adpt['create'](def, options);
            }
            else if (adptMethod['create']) {
                ins = generalAdapterMethod[adptMethod['create']](def, options);
            }

            // 
            if (!ins) {
                return null;
            }

            // $di
            ins.$di = $di.INS;

            // 
            setDIAttr(ins, 'parent', this);

            // 
            setDIAttr(ins, 'id', def.id);
            setDIAttr(ins, 'el', def.el);
            if (def.el && def.el.style.display == 'none') {
                setDIAttr(ins, 'styleDisplay', def.styleDisplay);
            }

            // 
            vuiSet[vuiSetKey] = ins;
            setDIAttr(ins, 'parentVUISetKey', vuiSetKey);
            addEntity(ins, 'INS');

            // adapter
            var setDataMethod;
            var methodName;
            for (methodName in adptMethod) {
                assert(
                    !COMMON_CONTRACT_METHOD[methodName], 
                    'common contract method can not be overwrite!' + methodName
                );
                if (methodName != 'create') {
                    // adapter method
                    // 
                    // 
                    // (1) adapterMethod
                    // 
                    // (2) setDIMethod
                    // adapterMethodinstallClzDIMethod
                    // setDIMethodoverride
                    setDIAdapterMethod(
                        ins, 
                        methodName, 
                        generalAdapterMethod[methodName]
                    );
                }
            }
            for (methodName in adpt) {
                assert(
                    !COMMON_CONTRACT_METHOD[methodName], 
                    'common contract method can not be overwrite!' + methodName
                );
                if (methodName != 'create') {
                    // 
                    setDIAdapterMethod(
                        ins, 
                        methodName, 
                        adpt[methodName]
                    );
                }
            }

            return ins;
        },

        /**
         * componentvui
         * 
         * @public
         * @param {string} refPath 'someAttr.some[4][5].some'
         * @return {Object} vui
         */
        vuiGet: function (refPath) {
            return getMakeAttr(this, 'vuiSet')[makePathKey(refPath)];
        },

        /**
         * ComponentgetValue
         * vuigetValue
         * vuinamekey
         * namegetValue
         * vuigetValuevuiGetValue
         * 
         * @public
         * @return {Object} value
         */
        getValue: function () {
            var def = this.$di('getDef');
            var valueDisabledMode = def.valueDisabledMode;

            var cmptValDisabled = this.$di('isValueDisabled');
            if (cmptValDisabled && valueDisabledMode == 'NORMAL') {
                return null;
            }

            var value = {};
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiIns;
            var vuiDef;
            var vuiValue;

            if (this.getValue) {
                value = this.getValue() || {};
            }

            var valDisabled;
            for (var refPathKey in vuiSet) {
                vuiIns = vuiSet[refPathKey];
                vuiDef = vuiIns.$di('getDef');
                valDisabled = cmptValDisabled || vuiIns.$di('isValueDisabled');

                if (vuiDef.name == null 
                    || (valDisabled && valueDisabledMode == 'NORMAL')
                ) { 
                    continue; 
                }

                value[vuiDef.name] = valDisabled && valueDisabledMode == 'DI'
                    ? null
                    : (
                        isObject(vuiValue = vuiIns.$di('getValue')) 
                            ? COMMON_PARAM_FACTORY.markParamMode(
                                vuiValue,
                                getOpt(vuiDef, 'cfgOpt', 'paramMode')
                            )
                            : vuiValue
                    );
            }

            return value;
        },

        /**
         * COMPONENTinteractionevent
         * disableFuncenableFunc
         * disableenable.
         * 
         * interactionaction
         * 
         * @public
         * @return {Object} event 
         *      {Function} event.disableFunc
         *      {Function} event.enableFunc
         */
        getEvent: function () {
            var event = getInteractMemo(this, 'diEvent');
            /*
            // sync view disable
            var visDef = event.viewDisableDef;
            if (visDef) {
                var key = 'INTERACTION_VIEW_DISABLE_' + this.$di('getId');
                event.viewDisable = {
                    disable: makeViewDisableFunc(visDef, 'disable', key),
                    enable: makeViewDisableFunc(visDef, 'enable', key)
                }
            };
            */
            return event;
        },

        getEventChannel: getEventChannel,

        setCommonParamGetter: function (commonParamGetter) {
            setDIAttr(this, 'commonParamGetter', commonParamGetter);
        },

        getCommonParamGetter: function () {
            return getDIAttr(this, 'commonParamGetter');
        },

        getReportTemplateId: function () {
            var getter = getDIAttr(this, 'commonParamGetter');
            if (getter) {
                return getter.getReportTemplateId()
            }
        },

        /**
         * 
         * 
         * @protected
         * @param {string} linkBridgeType 'I'(internal)'E'(external)
         * @param {string} url url
         * @param {string} param 
         */
        linkBridge: function (linkBridgeType, url, param) {
            // 
            if (linkBridgeType == 'I') {
                targetBlank(url + '?' + param);
            }
            // di-stub
            else if (linkBridgeType == 'E') {
                eventChannel && eventChannel.triggerEvent(
                    'linkbridge', 
                    [url, param]
                );
            }
        },

        /**
         * view disable
         * 
         * @protected
         * @param {string} actName disableenable
         * @param {string} datasourceId 
         */
        syncViewDisable: function (actName, datasourceId) {
            assert(
                actName == 'enable' || actName == 'disable',
                'Wrong actName: ' + actName
            );
            var def = this.$di('getDef');
            var key = 'ASYNC_VIEW_DISABLE_' + this.$di('getId');
            var vdDef = (def.sync || {}).viewDisable;
            doViewDisable(
                vdDef == 'ALL'
                    ? vdDef
                    : (isObject(vdDef) && vdDef[datasourceId]),
                actName,
                key
            );
        },

        /**
         * vui, 
         * 
         * @public
         */
        funcAuthVerify: function () {
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiIns;
            var vuiDef;

            for (var refPathKey in vuiSet) {
                vuiIns = vuiSet[refPathKey];
                vuiDef = vuiIns.$di('getDef');
                if (// vuifuncAuth
                    vuiDef.funcAuth 
                    && !(vuiDef.funcAuth in funcAuthKeys)
                ) {
                    // 
                    vuiIns.$di('getEl').style.display = 'none';
                    setDIAttr(vuiIns, 'hideByAuth', true);
                }
            }
        }        
    };

    var VCONTAINER_CONTRACT_METHOD = {
        /** 
         * VPART
         * VPART
         * 
         *
         * @param {string} refPath 'someAttr.some[4][5].some'
         * @param {Object=} options 
         * @return {Object} vpart
         */
        vpartCreate: function (refPath, options) {
            var def = this.$di('getRef', 'vpartRef', refPath, 'DEF');
            if (!def) { return null; }

            options = mergeOpt(
                def, 
                extend({}, options, { id: def.id, el: def.el }),
                'DATA_INIT'
            );

            // vpartSetcomponentvpart
            var vpartSet = getMakeAttr(this, 'vpartSet');
            var vpartSetKey = makePathKey(refPath);

            assert(
                !vpartSet[vpartSetKey],
                'vpart: refPath=' + refPath + ' vpartSetKey=' + vpartSetKey
            );

            // 
            var ins = new def.clz(options);

            // 
            if (!ins) {
                return null;
            }

            // $di
            ins.$di = $di.INS;

            // 
            setDIAttr(ins, 'parent', this);

            // 
            setDIAttr(ins, 'id', def.id);
            setDIAttr(ins, 'el', def.el);
            if (def.el && def.el.style.display == 'none') {
                setDIAttr(ins, 'styleDisplay', def.styleDisplay);
            }

            // 
            vpartSet[vpartSetKey] = ins;
            setDIAttr(ins, 'parentVPartSetKey', vpartSetKey);
            addEntity(ins, 'INS');

            return ins;
        },

        /**
         * vcontainervpart
         * 
         * @public
         * @param {string} refPath 'someAttr.some[4][5].some'
         * @return {Object} vui
         */
        vpartGet: function (refPath) {
            return getMakeAttr(this, 'vpartSet')[makePathKey(refPath)];
        }
    };

    var VUI_CONTRACT_METHOD = {
        /**
         * vuisetData
         * vuisetData
         * setDatavuisetData
         * dataOptoptions
         * mergeOpt
         * ComponentvuisetData
         * this._uSomeVUi.$di('setData', data);
         * vuisetData
         * 
         * @public
         * @param {*} data
         * @param {Object=} options 
         * @param {*=} options.forceData mergedata
         * @param {Object=} options.diEvent di
         */
        setData: function (data, options) {
            if (!this.$di) {
                return this.setData.apply(this, arguments);
            }

            var existMethod = getDIAdapterMethod(this, 'setData') || this.setData;
            if (existMethod) {
                options = options || {};
                data = mergeOpt(
                    this.$di('getDef'), data, 'DATA_SET', options
                );
                // TODO 
                // isSilent
                return existMethod.call(this, data);
            }
        },

        /**
         * vuigetValue
         * 
         * @public
         */
        getValue: function () {
            if (!this.$di) {
                return this.setData.apply(this, arguments);
            }

            var existMethod = getDIAdapterMethod(this, 'getValue') || this.getValue;
            if (existMethod) {
                return this.$di('isValueDisabled')
                    ? null
                    : existMethod.call(this);
            }
        },

        /**
         * vuiinit
         * 
         * @public
         */
        init: function () {
            if (!this.$di) {
                return this.init.apply(this, arguments);
            }

            var existMethod = getDIAdapterMethod(this, 'init') || this.init;
            mountInteractions(this);
            existMethod && existMethod.call(this);
        },

        /**
         * 
         *
         * @public
         */
        dispose: function () {
            if (!this.$di) {
                return this.dispose.apply(this, arguments);
            }

            var existMethod = getDIAdapterMethod(this, 'dispose') || this.dispose;
            var vuiSet = getDIAttr(getDIAttr(this, 'parent'), 'vuiSet');
            if (vuiSet) {
                delete vuiSet[getDIAttr(this, 'parentVUISetKey')];
            }
            removeEntity(this);
            existMethod && existMethod.call(this);
            this.$di('setEl', null);
        }
    };

    var VPART_CONTRACT_METHOD = {
        /**
         * 
         *
         * @public
         */
        dispose: function () {
            var vpartSet = getDIAttr(getDIAttr(this, 'parent'), 'vpartSet');
            if (vpartSet) {
                delete vpartSet[getDIAttr(this, 'parentVPartSetKey')];
            }
            removeEntity(this);
            this.dispose && this.dispose.call(this);
            this.$di('setEl', null);
        }
    }



    //----------------------------------------------------------------------
    // rule
    //----------------------------------------------------------------------

    /**
     * interaction
     * 
     * @private 
     * @param {Object} diEvent 
     * @param {Array.<Object>} atomRule
     *      
     *      { operator: 'includes', interactionIds: ['aaaaa-rid1', 'aaaa-rid2' ]}
     * @return {boolean} 
     */
    function evalRule(diEvent, atomRule) {
        // operator
        var ruleMap = { 
            includes: evalRuleIncludesExcludes, 
            excludes: evalRuleIncludesExcludes, 
            equals: evalRuleEquals
        };        

        assert(
            atomRule.operator in ruleMap,
            'Illegal rule: ' + atomRule.operator
        );

        return ruleMap[atomRule.operator](diEvent, atomRule);
    }

    /**
     * interaction incudes excludes
     * 
     * @private 
     * @param {Object} diEvent 
     * @param {Array.<Object>} atomRule
     *      
     *      { operator: 'includes', interactionIds: ['aaaaa-rid1', 'aaaa-rid2' ]}
     * @return {boolean} 
     */
     function evalRuleIncludesExcludes(diEvent, atomRule) {
        if (!diEvent) { return false; }

        var rSet = { includes: {}, excludes: {} };

        for (var j = 0; j < (atomRule.interactionIds || []).length; j ++) {
            rSet[atomRule.operator][atomRule.interactionIds[j]] = 1;
        }

        var path = getEventAttr(diEvent, 'interactPath');
        for (var i = 0, e, iid; e = path[path.length - i - 1]; i ++) {
            iid = getEventAttr(e, 'interactionId');

            if (iid in rSet.excludes) {
                return false;
            }

            if (rSet.includes[iid]) {
                delete rSet.includes[iid];
            }
        }

        if (!isEmptyObj(rSet.includes)) {
            return false;
        }

        return true;

        // TODO
        // 
        // for (
        //     var i = 0, e, eDef; 
        //     eDef = interactPathDef[dlen - i - 1], e = realPath[rlen - i - 1];
        //     i ++
        // ) {
        //     if (!eDef) {
        //         if (eventMatchMode == 'EXACT') { return false; }
        //         else { break; }
        //     }

        //     if (getEventAttr(e, 'dispatcherId') != eDef.dispatcherId
        //         || getEventAttr(e, 'eventName') != eDef.name
        //     ) {
        //         return false;
        //     }
        // }
    }

    /**
     * interaction equals
     * 
     * @private 
     * @param {Object} diEvent 
     * @param {Array.<Object>} atomRule
     *      
     *      { atomRule: 'equals', argHandlers: [ ... ], value: 1234 }
     * @return {boolean} 
     */
     function evalRuleEquals(diEvent, atomRule) {
        var val = parseArgHandlerDesc(atomRule).call(null, [])[0];
        return val == atomRule.value;
     }





    //-------------------------------------------------------------------
    // DI Event
    //-------------------------------------------------------------------

    /**
     * DI
     * 
     * @private
     * @param {string=} eventName 
     * @param {Object=} options 
     * @param {string=} options.dispatcherId eventdi insid
     * @param {string=} options.interactionId interactionid
     * @param {string=} options.isClone clone
     * @param {Array.<Object>=} options.interactPath 
     * @return {Function} event
     */
    function createDIEvent(eventName, options) {
        options = options || {};

        var evt = function (eName) {
            return createDIEvent(
                eName,
                // interactPatheventinteractPath
                { interactPath: evt[DI_EVENT_TAG].interactPath }         
            );
        }

        // event
        var repo = evt[DI_EVENT_TAG] = {
            eventName: eventName,
            dispatcherId: options.dispatcherId,
            interactionId: options.interactionId,
            interactPath: (options.interactPath || []).slice()
        };

        // eventinteractPath
        var path = repo.interactPath;
        options.isClone
            ? path.splice(path.length - 1, 1, evt)
            : path.push(evt);

        // event
        extend(evt, DI_EVENT_METHODS);

        return evt;
    };

    var DI_EVENT_METHODS = {
        /** 
         * 
         * 
         * @public
         * @this {Object} diEvent
         * @return {string} 
         */
        getEventName: function () {
            return this[DI_EVENT_TAG].eventName;
        },

        /** 
         * interactionId
         * 
         * @public
         * @this {Object} diEvent
         * @return {string} interactionIdId
         */
        getInteractionId: function () {
            return this[DI_EVENT_TAG].interactionId;
        }

        /**
         * 
         * 
         * @public
         */
        // isUserFirst: function () {
        //     var path = this[DI_EVENT_TAG].interactPath;
        //     return path && path[0] && path[0].getEventName() != INIT_EVENT_NAME
        // },

        /**
         * 
         * 
         * @public
         */
        // isInitFirst: function () {
        //     var path = this[DI_EVENT_TAG].interactPath;
        //     if (path 
        //         && path[0] 
        //         && path[0].getEventName() == INIT_EVENT_NAME
        //         && path[1] === this
        //     ) {
        //         return true;
        //     }
        //     else {
        //         return false;
        //     }
        // }
    };

    /**
     * 
     * 
     * @public
     * @this {Event} 
     * @param {Object} event 
     * @return {string} 
     */
    function cloneEvent(event) {
        var repo = event[DI_EVENT_TAG];
        return createDIEvent(
            repo.eventName,
            {
                dispatcherId: repo.dispatcherId,
                interactionId: repo.interactionId,
                interactPath: repo.interactPath,
                isClone: true
            }
        );
    }

    /**
     * event
     *
     * @private
     */
    function getEventAttr(event, attrName) {
        return event[DI_EVENT_TAG][attrName];
    }

    /**
     * event
     *
     * @private
     */
    function setEventAttr(event, attrName, value, checkExist) {
        if (checkExist && event[DI_EVENT_TAG][attrName] !== UNDEFINED) {
            throw new Error('diEvent("newEventName")diEvent');
        }
        event[DI_EVENT_TAG][attrName] = value;
    }

    /**
     * event
     *
     * @private
     */
    function isDIEvent(obj) {
        return isObject(obj) && obj[DI_EVENT_TAG];
    }





    //--------------------------------------------------------------------
    // DI Opt 
    //--------------------------------------------------------------------

    /**
     * opt
     * opt
     *      (1) def[optName] ==> Object
     *      (2) def[optName + 's'] ==> Array
     *
     * @private
     * @param {Object} src 
     * @param {string} optName opt
     * @return {Object} opt
     */
    function initializeOpt(def, optName) {

        // optCache
        var optCacheHome = def[DI_OPT_CACHE_TAG];
        if (!optCacheHome) {
            optCacheHome = def[DI_OPT_CACHE_TAG] = {};
        }
        optCacheHome[optName] = {};

        // opt
        var optHome = def[DI_OPT_HOME_TAG];
        if (!optHome) {
            optHome = def[DI_OPT_HOME_TAG] = {};
        }

        var opt = optHome[optName] = def[optName] || {};
        var opts = optHome[optName + 's'] = def[optName + 's'] || [];

        // def[optName]getOpt
        def[optName] = null;
        def[optName + 's'] = null;

        // idoptCache
        opt[DI_OPT_ID_TAG] = 'DI_OPT_' + getUID('DI_OPT');
        for (var i = 0; i < opts.length; i ++) {
            opts[i][optName][DI_OPT_ID_TAG] = 'DI_OPT_' + getUID('DI_OPT');
        }
    }

    /**
     * opt
     *
     * @private
     * @param {Object} src 
     * @param {string} optName opt
     * @param {string=} attr opt
     * @param {Obejct=} options 
     * @param {Object=} options.diEvent di
     * @param {boolean=} options.clone false
     * @return {Object} opt
     */
    function getOpt(def, optName, attr, options) {
        options = options || {};

        var optHome = def[DI_OPT_HOME_TAG];
        var optCache = def[DI_OPT_CACHE_TAG][optName];
        var opt = optHome[optName];
        var opts = optHome[optName + 's'];
        var diEvent = options.diEvent;
        var i;
        var o;
        var ret;
        var matchedOpt = [];
        var matchedIds = [];
        var evalRuleFunc = bind(evalRule, null, diEvent);

        matchedOpt.push(opt);
        matchedIds.push(opt[DI_OPT_ID_TAG]);

        // ruleopt
        for (i = 0; i < opts.length; i ++) {
            if ((o = opts[i]) 
                && o.rule 
                && o[optName]
                && evalJsonLogic(o.rule, evalRuleFunc)
            ) {
                matchedOpt.push(o[optName]);
                matchedIds.push(o[optName][DI_OPT_ID_TAG]);
            }
        }

        var cacheKey = matchedIds.join(SEP);

        // merge
        if (!(ret = optCache[cacheKey])) {
            ret = optCache[cacheKey] = {};
            for (i = 0; i < matchedOpt.length; i ++) {
                merge(
                    ret, 
                    matchedOpt[i], 
                    { overwrite: true, clone: 'WITHOUT_ARRAY' }
                );
            }
        }

        if (attr != null) {
            ret = ret[attr];
        }

        return options.clone
            ? clone(ret, { exclusion: [DI_OPT_CACHE_TAG] })
            : ret;
    }

    /**
     * opt
     *
     * @private
     * @param {Object} src 
     * @param {string} optName cfgOptdataOpt
     * @param {string} attr 
     * @param {*} value 
     */
    function setOpt(def, optName, attr, value) {
        def[DI_OPT_HOME_TAG][optName][attr] = value;

        // optcache
        def[DI_OPT_CACHE_TAG][optName] = {};
    }

    /** 
     * 
     *
     * @public
     * @param {Object} def 
     * @param {Object} invokerData options
     * @param {string} optType 'INIT', 'DATA'
     * @param {Object=} options
     * @param {Object=} options.forceData 
     * @param {Object=} options.diEvent di
     */
    function mergeOpt(def, invokerData, optType, options) {
        def = def || {};
        options = options || {};
        var ret = {};

        // clonemergeclone array
        var mOpt = { overwrite: true, clone: 'WITHOUT_ARRAY' };
        var mOpt2 = extend({}, mOpt, { exclusion: [DI_OPT_ID_TAG] });
        var optopt = { diEvent: options.diEvent };

        var clzDef = getClz(def.clzKey) || {};
        var clzDataOpt = getOpt(clzDef, 'dataOpt', null, optopt);
        var dataOpt = getOpt(def, 'dataOpt', null, optopt);

        merge(ret, clzDataOpt, mOpt2);
        merge(ret, invokerData, mOpt);
        merge(ret, dataOpt, mOpt2);

        if (optType == 'DATA_SET') {
            merge(ret, getOpt(def, 'dataSetOpt', null, optopt), mOpt2);
        }
        else if (optType == 'DATA_INIT') {
            merge(ret, getOpt(def, 'dataInitOpt', null, optopt), mOpt2);
        }
        else {
            throw new Error('error optType:' + optType);
        }

        options.forceData && 
                merge(ret, options.forceData, mOpt);

        return ret;
    }






    //-----------------------------------------------------------------------
    // Arg Handler 
    //-----------------------------------------------------------------------

    /**
     * argHandler
     * 
     * @param {Object} container argHandler
     * @param {Object=} scope 
     * @private
     */
    function parseArgHandlerDesc(container, scope) {
        var argH;
        var argHs = [];

        if (argH = container.argHandler) {
            argHs.push(argH);
        }
        if (argH = container.argHandlers) {
            argHs.push.apply(argHs, argH);
        }

        for (var i = 0; i < argHs.length; i ++) {
            argHs[i] = [scope].concat(argHs[i]);
        }

        return ARG_HANDLER_FACTORY.apply(null, argHs);
    }






    //-----------------------------------------------------------------------
    // DI Factory
    //-----------------------------------------------------------------------

    /**
     * enhanceDI
     * setDIMethodprototype
     * (a) 
     * 
     * (b) DIDI$('someMethod', ...)
     *
     * @private
     */
    function installClz() {
        var clzKey;
        var clzDef;
        var proto;

        generalAdapterMethod = getByPath(
            GENERAL_ADAPTER_METHOD_PATH,
            $getNamespaceBase()
        );

        for (clzKey in DICT.CLZ) {
            repository['CLZ'][clzKey] = clzDef = clone(DICT.CLZ[clzKey]);

            // 
            if (clzDef.clzPath 
                && (clzDef.clz = getByPath(clzDef.clzPath, $getNamespaceBase()))
            ) {
                proto = clzDef.clz.prototype;

                // 
                if (!getDIAttr(proto, 'protoInstalled', true)) {
                    setDIAttr(proto, 'protoInstalled', 1);

                    // $di
                    proto.$di = $di.INS;

                    // 
                    mountMethod(
                        proto,
                        [
                            'start',
                            'getDIFactory',
                            'setId',
                            'getId',
                            'getDef',
                            'isDeaf',
                            'setDeaf',
                            'setEl',
                            'getEl',
                            'disable',
                            'enable',
                            'diShow',
                            'diHide',
                            'setValueDisabled',
                            'isValueDisabled',
                            'addEventListener',
                            'dispatchEvent',
                            'registerEventAgent',
                            'getOpt',
                            'setOpt',
                            'getRef'
                        ],
                        COMMON_CONTRACT_METHOD
                    );

                    if (clzDef.clzType == 'COMPONENT') {
                        mountMethod(
                            proto,
                            [
                                'setTplMode',
                                'getTplMode',
                                'vuiCreate',
                                'vuiGet',
                                'getValue',
                                'getEvent',
                                'getEventChannel',
                                'getCommonParamGetter',
                                'setCommonParamGetter',
                                'getReportTemplateId',
                                'linkBridge',
                                'syncViewDisable',
                                'funcAuthVerify'                     
                            ],
                            COMPONENT_CONTRACT_METHOD
                        );
                    }                

                    if (clzDef.clzType == 'VCONTAINER') {
                        mountMethod(
                            proto,
                            [
                                'vpartCreate',
                                'vpartGet'
                            ],
                            VCONTAINER_CONTRACT_METHOD
                        );
                    }

                    if (clzDef.clzType == 'VUI') {
                        mountMethod(
                            proto,
                            [
                                'setData',
                                'getValue',
                                'init',
                                'dispose'
                            ],
                            VUI_CONTRACT_METHOD
                        );
                    }

                    if (clzDef.clzType == 'VPART') {
                        mountMethod(
                            proto,
                            [
                                'dispose'
                            ],
                            VPART_CONTRACT_METHOD
                        );
                    }

                    // 
                    setDIMethod(
                        proto, 
                        'getClzType',
                        (function (clzType) {
                            return function () { return clzType; }     
                        })(clzDef.clzType)
                    );
                }
            }

            // adapter
            clzDef.adapterPath && (
                clzDef.adapter = 
                    getByPath(clzDef.adapterPath, $getNamespaceBase())
            );

            // 
            initializeOpt(clzDef, 'dataOpt');
            initializeOpt(clzDef, 'dataInitOpt');
            initializeOpt(clzDef, 'dataSetOpt');
            initializeOpt(clzDef, 'valueGetOpt');
            initializeOpt(clzDef, 'cfgOpt');
        }
    }

    /**
     * di
     *
     * @private
     * @param {Object} proto prototype
     * @param {Array.<string>} methodNameList 
     * @param {Array.<string>} methodSet 
     */
    function mountMethod(proto, methodNameList, methodSet) {
        for (
            var i = 0, methodName, prefixedMethodName; 
            methodName = methodNameList[i]; 
            i ++
        ) {
            setDIMethod(proto, methodName, methodSet[methodName]);
        }
    }

    /**
     * di
     *
     * @private
     * @param {Object} def 
     * @param {Object} options 
     * @param {string} options.tplMode 'FROM_SNIPPET'
     * @param {string} options.commonParamGetter
     * @return {Object} 
     */
    function createIns(def, options) {   
        options = options || {};
        // new
        // globalTemp
        var opt = {
            id: def.id,
            el: def.el,
            // htmlsnippet
            tplMode: options.tplMode || 'FROM_SNIPPET',
            commonParamGetter: options.commonParamGetter
        };
        opt[DI_TMP_TAG] = extend({}, opt);

        var ins = new def.clz(
            mergeOpt(def, extend(options, opt), 'DATA_INIT')
        );

        addEntity(ins);

        return ins;
    }    

    /**
     * interaction
     *
     * @public
     * @param {Object} ins 
     */
    function mountInteractions(ins) {   
        var def = ins.$di('getDef');

        // (interaction)
        if (!def.interactions) { return; }

        for (
            var i = 0, interact; 
            interact = def.interactions[i]; 
            i ++
        ) {
            mountInteraction(ins, interact);
        }        
    }

    /**
     * interaction
     *
     * @public
     * @param {Object} ins 
     */
    function mountInteraction(ins, interact) {  
        var def = ins.$di('getDef');

        var events = [];
        interact.event && events.push(interact.event);
        interact.events && arrayPush.apply(events, interact.events);

        for (var j = 0, evt, triggerIns; j < events.length; j ++) {
            evt = events[j];
            triggerIns = evt.triggerIns || getEntity(evt.rid, 'INS');

            // vuidiEvent
            assert(
                triggerIns.$di('getDef').clzType != 'VUI',
                'vui'
            );

            if (!triggerIns) { return; }

            triggerIns.$di(
                'addEventListener', 
                evt.name,
                getDIMethod(ins, interact.action.name),
                ins,
                {
                    interactionId: interact.id,
                    dispatcherId: evt.rid,
                    argHandler: parseArgHandlerDesc(interact, ins),
                    once: interact.once,
                    viewDisableDef: interact.viewDisable,
                    rule: evt.rule 
                        ? ['and', interact.rule, evt.rule] 
                        : interact.rule
                }
            );
        }
    }

    /**
     * refPath
     * 
     *
     * @public
     * @param {Object} obj INSDEF
     * @param {string} refName 'vuiRef''vpartRef'
     * @param {string} refPath 'someAttr.some[4][5].some'
     * @param {string=} mode 'DEF''INS'
     * @param {Object=} options 
     * @param {boolean=} options.flatReturn 
     *      true
     *      falseid
     * @return {(Array.<Object>|Object)} refref
     */
    function getRef(obj, refName, refPath, mode, options) {
        options = options || {};

        var refBase = (
            getEntity(obj.$di('getId'), 'DEF') || {}
        )[refName];

        if (!refBase) { return null; }

        return findEntity(
            getByPath(refPath, refBase), 
            mode, 
            { isClone: true, flatReturn: options.flatReturn }
        );
    }

    /**
     * prototype
     *
     * @private
     * @param {Object} o prototype
     * @param {string} methodName 
     * @param {Function} method 
     */    
    function setDIMethod(o, methodName, method) {
        var pName = DI_METHOD_PREFIX + methodName;
        assert(!o.hasOwnProperty(pName), 'diMethod exists! ' + methodName);
        o[pName] = method;
    }      

    /**
     * 
     *
     * @private
     * @param {Object} o prototype
     * @param {string} methodName 
     * @return {Function} method 
     */    
    function getDIMethod(o, methodName) {
            // di
        return o[DI_METHOD_PREFIX + methodName]
            // 
            || o[methodName];
    }

    /**
     * adapterprototype
     *
     * @private
     * @param {Object} o prototype
     * @param {string} methodName 
     * @param {Function} method 
     */    
    function setDIAdapterMethod(o, methodName, method) {
        var pName = DI_ADAPTER_METHOD_PREFIX + methodName;
        assert(!o.hasOwnProperty(pName), 'diAdapterMethod exists! ' + methodName);
        o[pName] = method;
    }      

    /**
     * adapter
     *
     * @private
     * @param {Object} o prototype
     * @param {string} methodName 
     * @return {Function} method 
     */    
    function getDIAdapterMethod(o, methodName) {
        return o[DI_ADAPTER_METHOD_PREFIX + methodName];
    }

    /**
     * 
     *
     * @public
     * @param {string} clzKey key
     * @return {Object} clzDef 
     *      clzDef.clz 
     *      clzDef.clzKey key
     *      clzDef.clzPath 
     *      clzDef.adapterPath 
     *      clzDef.adapter 
     *      clzDef.dataOpt 
     */
    function getClz(clzKey) {
        return repository['CLZ'][clzKey];
    }

    /**
     * insdef
     *
     * @public
     * @param {Object} o 
     * @param {string} mode 'INS', 'DEF'
     * @return {DIFactory} 
     */
    function addEntity(o, mode) {
        if (mode == 'DEF') {
            if (o.clzType && o.id) {
                
                // clz
                var clzDef = getClz(
                    o.clzKey || DICT.DEFAULT_CLZ_KEY[o.clzType]
                ); 
                o = merge(clone(clzDef), o);

                // def
                o[DI_DEF_TAG] = true;

                // $di
                o.$di = $di.DEF;

                // 
                initializeOpt(o, 'dataOpt');
                initializeOpt(o, 'dataInitOpt');
                initializeOpt(o, 'dataSetOpt');
                initializeOpt(o, 'valueGetOpt');
                initializeOpt(o, 'cfgOpt');

                // 
                repository[o.clzType + '_DEF'][o.id] = assign({}, o);
            }
        }
        else {        
            repository[o.$di('getClzType')][o.$di('getId')] = o;
        }
        return instance;
    }    

    /**
     * 
     *
     * @public
     * @param {Object} o 
     */
    function removeEntity(o) {
        if (o[DI_DEF_TAG]) {
            delete repository[o.clzType + '_DEF'][o.id];
        }
        else {        
            delete repository[o.$di('getClzType')][o.$di('getId')];
        }
    }

    /**
     * 
     *
     * @private
     * @param {string} id id
     * @param {string} mode 'INS', 'DEF', 'RAW'
     * @return {Object} 
     */
    function getEntity(id, mode) {
        var suffix = mode == 'INS' ? '' : '_DEF';
        var o;
        var ret;
        var optCache;

        for (var i = 0, clzType; clzType = INS_CLZ_TYPE[i]; i ++) {
            if (clzType != 'CLZ' 
                && (o = repository[clzType + suffix][id])
            ) {
                if (mode == 'INS' || mode == 'RAW') {
                    return o;
                }
                // mode'DEF'
                else {
                    ret = clone(o, { exclusion: [DI_OPT_CACHE_TAG] });
                    // optCache
                    ret[DI_OPT_CACHE_TAG] = o[DI_OPT_CACHE_TAG];
                    return ret;
                }
            }
        }
        return null;
    }

    /**
     * insdef
     *
     * @public
     * @param {(Object|Array)} target 
     *      ObjectArrayid
     * @param {string} mode 'INS', 'DEF'
     * @param {Object=} options 
     * @param {boolean=} options.flatReturn 
     *      true
     *      falseid
     * @param {boolean=} options.isClone clone
     *      truetarget
     *      falsetargettarget
     * @return {Object} target 
     */
    function findEntity(target, mode, options) {
        options = options || {}
        var result;
        var i;
        var flatRet = options.flatReturn ? [] : null;

        if (isArray(target)) {
            result = options.isClone ? [] : target;
            for (i = 0; i < target.length; i ++) {
                target.hasOwnProperty(i)
                    && (result[i] = findEntity(target[i], mode));
            }
        }
        else if (isObject(target)) {
            result = options.isClone ? {} : target;
            for (i in target) {
                target.hasOwnProperty(i)
                    && (result[i] = findEntity(target[i], mode));
            }
        } 
        else {
            result = getEntity(target, mode);
            flatRet && flatRet.push(result);
        }

        return flatRet ? flatRet : result;
    }

    /**
     * unit
     *
     * @protected
     * @param {(string|Array)} clzType 
     *      
     * @param {Function} callback 
     *              {Object} def
     *              {Object} ins
     *              {string} id
     */
    function forEachEntity(clzType, callback) {
        clzType = isString(clzType) 
            ? [clzType] : (clzType || []);

        for (var i = 0, c, repoIns, repoDef; c = clzType[i]; i ++) {
            var repoDef = repository[c + '_DEF'];
            var repoIns = repository[c];
            for (var id in repoDef) {
                repoDef[id] && callback(repoDef[id], repoIns[id], id);
            }
        }
    }

    /**
     * di
     * 
     * @private
     * @param {Object} o ins
     * @param {string} attrName 
     * @param {*} attrValue 
     */
    function setDIAttr(o, attrName, attrValue) {
        if (o && attrName != null) {
            o[DI_ATTR_PREFIX + attrName] = attrValue;
        }
    }

    /**
     * di
     * 
     * @private
     * @param {Object} o ins
     * @param {string} attrName 
     * @param {bolean} notProto prototypefalse
     * @return {*} attrValue 
     */
    function getDIAttr(o, attrName, notProto) {
        if (o && attrName != null) {
            var name = DI_ATTR_PREFIX + attrName;
            return (!notProto || o.hasOwnProperty(name)) ? o[name] : null;
        }
        return null;
    }

    /**
     * 
     *
     * @param {Object} di
     * @param {string} attrName
     * @param {*=} makeValue {}
     * @private
     */
    function getMakeAttr(ins, attrName, makeValue) {
        if (makeValue === UNDEFINED) {
            makeValue = {};
        }
        var value = getDIAttr(ins, attrName);
        if (value === UNDEFINED) {
            setDIAttr(ins, attrName, value = makeValue);
        }
        return value;
    }

    /**
     * diglobal
     * new
     * 
     * @private
     * @param {Object} o 
     * @param {string} attrName 
     * @return {*} attrValue 
     */
    function getAttrIncludeGlobal(o, attrName) {
        var ret = getDIAttr(o, attrName);
        if (ret == null) {
            ret = (getGlobalTemp('DI_DEF_FOR_NEW') || {})[attrName];
        }
        return ret;
    }

    /**
     * 
     *
     * @public
     * @param {Object} ec  
     */
    function setEventChannel(ec) {
        eventChannel = ec;
    }

    /**
     * 
     *
     * @public
     * @param {Object}  
     */
    function getEventChannel() {
        return eventChannel;
    }

    /**
     * 
     * 
     * 
     * 
     * @public
     * @param {string} key 
     * @param {*} data
     */
    function setGlobalTemp(key, data) {
        globalTempData[key] = data;
    }

    /**
     * 
     * 
     * 
     * 
     * @public
     * @param {string} key 
     * @return {*} data
     */
    function getGlobalTemp(key) {
        return globalTempData[key];
    }

    /**
     * refPathkey
     *
     * @private
     */
    function makePathKey(refPath) {
        return refPath.replace(/[\]\s]/g, '').replace(/\[/g, '.');
    }

    /**
     * 
     *
     * @private
     */
    function registerEventAgent(obj, eventName) {
        var agent = obj[DI_EVENT_AGENT_TAG];
        if (!agent) {
            agent = obj[DI_EVENT_AGENT_TAG] = new XOBJECT();
            agent.eventNameMap = {};
        }
        if (eventName != null) {
            agent.eventNameMap[eventName] = 1;
        }
        else {
            agent.eventNameAll = 1;
        }
    }

    /**
     * 
     *
     * @private
     */
    function getEventAgentByName(obj, eventName) {
        var agent = obj[DI_EVENT_AGENT_TAG];
        if (agent 
            && (
                agent.eventNameAll
                || agent.eventNameMap[eventName]
            )
        ) {
            return agent;
        }
    }

    // @deprecated
    // 
    function rootSnippet(id) {
        if (!id && !rootSnippet) {
            return null;
        }
        id && (rootSnippet = id) || (id = rootSnippet);
        var def = getEntity(id, 'DEF');
        return def;
    }

    /*
    function makeViewDisableFunc(disDef, actName, key) {
        if (!disDef) { return null; }

        var repCmpt = repository['COMPONENT'];
        var repCtnr = repository['VCONTAINER'];

        if (disDef == 'ALL') {
            disDef = [];
            for (id in repCmpt) { disDef.push(id); }
            for (id in repCtnr) { disDef.push(id); }
        }

        return function () {
            for (var i = 0, ins, id; i < disDef.length; i ++) {
                id = disDef[i];
                ins = repCmpt[id] || repCtnr[id];
                ins && ins.$di(actName, key);
            }
        }
    }*/

    function setFuncAuth(auth) {
        if (!auth) {
            return;
        }
        funcAuthKeys = {};
        for (var i = 0; i < (auth || []).length; i ++) {
            funcAuthKeys[auth[i]] = 1;
        }
    }

    function doViewDisable(disDef, actName, key) {
        if (!disDef) { return null; }

        var repCmpt = repository['COMPONENT'];
        var repCtnr = repository['VCONTAINER'];

        if (disDef == 'ALL') {
            disDef = [];
            for (id in repCmpt) { disDef.push(id); }
            for (id in repCtnr) { disDef.push(id); }
        }

        for (var i = 0, ins, id; i < disDef.length; i ++) {
            id = disDef[i];
            ins = repCmpt[id] || repCtnr[id];
            ins && ins.$di(actName, key);
        }
    }

    function setInteractMemo(ins, attr, value) {
        var memo = getDIAttr(ins, 'interactMemo');
        if (!memo) {
            setDIAttr(ins, 'interactMemo', memo = {});
        }
        if (value !== UNDEFINED) {
            memo[attr] = value;
        }
        else {
            delete memo[attr];
        }
    }

    function getInteractMemo(ins, attr) {
        var memo = getDIAttr(ins, 'interactMemo');
        return memo ? memo[attr] : UNDEFINED;
    }

    /**
     * clone
     * clone
     *
     * @private
     * @param {*} args
     * @return {*} clone
     */
    function argsClone(args) {
        var result;
        var i;
        var len;
        var objStr = objProtoToString.call(args);
        var isArr;

        if (objStr == '[object Date]') {
            result = new Date(args.getTime());
        }
        else if (
            objStr == '[object Function]' 
            || objStr == '[object RegExp]'
        ) {
            result = args;
        }
        else if (
            // arraykey
            (isArr = objStr == '[object Array]')
            // Objectobject
            // 
            || args === Object(args)
        ) {
            result = isArr ? [] : {};
            !isArr && checkObjectClonable(args);
            for (i in args) {
                if (args.hasOwnProperty(i)) {
                    result[i] = argsClone(args[i]);
                }
            }
        } 
        else {
            result = args;
        }
        return result;
    }

    /**
     * 
     * 
     */
    function checkObjectClonable(obj) {
        var clonable = true;

        // DOM
        if (Object.prototype.toString.call(obj) != '[object Object]'
            // IEDOMtrue
            // isPrototypeOf
            || !('isPrototypeOf' in obj)) {
            clonable = false;
        }

        // new somefunc()
        if (// constructor
            obj.constructor
            // constructor
            && !hasOwnProperty.call(obj, 'constructor') 
            // isPrototypeOfconstructorObject
            && !hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')
        ) {
            clonable = false;
        }

        if (!clonable) {
            throw new Error('Object can not be clone: ' + obj);
        }
    };    

})();
/**
 * di.shared.ui.InteractEntity
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    Base Entity
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var assign = xutil.object.assign;
    var addClass = xutil.dom.addClass;
    var isObject = xutil.lang.isObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var XOBJECT = xui.XObject;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var alert;
    
    $link(function () {
        alert = di.helper.Dialog.alert;
    });    

    /**
     * Base Entity
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 
     * @param {Function=} options.commonParamGetter 
     *           
     */
    var INTERACT_ENTITY = $namespace().InteractEntity = 
        inheritsObject(
            XOBJECT,
            function (options) {

                // di
                this.$di('start', options);

                // 
                this.$di('registerEventAgent');

                // notifyattach$di
                this.notify = this.attach = this.attachOnce =                 
                    function () {
                        throw new Error('Forbiden function');
                    };

                // cssClass
                var el = this.$di('getEl');
                var className = this.DEF.className;
                el && className && addClass(el, className);

                // DEFmodel
                this.$createModelByDef(options);

                // view
                this.$createView && this.$createView(options);
            }
        );
    var INTERACT_ENTITY_CLASS = INTERACT_ENTITY.prototype;
    
    /**
     * 
     */
    INTERACT_ENTITY_CLASS.DEF = {};

    /**
     * model
     *
     * @private
     */
    INTERACT_ENTITY_CLASS.$createModelByDef = function (options) {
        var modelDef = this.DEF.model;
        if (!modelDef) { return; }

        var clz = modelDef.clz 
            || (modelDef.clzPath && getByPath(modelDef.clzPath));
        if (!clz) { return; }

        // model
        this._mModel = new clz(
            assign(
                {
                    commonParamGetter: this.$di('getCommonParamGetter'),
                    diFactory: this.$di('getDIFactory')
                },
                this.$createModelInitOpt(options)
            )
        );

        //    
        this._mModel.ajaxOptions = {
            defaultFailureHandler:
                bind(this.$defaultFailureHandler, this)
        };
    };

    /**
     * model
     * 
     *
     * @protected
     * @return {Object} 
     */
    INTERACT_ENTITY_CLASS.$createModelInitOpt = function (options) {
        return {};
    };

    /**
     * model
     *
     * @public
     * @return {Object} model
     */
    INTERACT_ENTITY_CLASS.getModel = function () {
        return this._mModel;
    };

    /**
     * model sync
     *
     * @protected
     * @param {Object} model
     * @param {string} datasourceId
     * @param {Object} param
     * @param {Object} diEvent
     * @param {Object} opt
     * @param {Object} ajaxOptions
     */
    INTERACT_ENTITY_CLASS.$sync = function (
        model, datasourceId, param, diEvent, opt, ajaxOptions
    ) {
        var o = {
            datasourceId: datasourceId,
            args: {
                param: param,
                diEvent: diEvent
            }
        }
        assign(o.args, opt);
        // syncajaxOptionsajax
        assign(o, ajaxOptions);
        return model.sync(o);
    };

    /**
     * dievent
     * $diEvent(options) 
     *      optionsdiEventundefined 
     * $diEvent('someEventName', options) 
     *      'someEventName'diEvent
     *      diEventeventnName
     *
     * @protected
     * @param {(string|Object)} eventName options
     * @param {string=} options xdatasourceoptionsdiEvent
     */
    INTERACT_ENTITY_CLASS.$diEvent = function (eventName, options) {
        if (arguments.length == 1 && isObject(eventName)) {
            options = eventName;
            eventName = null;
        }

        var diEvent = options.args.diEvent;
        return eventName
            ? (diEvent ? diEvent(eventName) : eventName)
            : diEvent;
    };

    /**
     * sync
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$syncEnable = function (datasourceId) {
        this.$di('syncViewDisable', 'enable', datasourceId);
        this.$di('enable', 'DI_SELF_' + datasourceId);
    };

    /**
     * sync
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$syncDisable = function (datasourceId) {
        this.$di('syncViewDisable', 'disable', datasourceId);
        this.$di('disable', 'DI_SELF_' + datasourceId);
    };

    /**
     * 
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$defaultFailureHandler = function (status, ejsonObj) {
        var eventChanel = this.$di('getEventChannel');

        switch (status) {
            case AJAX.ERROR_SESSION_TIMEOUT: // session 
                eventChanel.triggerEvent('sessiontimeout');
                alert(LANG.SAD_FACE + LANG.RE_LOGIN, null, true);
                break;
            case AJAX.ERROR_PARAM: // olap
                break;
            default:
                alert(LANG.SAD_FACE + LANG.ERROR);
        }
    };

})();
/**
 * ecui.ui.PanelPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.ui');

(function() {

    var inheritsObject = xutil.object.inheritsObject;
    var arraySlice = Array.prototype.slice;
    var addClass = xutil.dom.addClass;
    var UI_CONTROL = ecui.ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var XVIEW = xui.XView;

    var PANEL_PAGE = $namespace().PanelPage = 
        inheritsObject(
            XVIEW,
            function(options) {
                addClass(options.el, 'panel-page');
                this._bVisible = true;
                this._aPendingUpdater = [];
                this._sPageId = options.pageId;
                this._sFromPageId = options.fromPageId;
                this._sPageTitle = options.pageTitle;
            }
        );
    var PANEL_PAGE_CLASS = PANEL_PAGE.prototype;
    
    /**
     * 
     * @override
     * @private
     */
    PANEL_PAGE_CLASS.dispose = function() {
        this._aPendingUpdater = [];
        PANEL_PAGE.superClass.dispose.call(this);
    };

    /**
     * page
     * page
     *ajax
     * dompage
     * 
     * 
     * active
     * 
     * @public
     * @param {!Function} updater 
     * @param {Object=} scope updaterscopewindow
     * @param {...*} args updater
     */
    PANEL_PAGE_CLASS.updateView = function(updater, scope, args) {
        if (this._bVisible) {
            updater.apply(scope, arraySlice.call(arguments, 2));
        }
        else {
            this._aPendingUpdater.push(
                {
                    updater: updater,
                    scope: scope,
                    args: arraySlice.call(arguments, 2)
                }
            );
        }
    };

    /**
     * pageId
     *
     * @public
     * @return {string} pageId
     */
    PANEL_PAGE_CLASS.getPageId = function() {
        return this._sPageId;
    };
    
    /**
     * pageTitle
     *
     * @public
     * @return {string} pageTitle
     */
    PANEL_PAGE_CLASS.getPageTitle = function() {
        return this._sPageTitle;
    };
    
    /**
     * pageId
     *
     * @public
     * @return {string} fromPageId
     */
    PANEL_PAGE_CLASS.getFromPageId = function() {
        return this._sFromPageId;
    };
    
    /**
     * pageId
     *
     * @public
     * @param {string} fromPageId
     */
    PANEL_PAGE_CLASS.setFromPageId = function(fromPageId) {
        this._sFromPageId = fromPageId;
    };
    
    /**
     * PanelPageManager
     *
     * @public
     */
    PANEL_PAGE_CLASS.active = function(options) {
        this._bVisible = true;

        // panding
        var updaterWrap;
        while(updaterWrap = this._aPendingUpdater.shift()) {
            updaterWrap.updater.apply(updaterWrap.scope, updaterWrap.args);
        }

        this.$active(options || {});
    };

    /**
     * PanelPageManager
     *
     * @public
     */
    PANEL_PAGE_CLASS.inactive = function(options) {
        this._bVisible = false;
        this.$inactive(options);
    };

    /**
     * active
     *
     * @public
     */
    PANEL_PAGE_CLASS.isActive = function() {
        return this._bVisible;
    };

    /**
     * 
     *
     * @protected
     * @abstract
     */
    PANEL_PAGE_CLASS.$active = function() {};
    
    /**
     * 
     *
     * @protected
     * @abstract
     */
    PANEL_PAGE_CLASS.$inactive = function() {};

})();

/**
 * di.shared.adapter.BeakerChartVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    BeakerChart
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var extend = xutil.object.extend;
    var ecuiCreate = di.helper.Util.ecuiCreate;
    var formatNumber = xutil.number.formatNumber;
    var UI_BEAKER_CHART;
    var UI_BEAKER_CHART_CLASS;

    $link(function () {
        UI_BEAKER_CHART = ecui.ui.BeakerChart;
        UI_BEAKER_CHART_CLASS = UI_BEAKER_CHART.prototype;
    });

    /**
     * BeakerChart
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().BeakerChartVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData
        };
    };

    /**
     * 
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @return {Object} 
     */
    function create(def, options) {
        // ecui
        return ecuiCreate(
            UI_BEAKER_CHART,
            def.el,
            null,
            options
        );
    }

    /**
     * 
     * 
     * 
     *
     * @public
     * @this {Object} 
     * @param {Object} data 
     */
    function setData(data) {
        var series = data.series || [];
        var datasource = {};
        var beakerA = datasource.beakerA = { water: [] };
        var beakerB = datasource.beakerB = { water: [] };
        var o;

        for (var i = 3; o = series[i]; i ++) {
            beakerA.water.push(
                {
                    text: o.name,
                    value: o.data[0]
                }
            );
        }

        if (o = series[2]) {
            beakerA.mark = {
                text: o.name,
                value: o.data[0]
            };
        }

        if (o = series[1]) {
            beakerB.water.push(
                {
                    text: o.name,
                    value: o.data[0]
                }
            );
        }

        if (o = series[0]) {
            datasource.theRate = {
                text: o.name,
                value: o.data[0] != null
                    ? formatNumber(
                        o.data[0], 'I,III.DD%', void 0, void 0, true
                    )
                    : '-'
            };
        }
        
        datasource.title = data.xAxis[0].data[0];

        var o = {
            width: data.width,
            heigth: data.height,
            datasource: datasource
        }

        return UI_BEAKER_CHART_CLASS.setData.call(this, o);
    }

})();


/**
 * di.shared.adapter.CalendarPlusVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    CalendarPlus
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;
    var ecuiDispose = UTIL.ecuiDispose;
    var detachEvent = ecui.util.detachEvent;
    var attachEvent = ecui.util.attachEvent;
    var disposeControl = ecui.dispose;
    var repaint = ecui.repaint;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var formatTime = UTIL.formatTime;
    var CALENDAR_PLUS;
    var GLOBAL_MODEL;

    $link(function() {
        CALENDAR_PLUS = ecui.ui.CalendarPlus;
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * CalendarPlus
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().CalendarPlusVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @param {Object} options.granularities 
     *      'D', 'W', 'M', 'Q', 'Y'
     *          
     *          options.start 2012-12-12-5d
     *          options.end 
     * @return {Object} 
     */
    function create(def, options) {
        return ecuiCreate(CALENDAR_PLUS, def.el, null, prepareData(options));
    }

    /**
     * 
     *
     * @public
     */
    function setData(data) {
        this.setData(prepareData(data));
        // detachEvent(window, 'resize', repaint);

        // var disposeFunc = this.$dispose;
        // this.$dispose = new Function();
        // disposeControl(this);
        // this.$dispose = disposeFunc;

        // var el = this.getOuter();
        // el.innerHTML = '';
        // this.$setBody(el);
        // this.$resize();
        // CALENDAR_PLUS.client.call(this, el, prepareData(data));
        // this._bCreated = false;
        // this.cache(true, true);
        // this.init();

        // attachEvent(window, 'resize', repaint);
    }

    /**
     * 
     *
     * @private
     */
    function prepareData(options) {
        var now = GLOBAL_MODEL().getDateModel().now();

        var defUnit = {
                defaultTime: ['0d'],
                range: ['-1Y', '0d']
            };
        var granularities = options.granularities
            // granularity
            || { D: defUnit, W: defUnit, M: defUnit, Q: defUnit };

        var opt = {
            types: [],
            range: {},
            defaults: {}
        };

        var timeMap = {
            D: 'day', W: 'week', M: 'month', Q: 'quarter', Y: 'year'
        };

        var range;
        for (var gran in granularities) {
            opt.types.push(gran);

            range = granularities[gran];
            
            opt.defaults[timeMap[gran]] = formatObjTime(
                parseTimeUnitDef(range.defaultTime, [now, now]),
                gran
            ).start;
            opt.range[timeMap[gran]] = formatObjTime(
                parseTimeUnitDef(range.range, [now, now]) || {},
                gran
            );
        }

        return opt;
    }

    /**
     * 
     * 
     * @private
     */    
    function formatObjTime(obj, granularity) {
        for (var key in obj) {
            obj[key] = formatTime(obj[key], granularity);
        }
        return obj;
    }

    /**
     * 
     *
     * @public
     * @this {Object} 
     * @return {Object} 
     */
    function getValue() {
        var wrap = this.getDate();
        return {
            start: wrap.date,
            end: wrap.date,
            granularity: wrap.type
        };
    }

})();


/**
 * di.shared.adapter.EcuiCustomTableVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {

    var LANG = di.config.Lang;
    var assign = xutil.object.assign;
    
    /**
     * ecui
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().EcuiCustomTableVUIAdapter = function(def, options) {
        return {
            setData: setData//,
            // getValue: getValue
        };
    };

    /**
     * 
     *
     * @public
     */
    function setData(data) {
        var head = data.tableData.head || [];
        var tdata = data.tableData.data || [];
        var sortInfo = {};
        var i;
        var o;

        for (i = 0; o = head[i]; i ++) {
            if (o.orderby) {
                o.sortable = true;
                if (o.orderby == 'ASC' || o.orderby == 'DESC') {
                    sortInfo.sortby = o.field;
                    sortInfo.orderby = o.orderby.toLowerCase();
                }
            }
        }

        var options = assign({}, data, ['leftLock', 'rightLock', 'errorMsg']);
        var emptyText = LANG.EMPTY_TEXT;
        if(data.exception && data.exception != ''){
            emptyText = LANG.QUERY_ERROR_TEXT;
        }
        this.render(
            head, tdata, sortInfo, options, emptyText
        );
    }

    // /**
    //  * 
    //  */
    // function getValue() {
    //     // TODO
    // }

})();


/**
 * di.shared.adapter.EcuiInputTreeVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui input-tree
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {

    var ecuiCreate = di.helper.Util.ecuiCreate;
    var dateToString = xutil.date.dateToString;
    var isArray = xutil.lang.isArray;
    var DICT = di.config.Dict;

    /**
     * ecui input tree
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().EcuiInputTreeVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @return {Object} 
     */
    function create(def, options) {
        // 
        options.hideCancel = true;
        options.asyn = true;

        var ctrl = ecuiCreate(def.clz, def.el, null, options);

        ctrl.$di('registerEventAgent', 'async');

        // 
        ctrl.onloadtree = function (value, func) {
            /**
             * 
             *
             * @event
             */
            ctrl.$di(
                'dispatchEvent',
                'async',
                [
                    value,
                    function (data) {
                        func((data.datasource || {}).children || []);
                    }
                ]
            );
        }

        // iddom
        ctrl._uLayer.getOuter().setAttribute(DICT.TEST_ATTR, def.id);

        return ctrl;
    }

    /**
     * 
     * 
     * @public
     * @param {Object} data 
     */
    function setData(data) {
        if (!data) {
            return;
        }

        this.setData(
            { 
                root: data.datasource,
                selected: isArray(data.value) 
                    ? data.value[0] 
                    : (data.value || (data.datasource || {}).value)
            }, 
            { 
                hideCancel: data.hideCancel == null 
                    ? true : data.hideCancel, 
                asyn: data.asyn == null 
                    ? true : data.asyn
            }
        );
    }

    /**
     * 
     *
     * @public
     * @this {Object} 
     * @return {Object} 
     */
    function getValue() {
        var v = this.getValue();
        return v ? [v.value] : [];
    }

})();


/**
 * di.shared.adapter.EcuiInputVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    inputtextarea
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;

    /**
     * inputtextarea
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().EcuiInputVUIAdapter = function(def, options) {
        return {
            // getValue: getValue
        };
    };

})();


/**
 * di.shared.adapter.EcuiPagerVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecuiPager
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    /**
     * ecuiPager
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().EcuiPagerVUIAdapter = function(def, options) {
        return {
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 
     *
     * @public
     */
    function setData(data) {
        this.render(
            data.currentPage,
            data.totalRecordCount,
            String(data.pageSize)
        );
    }

    /**
     * 
     */
    function getValue() {
        // TODO
    }

})();


/**
 * di.shared.adapter.EcuiSelectVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    IstCalendar
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var DICT = di.config.Dict;
    var isArray = xutil.lang.isArray;

    /**
     * ecui Select
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().EcuiSelectVUIAdapter = function (def, options) {
        return {
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 
     * 
     * @public
     * @param {Object} data 
     * @param {Array.<Object>} data.datasource 
     *      
     *          {string} text
     *          {string} value
     * @param {Array.<string>} data.value 
     */
    function setData (data) {
        data = data || {};
        var datasource = data.datasource || [];
            
        // 
        this.setValue(
            getType.call(this) == 'ui-multi-select' ? [] : null
        );
        while(this.remove(0)) {}

        // 
        for (var i = 0, o; o = datasource[i]; i++) {
            var txt = String(o.text != null ? o.text : '');
            this.add(
                txt, 
                null,
                { value: o.value, prompt: txt }
            );
        }

        // 
        var value = data.value;
        value = (
                getType.call(this) == 'ui-multi-select'
                    ? value
                    : (value && value[0])
            )
            || (datasource[0] && datasource[0].value);
        value != null && this.setValue(value);
    }

    /**
     * 
     *
     * @public
     * @this {Object} 
     * @return {Object} 
     */
    function getValue() {
        var v;
        var type = getType.call(this);
        if (type == 'ui-select') {
            var sel = this.getSelected();
            v = sel ? sel.getValue() : null;
        }
        else {
            v = this.getValue();
        }
        return v == null 
            ? [] 
            : isArray(v) 
                ? v
                : [v];
    }

    function getType() {
        return this.getTypes().join(' ').indexOf('ui-multi-select') >= 0
            ? 'ui-multi-select'
            : 'ui-select';
    }

})();


/**
 * di.shared.adapter.EcuiSuggestVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui suggest
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var extend = xutil.object.extend;
    var ecuiCreate = di.helper.Util.ecuiCreate;

    /**
     * ecui suggest
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @param {string} options.valueType 
     *      'TEXT'getValuetext
     *      'VALUE'getValuevalue
     * @return {Object} vui adapter
     */
    $namespace().EcuiSuggestVUIAdapter = function(def, options) {
        return {
            create: create,
            getValue: getValueFunc[options.valueType || 'TEXT']
        };
    };

    /**
     * 
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @return {Object} 
     */
    function create(def, options) {
        var ctrl = ecuiCreate(def.clz, def.el, null, options);


        ctrl.$di('registerEventAgent', 'async');
        
        // 
        ctrl.onquery = function (value) {
            /**
             * 
             *
             * @event
             */
            ctrl.$di(
                'dispatchEvent',
                'async',
                [
                    (value || {}).text,
                    function (data) {
                        ctrl.update(data.datasource || []);
                    }
                ]
            );
        }

        return ctrl;
    }    

    /**
     * 
     *
     * @public
     * @this {Object} 
     * @return {string} 
     */
    var getValueFunc = {
        TEXT: function () {
            return (this.getValue() || {}).text || '';
        },
        VALUE: function () {
            return (this.getValue() || {}).value || '';
        }
    }

})();


/**
 * di.shared.adapter.HChartVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    HChart
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var formatTime = UTIL.formatTime;
    var dateToString = xutil.date.dateToString;
    var GLOBAL_MODEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * IstCalendar
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().HChartVUIAdapter = function(def, options) {
        return {
            setData: setData
        };
    };

    /**
     * 
     *
     * @public
     */
    function setData(data) {
        var now = GLOBAL_MODEL().getDateModel().now();

        if (data.weekViewRange) {
            var range = parseTimeUnitDef(data.weekViewRange, [now, now]);

            if (range) {
                var fmt = 'yyyy-MM-dd';
                range[0] = range.start ? dateToString(range.start, fmt) : null;
                range[1] = range.end ? dateToString(range.end, fmt) : null;

                for (
                    var i = 0, xAxisDef; 
                    xAxisDef = (data.xAxis || [])[i]; 
                    i ++
                ) {
                    xAxisDef.range = range;
                }
            }
        }

        this.setData(data);
    }

})();


/**
 * di.shared.adapter.IstCalendarVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    IstCalendar
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;
    var dateToString = xutil.date.dateToString;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var assign = xutil.object.assign;
    var GLOBAL_MODEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * IstCalendar
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().IstCalendarVUIAdapter = function(def, options) {
        return {
            create: create,
            getValue: getValue
        };
    };

    /**
     * 
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @param {string} options.start 
     *                      2012-12-12
     *                      -5d
     * @param {string} options.end rangeend
     * @param {string} options.range start-4d
     * @param {string} options.defaultTime 
     * @return {Object} 
     */
    function create(def, options) {
        var now = GLOBAL_MODEL().getDateModel().now();

        var opt = {};

        opt.now = now.getTime();

        var defTime = parseTimeUnitDef(options.defaultTime, [now, now]) || {};
        opt.date = defTime.start || new Date();
        opt.dateEnd = defTime.end;

        var range = parseTimeUnitDef(options.range, [now, now]);
        if (range) {
            opt.start = range.start;
            opt.end = range.end;
        }

        // 
        assign(opt, options, ['mode', 'viewMode', 'shiftBtnDisabled']);

        return ecuiCreate(def.clz, def.el, null, opt);
    }

    /**
     * 
     *
     * @public
     * @this {Object} 
     * @return {Object} 
     */
    function getValue() {
        var start = dateToString(this.getDate());

        if (this.getMode() == 'RANGE') {
            return {
                start: start,
                end: dateToString(this.getDateEnd())
            };
        }
        else {
            return {
                start: start,
                end: start
            }
        }
    }

})();


/**
 * di.shared.adapter.MetaConfigVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function () {

    var dateToString = xutil.date.dateToString;
    var isArray = xutil.lang.isArray;
    var DICT = di.config.Dict;
    var markParamMode;

    $link(function () {
        markParamMode = di.shared.model.CommonParamFactory.markParamMode;
    });

    /**
     * 
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().MetaConfigVUIAdapter = function (def, options) {
        var clzKey = def.clzKey;

        return {
            create: CREATE_METHOD[clzKey],
            setData: SET_DATA_METHOD[clzKey],
            updateData: UPDATE_DATA_METHOD[clzKey],
            getValue: GET_VALUE_METHOD[clzKey]
        };
    };

    /**
     * 
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @param {string} options.start 
     *                      2012-12-12
     *                      -5d
     * @param {string} options.end rangeend
     * @param {string} options.range start-4d
     * @param {string} options.defaultTime 
     * @return {Object} 
     */
    var CREATE_METHOD = {
        OLAP_META_DRAGGER: create4Dragger,
        OLAP_META_IND_SELECT: create4Select,
        OLAP_META_IND_MULTI_SELECT: create4Select
    };

    function create4Dragger(def, options) {
        var ins = new def.clz(options)            
        ins.$di('registerEventAgent', 'change');

        ins.attach(
            'sellinechange', 
            function (wrap) {
                ins.$di('dispatchEvent', 'change', [wrap]);
            }
        );
        ins.attach(
            'selitemchange', 
            function (wrap) {
                ins.$di('dispatchEvent', 'change', [wrap]);
            }
        );
        return ins;
    }

    function create4Select(def, options) {
        var ins = new def.clz(options);
        ins.$di('registerEventAgent', 'change');

        ins.attach(
            'change', 
            function (wrap) {
                // JSON
                markParamMode(wrap, 'JSON');
                ins.$di('dispatchEvent', 'change', [wrap]);
            }
        );
        return ins;
    }

    /**
     * 
     * 
     * @public
     * @param {Object} data 
     */
    var SET_DATA_METHOD = {
        OLAP_META_DRAGGER: setDataMethod,
        OLAP_META_IND_SELECT: setDataMethod,
        OLAP_META_IND_MULTI_SELECT: setDataMethod
    };

    function setDataMethod(data) {
        this.setData(data);
    }

    /**
     * 
     *
     * @public
     * @this {Object} 
     * @return {Object} 
     */
    var UPDATE_DATA_METHOD = {
        OLAP_META_DRAGGER: function (data) {
            this.refreshStatus(data);
        },
        OLAP_META_IND_SELECT: function (data) {
            // do nothing
        },
        OLAP_META_IND_MULTI_SELECT: function (data) {
            // do nothing
        }
    };

    /**
     * 
     *
     * @public
     * @this {Object} 
     * @return {Object} 
     */
    var GET_VALUE_METHOD = {
        OLAP_META_DRAGGER: function (data) {
            return this.getValue();
        },
        OLAP_META_IND_SELECT: function (data) {
            var val = this.getValue();
            markParamMode(val, 'JSON');
            return val;
        },
        OLAP_META_IND_MULTI_SELECT: function (data) {
            var val = this.getValue();
            markParamMode(val, 'JSON');
            return val;
        }
    };

})();


/**
 * di.shared.adapter.XCalendarVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    CalendarPlus
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;
    var ecuiDispose = UTIL.ecuiDispose;
    var detachEvent = ecui.util.detachEvent;
    var attachEvent = ecui.util.attachEvent;
    var disposeControl = ecui.dispose;
    var repaint = ecui.repaint;
    var parseTimeDef = UTIL.parseTimeDef;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var formatTime = UTIL.formatTime;
    var assign = xutil.object.assign;
    var clone = xutil.object.clone;
    var X_CALENDAR;
    var GLOBAL_MODEL;

    $link(function() {
        X_CALENDAR = ecui.ui.XCalendar;
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * XCalendar
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options vui
     * @return {Object} vui adapter
     */
    $namespace().XCalendarVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 
     *
     * @public
     * @param {Object} def vui
     * @param {Object} options 
     * @param {Object} options.granularities 
     *      'D', 'W', 'M', 'Q', 'Y'
     *          
     *          options.start 2012-12-12-5d
     *          options.end 
     * @return {Object} 
     */
    function create(def, options) {
        return ecuiCreate(X_CALENDAR, def.el, null, prepareInitData(options));
    }

    /**
     * 
     *
     * @public
     */
    function setData(data) {
        this.setDatasource(prepareSetData(data));
    }

    /**
     * 
     *
     * @private
     */
    function prepareInitData(options) {
        var opt = assign(
            {}, 
            options, 
            [   
                'viewMode', 
                'headText', 
                'rangeLinkStr', 
                'weekLinkStr', 
                'blankText', 
                'forbidEmpty'
            ]
        );
        opt.timeTypeList = [];
        return opt;
    }

    /**
     * 
     *
     * @private
     */
    function prepareSetData(options) {
        var now = GLOBAL_MODEL().getDateModel().now();
        var opt = clone(options);
        var timeTypeOpt = options.timeTypeOpt;
        var timeType;
        var o;
        var i;
        var dArr;
        var unit;
        var offsetBase;
        opt.timeTypeOpt = opt.timeTypeOpt || {};

        for (timeType in timeTypeOpt) {
            o = opt.timeTypeOpt[timeType] = timeTypeOpt[timeType];
            dArr = parseTimeDef(o.date, [now, now]);

            // FIXME
            // start
            // [[-1D], [-4D], ...]  [[-5D, -1D], [-9W, -6D], ...]
            if (dArr.length > 1) {
                o.date = [];
                for (i = 0; unit = dArr[i]; i ++) {
                    o.date.push(formatObjTime(unit, timeType).start);
                }
            }
            else {
                unit = formatObjTime(dArr[0],timeType);
                o.date = unit.end ? [unit.start, unit.end] : [unit.start];
            }
            o.range = formatObjTime(
                parseTimeUnitDef(o.range, [now, now]) || {},
                timeType
            );
            o.range.offsetBase = now;
        }

        return opt;
    }

    /**
     * 
     * 
     * @private
     */    
    function formatObjTime(obj, timeType) {
        for (var key in obj) {
            obj[key] = formatTime(obj[key], timeType);
        }
        return obj;
    }

    /**
     * 
     *
     * @public
     * @this {Object} 
     * @return {Object} 
     */
    function getValue() {
        // TODO
        // 
        var aDate = this.getValue();
        var timeType = this.getTimeType();
        return {
            start: formatTime(aDate[0], timeType),
            end: formatTime(aDate[1] || aDate[0], timeType),
            granularity: timeType
        };
    }

})();


/**
 * di.shared.model.CubeMetaModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    cubeModel
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var getUID = xutil.uid.getUID;
    var parse = baidu.json.parse;
    var stringify = baidu.json.stringify;
    var hasValue = xutil.lang.hasValue;
    var clone = xutil.object.clone;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var travelTree = xutil.collection.travelTree;
    var XDATASOURCE = xui.XDatasource;
    var GLOBAL_MODEL;

    $link(function () {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * cubeModel
     *
     * @class
     * @extends xui.XDatasource
     */
    var CUBE_META_MODEL = 
            $namespace().CubeMetaModel = 
            inheritsObject(XDATASOURCE, constructor);
    var CUBE_META_MODEL_CLASS = 
            CUBE_META_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     */
    function constructor(options) {
        this._sReportType = options.reportType;
    }

    /**
     * @override
     */
    CUBE_META_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CUBE_META_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            CUBE_INIT: URL.fn('CUBE_META'),
            DATASOURCE_INIT: URL.fn('DATASOURCE_META')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CUBE_META_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            // CUBE_INIT: function () {
            // },
            DATASOURCE_INIT: function () {
                return 'bizKey=' + textParam(GLOBAL_MODEL().getBizKey());
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CUBE_META_MODEL_CLASS.result = new XDATASOURCE.Set(
        {
            CUBE_INIT: function(data) {
                this._aCubeForest = data['cubeTree'];
            },
            DATASOURCE_INIT: function (data) {
                this._aDatasourceList = data['datasourceList']; 
            }
        }
    );

    /**
     * @public
     */
    CUBE_META_MODEL_CLASS.setReportType = function(reportType) {
        this._sReportType = reportType;
    };

    /**
     * cubemenu
     *
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    CUBE_META_MODEL_CLASS.getMenuData = function() {
        var menuTree = { menuList: [] };
        var selMenuId;
        var reportType = this._sReportType;

        ({
            RTPL_OLAP_TABLE: cubeMenu,
            RTPL_OLAP_CHART: cubeMenu,
            RTPL_PLANE_TABLE: datasourceMenu
        })[reportType].call(this);

        return { menuTree: menuTree };

        // cubemenu
        function cubeMenu() {
            menuTree.menuList.push({ text: 'CUBE', value: 1 });

            for (var i = 0, root; root = this._aCubeForest[i]; i ++) {
                var schemaName = root['schemaName'];
                travelTree(
                    root = clone(root['root']),
                    function(node, options) {
                        node.value = node.nodeName;
                        node.text = node.caption || ' - ';
                        if (node.children) {
                            return;
                        }
                        if (reportType == 'RTPL_OLAP_TABLE') {
                            node.url = 'di.console.editor.ui.OLAPEditor?'
                                + [
                                    'editorType=' + reportType,
                                    'reportType=' + reportType,
                                    'pageId=' + reportType + '_' + node.value + getUID(),
                                    'pageTitle=[] ' + node.text,
                                    'schemaName=' + schemaName,
                                    'cubeTreeNodeName=' + node.nodeName
                                ].join('&')
                        }
                        else if (reportType == 'RTPL_OLAP_CHART') {
                            node.url = 'di.console.editor.ui.OLAPEditor?'
                                + [
                                    'editorType=' + reportType,
                                    'reportType=' + reportType,
                                    'pageId=' + reportType + '_' + node.value + getUID(),
                                    'pageTitle=[] ' + reportType + '_' + node.text,
                                    'schemaName=' + schemaName,
                                    'cubeTreeNodeName=' + node.nodeName
                                ].join('&')
                        }
                    },
                    'children'
                );
                menuTree.menuList.push(root);
            }
            menuTree.selMenuId = 1;
        }

        // plane tabledatasourcemenu
        function datasourceMenu() {
            var chs = [];
            menuTree.menuList.push({ text: '', value: 1, children: chs });

            for (var i = 0, item; item = this._aDatasourceList[i]; i ++) {
                chs.push(
                    {
                        text: item.text,
                        value: item.value,
                        url: 'di.console.editor.ui.PlaneEditor?'
                            + [
                                'editorType=' + reportType,
                                'reportType=' + reportType,
                                'pageId=' + reportType + '_' + item.value + getUID(),
                                'pageTitle=[] ' + reportType + '_' + item.text,
                                'datasourceName=' + item.value
                            ].join('&')
                    }
                );
            }            
        }
    };

    /**
     * cubemenu
     *
     * @deprecate
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    // CUBE_META_MODEL_CLASS.getFullMenuByCubeMeta = function() {
    //     var menuTree = { menuList: [] };
    //     var selMenuId;

    //     menuTree.menuList.push(
    //         {
    //             text: '',
    //             value: 1
    //         }
    //     );

    //     for (
    //         var i = 0, root, schemaName; 
    //         root = this._aCubeForest[i]; 
    //         i ++
    //     ) {
    //         schemaName = root['schemaName'];
    //         travelTree(
    //             root = clone(root['root']),
    //             function(node, options) {

    //                 node.value = node.nodeName;
    //                 node.text = node.caption || ' - ';
    //                 node.floatTree = [
    //                     {
    //                         text: node.caption,
    //                         value: String(Math.random()),
    //                         url: 'schemaName=' + schemaName,
    //                         children: [
    //                             {
    //                                 text: '',
    //                                 value: String(Math.random()),
    //                                 url: 'di.console.editor.ui.OLAPEditor?'
    //                                     + [
    //                                         'reportType=TABLE',
    //                                         'schemaName=' + schemaName,
    //                                         'cubeTreeNodeName=' + node.nodeName
    //                                     ].join('&')
    //                             },
    //                             {
    //                                 text: '',
    //                                 value: String(Math.random()),
    //                                 url: 'di.console.editor.ui.PlaneEditor?'
    //                                     + [
    //                                         'datasourceName='
    //                                     ].join('&')
    //                             },
    //                             {
    //                                 text: '',
    //                                 url: 'di.console.editor.ui.OLAPEditor?'
    //                                     + [
    //                                         'reportType=CHART',
    //                                         'schemaName=' + schemaName,
    //                                         'cubeTreeNodeName=' + node.nodeName
    //                                     ].join('&')
    //                             }
    //                         ]
    //                     }
    //                 ];
    //             },
    //             'children'
    //         );
    //         menuTree.menuList.push(root);
    //     }
    //     menuTree.selMenuId = 1;

    //     // FIXME
    //     // 
    //     menuTree.menuList.push(
    //         {
    //             text: '',
    //             value: 19999,
    //             url: 'di.console.editor.ui.ReportPreview'
    //         }
    //     );

    //     return { menuTree: menuTree };
    // };

})();


/**
 * di.shared.model.DIChartModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var textParam = xutil.url.textParam;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * DI 
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_CHART_MODEL = 
            $namespace().DIChartModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_CHART_MODEL_CLASS = 
            DI_CHART_MODEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * 
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
        /**
         * 
         *
         * @type {Object}
         * @private
         */
        this._oRawChartData = {};
        /**
         * 
         *
         * @type {Object}
         * @private
         */
        this._oChartData = {};
    }

    /**
     * @override
     */
    DI_CHART_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('OLAP_CHART_DATA'),
            X_DATA: URL.fn('OLAP_CHART_X_DATA'),
            LITEOLAPCHART_DATA: URL.fn('LITEOLAP_CHART_DATA'),
            S_DATA: URL.fn('OLAP_CHART_S_DATA'),
            S_ADD_DATA: URL.fn('OLAP_CHART_S_ADD_DATA'),
            S_REMOVE_DATA: URL.fn('OLAP_CHART_S_REMOVE_DATA'),
            OFFLINE_DOWNLOAD: URL.fn('OLAP_CHART_OFFLINE_DOWNLOAD')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_CHART_MODEL_DATA_' + getUID(),
            X_DATA: 'DI_CHART_MODEL_X_DATA_' + getUID(),
            LITEOLAPCHART_DATA: 'DI_LITEOLAP_CHART_DATA_' + getUID(),
            S_DATA: 'DI_CHART_MODEL_S_DATA_' + getUID(),
            S_ADD_DATA: 'DI_CHART_MODEL_S_ADD_DATA_' + getUID(),
            S_REMOVE_DATA: 'DI_CHART_MODEL_S_REMOVE_DATA_' + getUID(),
            OFFLINE_DOWNLOAD: 'DI_CHART_OFFLINE_DOWNLOAD_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: doParam,
            X_DATA: doParam,
            S_DATA: doParam,
            S_ADD_DATA: doParam,
            S_REMOVE_DATA: doParam,
            LITEOLAPCHART_DATA: function (options) {
                var reportTemplateId = this._fCommonParamGetter.getReportTemplateId();
                var paramArr = [];
                paramArr.push(this._fCommonParamGetter());
                paramArr.push('analysisType=timetrend');
                paramArr.push('sourceTemplateId=' + reportTemplateId);
                if(options.args.param.COLUMN && options.args.param.COLUMN.length > 0){
                    var indNames = options.args.param.COLUMN;
                    for (var i = 0 ; i < indNames.length ; i++) {
                        paramArr.push('indNames='+textParam(indNames[i]));
                    };
                }
                return paramArr.join('&');
            },
            OFFLINE_DOWNLOAD: function (options) {
                return this._fCommonParamGetter(
                    { mainTo: options.args.param.email }
                );
            }
        }
    );
    function doParam(options) {
        var param = options.args.param;
        
        if (param.uniqueName) {
            // FIXME
            // 
            param.dimTags = param.uniqueName;
            delete param.uniqueName;
        }

        if (param.uniqueNames) {
            // @deprecated
            // argHandlerdimTagsList
            param.dimTagsList = param.uniqueNames;
            delete param.uniqueNames;
        }

        return this._fCommonParamGetter(param);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            X_DATA: doComplete,
            LITEOLAPCHART_DATA: doComplete,
            S_DATA: doComplete,
            S_ADD_DATA: doComplete,
            S_REMOVE_DATA: doComplete,
            OFFLINE_DOWNLOAD: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // reportTemplateIdid
        // FIXME 
        // 
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: doParse,
            X_DATA: doParse,
            LITEOLAPCHART_DATA: doParse,
            S_DATA: doParse,
            S_ADD_DATA: doParse,
            S_REMOVE_DATA: doParse
        }
    );

    /**
     * 
     *
     * @private
     */
    function doParse(data, ejsonObj, options) {
        try {
            var rawData = this._oRawChartData = data['reportChart'];

            // 
            var chartData = {};

            // FIXME
            // datetimedate
            if (rawData.xAxisType == 'datetime') {
                rawData.xAxisType = 'date';
            }

            chartData.chartType = 'line';
            chartData.series = rawData.seriesData;

            // 
            chartData.xAxis = [
                {
                    type: rawData.xAxisType,
                    data: rawData.xAxisCategories
                }
            ];

            // y
            // 
            var yNameMap = {};
            var k;
            var ser;
            for (k = 0; ser = chartData.series[k]; k ++) {
                yNameMap[ser.yAxisName] = 1;
            }
            k = 0;

            // y
            chartData.yAxis = [];
            if (rawData.yAxises) {
                for (var i = 0, ya; ya = rawData.yAxises[i]; i ++) {
                    // rawData.yAxisesyseriesy
                    // 
                    if (yNameMap[ya.name]) {
                        chartData.yAxis.push(
                            {
                                // 
                                format: ya.format,
                                // 
                                title: ya.unitName ? { text: ya.unitName } : null
                            }
                        );
                        // index
                        yNameMap[ya.name] = i;
                    }
                }
            }

            // seriesyindex
            var yAxisNum = 0;
            for (k in yNameMap) { yAxisNum ++; }
            if (yAxisNum > 1) {
                for (k = 0; ser = chartData.series[k]; k ++) {
                    ser.yAxisIndex = yNameMap[ser.yAxisName];
                }
            }

            this._oChartData = chartData;                    
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_CHART_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: doError,
            X_DATA: doError,
            LITEOLAPCHART_DATA: doError,
            S_DATA: doError,
            S_ADD_DATA: doError,
            S_REMOVE_DATA: doError
        }
    );

    /**
     * 
     *
     * @private
     */
    function doError(status, ejsonObj, options) {    
        this._oRawChartData = {};
        this._oChartData = {};
    }

    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    DI_CHART_MODEL_CLASS.getChartData = function() {
        return this._oChartData;
    };

})();


/**
 * di.shared.model.DIFormModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * DI 
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_FORM_MODEL = 
            $namespace().DIFormModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_FORM_MODEL_CLASS = 
            DI_FORM_MODEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * 
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter
    }

    /**
     * @override
     */
    DI_FORM_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('FORM_DATA'),
            ASYNC_DATA: URL.fn('FORM_ASYNC_DATA')
        }
    );    

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_FORM_MODEL_DATA_' + getUID(),
            ASYNC_DATA: 'DI_FORM_MODEL_ASYNC_DATA_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            ASYNC_DATA: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // reportTemplateIdid
        // FIXME 
        // 
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) {
                return this._fCommonParamGetter(options.args.param); 
            },
            ASYNC_DATA: function (options) {
                return this._fCommonParamGetter(options.args.param);
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: function (data, ejsonObj, options) {
                this._oInitData = (data || {}).params || {};
                return data;
            },
            ASYNC_DATA: function (data, ejsonObj, options) {
                return (data || {}).params || {};
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                // TODO
            },
            ASYNC_DATA: function (status, ejsonObj, options) {
                // TODO
            }
        }
    );

    /** 
     * 
     *
     * @public
     * @return {Object} 
     */
    DI_FORM_MODEL_CLASS.getInitData = function () {
        return this._oInitData;
    };    

})();


/**
 * di.shared.model.DIPlaneTableModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * DI 
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_PLANE_TABLE_MODEL = 
            $namespace().DIPlaneTableModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_PLANE_TABLE_MODEL_CLASS = 
            DI_PLANE_TABLE_MODEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * 
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
    }

    /**
     * @override
     */
    DI_PLANE_TABLE_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('PLANE_TABLE_DATA'),
            CHECK: URL.fn('PLANE_TABLE_CHECK'),
            SELECT: URL.fn('PLANE_TABLE_SELECT'),
            OFFLINE_DOWNLOAD: URL.fn('PLANE_TABLE_OFFLINE_DOWNLOAD')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_PLANE_TABLE_MODEL_DATA_' + getUID(),
            CHECK: 'DI_PLANE_TABLE_MODEL_CHECK_' + getUID(),
            SELECT: 'DI_PLANE_TABLE_MODEL_SELECT_' + getUID(),
            OFFLINE_DOWNLOAD: 'DI_TABLE_OFFLINE_DOWNLOAD_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) {
                return this._fCommonParamGetter(options.args.param);
            },
            CHECK: function (options) {
                return this._fCommonParamGetter(
                    // TODO
                    // 
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            SELECT: function (options) {
                return this._fCommonParamGetter(
                    // TODO
                    // 
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            OFFLINE_DOWNLOAD: function (options) {
                return this._fCommonParamGetter(
                    // TODO
                    // 
                    { mailTo: options.args.param.email }
                );
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            DRILL: doComplete,
            LINK_DRILL: doComplete,
            SELECT: doComplete,
            CHECK: doComplete,
            OFFLINE_DOWNLOAD: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // reportTemplateIdid
        // FIXME 
        // 
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: doParse,
            CHECK: function (data) { return data; },
            SELECT: function (data) { return data; }
        }
    );

    /**
     * 
     * 
     * @private
     */
    function doParse(data, ejsonObj, options) {
        try {
            var retData = {
                tableData: {
                    head: data.head,
                    data: data.data
                },
                pageInfo: data.pageInfo,
                exception: data.exception,
                actualSql: data.actualSql
            };
            return retData;
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oTableData = {};
                this._oBreadcrumbData = {};
            }
            // TODO
        }
    );

})();


/**
 * di.shared.model.DITableModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * DI 
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_RTPLCLONE_MODEL = 
            $namespace().DIRtplCloneModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_RTPLCLONE_MODEL_CLASS = 
            DI_RTPLCLONE_MODEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * 
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
    }

    /**
     * @override
     */
    DI_RTPLCLONE_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: URL.fn('RTPL_CLONE_GETDEFAULTIMAGENAME'),
            SAVE: URL.fn('RTPL_CLONE_SAVE'),
            CLEAR: URL.fn('RTPL_CLONE_CLEAR')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: 'RTPL_CLONE_GETDEFAULTIMAGENAME' + getUID(),
            SAVE: 'RTPL_CLONE_SAVE' + getUID(),
            CLEAR: 'RTPL_CLONE_CLEAR' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            SAVE: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            CLEAR: function (options) {
                return this._fCommonParamGetter(options.args);
            }
        }
    );


    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: doComplete,
            SAVE: doComplete,
            CLEAR: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // reportTemplateIdid
        // FIXME 
        // 
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: function (data) { return data; },
            SAVE: function (data) { return data; },
            CLEAR: function (data) { return data; }
        }
    );


    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oTableData = {};
                this._oBreadcrumbData = {};
            }
            // TODO
        }
    );

})();


/**
 * di.shared.model.DITableModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * DI 
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_TABLE_MODEL = 
            $namespace().DITableModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_TABLE_MODEL_CLASS = 
            DI_TABLE_MODEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * 
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
    }

    /**
     * @override
     */
    DI_TABLE_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('OLAP_TABLE_DATA'),
            DRILL: URL.fn('OLAP_TABLE_DRILL'),
            LINK_DRILL: URL.fn('OLAP_TABLE_LINK_DRILL'),
            SORT: URL.fn('OLAP_TABLE_SORT'),
            CHECK: URL.fn('OLAP_TABLE_CHECK'),
            SELECT: URL.fn('OLAP_TABLE_SELECT'),
            MEASURE_DES: URL.fn('MEASURE_DES'),
            OFFLINE_DOWNLOAD: URL.fn('OLAP_TABLE_OFFLINE_DOWNLOAD')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_TABLE_MODEL_DATA_' + getUID(),
            DRILL: 'DI_TABLE_MODEL_DRILL_' + getUID(),
            LINK_DRILL: 'DI_TABLE_MODEL_LINK_DRILL_' + getUID(),
            SORT: 'DI_TABLE_MODEL_SORT_' + getUID(),
            CHECK: 'DI_TABLE_MODEL_CHECK_' + getUID(),
            SELECT: 'DI_TABLE_MODEL_SELECT_' + getUID(),
            MEASURE_DES: 'MEASURE_DES_' + getUID(),
            OFFLINE_DOWNLOAD: 'DI_TABLE_OFFLINE_DOWNLOAD_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) {
                return this._fCommonParamGetter(options.args.param);
            },
            DRILL: function (options) {
                return createLinkDrillParam.call(this, options);
            },
            LINK_DRILL: function (options) {
                return createLinkDrillParam.call(this, options);
            },
            SORT: function (options) {
                var param = options.args.param;
                return this._fCommonParamGetter(
                    {
                        uniqueName: param.uniqueName,
                        sortType: param.currentSort
                    }
                );
            },
            CHECK: function (options) {
                return this._fCommonParamGetter(
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            MEASURE_DES: function (options) {
                var baseUrl = this._fCommonParamGetter();
                var url = baseUrl + '&' + options.args.param.colUniqueNamesArr.join('&');
                return url;
            },
            SELECT: function (options) {
                return this._fCommonParamGetter(
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            OFFLINE_DOWNLOAD: function (options) {
                return this._fCommonParamGetter(
                    { mailTo: options.args.param.email }
                );
            }
        }
    );

    /**
     * 
     *
     * @private
     */
    function createLinkDrillParam(options) {
        var param = options.args.param;
        var paramObj = {};
        
        paramObj['uniqueName'] = param.uniqueName;
        paramObj['lineUniqueName'] = param.lineUniqueName;

        paramObj['action'] = param.action;
        // FIXME
        // 
        paramObj['drillAxisName'] = 'ROW';
        
        return this._fCommonParamGetter(paramObj);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            DRILL: doComplete,
            LINK_DRILL: doComplete,
            SORT: doComplete,
            SELECT: doComplete,
            CHECK: doComplete,
            MEASURE_DES: doComplete,
            OFFLINE_DOWNLOAD: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // reportTemplateIdid
        // FIXME 
        // 
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: doParse,
            DRILL: doParse,
            LINK_DRILL: doParse,
            SORT: doParse,
            MEASURE_DES: function (data, ejsonObj, options) { 
                return data;
                 },
            CHECK: function (data) { return data; },
            SELECT: function (data) { return data; }
        }
    );

    /**
     * 
     * 
     * @private
     */
    function doParse(data, ejsonObj, options) {
        try {
            var retData = {};
            var tableData = retData.tableData = data['pivottable'];

            // 
            tableData.datasource = tableData.dataSourceRowBased;

            var i;
            var j;
            var o;
            var colspan;
            var headLength;

            // (colDefine)
            var firstLine = tableData['colFields'][0];
            var rawColDefine = tableData.colDefine;
            var colDefine = [];
            for (i = 0; i < firstLine.length; i ++) {
                o = firstLine[i];
                if (!o) { continue; }
                colspan = o.colspan || 1;
                for (j = 0; j < colspan; j ++) {
                    colDefine.push({ width:1 });
                }
            }
            headLength = colDefine.length - rawColDefine.length;
            for (i = 0; i < rawColDefine.length; i ++) {
                extend(colDefine[i + headLength], rawColDefine[i]);
            }
            tableData.colDefine = colDefine;

            // colspanrowspan
            // 
            // 
            // colFieldsrowHeadFields
            fixColFields(tableData, headLength);
            fixRowHeadFields(tableData, headLength);

            // 
            var sortType; 
            var sortKeyMap = { // 
                ASC: 'asc',
                DESC: 'desc',
                NONE: 'none'
            }
            for (i = 0; i < colDefine.length; i ++) {
                if (sortType = colDefine[i].currentSort) {
                    colDefine[i].orderby = sortKeyMap[sortType];
                }
            }

            retData.tableData.reportTemplateId = data['reportTemplateId'];
            // 
            retData.tableData.rowCheckMax = data['rowCheckMax'];
            retData.tableData.rowCheckMin = data['rowCheckMin'];

            // 
            var breadcrumb = data['mainDimNodes'] || [];
            if (breadcrumb) {
                for (i = 0; o = breadcrumb[i]; i ++) {
                    o.text = o['showName'];
                    o.value = i;
                    o.url = null;
                    if (i == breadcrumb.length - 1) {
                        o.disabled = true;
                    }
                    if (i == 0) {
                        o.isFirst = true;
                    }
                }
            }
            retData.breadcrumbData = {
                datasource: breadcrumb,
                maxShow: 5,
                hidePosPercent: 0.5
            }

            retData.pageInfo = {
                totalRecordCount: data['totalSize'],
                currRecordCount: data['currentSize']
            }

            // retData.tableDataOverlap = getDataOverlap(
            //     tableData, 
            //     options.args.viewStateWrap
            // );

            this._oData = retData;
            
            return retData;
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    /**
     * @public
     */
    DI_TABLE_MODEL_CLASS.getData = function () {
        return this._oData;
    };

    /**
     * 
     *
     * @protected
     */
    // function getDataOverlap(tableData, viewStateWrap) {
    //     if (!tableData || !viewStateWrap) { return; }

    //     var dataOverlap = {};

    //     // 
    //     var rowCheckedMap = viewStateWrap.rowCheckedMap;
    //     if (rowCheckedMap) {
    //         var rowChecked = [];
    //         for (var i = 0, rhd; rhd = tableData.rowDefine[i]; i ++) {
    //             (rhd.uniqueName in rowCheckedMap) && rowChecked.push(i);
    //         }

    //         dataOverlap.rowChecked = rowChecked;
    //     }

    //     return dataOverlap;
    // };

    /**
     * colFields{}
     * 
     *      rowspanheadLength
     *      rowspan
     *      
     * 
     * @private
     */
    function fixColFields(tableData, headLength) {
        var i;
        var j;
        var k;
        var o;
        var line;
        var rawLine;
        var colspan;
        var colFields = [];

        for (i = 0; rawLine = tableData.colFields[i]; i ++) {
            colFields.push(line = []);
            if (i > 0) {
                // 
                for (k = 0; k < headLength; k ++) {
                    line.push({});
                }
            }
            for (j = 0; j < rawLine.length; j ++) {
                line.push(o = rawLine[j]);
                colspan = (o || {}).colspan || 1;
                for (k = 1; k < colspan; k ++) {
                    // 
                    line.push({});
                }
            }
        }
        tableData.colFields = colFields;
    }

    /**
     * rowHeadFields{}
     * 
     *      colspan
     *      rowspan
     *      
     *
     * @private
     */
    function fixRowHeadFields(tableData, headLength) {
        var i;
        var j;
        var line;
        var rawLine;
        var rowHeadFields = [];

        for (i = 0; rawLine = tableData.rowHeadFields[i]; i ++) {
            rowHeadFields.push(line = []);
            // 
            for (j = 0; j < headLength - rawLine.length; j ++) {
                line.push({});
            }
            for (j = 0; j < rawLine.length; j ++) {
                line.push(rawLine[j]);
            }
        }
        tableData.rowHeadFields = rowHeadFields;
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oTableData = {};
                this._oBreadcrumbData = {};
            }
            // TODO
        }
    );

})();


/**
 * di.shared.model.GlobalMenuManager
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [] 
 * author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

/**
 * []
 * globalMenu
 */
(function() {
    
    /*  */
    var inheritsObject = xutil.object.inheritsObject;
    var bind = xutil.fn.bind;
    var getByPath = xutil.object.getByPath;
    var XDATASOURCE = xui.XDatasource;
        
    /*  */
    var GLOBAL_MENU_MANAGER = $namespace().GlobalMenuManager = 
            inheritsObject(
                XDATASOURCE,
                function (options) {
                    this.businessData = options.globalMenu;
                }
            );
    var GLOBAL_MENU_MANAGER_CLASS = GLOBAL_MENU_MANAGER.prototype;
    
    /**
     * 
     * @protected
     */
    GLOBAL_MENU_MANAGER_CLASS.$dispose = function() {
        GLOBAL_MENU_MANAGER.superClass.$dispose.call(this);
    };
    
    /**
     * 
     * @public
     * 
     * @return {Object} 
     *          {string} menuId ID
     *          {string} menuName 
     *          {string} menuPage 
     *          {string} menuUrl URL
     */
    GLOBAL_MENU_MANAGER_CLASS.getSelected = function() {
        return this.businessData && this.businessData.selMenu;
    };
    
    /**
     * 
     * @public
     * 
     * @return {Array} 
     */
    GLOBAL_MENU_MANAGER_CLASS.getMenuData = function() {
        return this.businessData && this.businessData.menuList;
    }
    
    /**
     * 
     * @public
     * 
     * @return {Constructor#ecui.ui.Control} 
     */
    GLOBAL_MENU_MANAGER_CLASS.getControlClass = function() {
        var classPath = (this.getSelected() || {}).menuPage;
        return classPath ? getByPath(classPath) : null;
    };
    
    /**
     * 
     * @protected
     */
    GLOBAL_MENU_MANAGER_CLASS.parse = function(data) {
        // GLOBAL_MODEL
        var globalMenu = data && data.globalMenu || {};
        this.businessData = {
            menuList: globalMenu.menuList, 
            selMenu: globalMenu.selMenu
        };
        return this.businessData;
    };
    
    /**
     * 
     * @public
     */
    GLOBAL_MENU_MANAGER_CLASS.changeMenu = function(args) {
        // to be continued ...
    };

    /**
     * 
     * 
     */
    GLOBAL_MENU_MANAGER_CLASS.setGlobalMenu = function(gm) {
        this._uGlobalMenu = gm;
    };    
        
})();


/**
 * di.shared.model.MetaConditionModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var stringify = baidu.json.stringify;
    var stringifyParam = xutil.url.stringifyParam;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var numberParam = xutil.url.numberParam;
    var arrayProtoPush = Array.prototype.push;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var logError = UTIL.logError;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     * @param {Object} options
     * @param {Object} options.reportType
     * @param {Function=} options.commonParamGetter    
     */
    var META_CONDITION_MODEL = 
            $namespace().MetaConditionModel = 
            inheritsObject(XDATASOURCE, constructor);
    var META_CONDITION_MODEL_CLASS = 
            META_CONDITION_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * TABLE  CHART
         *
         * @type {string}
         * @private
         */
        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        /**
         * 
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = 
            options.commonParamGetter || function () { return ''; }
        /**
         * 
         *
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oIndList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * 
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oDimList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * selLine
         * keyselLinevalueselLinelist
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oSelLineWrap = new LINKED_HASH_MAP(null, 'k', 'l');
        /**
         * 
         * dimMetas: {}
         * indMetas: {}
         *      {Array.<string>} validMetaNames
         *      {Array.<string>} selectedMetaNames
         *
         * @type {Object}
         * @private
         */
        this._oStatusWrap = {};
        /**
         * 
         *
         * @private
         */
        this._oSeriesCfg = {};
    }

    /**
     * @override
     */
    META_CONDITION_MODEL_CLASS.init = function () {};

    var URL_MAP = {
        META_DATA: {
            RTPL_OLAP_TABLE: URL.fn('META_CONDITION_IND_DIM_TABLE'),
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_IND_DIM_CHART')
        },
        SELECT: {
            RTPL_OLAP_TABLE: URL.fn('META_CONDITION_SELECT_TABLE'),
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_SELECT_CHART')
        },
        CANDIDATE_INIT: {
            RTPL_OLAP_TABLE: URL.fn('META_CONDITION_CANDIDATE_INIT'),
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_CANDIDATE_INIT')
        },
        CANDIDATE_SUBMIT: {
            RTPL_OLAP_TABLE: URL.fn('META_CONDITION_CANDIDATE_SUBMIT'),
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_CANDIDATE_SUBMIT')
        },
        ADD_SERIES_GROUP: {
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_ADD_SERIES_GROUP')
        },
        REMOVE_SERIES_GROUP: {
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_REMOVE_SERIES_GROUP')
        },
        CHART_CONFIG_INIT: {
            RTPL_OLAP_CHART: URL.fn('CONSOLE_CHART_CONFIG_INIT')
        },
        CHART_CONFIG_SUBMIT: {
            RTPL_OLAP_CHART: URL.fn('CONSOLE_CHART_CONFIG_SUBMIT')
        },
        ROWHEAD_CONFIG_INIT: {
            RTPL_OLAP_TABLE: URL.fn('ROWHEAD_CONFIG_INIT')
        },
        ROWHEAD_CONFIG_SUBMIT: {
            RTPL_OLAP_TABLE: URL.fn('ROWHEAD_CONFIG_SUBMIT')
        },
        DIMSHOW_CONFIG_INIT: {
            RTPL_OLAP_TABLE: URL.fn('DIMSHOW_CONFIG_INIT'),
            RTPL_OLAP_CHART: URL.fn('DIMSHOW_CONFIG_INIT')
        },
        DIMSHOW_CONFIG_SUBMIT: {
            RTPL_OLAP_TABLE: URL.fn('DIMSHOW_CONFIG_SUBMIT'),
            RTPL_OLAP_CHART: URL.fn('DIMSHOW_CONFIG_SUBMIT')
        },
        GET_TEMPLATE_INFO: {
            RTPL_OLAP_TABLE: URL.fn('GET_TEMPLATE_INFO'),
            RTPL_OLAP_CHART: URL.fn('GET_TEMPLATE_INFO')
        },


        REPORT_ROWMERGE_KEY_SUBMIT : {
            RTPL_OLAP_TABLE: URL.fn('REPORT_ROWMERGE_KEY_SUBMIT'),
            RTPL_OLAP_CHART: URL.fn('REPORT_ROWMERGE_KEY_SUBMIT')
        },
        DATA_FORMAT_SET : {
            RTPL_OLAP_TABLE: URL.fn('DATA_FORMAT_SET'),
            RTPL_OLAP_CHART: URL.fn('DATA_FORMAT_SET')
        }
    };    

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    META_CONDITION_MODEL_CLASS.url = function (options) {
        return URL_MAP[options.datasourceId][this._sReportType]();
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    META_CONDITION_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            META_DATA: function (options) { 
                return this._fCommonParamGetter(); 
            },
            SELECT: function (options) {
                var args = options.args;
                var changeWrap = args.changeWrap;
                var paramArr = [];

                paramArr.push(this._fCommonParamGetter());
                arrayProtoPush.apply(
                    paramArr, 
                    wrapArrayParam(changeWrap.uniqNameList, 'uniqNameList')
                );
                paramArr.push('from=' + textParam(changeWrap.from));
                paramArr.push('to=' + textParam(changeWrap.to));
                paramArr.push(
                    'toPosition=' + numberParam(changeWrap.toPosition, -1)
                );
                return paramArr.join('&');
            },
            CANDIDATE_INIT: function (options) {
                return this._fCommonParamGetter();
            },
            CANDIDATE_SUBMIT: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            ADD_SERIES_GROUP: function (options) {
                return this._fCommonParamGetter();
            },
            REMOVE_SERIES_GROUP: function (options) {
                return this._fCommonParamGetter({ from: options.args.selLineName });
            },
            CHART_CONFIG_INIT: function (options) {
                return this._fCommonParamGetter();
            },
            CHART_CONFIG_SUBMIT: function (options) {
                var args = options.args;
                var getter = this._fCommonParamGetter;
                getter.markParamMode(args.series, 'JSON');
                getter.markParamMode(args.yAxises, 'JSON');
                return getter(args);
            },
            ROWHEAD_CONFIG_INIT: function (options) {
                return this._fCommonParamGetter();
            },
            ROWHEAD_CONFIG_SUBMIT: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            DIMSHOW_CONFIG_INIT: function (options) {
                return this._fCommonParamGetter();
            },
            DIMSHOW_CONFIG_SUBMIT: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            GET_TEMPLATE_INFO : function(options){
                var param=[];
                param.push(
                    'reportTemplateId=' + textParam(
                        this._fCommonParamGetter.getReportTemplateId()
                    ),
                    'templateKey=' + textParam(options.args.key) 
                );
                return param.join('&');

            },
            DATA_FORMAT_SET : function(options){
                var param = [];
                param.push(
                     'reportTemplateId=' + textParam(
                        this._fCommonParamGetter.getReportTemplateId()
                    ),
                    'dataFormatDto='+ textParam(stringify(options.args.formatDto))
                );
                return param.join('&');
            },
            REPORT_ROWMERGE_KEY_SUBMIT : function(options) {
                var param = [];
                param.push(
                    'reportTemplateId=' + textParam(
                        this._fCommonParamGetter.getReportTemplateId()
                    )
                );
                for(var key in options.args){
                    if(key == 'updateTemplateProperty'){
                        var list = options.args[key];
                        for(var rwValue in list){
                            param.push(key + '=' + list[rwValue]);
                        }
                    }else{
                        param.push(key + '=' + textParam(options.args[key]));
                    }
                    
                }
                return param.join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    META_CONDITION_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            META_DATA: metaDataParse,
            SELECT: selectParse,
            CANDIDATE_INIT: defaultParse,
            CANDIDATE_SUBMIT: defaultParse,
            ADD_SERIES_GROUP: metaDataParse,
            REMOVE_SERIES_GROUP: metaDataParse,
            CHART_CONFIG_INIT: defaultParse,
            CHART_CONFIG_SUBMIT: defaultParse,
            ROWHEAD_CONFIG_INIT: defaultParse,
            ROWHEAD_CONFIG_SUBMIT: defaultParse,
            DIMSHOW_CONFIG_INIT: defaultParse,
            DIMSHOW_CONFIG_SUBMIT: defaultParse,
            GET_TEMPLATE_INFO : mergeParse,
            DATA_FORMAT_SET : defaultParse,
            REPORT_ROWMERGE_KEY_SUBMIT : defaultParse
        }
    );

    function mergeParse(data,ejsonObj,options){
        var type = data.type || 'SIMPLE';
        var result = {};
        for(var arg in data){
            result[arg] = data[arg];
        }
        result.dimList = this._oDimList;
        return result;
    }

    function metaDataParse(data, ejsonObj, options) {
        try {
            var me = this;

            // 
            this.$clean();

            // 
            var metaData = data['metaData'];
            this._oIndList.appendAll(metaData['inds']);
            this._oDimList.appendAll(metaData['dims']);

            // 
            setIndDimClazz.call(this, this._oIndList, 'IND');
            setIndDimClazz.call(this, this._oDimList, 'DIM');

            // series
            this._oSeriesCfg = {};
            var seriesTypes = data['seriesTypes'] || {};
            for (var serName in seriesTypes) {
                this._oSeriesCfg[serName] = {
                    type: seriesTypes[serName]
                    // TODO
                    // 
                };
            }

            // selLine
            for (
                var i = 0, key, list; 
                key = data['index4Selected'][i]; 
                i ++
            ) {
                this._oSelLineWrap.addLast(
                    {
                        k: key,
                        l: list = new LINKED_HASH_MAP(
                            data['selected'][key], 
                            'uniqName'
                        )
                    }
                );
                setIndDimClazz.call(this, list);
            }

            // 
            doMerge.call(this, data);
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    function selectParse(data, ejsonObj, options) {
        try {
            // 
            doMerge.call(this, data);

            // selectedModel
            this.$updateSelected(options.args.changeWrap);
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }    

    function defaultParse(data) {
        return data;
    }

    /**
     * selectedmeta
     * 
     * @private
     */
    function doMerge(data) {

        // selectedstatusmeta
        if (this._oStatusWrap = data['metaStatusData']) {
            // 
            mergeStatus.call(
                this, 
                this._oStatusWrap.indMetas, 
                this._oIndList
            );
            mergeStatus.call(
                this, 
                this._oStatusWrap.dimMetas, 
                this._oDimList
            );
        }

        // metafixedalignselected
        var indList = this._oIndList;
        var dimList = this._oDimList;
        this._oSelLineWrap.foreach(
            function (selLineName, selLine, index) {
                selLine.foreach(function (key, item, idx) {
                    var o;
                    if ((o = indList.get(key))
                        || (o = dimList.get(key))
                    ) {
                        extend(item, o);
                    }
                });
            }
        );
    }

    /**
     * status
     *
     * @private
     */
    function mergeStatus(statusWrap, baseList) {
        // disabled
        baseList.foreach(
            function (k, item, index) {
                item.status = DICT.META_STATUS.DISABLED;
            }
        );

        if (!statusWrap) { return; }

        var validMetaNames = statusWrap.validMetaNames;
        !validMetaNames 
            && (validMetaNames = statusWrap.validMetaNames = []);

        var selectedMetaNames = statusWrap.selectedMetaNames;
        !selectedMetaNames 
            && (selectedMetaNames = statusWrap.selectedMetaNames = []);

        // normalselected
        // visiblebaseList
        // 
        var i;
        var o;
        var item;
        for (i = 0; i < validMetaNames.length;) {
            if (item = baseList.get(validMetaNames[i])) {
                item.status = DICT.META_STATUS.NORMAL;
                i ++;
            }
            else {
                validMetaNames.splice(i, 1);
            }
        }
        for (i = 0; i < selectedMetaNames.length;) {
            if (item = baseList.get(selectedMetaNames[i])) {
                item.status = DICT.META_STATUS.SELECTED;
                i ++;
            }
            else {
                selectedMetaNames.splice(i, 1);
            }
        }

        // disabled
        var disabledMetaNames = statusWrap.disabledMetaNames = [];
        baseList.foreach(
            function (k, item, index) {
                if (item.status == DICT.META_STATUS.DISABLED) {
                    disabledMetaNames.push(k);
                }
            }
        );
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    META_CONDITION_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            META_DATA: function (status, ejsonObj, options) {
                this._oIndList.clean();
                this._oDimList.clean();
                this._oSelLineWrap.clean();
                this._oStatusWrap = {};
            },
            SAVE: function (status, ejsonObj, options) {
                // TODO 
                // 
            }
        }
    );

    /**
     * 
     *
     * @private
     */
    function setIndDimClazz(list, flag) {
        var me = this;
        list.foreach(
            function (key, o) {
                if (flag) {
                    o.clazz = flag;
                }
                else if (me._oIndList.containsKey(o.uniqName)) {
                    o.clazz = 'IND';
                }
                else if (me._oDimList.containsKey(o.uniqName)) {
                    o.clazz = 'DIM';
                }
            }
        );        
    }

    /**
     * selLine
     *
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    META_CONDITION_MODEL_CLASS.getSelLineWrap = function () {
        return this._oSelLineWrap;
    };

    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    META_CONDITION_MODEL_CLASS.getIndDim = function () {
        return {
            indList: this._oIndList,
            dimList: this._oDimList
        };
    };

    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    META_CONDITION_MODEL_CLASS.getStatusWrap = function () {
        return this._oStatusWrap;
    };

    /**
     * uniqName
     * 
     * @public
     * @param {string} uniqName
     * @return {Object} metaItem
     */
    META_CONDITION_MODEL_CLASS.getMetaItem = function (uniqName) {  
        var item = this._oIndList.get(uniqName);
        if (!item) {
            item = this._oDimList.get(uniqName);
        }
        return item;
    };
    
    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    META_CONDITION_MODEL_CLASS.getSeriesCfg = function () {
        return this._oSeriesCfg;
    };

    META_CONDITION_MODEL_CLASS.$clean = function() {
        this._oIndList.cleanWithoutDefaultAttr();
        this._oDimList.cleanWithoutDefaultAttr();
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        this._oStatusWrap = {};
        this._oSeriesCfg = {};
    };

    /**
     * 
     * 
     * @public
     * @param {Object} selLineWrap keyvalue 
     * @return {Object} keyfrom, to, toPosition
     */
    META_CONDITION_MODEL_CLASS.diffSelected = function (selLineWrap) {
        var srcList;
        var removeList; 
        var addList;
        var changeWrap = { uniqNameList: [] };

        for (var name in selLineWrap) {
            srcList = this._oSelLineWrap.get(name);
            diffLineSelected.call(
                this, 
                name, 
                selLineWrap[name], 
                srcList, 
                changeWrap
            );
        }

        return changeWrap;
    };

    /**
     * 
     * 
     * 
     * @private
     * @param {string} lineName
     * @param {Array.<string>} currLine
     * @param {xutil.LinkedHashMap} srcList 
     * @param {Object} result
     */
    function diffLineSelected(lineName, currLine, srcList, result) {
        // 
        if (currLine.length == srcList.size()) {
            var diffKeySrc;
            var diffIndex;
            var tarIndexCurr;
            var tarIndexSrc;
            var tarKeySrc;
            srcList.foreach(
                function (key, value, index) {
                    if (diffIndex == null) {
                        if (key != currLine[index]) { 
                            // 
                            diffKeySrc = key; 
                            diffIndex = index;
                        }
                    }
                    else {
                        if (diffKeySrc == currLine[index]) {
                            tarIndexCurr = index;
                        }
                        if (currLine[diffIndex] == key) {
                            tarIndexSrc = index;
                            tarKeySrc = key;
                        }
                    }
                }
            );
            if (diffIndex != null) {
                result.from = lineName;
                result.to = lineName;
                result.fromLineData = currLine;
                result.toLineData = currLine;
                if (tarIndexSrc > tarIndexCurr) {
                    result.uniqName = tarKeySrc;
                    result.toPosition = diffIndex;
                }
                else {
                    result.uniqName = diffKeySrc;
                    result.toPosition = tarIndexCurr;
                }
                result.uniqNameList.push(result.uniqName);
            }
        }
        // 
        else if (currLine.length > srcList.size()) {
            for (var i = 0, name; i < currLine.length; i ++) {
                name = currLine[i];
                if (!srcList.containsKey(name)) {
                    result.uniqName = name
                    result.uniqNameList.splice(0, 1, name);
                    result.to = lineName;
                    result.toLineData = currLine;
                    if (result.toPosition == null) {
                        result.toPosition = i;
                    }
                }
            }
        }
        // 
        else if (currLine.length < srcList.size()) {
            srcList.foreach(
                function (name, value, index) {
                    if (currLine[index] != name) {
                        result.uniqName = name
                        result.uniqNameList.push(name);
                        result.from = lineName;
                        result.fromLineData = currLine;
                        return false;
                    }
                }
            );
        }
        // FIXME
        // FIXME
        result.uniqNameList.splice(1, result.uniqNameList.length - 1);
    };

    /**
     * 
     * 
     * @protected
     * @param {Object} changeWrap
     * @param {Array.<string>} changeWrap.uniqNameList
     * @param {string} changeWrap.from
     * @param {string} changeWrap.to
     * @param {number} changeWrap.toPosition
     */
    META_CONDITION_MODEL_CLASS.$updateSelected = function (changeWrap) {
        var fromList = changeWrap.from != changeWrap.to
                ? this._oSelLineWrap.get(changeWrap.from)
                : null;
        var toList = this._oSelLineWrap.get(changeWrap.to);

        var fromLineData = changeWrap.fromLineData;
        var toLineData = changeWrap.toLineData;
        var i = 0;
        var uniqName;

        if (fromList) {
            fromList.cleanWithoutDefaultAttr();
            for (i = 0; i < fromLineData.length; i ++) {
                uniqName = fromLineData[i];
                fromList.addLast(this.getMetaItem(uniqName));
            }
        }

        if (toList) {
            toList.cleanWithoutDefaultAttr();
            for (i = 0; i < toLineData.length; i ++) {
                uniqName = toLineData[i];
                toList.addLast(this.getMetaItem(uniqName));
            }
        }

        //----------------------------------
        // ONLY FOR TESTING. TO BE DELETED.
        // console.log(changeWrap);
        // console.log('      uniqNameList= ' + changeWrap.uniqNameList);
        // console.log('      from= ' + changeWrap.from);
        // console.log('      fromLineData= ' + changeWrap.fromLineData);
        // console.log('      to= ' + changeWrap.to);
        // console.log('      toLineData= ' + changeWrap.toLineData);
        // console.log('      toPosition= ' + changeWrap.toPosition);
        // this._oSelLineWrap.foreach(function (k, item, index) {
        //     console.log('LINE NAME::: ' + k);
        //     item.foreach(function (kk, oo, ii) {
        //         var arr = [];
        //         arr.push(kk);
        //         console.log('          ' + arr.join('  '));
        //     });
        // });
    };

})();


/**
 * di.shared.model.OlapMetaConfigModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var isArray = xutil.lang.isArray;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     * @param {Object} options
     * @param {Object} options.reportType
     * @param {Function=} options.commonParamGetter    
     */
    var OLAP_META_CONFIG_MODEL = 
            $namespace().OlapMetaConfigModel = 
            inheritsObject(XDATASOURCE, constructor);
    var OLAP_META_CONFIG_MODEL_CLASS = 
            OLAP_META_CONFIG_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * TABLE  CHART
         *
         * @type {string}
         * @private
         */
        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        /**
         * 
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
        /**
         * 
         *
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oIndList = new LINKED_HASH_MAP(null, 'uniqName');


        /**
         * liteOlap
         *
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._liteOlapIndList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * 
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oDimList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * selLine
         * keyselLinevalueselLinelist
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oSelLineWrap = new LINKED_HASH_MAP(null, 'k', 'l');
        /**
         * 
         * dimMetas: {}
         * indMetas: {}
         *      {Array.<string>} validMetaNames
         *      {Array.<string>} selectedMetaNames
         *
         * @type {Object}
         * @private
         */
        this._oStatusWrap = {};
        /**
         * 
         *
         * @private
         */
        this._oSeriesCfg = {};
    }

    /**
     * @override
     */
    OLAP_META_CONFIG_MODEL_CLASS.init = function () {};

    var URL_MAP = {
        RTPL_OLAP_TABLE: {
            DATA: URL.fn('META_CONDITION_IND_DIM_TABLE'),
            LITEOLAP_INDS_DATA: URL.fn('LITEOLAP_INDS_META_DATA'),
            SELECT: URL.fn('META_CONDITION_SELECT_TABLE'),
            LIST_SELECT: URL.fn('META_CONDITION_LIST_SELECT_TABLE')
        },
        RTPL_OLAP_CHART: {
            DATA: URL.fn('META_CONDITION_IND_DIM_CHART'),
            LITEOLAP_INDS_DATA: URL.fn('LITEOLAP_INDS_META_DATA'),
            SELECT: URL.fn('META_CONDITION_SELECT_CHART'),
            LIST_SELECT: URL.fn('META_CONDITION_LIST_SELECT_CHART')
        }
    };    

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.url = function (options) {
        return URL_MAP[this._sReportType][options.datasourceId]();
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'OLAP_META_CONFIG_MODEL_DATA_' + getUID(),
            SELECT: 'OLAP_META_CONFIG_MODEL_SELECT_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            LITEOLAP_INDS_DATA: doComplete,
            SELECT: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // reportTemplateIdid
        // FIXME 
        // 
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) { 
                return this._fCommonParamGetter(options.args.param);
            },
            LITEOLAP_INDS_DATA: function (options) { 
                return this._fCommonParamGetter(options.args.param);
            },
            SELECT: function (options) {
                var changeWrap = options.args.changeWrap;
                var paramArr = [];

                var param = {
                    from: changeWrap.from,
                    to: changeWrap.to,
                    toPosition: changeWrap.toPosition != null 
                        ? changeWrap.toPosition : -1,
                    needShowCalcInds: options.args.needShowCalcInds,
                    uniqNameList: []
                };

                param.uniqNameList.push.apply(
                    param.uniqNameList,
                    changeWrap.uniqNameList
                );

                return this._fCommonParamGetter(param);
            }, 
            LIST_SELECT: function (options) {
                return this._fCommonParamGetter(options.args);
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: function (data, ejsonObj, options) {
                try {
                    var me = this;

                    this.$clean();
                    
                    // 
                    var metaData = data['metaData'];
                    this._oIndList.appendAll(metaData['inds']);
                    this._oDimList.appendAll(metaData['dims']);

                    // 
                    setIndDimClazz.call(this, this._oIndList, 'IND');
                    setIndDimClazz.call(this, this._oDimList, 'DIM');

                    // series
                    this._oSeriesCfg = {};
                    var seriesTypes = data['seriesTypes'] || {};
                    for (var serName in seriesTypes) {
                        this._oSeriesCfg[serName] = {
                            type: seriesTypes[serName]
                            // TODO
                            // 
                        };
                    }

                    // selLine
                    for (
                        var i = 0, key, list; 
                        key = data['index4Selected'][i]; 
                        i ++
                    ) {
                        this._oSelLineWrap.addLast(
                            {
                                k: key,
                                l: list = new LINKED_HASH_MAP(
                                    data['selected'][key], 
                                    'uniqName'
                                )
                            }
                        );
                        setIndDimClazz.call(this, list);
                    }

                    // 
                    doMerge.call(this, data);
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            },

            LITEOLAP_INDS_DATA: function (data, ejsonObj, options) {
                try {
                    var me = this;

                    this.$clean();
                    
                    // 
                    // var metaData = data['metaData']['inds'];
                    // var metaStatusData = data['metaStatusData']['indMetas']['selectedMetaNames'];
                    // var selectedInds=[];
                    // for (var i = metaData.length - 1; i >= 0; i--) {
                    //     for (var j = metaStatusData.length - 1; j >= 0; j--) {
                    //         if(metaData[i]['uniqName']== metaStatusData[j]){
                    //             selectedInds.push(metaData[i]);
                    //             break;
                    //         }
                    //     };
                    // };

                    //this._liteOlapIndList.appendAll(data['selected']['COLUMN']);


                    // 
                    //doMerge.call(this, data);
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            },

            SELECT: function (data, ejsonObj, options) {
                try {
                    // 
                    doMerge.call(this, data);

                    // selectedModel
                    this.$updateSelected(options.args.changeWrap);
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            }
        }
    );

    /**
     * selectedmeta
     * 
     * @private
     */
    function doMerge(data) {

        // selectedstatusmeta
        if (this._oStatusWrap = data['metaStatusData']) {
            // 
            mergeStatus.call(
                this, 
                this._oStatusWrap.indMetas, 
                this._oIndList
            );
            mergeStatus.call(
                this, 
                this._oStatusWrap.dimMetas, 
                this._oDimList
            );
        }

        // metafixedalignselected
        var indList = this._oIndList;
        var dimList = this._oDimList;
        this._oSelLineWrap.foreach(
            function (selLineName, selLine, index) {
                selLine.foreach(function (key, item, idx) {
                    var o;
                    if ((o = indList.get(key))
                        || (o = dimList.get(key))
                    ) {
                        extend(item, o);
                    }
                });
            }
        );
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oIndList.clean();
                this._liteOlapIndList.clean();
                this._oDimList.clean();
                this._oSelLineWrap.clean();
                this._oStatusWrap = {};
            }
        }
    );

    OLAP_META_CONFIG_MODEL_CLASS.$clean = function() {
        this._oIndList.cleanWithoutDefaultAttr();
        this._liteOlapIndList.cleanWithoutDefaultAttr();
        this._oDimList.cleanWithoutDefaultAttr();
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        this._oStatusWrap = {};
        this._oSeriesCfg = {};
    };

    /**
     * 
     *
     * @private
     */
    function setIndDimClazz(list, flag) {
        var me = this;
        list.foreach(
            function (key, o) {
                if (flag) {
                    o.clazz = flag;
                }
                else if (me._oIndList.containsKey(o.uniqName)) {
                    o.clazz = 'IND';
                }
                else if (me._oDimList.containsKey(o.uniqName)) {
                    o.clazz = 'DIM';
                }
            }
        );        
    }

    /**
     * status
     *
     * @private
     */
    function mergeStatus(statusWrap, baseList) {
        // disabled
        baseList.foreach(
            function (k, item, index) {
                item.status = DICT.META_STATUS.DISABLED;
            }
        );

        if (!statusWrap) { return; }

        var validMetaNames = statusWrap.validMetaNames;
        !validMetaNames 
            && (validMetaNames = statusWrap.validMetaNames = []);

        var selectedMetaNames = statusWrap.selectedMetaNames;
        !selectedMetaNames 
            && (selectedMetaNames = statusWrap.selectedMetaNames = []);

        // normalselected
        // visiblebaseList
        // 
        var i;
        var o;
        var item;
        for (i = 0; i < validMetaNames.length;) {
            if (item = baseList.get(validMetaNames[i])) {
                item.status = DICT.META_STATUS.NORMAL;
                i ++;
            }
            else {
                validMetaNames.splice(i, 1);
            }
        }
        for (i = 0; i < selectedMetaNames.length;) {
            if (item = baseList.get(selectedMetaNames[i])) {
                item.status = DICT.META_STATUS.SELECTED;
                i ++;
            }
            else {
                selectedMetaNames.splice(i, 1);
            }
        }

        // disabled
        var disabledMetaNames = statusWrap.disabledMetaNames = [];
        baseList.foreach(
            function (k, item, index) {
                if (item.status == DICT.META_STATUS.DISABLED) {
                    disabledMetaNames.push(k);
                }
            }
        );
    }

    /**
     * selLine
     *
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    OLAP_META_CONFIG_MODEL_CLASS.getSelLineWrap = function () {
        return this._oSelLineWrap;
    };

    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    OLAP_META_CONFIG_MODEL_CLASS.getIndDim = function () {
        return {
            indList: this._oIndList,
            dimList: this._oDimList
        };
    };

    /**
     * LiteOlap
     *
     * @public
     * @return {Object} 
     */
    OLAP_META_CONFIG_MODEL_CLASS.getLiteOlapIndList = function () {
        return this._liteOlapIndList;
    };

    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    OLAP_META_CONFIG_MODEL_CLASS.getUpdateData = function () {
        return this._oStatusWrap;
    };

    /**
     * 
     *
     * @public
     * @return {Object} 
     */
    OLAP_META_CONFIG_MODEL_CLASS.getSeriesCfg = function () {
        return this._oSeriesCfg;
    };

    /**
     * uniqName
     * 
     * @public
     * @param {string} uniqName
     * @return {Object} metaItem
     */
    OLAP_META_CONFIG_MODEL_CLASS.getMetaItem = function (uniqName) {  
        var item = this._oIndList.get(uniqName);
        if (!item) {
            item = this._oDimList.get(uniqName);
        }
        return item;
    };

    /**
     * 
     * 
     * @public
     * @param {Object} selLineWrap keyvalue 
     * @return {Object} keyfrom, to, toPosition
     */
    OLAP_META_CONFIG_MODEL_CLASS.diffSelected = function (selLineWrap) {
        var srcList;
        var removeList; 
        var addList;
        var changeWrap = { uniqNameList: [] };

        for (var name in selLineWrap) {
            srcList = this._oSelLineWrap.get(name);
            diffLineSelected.call(
                this, 
                name, 
                selLineWrap[name], 
                srcList, 
                changeWrap
            );
        }

        return changeWrap;
    };

    /**
     * 
     * 
     * 
     *  from-to
     *  from-to
     * 
     * @private
     * @param {string} lineName
     * @param {Array.<string>} currLine
     * @param {xutil.LinkedHashMap} srcList 
     * @param {Object} result
     */
    function diffLineSelected(lineName, currLine, srcList, result) {
        // 
        if (currLine.length == srcList.size()) {
            var diffKeySrc;
            var diffIndex;
            var tarIndexCurr;
            var tarIndexSrc;
            var tarKeySrc;
            srcList.foreach(
                function (key, value, index) {
                    if (diffIndex == null) {
                        if (key != currLine[index]) { 
                            // 
                            diffKeySrc = key; 
                            diffIndex = index;
                        }
                    }
                    else {
                        if (diffKeySrc == currLine[index]) {
                            tarIndexCurr = index;
                        }
                        if (currLine[diffIndex] == key) {
                            tarIndexSrc = index;
                            tarKeySrc = key;
                        }
                    }
                }
            );
            if (diffIndex != null) {
                result.from = lineName;
                result.to = lineName;
                result.fromLineData = currLine;
                result.toLineData = currLine;
                if (tarIndexSrc > tarIndexCurr) {
                    result.uniqName = tarKeySrc;
                    result.toPosition = diffIndex;
                }
                else {
                    result.uniqName = diffKeySrc;
                    result.toPosition = tarIndexCurr;
                }
                result.uniqNameList.push(result.uniqName);
            }
        }
        // 
        else if (currLine.length > srcList.size()) {
            for (var i = 0, name; i < currLine.length; i ++) {
                name = currLine[i];
                if (!srcList.containsKey(name)) {
                    result.uniqName = name
                    result.uniqNameList.splice(0, 1, name);
                    result.to = lineName;
                    result.toLineData = currLine;
                    if (result.toPosition == null) {
                        result.toPosition = i;
                    }
                }
            }
        }
        // 
        else if (currLine.length < srcList.size()) {
            srcList.foreach(
                function (name, value, index) {
                    if (currLine[index] != name) {
                        result.uniqName = name
                        result.uniqNameList.push(name);
                        result.from = lineName;
                        result.fromLineData = currLine;
                        return false;
                    }
                }
            );
        }
        // FIXME
        // FIXME
        result.uniqNameList.splice(1, result.uniqNameList.length - 1);
    };

    /**
     * 
     * 
     * @protected
     * @param {Object} changeWrap
     * @param {Array.<string>} changeWrap.uniqNameList
     * @param {string} changeWrap.from
     * @param {string} changeWrap.to
     * @param {number} changeWrap.toPosition
     */
    OLAP_META_CONFIG_MODEL_CLASS.$updateSelected = function (changeWrap) {
        var fromList = changeWrap.from != changeWrap.to
                ? this._oSelLineWrap.get(changeWrap.from)
                : null;
        var toList = this._oSelLineWrap.get(changeWrap.to);

        var fromLineData = changeWrap.fromLineData;
        var toLineData = changeWrap.toLineData;
        var i = 0;
        var uniqName;

        if (fromList) {
            fromList.cleanWithoutDefaultAttr();
            for (i = 0; i < fromLineData.length; i ++) {
                uniqName = fromLineData[i];
                fromList.addLast(this.getMetaItem(uniqName));
            }
        }

        if (toList) {
            toList.cleanWithoutDefaultAttr();
            for (i = 0; i < toLineData.length; i ++) {
                uniqName = toLineData[i];
                toList.addLast(this.getMetaItem(uniqName));
            }
        }

        //----------------------------------
        // ONLY FOR TESTING. TO BE DELETED.
        // console.log(changeWrap);
        // console.log('      uniqNameList= ' + changeWrap.uniqNameList);
        // console.log('      from= ' + changeWrap.from);
        // console.log('      fromLineData= ' + changeWrap.fromLineData);
        // console.log('      to= ' + changeWrap.to);
        // console.log('      toLineData= ' + changeWrap.toLineData);
        // console.log('      toPosition= ' + changeWrap.toPosition);
        // this._oSelLineWrap.foreach(function (k, item, index) {
        //     console.log('LINE NAME::: ' + k);
        //     item.foreach(function (kk, oo, ii) {
        //         var arr = [];
        //         arr.push(kk);
        //         console.log('          ' + arr.join('  '));
        //     });
        // });
    };

    //------------------------------------------------
    // 
    //------------------------------------------------

    

})();


/**
 * di.shared.model.PageInfo
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:   
 *          
 * @author: sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function() {
    
    //---------------------------------------
    // 
    //---------------------------------------
    
    var textParam = xutil.url.textParam;
    var clone = xutil.object.clone;
        
    //---------------------------------------
    // 
    //---------------------------------------

    /**
     * 
     *
     * @class
     * @constructor
     * @param {(Object|PageInfo)=} pageInfo 
     *          {number} disabled 
     *          {number} totalRecordCount 
     *          {number} pageSize 
     *          {number} currentPage 1
     */
    var PAGE_INFO = $namespace().PageInfo = function(pageInfo) {
        /**
         * 
         *
         * @type {boolean}
         * @public
         */
        this.disable;
        /**
         * 
         *
         * @type {number}
         * @public
         */
        this.totalRecordCount;
        /**
         * 
         *
         * @type {number}
         * @public
         */
        this.pageSize;

        this.setData(pageInfo);
    };
    var PAGE_INFO_CLASS = PAGE_INFO.prototype;
        
    /**
     * 
     * 
     * @public
     * @param {Object} pageInfo 
     *          pageInfo
     *          {number} disabled 
     *          {number} totalRecordCount 
     *          {number} pageSize 
     *          {number} currentPage 1
     */
    PAGE_INFO_CLASS.setData = function(pageInfo) {
        if (pageInfo) {
            if (pageInfo.disabled != null) {
                this.disabled = pageInfo.disabled;
            }
            if (pageInfo.totalRecordCount != null) {
                this.totalRecordCount = pageInfo.totalRecordCount;
            }
            if (pageInfo.pageSize != null) {
                this.pageSize = pageInfo.pageSize;
            }
            if (pageInfo.currentPage != null) {
                this.currentPage = pageInfo.currentPage;
            }
        }
    };

    /**
     * page info
     * 
     * @public
     * @param {Object} serverPageInfo page infojson
     * @param {string=} type page bean
     *              'TCOM', 
     *              
     */
    PAGE_INFO_CLASS.setServerData = function(serverPageInfo, type) {
        var pageInfo;

        switch (type) {
            case 'TCOM': 
                pageInfo = {};
                if (serverPageInfo) {
                    pageInfo.disabled = false;
                    pageInfo.totalRecordCount = 
                        parseInt(serverPageInfo.totalRecNum) || 0;
                    pageInfo.pageSize = 
                        parseInt(serverPageInfo.pageSize) || 0;
                    pageInfo.currentPage = 
                        parseInt(serverPageInfo.curPageNum) || 0;
                }
                break;

            default:
                pageInfo = serverPageInfo;
        }

        this.setData(pageInfo);
    };

    /**
     * server
     * 
     * @public
     * @param {string=} prefix : 
     *              'model.page.cur_page_num ...'
     *              'model.page.',
     *              'page.'
     * @param {string=} type page bean
     *              'TCOM', 
     *              
     * @return {string} page info
     */
    PAGE_INFO_CLASS.getServerParam = function(prefix, type) {
        var paramArr = [];

        if (prefix == null) {
            prefix = 'page.';
        }

        switch (type) {
            case 'TCOM': 
                paramArr.push(
                    prefix + 'curPageNum=' + textParam(this.currentPage)
                );
                paramArr.push(
                    prefix + 'pageSize=' + textParam(this.pageSize)
                );
                break;

            default:
                paramArr.push(
                    prefix + 'currentPage' + textParam(this.currentPage)
                );
                paramArr.push(
                    prefix + 'pageSize' + textParam(this.pageSize)
                );
        }

        return paramArr.join('&');            
    };

})();


/**
 * di.shared.model.PanelPageRadioAdapter
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    PanelPageManagerRADIO
 * @author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function () {
    
    var bind = xutil.fn.bind; 
        
    var PANEL_PAGE_RADIO_ADAPTER = $namespace().PanelPageRadioAdapter = {};
        
    /**
     * 
     */
    PANEL_PAGE_RADIO_ADAPTER.$bind = function () {
        this._uPanelPageContainer.onbeforechange = bind(this.$pageBeforeChangeHandler, this);
        this._uPanelPageContainer.onafterchange = bind(this.$pageAfterChangeHandler, this);
    };
    
    /**
     * item
     */
    PANEL_PAGE_RADIO_ADAPTER.$addItem = function (panelPage, options) {
        var container = this._uPanelPageContainer,
            content = container.add({value: options.id, text: options.title}, 
                function() { return panelPage({el: null, parent: container, pageId: options.pageId}); });
        return {content: content, item: options.id};
    };
        
    /**
     * item
     */
    PANEL_PAGE_RADIO_ADAPTER.$selectItem = function (pageWrap) {
        this._uPanelPageContainer.select(pageWrap.item);
    };
    
    /**
     * pageId
     */
    PANEL_PAGE_RADIO_ADAPTER.$retrievalPageId = function () {
        return arguments[0];
    }
    
    /**
     * 
     */
    PANEL_PAGE_RADIO_ADAPTER.$setTitle = function (pageId, title) {
        // not supported yet
    }
        
    /**
     * 
     */
    PANEL_PAGE_RADIO_ADAPTER.$$mark = function (pageId, mark) {
        // not supported yet
    }
        
})();


/**
 * di.shared.model.PanelPageTabAdapter
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    PanelPageManagerTAB
 * @author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

(function () {
    
    var bind = xutil.fn.bind;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    
    var PANEL_PAGE_TAB_ADAPTER = $namespace().PanelPageTabAdapter = {};
        
    /**
     * 
     */
    PANEL_PAGE_TAB_ADAPTER.$bind = function () {
        this._uPanelPageContainer.onbeforechange = bind(this.$pageBeforeChangeHandler, this);
        this._uPanelPageContainer.onafterchange = bind(this.$pageAfterChangeHandler, this);
        this._uPanelPageContainer.ontabclose = bind(this.$pageCloseHandler, this);
    };
    
    /**
     * item
     */
    PANEL_PAGE_TAB_ADAPTER.$addItem = function (panelPage, options) {
        var o = this._uPanelPageContainer.addTab(
            function (el, parent) {
                return panelPage(
                    { 
                        el: el, 
                        parent: parent, 
                        pageId: options.pageId
                    }
                );
            }, 
            {
                title: options.title,
                index: options.index,
                canClose: options.canClose,
                memo: options.pageId
            }
        );
        return {content: o.tabContent, item: o.tabItem};
    };
    
    /**
     * item
     */
    PANEL_PAGE_TAB_ADAPTER.$selectItem = function (pageWrap) {
        this._uPanelPageContainer.selectTab(pageWrap.item);
    };
        
    
    /**
     * pageId
     */
    PANEL_PAGE_TAB_ADAPTER.$retrievalPageId = function () {
        var item = arguments[0];
        return item.getMemo();
    }

    /**
     * 
     */
    PANEL_PAGE_TAB_ADAPTER.$setTitle = function (pageId, title) {
        var pageWrap = this._oPanelPageSet.get(pageId);
        pageWrap && pageWrap.item.setTitle(title);
    }    

    /**
     * 
     */
    PANEL_PAGE_TAB_ADAPTER.$mark = function (pageId, mark) {
        var pageWrap = this._oPanelPageSet.get(pageId);
        if (pageWrap) {
            var item = pageWrap.item;
            mark
                ? addClass(item.getOuter(), item.getType() + '-mark')
                : removeClass(item.getOuter(), item.getType() + '-mark');
        }
    }    
    
})();


/**
 * di.shared.model.PanelPageManager
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    [] panel page
 *          tab
 * @author:  sushuang(sushuang@baidu.com)
 */

$namespace('di.shared.model');

/**
 * []
 * {ecui.ui.Control} panelPageContainer 
 */
(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------
    
    var inheritsObject = xutil.object.inheritsObject;
    var XDATASOURCE = xui.XDatasource;
    var bind = xutil.fn.bind;
    var isString = xutil.lang.isString;
    var hasValue = xutil.lang.hasValue;
    var extend = xutil.object.extend;
    var getUID = xutil.uid.getUID;
    var getByPath = xutil.object.getByPath;
    var parseParam = xutil.url.parseParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    
    //------------------------------------------
    // 
    //------------------------------------------

    var PANEL_PAGE_MANAGER = $namespace().PanelPageManager = 
        inheritsObject(
            XDATASOURCE,
            /**
             * @param {Object} options
             *          {Object} adapter 
             */
            function(options) {
                // 
                this._oPanelPageSet = new LINKED_HASH_MAP();
                this._oCurrPageWrap;
                this._sCurrPageId;
                // 
                extend(this, options.adapter);
            }
        );
    var PANEL_PAGE_MANAGER_CLASS = PANEL_PAGE_MANAGER.prototype;
        
    /**
     * 
     *
     * @public
     */
    PANEL_PAGE_MANAGER_CLASS.init = function() {
        this.$bind();
    };

    /**
     * url
     *
     * @public 
     * @param {string} uri di.some.SomePage?pageId=XXX&pageTitle=XXX&otherParam=XXX
     * @param {Object} options uri
     * @param {string} options.pageId
     * @param {string} options.pageTitle
     * @param {boolean} options.forceCreate truepageIdpageId
     * @param {boolean} options.forceActive , false
     */
    PANEL_PAGE_MANAGER_CLASS.openByURI = function(uri, options, oncreate) {
        var arr = uri.split('?');
        var pageClass = getByPath(arr[0]);
        var param = parseParam(arr[1]);
        options = options || {};
        extend(param, options);
        var forceCreate = param.forceCreate;
        var pageId = forceCreate
            ? ('PANEL_PAGE_' + getUID('PANEL_PAGE'))
            : param.pageId;
        var pageTitle = param.pageTitle;
        param.panelPageManager = this;

        // tab
        var page = this.getPage(pageId);
        if (!page || forceCreate) {
            this.add(
                function(opt) {
                    opt.el.appendChild(param.el = document.createElement('div'));
                    // pageClassdi.shared.ui.PanelPage
                    page = new pageClass(param);
                    return page;
                },
                {
                    pageId: pageId,
                    title: pageTitle,
                    canClose: true
                }
            );
            // 
            page.init();
            oncreate && oncreate(page);
        }

        // 
        this.select(pageId, param);

        return page;
    };

    /**
     *  panel pange
     *
     * @public 
     * @param {ecui.ui.PanelPage|Function} panelPage panel page
     *          panel page
     *          
     *          @param {Object} options 
     *                      {HTMLElement} el dom
     *                              
     *                      {ecui.ui.Control} parent 
     *                      {string} pageId ID
     *          @return {ecui.ui.PanelPage} 
     * @param {Object} options 
     *          {string} pageId ID
     *          {string} title 
     *          {number} index 
     *          {boolean} canClose 
     * @return {number} ID
     */
    PANEL_PAGE_MANAGER_CLASS.add = function(panelPage, options) {
        var o, pageId;
        options = options || {};
        
        if (!panelPage) { return null; }

        !hasValue(pageId = options.pageId) 
            && (pageId = options.pageId = this.$genPageId());

        if (this._oPanelPageSet.containsKey(pageId)) {
            throw new Error('Duplicate panel page ID! id=' + pageId); 
        }
        
        o = this.$addItem(panelPage, options);
        
        this._oPanelPageSet.addFirst(
            { page: o.content, item: o.item }, 
            pageId
        );
        
        return pageId;
    };
    
    /**
     * panel pange
     *
     * @public 
     * @param {string} panelPageWrap ID
     * @return {boolean} 
     */
    PANEL_PAGE_MANAGER_CLASS.exists = function(pageId) {
        return !!this._oPanelPageSet.containsKey(pageId);
    };
    
    /**
     *  panel pange
     *
     * @public 
     * @param {string} nextPageId ID
     * @param {Object} options 
     * @param {boolean=} options.forceActive false
     */
    PANEL_PAGE_MANAGER_CLASS.select = function(nextPageId, options) {
        options = options || {};
        var forceActive = options.forceActive;
        var nextPageWrap = this._oPanelPageSet.get(nextPageId);
        
        if (nextPageWrap) {
            var isChange = nextPageWrap != this._oCurrPageWrap;

            if (isChange) {
                // inactive
                if (this._oCurrPageWrap) {
                    this._oCurrPageWrap.page.inactive();
                    this.notify('page.inactive', [this._sCurrPageId]);
                }
                // tab
                this._oCurrPageWrap = nextPageWrap;
                var lastPageId = this._sCurrPageId;
                this._sCurrPageId = nextPageId;
                this.$selectItem(nextPageWrap);
                // 
                this._oPanelPageSet.remove(nextPageId);
                this._oPanelPageSet.addLast(nextPageWrap, nextPageId);
                this.notify('page.change', [nextPageId, lastPageId]);
            }

            if (forceActive || isChange) {
                // active
                nextPageWrap.page.active(options);
                this.notify('page.active', [nextPageId]);
            }
        }
    };

    /**
     * 
     *
     * @public
     * @return {number} pageId page
     * @return {Object} options 
     */
    PANEL_PAGE_MANAGER_CLASS.goTo = function(pageId, options) {
        this.select(pageId, options);
    };
    
    /**
     * panel page
     *
     * @public
     * @return {number} 
     */
    PANEL_PAGE_MANAGER_CLASS.size = function() {
        return this._oPanelPageSet.size();
    };
    
    /**
     * 
     *
     * @public
     * @param {string} pageId id
     * @return {PanelPage} panelPage
     */
    PANEL_PAGE_MANAGER_CLASS.getPage = function(pageId) {
        return (this._oPanelPageSet.get(pageId) || {}).page;
    };
    
    /**
     * 
     *
     * @public
     * @return {PanelPage} panelPage
     */
    PANEL_PAGE_MANAGER_CLASS.getCurrentPage = function() {
        return this._oCurrPageWrap ? this._oCurrPageWrap.page : null;
    };

    /**
     * ID
     *
     * @public
     * @return {string} pageId
     */
    PANEL_PAGE_MANAGER_CLASS.getCurrentPageId = function() {
        return this._sCurrPageId;
    };
    
    /**
     * 
     *
     * @public
     * @param {string} pageId id
     * @param {string} title 
     */
    PANEL_PAGE_MANAGER_CLASS.setTitle = function(pageId, title) {
        return this.$setTitle(pageId, title);
    };

    /**
     * 
     *
     * @public
     * @param {string} pageId id
     * @return {string} title 
     */
    PANEL_PAGE_MANAGER_CLASS.mark = function(pageId, mark) {
        return this.$mark(pageId, mark);
    };
    
    /**
     * page before change
     *
     * @protected
     */
    PANEL_PAGE_MANAGER_CLASS.$pageBeforeChangeHandler = function() {
        if (this._oCurrPageWrap) {
            // inactive
            this._oCurrPageWrap.page.inactive();
            this.notify('page.inactive', [this._sCurrPageId]);
        }
    };
    
    /**
     * page after change
     *
     * @protected
     */
    PANEL_PAGE_MANAGER_CLASS.$pageAfterChangeHandler = function() {
        var nextPageId = this.$retrievalPageId.apply(this, arguments);
        var lastPageId = this._sCurrPageId;
        var nextPageWrap;
        
        if (nextPageWrap = this._oPanelPageSet.get(nextPageId)) {
            // 
            this._oCurrPageWrap = nextPageWrap;
            this._sCurrPageId = nextPageId;
            this._oPanelPageSet.remove(nextPageId);
            this._oPanelPageSet.addLast(nextPageWrap, nextPageId);
            this.notify('page.change', [nextPageId, lastPageId]);
            // active
            nextPageWrap.page.active();
            this.notify('page.active', [nextPageId]);
        }
    };
    
    /**
     * close
     *
     * @protected
     */
    PANEL_PAGE_MANAGER_CLASS.$pageCloseHandler = function() {
        var closePageId = this.$retrievalPageId.apply(this, arguments);
        
        //  
        if (this._oPanelPageSet.size() <= 1) {
            return false;
        }
        
        var closePageWrap = this._oPanelPageSet.remove(closePageId);

        // fromPageId
        this._oPanelPageSet.foreach(
            function(pageId, wrap, index) {
                if (wrap.page.getFromPageId() == closePageId) {
                    wrap.page.setFromPageId(closePageWrap.page.getFromPageId());
                }
            }
        );

        // 
        closePageWrap.page.dispose();
        
        // 
        if (this._oCurrPageWrap && this._oCurrPageWrap == closePageWrap) {
            this._oCurrPageWrap = null;
            this._sCurrPageId = null;
            this.goTo(this._oPanelPageSet.lastKey());
        }

        this.notify('page.close', [closePageId]);
    };
    
    /**
     * pageId
     *
     * @protected
     * @return {string} pageId
     */
    PANEL_PAGE_MANAGER_CLASS.$genPageId = function() {
        var id = 1;
        while (this._oPanelPageSet.containsKey(id)) { id ++; }
        return id;
    };  
        
    /**
     * 
     *
     * @public
     */
    PANEL_PAGE_MANAGER_CLASS.inject = function(panelPageContainer) {
        // @protected
        this._uPanelPageContainer = panelPageContainer;
    };

    /**
     * pages
     *
     * @public
     */
    PANEL_PAGE_MANAGER_CLASS.forEachPage = function(callback) {
        this._oPanelPageSet.foreach(
            function (id, item, index) {
                callback(id, item.page, index);
            }
        );
    };

})();


/**
 * di.shared.model.TableModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:   Model
 *          
 *          Model
 * @author: sushuang(sushuang@baidu.com)
 * @depend: xui, xutil
 */

$namespace('di.shared.model');

/**
 * @usage prepareArgscmdchangeArgs
 *        persistentgetData
 *
 * 
 *    {Object|Array{Object}} sortInfo 
 *        Object
 *        {string} orderby 'asc''desc'
 *        {string} sortby 
 *        Array
 *        getData
 *    {(Object|PageInfo)} pageInfo 
 *        {number} disabled 
 *        {number} totalRecordCount 
 *        {number} pageSize 
 *        {number} currentPage 1
 */
(function() {
    
    //-------------------------------------------
    // 
    //-------------------------------------------

    var xobject = xutil.object;
    var xlang = xutil.lang;
    var extend = xobject.extend;
    var inheritsObject = xobject.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var sortList = xutil.collection.sortList;
    var hasValue = xlang.hasValue;
    var isArray = xlang.isArray;
    var XDATASOURCE = xui.XDatasource;
    var DICT = di.config.Dict;
    var URL = di.config.URL;
    var PAGE_INFO;

    $link(function() {
        PAGE_INFO = di.shared.model.PageInfo;
    });

    //-------------------------------------------
    // 
    //-------------------------------------------

    /**
     * 
     *
     * @class
     * @extend xui.XDatasource
     */
    var TABLE_MODEL = 
            $namespace().TableModel = 
            inheritsObject(XDATASOURCE, constructor);
    var TABLE_MODEL_CLASS = TABLE_MODEL.prototype;

    TABLE_MODEL_CLASS.DEFAULT_PAGE_SIZE = 20;

    //-------------------------------------------
    // 
    //-------------------------------------------

    /**
     * 
     * 
     * @constructor
     * @private
     */
    function constructor() {
        /**
         * 
         * 
         *
         * @type {Array.<Object>}
         * @private
         */
        this._oDatasource = [];
        /**
         * 
         *
         * @type {Object}
         * @private
         */
        this._oWrap = {
            sortInfo: {},
            pageInfo: new PAGE_INFO(),
            pageData: []
        }
    }

    /**
     * 
     *
     * @public
     * @return {Object} 
     *          {Array} pageData
     *          {Object} sortInfo
     *          {PageInfo} pageInfo
     */
    TABLE_MODEL_CLASS.getData = function() {
        var ret = extend({}, this._oWrap);
        ret.sortInfo = this.$getMainSortInfo(ret.sortInfo);
        return ret;
    };

    /**
     * 
     *
     *
     * @protected
     * @return {Object} 
     *          {Array} pageData
     *          {Object} sortInfo
     *          {PageInfo} pageInfo     
     */
    TABLE_MODEL_CLASS.$getWrap = function() {
        return this._oWrap;
    };

    /**
     * 
     *
     * @public
     * @return {Array.<Object>} 
     */
    TABLE_MODEL_CLASS.getDatasource = function() {
        return this._oDatasource || [];
    };

    /**
     * 
     *
     * @public
     * @param {string} cmd 
     *          'CMD_INIT', 'CMD_SORT', 
     *          'CMD_PAGE_CHANGE', 'CMD_PAGE_SIZE_CHANGE'
     * @param {Object} changeArgs 
     *          
     *          {(Object|Array.<Object>)} sortInfo
     *          {(Object|PageInfo)} pageInfo
     * @return {Object} initArgs
     *          {Object} sortInfo
     *          {PageInfo} pageInfo
     */
    TABLE_MODEL_CLASS.prepareArgs = function(cmd, changeArgs) {
        var wrap = this._oWrap;
        return this['$' + cmd](cmd, changeArgs);
    };

    /**
     * Model
     *
     * @public
     * @param {Object} datasource 
     * @param {Object} initArgs 
     *          {(Object|Array.<Object>)} sortInfo
     *          {(Object|PageInfo)} pageInfo
     * @param {boolean} useRawData false
     */
    TABLE_MODEL_CLASS.persistent = function(datasource, initArgs, useRawData) {
        this._oWrap = extend({}, initArgs);
        this._oDatasource = datasource || this._oDatasource;

        if (useRawData) {
            this._oWrap.pageData = datasource;
        } 
        else {
            this._oWrap.pageInfo.totalRecordCount = this._oDatasource.length;
            this.$sortTable(datasource, this._oWrap.sortInfo);
            this._oWrap.pageData = this.$pagingTable(
                datasource, 
                this._oWrap.pageInfo
            );
        }
    };


    /**
     * initArgs
     *
     * @protected
     */
    TABLE_MODEL_CLASS.$CMD_INIT = function(cmd, changeArgs) {
        var wrap = this._oWrap;
        var initArgs = {};
        var pageSize = wrap.pageInfo.pageSize;
        initArgs.sortInfo = this.$initSortInfo();
        initArgs.pageInfo = this.$initPageInfo();
        pageSize && (initArgs.pageInfo.pageSize = pageSize);
        return initArgs;
    };
    TABLE_MODEL_CLASS.$CMD_SORT = function(cmd, changeArgs) {
        var wrap = this._oWrap;
        var initArgs = {};
        var pageSize = wrap.pageInfo.pageSize;
        if (this.$getMainSortInfo(changeArgs.sortInfo).sortby != 
                this.$getMainSortInfo(wrap.sortInfo).sortby
        ) {
            initArgs.sortInfo = this.$changeSortby(
                this.$getMainSortInfo(changeArgs.sortInfo).sortby
            );
        } else {
            initArgs.sortInfo = wrap.sortInfo;
            this.$getMainSortInfo(initArgs.sortInfo).orderby = 
                this.$changeOrderby(initArgs.sortInfo);
        }
        initArgs.pageInfo = wrap.pageInfo;
        pageSize && (initArgs.pageInfo.pageSize = pageSize);
        return initArgs;
    };
    TABLE_MODEL_CLASS.$CMD_CHANGE_PAGE = function(cmd, changeArgs) {
        var wrap = this._oWrap;
        var initArgs = {};
        var pageSize = wrap.pageInfo.pageSize;
        initArgs.sortInfo = wrap.sortInfo;
        initArgs.pageInfo = wrap.pageInfo;
        initArgs.pageInfo.currentPage = Number(
            changeArgs.pageInfo.currentPage
        );
        pageSize && (initArgs.pageInfo.pageSize = pageSize);
        return initArgs;
    };
    TABLE_MODEL_CLASS.$CMD_CHANGE_PAGE_SIZE = function(cmd, changeArgs) {
        var wrap = this._oWrap; 
        var initArgs = {};
        var pageSize = wrap.pageInfo.pageSize;
        initArgs.sortInfo = this.$initSortInfo();
        initArgs.pageInfo = this.$initPageInfo();
        initArgs.pageInfo.pageSize = Number(
            changeArgs.pageInfo.pageSize
        );
        return initArgs;
    };

    /**
     * pageInfo
     *
     * @protected
     * @return {PageInfo} pageInfo
     */
    TABLE_MODEL_CLASS.$initPageInfo = function() {
        return new PAGE_INFO(
            {
                disabled: false,
                currentPage: 1,
                pageSize: this.DEFAULT_PAGE_SIZE
            }
        );
    };

    /**
     * sortInfo
     * 
     * @protected
     * @return {(Object|Array.<Object>)} sortInfo
     */
    TABLE_MODEL_CLASS.$initSortInfo = function() {
        return { sortby: null, orderby: null, dataField: null };
    };

    /**
     * sortby
     * 
     * @protected
     * @param {string} newSortby
     * @return {(Object|Array.<Object>)} sortInfo
     */
    TABLE_MODEL_CLASS.$changeSortby = function(newSortby) {
        return { sortby: newSortby, orderby: null, dataField: newSortby };
    };

    /**
     * orderby
     * 
     * @protected
     * @param {(Object|Array.<Object>)} oldSortInfo
     * @return {string} orderby
     */
    TABLE_MODEL_CLASS.$changeOrderby = function(oldSortInfo) {
        var sInfo = isArray(oldSortInfo) ? oldSortInfo[0] : oldSortInfo;
        return sInfo.orderby == 'asc' ? 'desc' : 'asc'; 
    };

    /**
     * 
     * sortInfoorderby
     * ascdesc
     * 
     * @protected
     * @param {Array{Object}} datasource
     * @param {(Object|Array.<Object>)} sortInfo
     */
    TABLE_MODEL_CLASS.$sortTable = function(datasource, sortInfo) {
        if (!datasource || !sortInfo) { 
            return; 
        }
        
        var sortInfoArr = isArray(sortInfo) ? sortInfo : [sortInfo];
        for (
            var i = sortInfoArr.length - 1, o, compareFunc; 
            o = sortInfoArr[i]; 
            i --
        ) {
            if (hasValue(o.dataField) && o.orderby) {
                compareFunc = o.orderby == 'asc' ? '<' : '>'; 
                sortList(datasource, o.dataField, compareFunc, false);
            }
        }
    };    
    
    /**
     * 
     * 
     * @protected
     * @param {Array.<Object>} datasource
     * @param {(Object|PageInfo)} pageInfo
     * @return {Array} 
     */
    TABLE_MODEL_CLASS.$pagingTable = function(datasource, pageInfo) {
        var start;
        var length;
        var ret = [];
        if (pageInfo.disabled) {
            start = 0;
            length = datasource.length;
        } else {
            start = (pageInfo.currentPage - 1) * pageInfo.pageSize;
            length = pageInfo.pageSize;
        }
        for (
            var i = 0, o; 
            i < length && (o = datasource[start + i]); 
            i ++
        ) {
            ret.push(o);
        }
        return ret;
    };

    /**
     * sortInfo
     *
     * @protected
     */
    TABLE_MODEL_CLASS.$getMainSortInfo = function(sortInfo) {
        return isArray(sortInfo) ? sortInfo[0] : sortInfo;
    };  

})();


/**
 * di.shared.ui.BaseConfigPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var ecuiCreate = UTIL.ecuiCreate;
    var addClass = xutil.dom.addClass;
    var disposeInnerControl = UTIL.disposeInnerControl;
    var template = xutil.string.template;
    var toShowText = xutil.string.toShowText;
    var q = xutil.dom.q;
    var inheritsObject = xutil.object.inheritsObject;
    var hasValueNotBlank = xutil.lang.hasValueNotBlank;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var alert = di.helper.Dialog.alert;
    var isString = xutil.lang.isString;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var stringToDate = xutil.date.stringToDate;
    var removeDom = xutil.dom.remove;
    var trim = xutil.string.trim;
    var bind = xutil.fn.bind;
    var XVIEW = xui.XView;
    var UI_FORM = ecui.ui.Form;
    var UI_BUTTON = ecui.ui.Button;
        
    $link(function() {
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * (xutil.object.createSingle)
     * 
     * @class
     * @extends xui.XView
     */
    var BASE_CONFIG_PANEL = $namespace().BaseConfigPanel = 
            inheritsObject(XVIEW, constructor);
    var BASE_CONFIG_PANEL_CLASS = BASE_CONFIG_PANEL.prototype;

    //-----------------------------------
    // 
    //-----------------------------------

    var TPL_MAIN = [
            '<div class="q-di-form">',
                '<label>#{0}</label>',
                '<div class="q-di-form-content">#{1}</div>',
                '<div>',
                    '<div class="di-dim-select-btn">',
                        '<div class="q-di-submit"></div>',
                        '<div class="q-di-cancel"></div>',
                    '</div>',
                '<div>',
            '</div>'
        ].join('');

    //-----------------------------------
    // 
    //-----------------------------------

    /**
     * View
     *
     * @abstract
     * @protected
     * @param {Object} options 
     */
    BASE_CONFIG_PANEL_CLASS.$doCreateView = function(options) {
    };

    /**
     * Model
     *
     * @abstract
     * @protected
     * @param {Object} options 
     */
    BASE_CONFIG_PANEL_CLASS.$doCreateModel = function(options) {
    };

    /**
     * model
     *
     * @abstract
     * @protected
     * @return {xui.XDatasource} model
     */
    BASE_CONFIG_PANEL_CLASS.$doGetModel = function() {
        // modelthis._mModel
        return this._mModel;
    };

    /**
     * 
     *
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doInit = function() {
    };

    /**
     * tpl
     *
     * @abstract
     * @protected
     * @param {Object} options 
     * @return {string} html
     */
    BASE_CONFIG_PANEL_CLASS.$doGetContentTPL = function(options) {
        return '';
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doResetInput = function() {
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doOpenSync = function() {
        // 
        var dsId = this.$getDS().INIT;
        if (dsId) {
            this.$doGetModel().sync(
                { 
                    datasourceId: dsId,
                    args: this.$doGetInitArgs()
                }
            );
        }
        else {
            this.$handleInitSuccess({});
        }
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doSubmit = function() {
        var args = this.$doGetSubmitArgs();
        if (isString(args)) {
            // 
            alert(args);
            return;
        }

        var dsId = this.$getDS().SUBMIT;
        var options = { datasourceId: dsId, args: args };
        if (dsId) {
            this.$doGetModel().sync(options);
        }
        else {
            this.$handleSubmitSuccess(null, null, options);
        }
    };

    /**
     * 
     *
     * @protected
     * @event
     */
    BASE_CONFIG_PANEL_CLASS.$doCancel = function() {
        this.close();
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doSubmitSuccess = function(contentEl, data) {
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doEnable = function() {
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doDisable = function() {
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     * @return {Object} { aaa: 1, bbb: '123' }
     */
    BASE_CONFIG_PANEL_CLASS.$doGetInitArgs = function() {
        return {};
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     * @return {Object} { aaa: 1, bbb: '123' }
     */
    BASE_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        return {};
    };

    /**
     * 
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doDispose = function() {
        // 
    };

    //-----------------------------------
    // 
    //-----------------------------------

    /**
     * 
     *
     * @constructor
     * @param {Object} options 
     * @param {Object=} options.model
     * @param {Object=} options.parent
     * @param {string} options.cssName css 
     * @param {string} options.panelTitle  
     */
    function constructor(options) {

        this._mModel = options.model;
        this._uParent = options.parent;

        // Model
        this.$doCreateModel(options);

        this._bOpened = false;

        // dom
        var el = this._el = options.el || document.createElement('div');
        addClass(el, options.cssName || 'di-config-panel')

        document.body.appendChild(el);
        el.innerHTML = template(
            TPL_MAIN, 
            toShowText(options.panelTitle || this.PANEL_TITLE, '', true),
            this.$doGetContentTPL(options)
        );

        // 
        this._uForm = ecuiCreate(
            UI_FORM,
            q('q-di-form', el)[0],
            null,
            { hide: true }
        );
        this._uSubmitBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-submit', el)[0],
            null,
            { primary: 'ui-button-g' }
        );
        this._uCancelBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-cancel', el)[0],
            null,
            { primary: 'ui-button' }
        );
        this._eContent = q('q-di-form-content', el)[0];

        // View
        this.$doCreateView(options);
    }

    /**
     * @override
     */
    BASE_CONFIG_PANEL_CLASS.init = function() {
        var me = this;
        var ds;
        var model = this.$doGetModel();

        this._uSubmitBtn.onclick = bind(this.$doSubmit, this);
        this._uCancelBtn.onclick = bind(this.$doCancel, this);

        this._uForm.onhide = function () {
            me._bOpened = false;
        };

        // Init
        this._uForm.init();
        this._uSubmitBtn.init();
        this._uCancelBtn.init();

        // 
        this.$doInit();

        this.$doResetInput();
    };
    
    /**
     * @override
     */
    BASE_CONFIG_PANEL_CLASS.dispose = function() {
        // 
        this.$doDispose();

        this._uForm && this._uForm.dispose();
        this._uSubmitBtn && this._uSubmitBtn.dispose();
        this._uCancelBtn && this._uCancelBtn.dispose();
        this._eContent = null;
        removeDom(this._el);
        this._el = null;

        BASE_CONFIG_PANEL.superClass.dispose.call(this);
    };

    /**
     * DOM
     *
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.getEl = function() {
        return this._el;
    };

    /**
     * DOM
     *
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.getContentEl = function() {
        return this._eContent;
    };

    /**
     * 
     *
     * @public
     * @param {string} mode 
     *                       'VIEW': 
     *                       'EDIT': 
     */
    BASE_CONFIG_PANEL_CLASS.open = function(mode, options) {
        this._sMode = mode;
        this._bOpened = true;
        var model = this._mModel;

        // 
        // DATASOURCE_ID_MAPPINGopenDATASOURCE_ID_MAPPING
        if (ds = this.$getDS().INIT) {
            model.attachOnce(
                ['sync.preprocess.' + ds, openCheck(this.disable), this],
                ['sync.result.' + ds, openCheck(this.$handleInitSuccess), this],
                ['sync.error.' + ds, openCheck(this.$handleInitError), this],
                ['sync.complete.' + ds, openCheck(this.enable), this]
            );
        }
        if (ds = this.$getDS().SUBMIT) {
            model.attachOnce(
                ['sync.preprocess.' + ds, openCheck(this.disable), this],
                ['sync.result.' + ds, openCheck(this.$handleSubmitSuccess), this],
                ['sync.error.' + ds, openCheck(this.$handleSubmitError), this],
                ['sync.complete.' + ds, openCheck(this.enable), this]
            );
        }

        this.$doOpen(mode, options);

        this.$doResetInput();

        this.$doOpenSync();
    };

    /**
     * 
     *
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.close = function() {
        this._uForm.hide();
    };

    /**
     * 
     *
     * @override
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.enable = function() {
        if (this._bDisabled) {
            this._uSubmitBtn.enable();
            this._uCancelBtn.enable();
            // 
            this.$doEnable();
        }
        BASE_CONFIG_PANEL.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @override
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.disable = function() {
        if (!this._bDisabled) {
            this._uSubmitBtn.disable();
            this._uCancelBtn.disable();
            // 
            this.$doDisable();
        }
        BASE_CONFIG_PANEL.superClass.disable.call(this);
    };    

    /**
     * 
     *
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$handleInitSuccess = function(data) {
        try {
            this._uForm.showModal(DICT.DEFAULT_MASK_OPACITY);

            // 
            this.$doRender(this.getContentEl(), data);

            this._uForm.resize();
            
            this._uForm.center();
        }
        catch (e) {
            // 
            // try catch
            // this.$handleInitError();
        }
    };

    /**
     * 
     *
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$handleInitError = function() {
        var me = this;
        // 
        DIALOG.alert(
            LANG.GET_DIM_TREE_ERROR,
            function() {
                me.close();
            }
        );
    };

    /**
     * 
     *
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$handleSubmitSuccess = function(data, ejsonObj, options) {
        this.$doSubmitSuccess(this.getContentEl(), data, ejsonObj, options);
        this.close();
        /**
         * @event di.shared.ui.BaseConfigPanel#submit.close
         */
        this.notify('submit.close', [data, ejsonObj, options]);
    };

    /**
     * 
     *
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$handleSubmitError = function(status) {
        DIALOG.alert(LANG.SAVE_FAILURE);
    };

    /**
     * @private
     */
    BASE_CONFIG_PANEL_CLASS.$getDS = function(status) {
        return this.DATASOURCE_ID_MAPPING || {};
    };

    /**
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.center = function() {
        this._uForm.center();
    };

    function openCheck(fn) {
        return function () {
            if (this._bOpened) {
                return fn.apply(this, arguments);
            }
        }
    }

})();


/**
 * di.shared.ui.DIChart
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * DI 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_CHART = $namespace().DIChart = 
        inheritsObject(INTERACT_ENTITY);
    var DI_CHART_CLASS = DI_CHART.prototype;
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * interactionapi
     */
    DI_CHART_CLASS.EXPORT_HANDLER = {
        sync: { datasourceId: 'DATA' },
        syncX: { datasourceId: 'X_DATA' },
        syncLiteOlapChart: { datasourceId: 'LITEOLAPCHART_DATA' },
        syncS: { datasourceId: 'S_DATA' },
        syncSAdd: { datasourceId: 'S_ADD_DATA' },
        syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
        clear: {}
    };

    /**
     * 
     */
    DI_CHART_CLASS.DEF = {
        // interactionapi
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncX: { datasourceId: 'X_DATA' },
            syncLiteOlapChart: { datasourceId: 'LITEOLAPCHART_DATA' },
            syncS: { datasourceId: 'S_DATA' },
            syncSAdd: { datasourceId: 'S_ADD_DATA' },
            syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
            clear: {}
        },
        // css
        className: 'di-chart',
        // model
        model: {
            clzPath: 'di.shared.model.DIChartModel'
        }
    };


    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    DI_CHART_CLASS.$createView = function (options) {
        var el = this.$di('getEl');

        this._uChart = this.$di('vuiCreate', 'mainChart');

        // 
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');
    };

    /**
     * 
     *
     * @public
     */
    DI_CHART_CLASS.init = function () {
        var key;
        var exportHandler = this.DEF.exportHandler;
        
        // 
        for (key in exportHandler) {
            var id = exportHandler[key].datasourceId;
            this.getModel().attach(
                ['sync.preprocess.' + id, this.$syncDisable, this, id],
                ['sync.result.' + id, this.$renderMain, this],
                ['sync.result.' + id, this.$handleDataLoaded, this],
                ['sync.error.' + id, this.$handleDataError, this],
                ['sync.complete.' + id, this.$syncEnable, this, id]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        this.getModel().attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        this._uDownloadBtn && (
            this._uDownloadBtn.onclick = bind(this.$handleDownload, this)
        );
        this._uOfflineDownloadBtn && (
            this._uOfflineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                this.getModel(),
                this._uChart, 
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ], 
            'init'
        );
    };

    /**
     * @override
     */
    DI_CHART_CLASS.dispose = function () {
        this._uChart && this._uChart.$di('dispose');
        DI_CHART.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     * @param {Object} options 
     */
    (function () {
        var exportHandler = DI_CHART_CLASS.DEF.exportHandler;
        for (var funcName in exportHandler) {
            DI_CHART_CLASS[funcName] = getSyncMethod(
                exportHandler[funcName].datasourceId
            );
        }
        function getSyncMethod(datasourceId) {
            return function (options) {
                // 
                /*
                var diEvent = this.$di('getEvent');
                var vd = diEvent.viewDisable;
                vd && this.getModel().attachOnce(
                    ['sync.preprocess.' + datasourceId, vd.disable],
                    ['sync.complete.' + datasourceId, vd.enable]
                );*/

                // 
                this.$sync(
                    this.getModel(),
                    datasourceId,
                    (options || {}),
                    this.$di('getEvent')
                );
            };
        }
    })();

    /**
     * 
     * 
     * @public
     */
    DI_CHART_CLASS.clear = function () {  
        this._uChart && this._uChart.$di('setData');
    };

    /**
     * 
     * 
     * @protected
     */
    DI_CHART_CLASS.$renderMain = function (data, ejsonObj, options) {
        this._uChart.$di(
            'setData', 
            this.getModel().getChartData(),
            { diEvent: this.$diEvent(options) }
        );
        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 
     *
     * @public
     */
    DI_CHART_CLASS.resize = function () {
    };

    /**
     * 
     *
     * @protected
     */
    DI_CHART_CLASS.enable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'enable'
        );
        DI_CHART.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @protected
     */
    DI_CHART_CLASS.disable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'disable'
        );
        DI_CHART.superClass.disable.call(this);
    };    

    /**
     * 
     *
     * @protected
     */
    DI_CHART_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('OLAP_CHART_DOWNLOAD') 
            + '?' + commonParamGetter();
        download(url, null, true);

        // reportTemplateId
        commonParamGetter.update();
    };

    /**
     * 
     *
     * @protected
     */
    DI_CHART_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_CHART_CLASS.$handleDataLoaded = function  (data, ejsonObj, options) {
        /**
         * datasourceId
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded.' + options.datasourceId, options)
        );

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataloaded', options));
    };

    /**
     * 
     * 
     * @protected
     */
    DI_CHART_CLASS.$handleDataError = function (status, ejsonObj, options) {

        // 
        this.clear();

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
    };

    /**
     * 
     * 
     * @protected
     */
    DI_CHART_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * di.shared.ui.DIForm
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var isObject = xutil.lang.isObject;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var extend = xutil.object.extend;

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * DI 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {string} options.submitMode 
     *      'IMMEDIATE'
     *      'CONFIRM'
     * @param {(Object|boolean)=} options.confirmBtn 
     *      Object{ text: '' }
     */
    var DI_FORM = $namespace().DIForm = 
        inheritsObject(INTERACT_ENTITY);
    var DI_FORM_CLASS = DI_FORM.prototype;

    /**
     * 
     */
    DI_FORM_CLASS.DEF = {
        // interactionapi
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // css
        className: 'di-form',
        // model
        model: {
            clzPath: 'di.shared.model.DIFormModel'
        }
    };

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    DI_FORM_CLASS.$createView = function (options) {
        this._oOptions = extend({}, options);
        options.submitMode = options.submitMode || 'IMMEDIATE';

        // 
        this._aInput = [];
        for (var i = 0, o; o = this.$di('vuiCreate', 'input.' + i); i ++) {
            this._aInput.push(o);
            // json
            o.$di('setOpt', 'cfgOpt', 'paramMode', 'JSON');
        }

        // 
        this._uConfirmBtn = this.$di('vuiCreate', 'confirm');
    };

    /**
     * 
     *
     * @public
     */
    DI_FORM_CLASS.init = function() {
        var me = this;
        var i;
        var input;
        var def;
        var cfgOpt;

        // 
        this.getModel().attach(
            ['sync.preprocess.DATA', this.$syncDisable, this, 'DATA'],
            ['sync.result.DATA', this.$renderMain, this],
            ['sync.result.DATA', this.$handleDataLoaded, this],
            ['sync.error.DATA', this.$handleDataError, this],
            ['sync.complete.DATA', this.$syncEnable, this, 'DATA'],

            // ASYNCdisablesuggestdisasbleinput            
            // ['sync.preprocess.ASYNC_DATA', this.disable, this, 'DI_FORM'],
            ['sync.result.ASYNC_DATA', this.$renderAsync, this],
            ['sync.error.ASYNC_DATA', this.$handleAsyncError, this]
            // ['sync.complete.ASYNC_DATA', this.enable, this, 'DI_FORM']
        );

        // 
        for (i = 0; input = this._aInput[i]; i ++ ) {
            def = input.$di('getDef');
            cfgOpt = input.$di('getOpt', 'cfgOpt');

            // 
            if (!cfgOpt.changeSilent) {
                input.$di(
                    'addEventListener',
                    'change',
                    this.$handleChange,
                    this
                );
            }

            // 
            if (cfgOpt.async) {
                input.$di(
                    'addEventListener',
                    'async',
                    this.$handleAsync,
                    this,
                    { bindArgs: [input] }
                );
            }
        }

        if (this._uConfirmBtn) {
            this._uConfirmBtn.onclick = function() {
                me.$submit();
            }
        }

        for (i = 0; input = this._aInput[i]; i ++ ) {
            input.$di('init');
        }
    };

    /**
     * @override
     */
    DI_FORM_CLASS.dispose = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
            input.$di('dispose');
        }
        DI_FORM.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     */
    DI_FORM_CLASS.sync = function(options) {

        // 
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA',  vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

        // 
        var paramList = [];
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
            paramList.push(input.$di('getDef').name);
        }

        this.$sync(
            this.getModel(),
            'DATA',
            { paramList: paramList },
            this.$di('getEvent')
        );
    };

    /**
     * 
     *
     * @public
     */
    DI_FORM_CLASS.clear = function(options) {
        // TODO
    };

    /**
     * 
     *
     * @protected
     */
    DI_FORM_CLASS.$submit = function() {
        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', 'submit', [this.$di('getValue')]);
    };

    /**
     * 
     * 
     * @protected
     */
    DI_FORM_CLASS.$renderMain = function(data, ejsonObj, options) {

        var setDataOpt = { diEvent: this.$diEvent(options) };

        // 
        var initData = this.getModel().getInitData();
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
            input.$di(
                'setData',
                initData[input.$di('getDef').name],
                setDataOpt
            );
        }

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 
     * 
     * @protected
     */
    DI_FORM_CLASS.$renderAsync = function(data, ejsonObj, options) {
        var args = options.args;
        args.callback(data[args.input.$di('getDef').name] || {});
    };

    /**
     * 
     *
     * @public
     */
    DI_FORM_CLASS.resize = function() {
    };

    /**
     * 
     *
     * @protected
     */
    DI_FORM_CLASS.enable = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++) {
            input.$di('enable');
        }
        this._uConfirmBtn && this._uConfirmBtn.$di('enable');
        DI_FORM.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @protected
     */
    DI_FORM_CLASS.disable = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++) {
            input.$di('disable');
        }
        this._uConfirmBtn && this._uConfirmBtn.$di('disable');
        DI_FORM.superClass.disable.call(this);
    };    

    /**
     * 
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleDataLoaded = function(data, ejsonObj, options) {
        /**
         * 
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded', options),
            [this.$di('getValue')]
        );
    };

    /**
     * 
     *
     * @event
     * @protected
     */
    DI_FORM_CLASS.$handleChange = function() {
        if (this._oOptions.submitMode == 'IMMEDIATE') {
            this.$submit();
        }
    };

    /**
     * 
     *
     * @event
     * @protected
     */
    DI_FORM_CLASS.$handleAsync = function(input, value, callback) {
        var name = input.$di('getDef').name;
        var arg = {};

        this.$sync(
            this.getModel(),
            'ASYNC_DATA',
            {
                paramName: name,
                arg: value
            },
            null,
            {
                value: value,
                callback: callback,
                input: input
            }
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleDataError = function(status, ejsonObj, options) {
        // 
        this.clear();

        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * async
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleAsyncError = function() {
        // TODO
        this.$di('dispatchEvent', 'rendered');
    };

})();
/**
 * di.shared.ui.DILiteOlapChart
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * DI 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_LITEOLAP_CHART = $namespace().DILiteOlapChart = 
        inheritsObject(INTERACT_ENTITY);
    var DI_LITEOLAP_CHART_CLASS = DI_LITEOLAP_CHART.prototype;
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * interactionapi
     */
    DI_LITEOLAP_CHART_CLASS.EXPORT_HANDLER = {
        sync: { datasourceId: 'DATA' },
        syncX: { datasourceId: 'X_DATA' },
        syncLiteOlapChart: { datasourceId: 'LITEOLAPCHART_DATA' },
        syncS: { datasourceId: 'S_DATA' },
        syncSAdd: { datasourceId: 'S_ADD_DATA' },
        syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
        clear: {}
    };

    /**
     * 
     */
    DI_LITEOLAP_CHART_CLASS.DEF = {
        // interactionapi
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncX: { datasourceId: 'X_DATA' },
            syncLiteOlapChart: { datasourceId: 'LITEOLAPCHART_DATA' },
            syncS: { datasourceId: 'S_DATA' },
            syncSAdd: { datasourceId: 'S_ADD_DATA' },
            syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
            clear: {}
        },
        // css
        className: 'di-chart',
        // model
        model: {
            clzPath: 'di.shared.model.DIChartModel'
        }
    };


    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    DI_LITEOLAP_CHART_CLASS.$createView = function (options) {
        var el = this.$di('getEl');

        this._uChart = this.$di('vuiCreate', 'mainChart');

        // 
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');
    };

    /**
     * 
     *
     * @public
     */
    DI_LITEOLAP_CHART_CLASS.init = function () {
        var key;
        var exportHandler = this.DEF.exportHandler;
        
        // 
        for (key in exportHandler) {
            var id = exportHandler[key].datasourceId;
            this.getModel().attach(
                ['sync.preprocess.' + id, this.$syncDisable, this, id],
                ['sync.result.' + id, this.$renderMain, this],
                ['sync.result.' + id, this.$handleDataLoaded, this],
                ['sync.error.' + id, this.$handleDataError, this],
                ['sync.complete.' + id, this.$syncEnable, this, id]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        this.getModel().attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        this._uDownloadBtn && (
            this._uDownloadBtn.onclick = bind(this.$handleDownload, this)
        );
        this._uOfflineDownloadBtn && (
            this._uOfflineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                this.getModel(),
                this._uChart, 
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ], 
            'init'
        );
    };

    /**
     * @override
     */
    DI_LITEOLAP_CHART_CLASS.dispose = function () {
        this._uChart && this._uChart.$di('dispose');
        DI_LITEOLAP_CHART.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     * @param {Object} options 
     */
    (function () {
        var exportHandler = DI_LITEOLAP_CHART_CLASS.DEF.exportHandler;
        for (var funcName in exportHandler) {
            DI_LITEOLAP_CHART_CLASS[funcName] = getSyncMethod(
                exportHandler[funcName].datasourceId
            );
        }
        function getSyncMethod(datasourceId) {
            return function (options) {
                // 
                /*
                var diEvent = this.$di('getEvent');
                var vd = diEvent.viewDisable;
                vd && this.getModel().attachOnce(
                    ['sync.preprocess.' + datasourceId, vd.disable],
                    ['sync.complete.' + datasourceId, vd.enable]
                );*/

                // 
                this.$sync(
                    this.getModel(),
                    datasourceId,
                    (options || {}),
                    this.$di('getEvent')
                );
            };
        }
    })();

    /**
     * 
     * 
     * @public
     */
    DI_LITEOLAP_CHART_CLASS.clear = function () {  
        this._uChart && this._uChart.$di('setData');
    };

    /**
     * 
     * 
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$renderMain = function (data, ejsonObj, options) {
        this._uChart.$di(
            'setData', 
            this.getModel().getChartData(),
            { diEvent: this.$diEvent(options) }
        );
        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 
     *
     * @public
     */
    DI_LITEOLAP_CHART_CLASS.resize = function () {
    };

    /**
     * 
     *
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.enable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'enable'
        );
        DI_LITEOLAP_CHART.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.disable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'disable'
        );
        DI_LITEOLAP_CHART.superClass.disable.call(this);
    };    

    /**
     * 
     *
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('OLAP_CHART_DOWNLOAD') 
            + '?' + commonParamGetter();
        download(url, null, true);

        // reportTemplateId
        commonParamGetter.update();
    };

    /**
     * 
     *
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleDataLoaded = function  (data, ejsonObj, options) {
        /**
         * datasourceId
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded.' + options.datasourceId, options)
        );

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataloaded', options));
    };

    /**
     * 
     * 
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleDataError = function (status, ejsonObj, options) {

        // 
        this.clear();

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
    };

    /**
     * 
     * 
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * di.shared.ui.DIPlaneTable
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var jsonStringify = baidu.json.stringify;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var ARG_HANDLER_FACTORY;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
    });
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * DI 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_PLANE_TABLE = $namespace().DIPlaneTable = 
        inheritsObject(INTERACT_ENTITY);
    var DI_PLANE_TABLE_CLASS = DI_PLANE_TABLE.prototype;
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     */
    DI_PLANE_TABLE_CLASS.DEF = {
        // interactionapi
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // css
        className: 'di-plane-table',
        // model
        model: {
            clzPath: 'di.shared.model.DIPlaneTableModel'
        }
    };

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    DI_PLANE_TABLE_CLASS.$createView = function (options) {
        var el = this.$di('getEl');

        this._uTable = this.$di('vuiCreate', 'mainTable');

        // 
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // Excel add by MENGRAN at 2013-12-17
        this._uDownloadExcelBtn = this.$di('vuiCreate', 'downloadExcel');

        // 
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');

        // 
        this._uPager = this.$di('vuiCreate', 'pager');
    };

    /**
     * 
     *
     * @public
     */
    DI_PLANE_TABLE_CLASS.init = function () {
        var me = this;
        var key;
        var model = this.getModel();
        var table = this._uTable;
        var downloadBtn = this._uDownloadBtn;
        var downloadExcelBtn = this._uDownloadExcelBtn;
        var offlineDownloadBtn = this._uOfflineDownloadBtn;  
        var pager = this._uPager;

        // 
        for (key in { 
                'DATA': 1, 
                'DRILL': 1, 
                'SORT': 1
            }
        ) {
            model.attach(
                ['sync.preprocess.' + key, this.$syncDisable, this, key],
                ['sync.result.' + key, this.$renderMain, this],
                ['sync.result.' + key, this.$handleDataLoaded, this],
                ['sync.error.' + key, this.$handleDataError, this],
                ['sync.complete.' + key, this.$syncEnable, this, key]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        model.attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        model.attach(
            ['sync.preprocess.CHECK', this.$syncDisable, this, 'CHECK'],
            ['sync.result.CHECK', this.$handleRowAsync, this, false],
            ['sync.error.CHECK', this.$handleRowAsync, this, true],
            ['sync.complete.CHECK', this.$syncEnable, this, 'CHECK']
        );
        model.attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleRowAsync, this, false],
            ['sync.error.SELECT', this.$handleRowAsync, this, true],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );

        model.init();

        table.onsort = bind(this.$handleSort, this);
        table.onrowclick = bind(this.$handleRowClick, this);
        table.onrowselect = bind(this.$handleRowCheck, this, 'rowselect', 'SELECT');
        table.onrowcheck = bind(this.$handleRowCheck, this, 'rowcheck', 'CHECK');
        table.onrowuncheck = bind(this.$handleRowCheck, this, 'rowuncheck', 'CHECK');
        table.oncelllinkbridge = bind(this.$handleLinkBridge, this);

        if (pager) {
            pager.onchange = bind(this.$handlePageChange, this);
            pager.onpagesizechange = bind(this.$handlePageSizeChange, this);
        }

        downloadBtn && (
            downloadBtn.onclick = bind(this.$handleDownload, this)
        );
        downloadExcelBtn && (
            downloadExcelBtn.onclick = bind(this.$handleDownloadExcel, this)
        );
        offlineDownloadBtn && (
            offlineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                table,
                downloadBtn,
                offlineDownloadBtn,
                pager
            ],
            'init'
        );

        this.$di('getEl').style.display = 'none';
    };

    /**
     * @override
     */
    DI_PLANE_TABLE_CLASS.dispose = function () {
        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn
            ],
            'dispose'
        );
        DI_PLANE_TABLE.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     * @event
     * @param {Object} options 
     */
    DI_PLANE_TABLE_CLASS.sync = function (options) {

        // 
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA', vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

        options = assign({ DI_querySessionClear: true }, options);
        if (this._uPager) {
            options.pageSize = this._uPager.getPageSize();
        }

        // 
        this.$sync(this.getModel(), 'DATA', options, this.$di('getEvent'));
    };

    /**
     * 
     *
     * @public
     * @event
     */
    DI_PLANE_TABLE_CLASS.clear = function () {
        foreachDo(
            [
                this._uTable,
                this._uPager
            ],
            'setData'
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$renderMain = function (data, ejsonObj, options) {
        this.$di('getEl').style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn               
            ],
            'diShow'
        );

        var setDataOpt = { diEvent: this.$diEvent(options) };

        // 
        this._uTable.$di('setData', data, setDataOpt);

        // 
        if (this._uPager) {
            if (data.pageInfo) {
                this._uPager.show();
                this._uPager.$di('setData', data.pageInfo, setDataOpt);
            }
            else {
                this._uPager.hide();
            }
        }

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 
     *
     * @public
     */
    DI_PLANE_TABLE_CLASS.resize = function () {
        this._uTable && this._uTable.resize();
    };

    /**
     * 
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.enable = function () {
        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn
            ],
            'enable'
        );
        DI_PLANE_TABLE.superClass.enable.call(this);
    };

    /**
     * 
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.disable = function () {
        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn
            ],
            'disable'
        );
        DI_PLANE_TABLE.superClass.disable.call(this);
    };

    /**
     * DIFactorydimTagsList
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.getDimTagsList = function () {
        var dimTagsList =  ARG_HANDLER_FACTORY(
            [this, "getValue", this.$di("getId"), "table.rowChecked", "dimTagsList"],
            [this, "attrArr", "dimTagsList", "value"]
        )([{}])[0].dimTagsList;

        // dimTagsListjson
        for (var i = 0, o; i < dimTagsList.length; i ++) {
            if (o = dimTagsList[i]) {
                dimTagsList[i] = jsonStringify(o);
            }
        }

        return dimTagsList;
    };

    /**
     * 
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('PLANE_TABLE_DOWNLOAD')
            + '?' + commonParamGetter();
        download(url, null, true);

        // reportTemplateId
        commonParamGetter.update();
    };

    /**
     * Excel
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleDownloadExcel = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('PLANE_TABLE_DOWNLOADEXCEL')
            + '?' + commonParamGetter();
        download(url, null, true);

        // reportTemplateId
        commonParamGetter.update();
    };

    /**
     * 
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 
     *
     * @protected
     * @param {string} linkBridgeType 'I'(internal)'E'(external)
     * @param {string} url url
     * @param {Object} options 
     */
    DI_PLANE_TABLE_CLASS.$handleLinkBridge = function (colDefItem, rowDefItem) {
        // FIXME
        // olap
        this.$di(
            'linkBridge', 
            colDefItem.linkBridge, 
            URL('PLANE_TABLE_LINK_BRIDGE'),
            this.$di('getCommonParamGetter')(
                {
                    colUniqName: colDefItem.uniqueName,
                    rowUniqName: rowDefItem.uniqueName,
                    colDefineId: colDefItem.colDefineId
                }
            )
        );
    };    

    /**  
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleRowClick = function (rowDefItem) {
        /**
         * 
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            'rowclick',
            [{ uniqueName: rowDefItem.uniqueName }]
        );
    };

    /**  
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleRowCheck = function (eventName, datasourceId, rowData, callback) {
        this.$sync(
            this.getModel(),
            datasourceId,
            { uniqueName: rowData.uniqueName },
            null,
            {
                rowData: rowData,
                eventName: eventName,
                callback: callback
            }
        );
    };

    /**  
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleSort = function (orderbyParamKey) {
        this.$sync(
            this.getModel(),
            'DATA',
            { orderbyParamKey: orderbyParamKey }
        );
    };

    /**  
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleRowAsync = function (isFailed, data, ejsonObj, options) {
        var args = options.args;

        // 
        args.callback(data.selected);

        /**
         * line check
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            args.eventName,
            [ assign({}, args.rowData) ]
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handlePageChange = function (currentPage) {
        this.$sync(
            this.getModel(),
            'DATA',
            { 
                currentPage: currentPage,
                pageSize: this._uPager ? this._uPager.getPageSize() : void 0
            }
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handlePageSizeChange = function (pageSize) {
        this.$sync(
            this.getModel(),
            'DATA',
            { pageSize: pageSize }
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleDataLoaded = function (data, ejsonObj, options) {
        var datasourceId = options.datasourceId;    
        var value = this.$di('getValue');
        var args;
        var param = options.args.param;

        if (datasourceId == 'DATA') {
            args = [value];
        }
        else if (datasourceId == 'SORT') {
            args = [assign({}, param, ['field', 'orderby'])];
        }

        /**
         * datasourceId
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            this.$diEvent('dataloaded.' + datasourceId, options),
            args
        );

        if (datasourceId in { DATA: 1, SORT: 1 }) {
            /**
             * DRILL
             *
             * @event
             */
            this.$di(
                'dispatchEvent',
                this.$diEvent('datachange', options),
                [value]
            );
        }

        /**
         * 
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded', options), 
            [value]
        );

        /**
         * sql
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('outputexecinfo', options), 
            [{ data: data }]
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleDataError = function (status, ejsonObj, options) {
        this.$di('getEl').style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn
            ],
            'diShow'
        ); 

        // 
        this.clear();

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
    };

    /**
     * 
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * di.shared.ui.DITable
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI OLAP
 *          
 *          DIPivotTableDIOlapTable
 *          DIPlaneTable
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var ARG_HANDLER_FACTORY;
    var alert = di.helper.Dialog.alert;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * DI 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_RTPLCLONE = $namespace().DIRtplClone = 
        inheritsObject(INTERACT_ENTITY);
    var DI_RTPLCLONE_CLASS = DI_RTPLCLONE.prototype;
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     */
    DI_RTPLCLONE_CLASS.DEF = {
        // css
        className: 'di-rtplclone',
        // model
        model: {
            clzPath: 'di.shared.model.DIRtplCloneModel'
        }
    };

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    DI_RTPLCLONE_CLASS.$createView = function (options) {
        var el = this.$di('getEl');
         // 
        this._saveRtplCloneBtn = this.$di('vuiCreate', 'saveRtplClone');
        this._clearRtplCloneBtn = this.$di('vuiCreate', 'clearRtplClone');
    };

    /**
     * 
     *
     * @public
     */
    DI_RTPLCLONE_CLASS.init = function () {
        var me = this;
        var key;
        var model = this.getModel();
        var saveRtplCloneBtn = this._saveRtplCloneBtn;
        var clearRtplCloneBtn = this._clearRtplCloneBtn;

        foreachDo(
            [
             	saveRtplCloneBtn,
             	clearRtplCloneBtn
            ],
            'init'
        );
        // 
        model.attach(
            ['sync.preprocess.SAVE', this.disable, this],
            ['sync.result.SAVE', this.$handleSaveSuccess, this],
            ['sync.error.SAVE', this.$handleError, this],
            ['sync.complete.SAVE', this.enable, this]
        );
        model.attach(
            ['sync.preprocess.GET_DEFAUL_IMAGENAME', this.disable, this],
            ['sync.result.GET_DEFAUL_IMAGENAME', this.$handleClear, this],
            ['sync.error.GET_DEFAUL_IMAGENAME', this.$handleError, this],
            ['sync.complete.GET_DEFAUL_IMAGENAME', this.enable, this]
        );
        model.attach(
            ['sync.preprocess.CLEAR', this.disable, this],
            ['sync.result.CLEAR', this.$handleClearSuccess, this],
            ['sync.error.CLEAR', this.$handleError, this],
            ['sync.complete.CLEAR', this.enable, this]
        );
        saveRtplCloneBtn && (
        		saveRtplCloneBtn.onclick = bind(this.$handleSaveRtplClone, this)
        );
        clearRtplCloneBtn && (
        		clearRtplCloneBtn.onclick = bind(this.$handleClearRtplClone, this)
        );
    };

    /**
     * @override
     */
    DI_RTPLCLONE_CLASS.dispose = function () {
        foreachDo(
            [
                this._saveRtplCloneBtn,
                this._clearRtplCloneBtn,
            ],
            'dispose'
        );
    	DI_RTPLCLONE.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     * @event
     * @param {Object} options 
     */
    DI_RTPLCLONE_CLASS.sync = function (options) {

        // 
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA', vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

    };

    /**
     * 
     *
     * @public
     * @event
     */
    DI_RTPLCLONE_CLASS.clear = function () {
    };

    /**
     * 
     * 
     * @protected
     */
    DI_RTPLCLONE_CLASS.$handleSaveSuccess = function (data, ejsonObj, options) {
        alert(LANG.SMILE_FACE + '');
    };


    DI_RTPLCLONE_CLASS.$handleClearSuccess = function (data, ejsonObj, options) {
        alert(LANG.SMILE_FACE + '');
    };

    DI_RTPLCLONE_CLASS.$handleClear = function (data, ejsonObj, options) {
        //alert(data.defaultImageName);
        var reportImageName = data.defaultImageName;
        var commonParamGetter = this.$di('getCommonParamGetter');
        var model = this.getModel();
         // 
        model.sync(
            { 
                datasourceId: 'CLEAR', 
                args: {
                    reportImageName: reportImageName
                }
            }
        );
        commonParamGetter.update();
    };

    /**
     * 
     * 
     * @protected
     */
    DI_RTPLCLONE_CLASS.$handleError = function (data, ejsonObj, options) {
        //alert('');
    };

    /**
     * 
     *
     * @public
     */
    DI_RTPLCLONE_CLASS.resize = function () {

    };

    /**
     * 
     *
     * @protected
     */
    DI_RTPLCLONE_CLASS.enable = function () {
        foreachDo(
            [
                this._saveRtplCloneBtn,
                this._clearRtplCloneBtn
            ],
            'enable'
        ); 
    	DI_RTPLCLONE.superClass.enable.call(this);
    };

    /**
     * 
     *
     * @protected
     */
    DI_RTPLCLONE_CLASS.disable = function () {
        foreachDo(
            [
                this._saveRtplCloneBtn,
                this._clearRtplCloneBtn
            ],
            'disable'
        ); 
    	DI_RTPLCLONE.superClass.disable.call(this);
    };

    /**
     * 
     *
     * @protected
     */
    DI_RTPLCLONE_CLASS.$handleSaveRtplClone = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');
        var model = this.getModel();
         // 
        model.sync(
            { 
                datasourceId: 'SAVE', 
                args: {
                    asDefault: true
                }
            }
        );
        commonParamGetter.update();

    };
    
    /**
     * 
     *
     * @protected
     */
    DI_RTPLCLONE_CLASS.$handleClearRtplClone = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');
        var model = this.getModel();
         // 
        model.sync(
            { 
                datasourceId: 'GET_DEFAUL_IMAGENAME', 
                args: {
                    asdadasda: 'asdadadad'
                }
            }
        );
        commonParamGetter.update();
    };

})();
/**
 * di.shared.ui.DITab
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI tab
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var ecuiDispose = UTIL.ecuiDispose;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var ecuiCreate = UTIL.ecuiCreate;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var TAB_CONTAINER = ecui.ui.TabContainer;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * DI tab
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {boolean=} options.autoDeaf deaf
     *                  deaftrue
     * @param {boolean=} options.autoComponentValueDisabled componentvalueDisabled
     *                  value disablefalse
     * @param {boolean=} options.autoVUIValueDisabled vuivalueDisabled
     *                  value disabletrue
     */
    var DI_TAB = $namespace().DITab = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var DI_TAB_CLASS = DI_TAB.prototype;
    
    /**
     * 
     */
    DI_TAB_CLASS.DEF = {
        // css
        className: 'di-tab'
    };

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @constructor
     * @public
     * @param {Object} options 
     */
    function constructor(options) {
        var el = this.$di('getEl');
        var o = document.createElement('div');
        el.appendChild(o);

        this._bAutoDeaf = options.autoDeaf == null ? true : options.autoDeaf;
        this._bAutoComponentValueDisabled = 
            options.autoComponentValueDisabled == null
                ? false : options.autoComponentValueDisabled;
        this._bAutoVUIValueDisabled = 
            options.autoVUIValueDisabled == null
                ? true : options.autoVUIValueDisabled;

        this._aTab = [];        
        // TODO
        // vuiecui
        this._uTab = ecuiCreate(TAB_CONTAINER, o);
        this._aBodyPart = [];

        // tab vpart
        var tabs = this.$di('getRef', 'vpartRef', 'tab');
        var bodys = this.$di('getRef', 'vpartRef', 'body');
        for (var i = 0, tabDef, bodyDef; tabDef = tabs[i]; i ++) {
            bodyDef = bodys[i];
            this._aTab.push(
                this._uTab.addTab(
                    null, 
                    assign(
                        {
                            tabEl: tabDef.el,
                            contentEl: bodyDef.el
                        },
                        tabDef.$di('getOpt', 'dataOpt'),
                        ['title', 'canClose']
                    )
                )
            );

            this._aBodyPart.push(this.$di('vpartCreate', 'body.' + i));
        }
    };

    /**
     * 
     *
     * @public
     */
    DI_TAB_CLASS.init = function() {
        var me = this;

        // 
        this._uTab.onafterchange = function(ctrlItem, lastCtrlItem) {

            // 
            me.$resetDisabled();

            for (
                var i = 0, item, bodyPart; 
                bodyPart = me._aBodyPart[i], item = me._aTab[i]; 
                i ++
            ) {
                /** 
                 * vpart
                 * 
                 * @event
                 */
                if (item.tabItem == ctrlItem) {
                    bodyPart.$di('dispatchEvent', 'active');
                }
                /** 
                 * vpart
                 * 
                 * @event
                 */
                if (item.tabItem == lastCtrlItem) {
                    bodyPart.$di('dispatchEvent', 'inactive');
                }
            }

            /**
             * 
             *
             * @event
             */
            me.$di('dispatchEvent', 'rendered');
            /**
             * tab
             *
             * @event
             */
            me.$di('dispatchEvent', 'change');
        }

        var opt = this.$di('getOpt', 'dataOpt');
        // 
        var selIndex = opt.selected - 1;
        var sel;
        if (sel = this._aTab[selIndex]) {
            this._uTab.selectTab(sel.tabItem);
            me.$di('dispatchEvent', 'rendered');
        }

        this.$resetDisabled();

        sel && this._aBodyPart[selIndex].$di('dispatchEvent', 'active');
    };

    /**
     * @protected
     */
    DI_TAB_CLASS.$resetDisabled = function() {
        var key = this.$di('getId');
        var bodys = this.$di('getRef', 'vpartRef', 'body', 'DEF');

        for (var i = 0, tab, inners, notCurr; tab = this._aTab[i]; i ++) {
            notCurr = this._uTab.getSelected() != tab.tabItem;

            inners = bodys[i].$di(
                'getRef', 'componentRef', 'inner', 'INS'
            ) || [];

            for (var j = 0; j < inners.length; j ++) {
                if (inners[j]) {
                    this._bAutoDeaf 
                        && inners[j].$di('setDeaf', notCurr, key);
                    this._bAutoComponentValueDisabled 
                        && inners[j].$di('setValueDisabled', notCurr, key);
                }
            }

            if (this._bAutoVUIValueDisabled) {
                inners = bodys[i].$di(
                    'getRef', 'vuiRef', 'inner', 'INS'
                ) || [];

                for (var j = 0; j < inners.length; j ++) {
                    inners[j] && inners[j].$di('setValueDisabled', notCurr, key);
                }
            }
        }    
    };

    /**
     * @override
     */
    DI_TAB_CLASS.dispose = function() {
        this._uTab && ecuiDispose(this._uTab);
        this._aTab = [];
        DI_TAB.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     */
    DI_TAB_CLASS.resize = function() {
        this._uTab && this._uTab.resize();
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    DI_TAB_CLASS.enable = function(key) {
        this._uTab && this._uTab.enable();
        DI_TAB.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    DI_TAB_CLASS.disable = function(key) {
        this._uTab && this._uTab.disable();
        DI_TAB.superClass.disable.call(this);
    };

})();
/**
 * di.shared.ui.DITable
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI OLAP
 *          
 *          DIPivotTableDIOlapTable
 *          DIPlaneTable
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var ARG_HANDLER_FACTORY;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * DI 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_TABLE = $namespace().DITable = 
        inheritsObject(INTERACT_ENTITY);
    var DI_TABLE_CLASS = DI_TABLE.prototype;
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     */
    DI_TABLE_CLASS.DEF = {
        // interactionapi
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // css
        className: 'di-table',
        // model
        model: {
            clzPath: 'di.shared.model.DITableModel'
        }
    };

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    DI_TABLE_CLASS.$createView = function (options) {
        var el = this.$di('getEl');
        //ajax
        this._needMeasureDes = this.$di('getDef').needMeasureDes;
        this._uTable = this.$di('vuiCreate', 'mainTable');

        // 
        this._uBreadcrumb = this.$di('vuiCreate', 'breadcrumb', { maxShow: 5 });

        // 
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');

        // 
        // totalRecordCount, currRecordCount
        this._uCountInfo = this.$di('vuiCreate', 'countInfo');
    };

    /**
     * 
     *
     * @public
     */
    DI_TABLE_CLASS.init = function () {
        var me = this;
        var key;
        var model = this.getModel();
        var table = this._uTable;
        var breadcrumb = this._uBreadcrumb;
        var countInfo = this._uCountInfo;
        var downloadBtn = this._uDownloadBtn;
        var offlineDownloadBtn = this._uOfflineDownloadBtn;                

        // 
        for (key in { 
                'DATA': 1, 
                'DRILL': 1, 
                'LINK_DRILL': 1,
                'SORT': 1
            }
        ) {
            model.attach(
                ['sync.preprocess.' + key, this.$syncDisable, this, key],
                ['sync.result.' + key, this.$renderMain, this],
                ['sync.result.' + key, this.$handleDataLoaded, this],
                ['sync.error.' + key, this.$handleDataError, this],
                ['sync.complete.' + key, this.$syncEnable, this, key]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        model.attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        model.attach(
            ['sync.preprocess.CHECK', this.$syncDisable, this, 'CHECK'],
            ['sync.result.CHECK', this.$handleRowAsync, this, false],
            ['sync.error.CHECK', this.$handleRowAsync, this, true],
            ['sync.complete.CHECK', this.$syncEnable, this, 'CHECK']
        );
        model.attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleRowAsync, this, false],
            ['sync.error.SELECT', this.$handleRowAsync, this, true],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );

        if(this._needMeasureDes && this._needMeasureDes == true){
           model.attach(
                ['sync.result.MEASURE_DES', this.$setMeasureDes4Table, this]
            ); 
        }
        


        model.init();

        table.onexpand = bind(this.$handleExpand, this);
        table.oncollapse = bind(this.$handleCollapse, this);
        table.onsort = bind(this.$handleSort, this);
        table.onrowclick = bind(this.$handleRowClick, this);
        table.onrowselect = bind(this.$handleRowCheck, this, 'rowselect', 'SELECT');
        table.onrowcheck = bind(this.$handleRowCheck, this, 'rowcheck', 'CHECK');
        table.onrowuncheck = bind(this.$handleRowCheck, this, 'rowuncheck', 'CHECK');
        table.oncelllinkdrill = bind(this.$handleLinkDrill, this);
        table.oncelllinkbridge = bind(this.$handleLinkBridge, this);

        breadcrumb && (
            breadcrumb.onchange = bind(this.$handleBreadcrumbChange, this)
        );
        downloadBtn && (
            downloadBtn.onclick = bind(this.$handleDownload, this)
        );
        offlineDownloadBtn && (
            offlineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                table,
                breadcrumb,
                countInfo,
                downloadBtn,
                offlineDownloadBtn
            ],
            'init'
        )
        breadcrumb && breadcrumb.hide();

        this.$di('getEl').style.display = 'none';
    };

    /**
     * @override
     */
    DI_TABLE_CLASS.dispose = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'dispose'
        )
        DI_TABLE.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     * @event
     * @param {Object} options 
     */
    DI_TABLE_CLASS.sync = function (options) {

        // 
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA', vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

        // 
        this.$sync(
            this.getModel(),
            'DATA',
            options || {},
            this.$di('getEvent')
        );
    };

    /**
     * 
     *
     * @public
     * @event
     */
    DI_TABLE_CLASS.clear = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo
            ],
            'setData'
        ); 
    };

    /**
     * 
     * 
     * @protected
     */
    DI_TABLE_CLASS.$renderMain = function (data, ejsonObj, options) {
        this.$di('getEl').style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn                
            ],
            'diShow'
        ); 

        var setDataOpt = { diEvent: this.$diEvent(options) };

        /*
         *   
         * 
         * setData
         * setData
         * 
         * 1-3px
         * 
         *   
         */
        var UI_SCROLLBAR_CLASS = ecui.ui.Scrollbar.prototype;
        var lastScrollTop = this._uTable._uVScrollbar.getValue();   //  
        var lastScrollLeft = this._uTable._uHScrollbar.getValue();  //  
        
        // 
        this._uTable.$di('setData', data.tableData, setDataOpt);

        /*
         * ecui.ui.Scrollbar.prototype.setValue  table.js  UI_TABLE_SCROLL_SETVALUE 
         *  this._uTable._uVScrollbar.setValue(lastScrollTop)
         *  UI_TABLE_SCROLL_SETVALUE   lastScrollTop
         */
        UI_SCROLLBAR_CLASS.setValue.call(this._uTable._uVScrollbar, lastScrollTop);
        UI_SCROLLBAR_CLASS.setValue.call(this._uTable._uHScrollbar, lastScrollLeft);
        //  -----------------  -----------------

        // jsonneedMeasureDestrue
        if(this._needMeasureDes && this._needMeasureDes == true){
            // olaptableajax
            var paramArr = [];
                for (var j = 0; j < this._uTable._aColDefine.length; j++) {
                    if(this._uTable._aColDefine[j] && this._uTable._aColDefine[j].uniqueName){
                       paramArr.push('colUniqueNames='+this._uTable._aColDefine[j].uniqueName); 
                    }
                };
            this.$sync(
                this.getModel(),
                'MEASURE_DES',
                { colUniqueNamesArr: paramArr},
                null,
                null,
                { 
                    ajaxOptions:{
                        showWaiting : false
                    }
                    
                }
            );
        }
        // 
        if (this._uBreadcrumb) {
            if (data.breadcrumbData.datasource
                && data.breadcrumbData.datasource.length > 0
            ) {
                this._uBreadcrumb.show();
                this._uBreadcrumb.$di('setData', data.breadcrumbData, setDataOpt);
            }
            else {
                this._uBreadcrumb.hide();
            }
        }

        // 
        this._uCountInfo && this._uCountInfo.$di(
            'setData', 
            {
                args: {
                    totalRecordCount: data.pageInfo.totalRecordCount,
                    currRecordCount: data.pageInfo.currRecordCount
                }
            },
            setDataOpt
        );

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 
     *
     * @public
     */
    DI_TABLE_CLASS.resize = function () {
        this._uTable && this._uTable.resize();
    };

    /**
     * 
     *
     * @protected
     */
    DI_TABLE_CLASS.enable = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'enable'
        ); 
        DI_TABLE.superClass.enable.call(this);
    };

    /**
     * 
     *
     * @protected
     */
    DI_TABLE_CLASS.disable = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'disable'
        ); 
        DI_TABLE.superClass.disable.call(this);
    };

    /**
     * DIFactorydimTagsList
     *
     * @protected
     */
    DI_TABLE_CLASS.getDimTagsList = function () {
        return ARG_HANDLER_FACTORY(
            [this, "getValue", this.$di("getId"), "table.rowChecked", "dimTagsList"],
            [this, "attrArr", "dimTagsList", "value.uniqueName"]
        )([{}])[0].dimTagsList;
    };

    /**
     * 
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('OLAP_TABLE_DOWNLOAD') 
            + '?' + commonParamGetter();
        download(url, null, true);

        // reportTemplateId
        commonParamGetter.update();
    };

    /**
     * 
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleBreadcrumbChange = function (wrap) {
        this.$sync(
            this.getModel(),
            'LINK_DRILL',
            {
                action: 'EXPAND',
                // uniq
                uniqueName: wrap['uniqName']
            }
        );
    };  

    /**
     * link
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleLinkDrill = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'LINK_DRILL',
            {
                action: 'EXPAND',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']
            }
        );
    };        

    /**
     * 
     *
     * @protected
     * @param {string} linkBridgeType 'I'(internal)'E'(external)
     * @param {string} url url
     * @param {Object} options 
     */
    DI_TABLE_CLASS.$handleLinkBridge = function (colDefItem, rowDefItem) {
        this.$di(
            'linkBridge', 
            colDefItem.linkBridge, 
            URL('OLAP_TABLE_LINK_BRIDGE'),
            this.$di('getCommonParamGetter')(
                {
                    colUniqName: colDefItem.uniqueName,
                    rowUniqName: rowDefItem.uniqueName,
                    colDefineId: colDefItem.colDefineId
                },
                {
                    excludes: ['diAgent']
                }
            )
        );
    };    

    /**
     * 
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleExpand = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'DRILL',
            {
                action: 'EXPAND',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']
            }
        );
    };

    /**
     * 
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleCollapse = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'DRILL',
            {
                action: 'COLLAPSE',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']
            }
        );
    };

    /**  
     * 
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowClick = function (rowDefItem) {
        /**
         * 
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            'rowclick',
            [{ uniqueName: rowDefItem.uniqueName }]
        );
    };

    /**  
     * 
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowCheck = function (eventName, datasourceId, rowDefItem, callback) {
        if(rowDefItem.uniqueName == 'SUMMARY_CUST: [SUMMARY_NODE].[ALL]'){
            //
        }
        else{
            this.$sync(
                this.getModel(),
                datasourceId, 
                { uniqueName: rowDefItem.uniqueName },
                null,
                {
                    eventName: eventName,
                    callback: callback
                }
            );
       }
        
    };

    /**  
     * 
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleSort = function (colDefineItem) {
        this.$sync(
            this.getModel(),
            'SORT',
            colDefineItem
        );
    };
    /**
    * olaptdtitle
    */
    DI_TABLE_CLASS.$setMeasureDes4Table = function (data, ejsonObj, options) {
        this._uTable.$setMeasureDes4Table(data);
    };

    /**  
     * 
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowAsync = function (isFailed, data, ejsonObj, options) {

        // 
        options.args.callback(data.selected);

        /**
         * line check
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            options.args.eventName,
            [{ uniqueName: options.args.param.uniqueName }]
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleDataLoaded = function (data, ejsonObj, options) {
        var datasourceId = options.datasourceId;     
        var value = this.$di('getValue');
        var args;
        var param = options.args.param;

        if (datasourceId == 'DATA') {
            args = [value];
        }
        else if (datasourceId == 'LINK_DRILL') {
            args = [assign({}, param, ['uniqueName'])];
        }
        else if (datasourceId == 'DRILL') {
            args = [assign({}, param, ['uniqueName', 'lineUniqueName'])];
        }
        else if (datasourceId == 'SORT') {
            args = [assign({}, param, ['uniqueName', 'currentSort'])];
        }

        /**
         * datasourceId
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            this.$diEvent('dataloaded.' + datasourceId, options),
            args
        );

        if (datasourceId in { DATA: 1, LINK_DRILL: 1, SORT: 1 }) {
            /**
             * DRILL
             *
             * @event
             */
            this.$di(
                'dispatchEvent', 
                this.$diEvent('datachange', options), 
                [value]
            );
        }

        /**
         * 
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded', options), 
            [value]
        );
    };

    /**
     * 
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleDataError = function (status, ejsonObj, options) {
        this.$di('getEl').style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'diShow'
        ); 

        // 
        this.clear();

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
    };

    /**
     * 
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * di.shared.ui.FoldPanel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {boolean=} options.autoDeaf deaf
     *                  deaftrue
     * @param {boolean=} options.autoComponentValueDisabled componentvalueDisabled
     *                  value disablefalse
     * @param {boolean=} options.autoVUIValueDisabled vuivalueDisabled
     *                  value disabletrue
     */
    var FOLD_PANEL = $namespace().FoldPanel = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var FOLD_PANEL_CLASS = FOLD_PANEL.prototype;

    /**
     * 
     */
    FOLD_PANEL_CLASS.DEF = {
        // css
        className: 'di-fold-panel'
    };

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @constructor
     * @public
     * @param {Object} options 
     */
    function constructor(options) {
        var el = this.$di('getEl');
        var o = document.createElement('div');
        el.appendChild(o);

        this._bFolded = true;
        this._bAutoDeaf = options.autoDeaf == null 
            ? true : options.autoDeaf;
        this._bAutoComponentValueDisabled = 
            options.autoComponentValueDisabled == null
                ? false : options.autoComponentValueDisabled;
        this._bAutoVUIValueDisabled = 
            options.autoVUIValueDisabled == null
                ? true : options.autoVUIValueDisabled;

        this._oBodyDef = this.$di('getRef', 'vpartRef', 'body', 'DEF');
        this._oCtrlBtnDef = this.$di('getRef', 'vpartRef', 'ctrlBtn', 'DEF');

        var defaultHide = options.defaultHide == null
                ? true : options.defaultHide;

        this.$createCtrlBtn();
        this.$resetCtrlBtnText();
        this.$ctrlBtnChange(defaultHide);
    };

    /**
     * 
     *
     * @public
     */
    FOLD_PANEL_CLASS.init = function() {
        this.$resetDisabled();
    };

    /**
     * ctrlBtn
     *
     * @protected
     */
    FOLD_PANEL_CLASS.$createCtrlBtn = function() {
        // ctrlBtn
        this._oCtrlBtnDef.el.innerHTML = [
            '<a href="#" class="di-fold-panel-ctrl-btn">',
                '<span class="di-fold-panel-ctrl-btn-text">&nbsp;</span>',
            '</a>',
            '<span class="di-fold-panel-ctrl-down"></span>'
        ].join('');

        var el = this._oCtrlBtnDef.el.firstChild;
        var me = this;
        el.onclick = function() {
            if (!me._bDisabled) { 
                me.$ctrlBtnChange();
                me.$resetDisabled();
            }
            return false;
        }
    };

    /**
     * @override
     */
    FOLD_PANEL_CLASS.dispose = function() {
        this._oCtrlBtnDef = null;
        this._oBodyDef = null;
        FOLD_PANEL.superClass.dispose.call(this);
    };

    /**
     * @protected
     */
    FOLD_PANEL_CLASS.$resetDisabled = function() {
        var inners;
        var key = this.$di('getId');

        inners = this._oBodyDef.$di(
            'getRef', 'componentRef', 'inner', 'INS'
        ) || [];

        for (var j = 0; j < inners.length; j ++) {
            if (inners[j]) {
                this._bAutoDeaf 
                    && inners[j].$di('setDeaf', this._bFolded, key);
                this._bAutoComponentValueDisabled
                    && inners[j].$di('setValueDisabled', this._bFolded, key);
            }
        }

        if (this._bAutoVUIValueDisabled) {
            inners = this._oBodyDef.$di(
                'getRef', 'vuiRef', 'inner', 'INS'
            ) || [];

            for (var j = 0; j < inners.length; j ++) {
                inners[j] && inners[j].$di('setValueDisabled', this._bFolded, key);
            }
        }
    };

    /**
     * 
     *
     * @public
     */
    FOLD_PANEL_CLASS.resize = function() {
    };

    /**
     * ctrlBtn
     *
     * @protected
     */    
    FOLD_PANEL_CLASS.$resetCtrlBtnText = function() {
        var btnDef = this._oCtrlBtnDef;
        var dataOpt = btnDef.$di('getOpt', 'dataOpt');

        // 
        // TODO
        btnDef.el.firstChild.firstChild.innerHTML = this._bFolded
            ? dataOpt.expandText 
            : dataOpt.collapseText;
        btnDef.el.lastChild.className = this._bFolded
            ? 'di-fold-panel-ctrl-down'
            : 'di-fold-panel-ctrl-up';
    };

    /**
     * 
     *
     * @protected
     * @param {boolean=} toFold 
     */
    FOLD_PANEL_CLASS.$ctrlBtnChange = function(toFold) {
        var style = this._oBodyDef.el.style;

        this._bFolded = toFold == null ? !this._bFolded : toFold;

        this.$resetCtrlBtnText();

        style.display = this._bFolded ? 'none' : '';

        /**
         * 
         *
         * @event
         */
        this.$di('dispatchEvent', 'rendered');
    };

})();
/**
 * di.shared.ui.GeneralSnippet
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * DI 
     * 
     * @class
     * @extends xui.XView
     */
    var SNIPPET = $namespace().GeneralSnippet = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var SNIPPET_CLASS = SNIPPET.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @constructor
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        // ...
    };
    
    /**
     * @override
     */
    SNIPPET_CLASS.dispose = function() {
    };

})();
/**
 * di.shared.ui.GeneralVContainer
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    VCONTAINER
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var XVIEW = xui.XView;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * VCONTAINER
     * 
     * @class
     * @extends xui.XView
     */
    var GENERAL_VCONTAINER = $namespace().GeneralVContainer = 
            inheritsObject(XVIEW, constructor);
    var GENERAL_VCONTAINER_CLASS = GENERAL_VCONTAINER.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @constructor
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        this._oOptions = assign({}, options);
    };
    
    /**
     * @override
     */
    GENERAL_VCONTAINER_CLASS.dispose = function() {
        this.$di('disposeMainEl');
    };

})();
/**
 * di.shared.ui.GeneralVPart
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    VCONTAINER
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var XVIEW = xui.XView;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * VCONTAINER
     * 
     * @class
     * @extends xui.XView
     */
    var GENERAL_VPART = $namespace().GeneralVPart = 
            inheritsObject(XVIEW, constructor);
    var GENERAL_VPART_CLASS = GENERAL_VPART.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @constructor
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        this._oOptions = assign({}, options);
    };
    
    /**
     * @override
     */
    GENERAL_VPART_CLASS.dispose = function() {
        this.$di('disposeMainEl');
    };

})();
/**
 * di.shared.ui.OlapMetaConfig
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var ecuiDispose = UTIL.ecuiDispose;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var ecuiCreate = UTIL.ecuiCreate;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var getUID = xutil.uid.getIncreasedUID;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {Object} options.reportType 
     *          TABLE()CHART
     * @param {string} options.submitMode 
     *      'IMMEDIATE'
     *      'CONFIRM'
     * @param {boolean} options.needShowCalcInds 
     */
    var LITEOLAP_META_CONFIG = $namespace().LiteOlapMetaConfig = 
        inheritsObject(INTERACT_ENTITY);
    var LITEOLAP_META_CONFIG_CLASS = LITEOLAP_META_CONFIG.prototype;
    
    /**
     * 
     */
    LITEOLAP_META_CONFIG_CLASS.DEF = {
        // interactionapi
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncLiteOlapInds: { datasourceId: 'LITEOLAP_INDS_DATA' },
            clear: {}
        },
        // css
        className: 'olap-meta-config',
        // model
        model: {
            clzPath: 'di.shared.model.OlapMetaConfigModel'
        }
    };

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     * @param {Object} options 
     */
    LITEOLAP_META_CONFIG_CLASS.$createModelInitOpt = function (options) {
        return { reportType: options.reportType };
    };
    
    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    LITEOLAP_META_CONFIG_CLASS.$createView = function (options) {
        /**
         * 
         *
         * @type {boolean}
         * @private
         */
        this._bNeedShowCalcInds = options.needShowCalcInds || false;
        /**
         * datasourceId
         *
         * @type {Object}
         * @private
         */
        var did = this._oDatasourceId = options.datasourceId || {};
        did.DATA = did.DATA || 'DATA';
        did.SELECT = did.SELECT || 'SELECT';
        /**
         * 
         * 
         * @type {string}
         * @private 
         */
        this._sSubmitMode = options.submitMode;

        this._uOlapMetaSelector = this.$di('vuiCreate', 'main');
    };
    
    /**
     * 
     *
     * @public
     */
    LITEOLAP_META_CONFIG_CLASS.init = function () {
        // 
        this.getModel().attach(
            ['sync.preprocess.DATA', this.$syncDisable, this, 'DATA'],
            ['sync.result.DATA', this.$renderMain, this],
            ['sync.error.DATA', this.$handleMetaError, this],
            ['sync.complete.DATA', this.$syncEnable, this, 'DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.LITEOLAP_INDS_DATA', this.$syncDisable, this, 'LITEOLAP_INDS_DATA'],
            ['sync.result.LITEOLAP_INDS_DATA', this.$renderLiteOlapMain, this],
            ['sync.error.LITEOLAP_INDS_DATA', this.$handleMetaError, this],
            ['sync.complete.LITEOLAP_INDS_DATA', this.$syncEnable, this, 'LITEOLAP_INDS_DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleSelected, this],
            ['sync.error.SELECT', this.$handleSelectError, this],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );
        this.getModel().attach(
            ['sync.preprocess.LIST_SELECT', this.$syncDisable, this, 'LIST_SELECT'],
            ['sync.result.LIST_SELECT', this.$handleSelected, this],
            ['sync.error.LIST_SELECT', this.$handleSelectError, this],
            ['sync.complete.LIST_SELECT', this.$syncEnable, this, 'LIST_SELECT']
        );
        this._uOlapMetaSelector.$di(
            'addEventListener',
            'change', 
            this.$handleChange, 
            this
        );

        this._uOlapMetaSelector.$di('init');
        this.getModel().init();
    };

    /**
     * @override
     */
    LITEOLAP_META_CONFIG_CLASS.dispose = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.dispose();
        this.getModel() && this.getModel().dispose();
        LITEOLAP_META_CONFIG.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     */
    LITEOLAP_META_CONFIG_CLASS.sync = function () {
        var datasourceId = this._oDatasourceId.DATA;

        // 
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 
        this.$sync(
            this.getModel(),
            datasourceId,
            {
                needShowCalcInds: this._bNeedShowCalcInds,
                inEditMode: false
            },
            this.$di('getEvent')
        );
    };

    // liteOlap
    LITEOLAP_META_CONFIG_CLASS.syncLiteOlapInds = function () {
        var datasourceId = 'LITEOLAP_INDS_DATA';

        // 
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 
        this.$sync(
            this.getModel(),
            datasourceId,
            {
                needShowCalcInds: this._bNeedShowCalcInds,
                inEditMode: false
            },
            this.$di('getEvent')
        );
    };

    /**
     * 
     * 
     * @public
     */
    LITEOLAP_META_CONFIG_CLASS.clear = function () {  
        // TODO
    };

    /**
     * 
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$renderMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';
        var model = this.getModel();

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                inddim: model.getIndDim(),
                selLineDataWrap: model.getSelLineWrap(),
                seriesCfg: model.getSeriesCfg(),
                model: model,
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
    };

    /**
     * liteOlap
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$renderLiteOlapMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';
        var model = this.getModel();

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                indList: ejsonObj.data['inds'],
                selectedInds: ejsonObj.data['currentInds'],
                model: model,
                selLineName: 'COLUMN',
                renderType: 'liteOlap',
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
        /**
             * 
             *
             * @event
             */
        this.$di('dispatchEvent', 'submit');
    };
    /**
     * 
     *
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$handleSelected = function () {
        // 
        this._uOlapMetaSelector.$di(
            'updateData',
            this._mModel.getUpdateData()
        );

        if (this._sSubmitMode == 'IMMEDIATE') {
            /**
             * 
             *
             * @event
             */
            this.$di('dispatchEvent', 'submit');
        }
    };

    /**
     * liteOlapchangeselectIndsubmit
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$handleChange = function (wrap) {
    	// 
        this._uOlapMetaSelector.$di(
            'updateData',
            this._mModel.getUpdateData()
        );

        if (this._sSubmitMode == 'IMMEDIATE') {
            /**
             * 
             *
             * @event
             */
            this.$di('dispatchEvent', 'submit');
        }
    };

    /**
     * 
     *
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.enable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('enable');
        LITEOLAP_META_CONFIG.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.disable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('disable');
        LITEOLAP_META_CONFIG.superClass.disable.call(this);
    };    

    /**
     * 
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$handleMetaError = function () {
        this.clear();
        DIALOG.errorAlert();
    };

    /**
     * 
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$handleSelectError = function () {
        DIALOG.errorAlert();
    };

})();
/**
 * di.shared.ui.MetaCondition
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var ecuiDispose = UTIL.ecuiDispose;
    var extend = xutil.object.extend;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var ecuiCreate = UTIL.ecuiCreate;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var UI_BUTTON = ecui.ui.Button;
    var UI_DROPPABLE_LIST;
    var UI_DRAGPABLE_LIST;
    var getByPath = xutil.object.getByPath;
    var getUID = xutil.uid.getIncreasedUID;
    var XVIEW = xui.XView;
    var META_CONDITION_MODEL;
    var DIM_SELECT_PANEL;
        
    $link(function () {
        UI_DROPPABLE_LIST = getByPath('ecui.ui.DroppableList');
        UI_DRAGPABLE_LIST = getByPath('ecui.ui.DraggableList');
        META_CONDITION_MODEL = di.shared.model.MetaConditionModel;
        DIM_SELECT_PANEL = di.shared.ui.DimSelectPanel;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 
     * @param {Object} options.reportType 
     *          TABLE()CHART
     * @param {Function=} options.commonParamGetter      
     */
    var META_CONDITOIN = $namespace().MetaCondition = 
        inheritsObject(
            XVIEW,
            function (options) {
                createModel.call(this, options);
                createView.call(this, options);
            }
        );
    var META_CONDITOIN_CLASS = META_CONDITOIN.prototype;
    
    //------------------------------------------
    //  
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="#{css}-src">',
            '<div class="#{css}-ind">',
                '<div class="#{css}-head-text"></div>',
                '<div class="#{css}-ind-line q-di-meta-ind"></div>',
            '</div>',
            '<div class="#{css}-dim">',
                '<div class="#{css}-head-text"></div>',
                '<div class="#{css}-dim-line q-di-meta-dim"></div>',
            '</div>',
        '</div>',
        '<div class="#{css}-btns">',
            '#{btns}',
        '</div>',
        '<div class="#{css}-tar q-di-meta-tar"></div>'
    ].join('');

    var TPL_SEL_LINE = [
        '<div class="#{css}-sel">',
            '<div class="#{css}-head-text">#{txt}#{selLineName}</div>',
            '<div class="#{css}-sel-line q-di-meta-sel-line"></div>',
            '#{delBtn}',
        '</div>'
    ].join('');

    var TPL_CHART_BTNS = [
        '<div class="#{css}-add-line-btn ui-button-g ui-button"></div>',
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     * @param {Object} options 
     */
    function createModel(options) {
        /**
         * TABLE  CHART
         *
         * @type {string}
         * @private
         */
        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        /**
         * 
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;

        this._mMetaConditionModel = new META_CONDITION_MODEL(
            { 
                reportType: this._sReportType,
                commonParamGetter: this._fCommonParamGetter
            }
        );
    };
    
    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    function createView(options) {
        var el = this._eMain = options.el;
        var css = 'meta-condition';
        var reportType = this._sReportType;
        addClass(el, css);

        // 
        el.innerHTML = template(
            TPL_MAIN, 
            { 
                css: css,
                btns: reportType == 'RTPL_OLAP_CHART'
                    ? template(TPL_CHART_BTNS, { css: css })
                    : ''
            }
        );

        // selLinekeyselLineName
        this._oSelLineWrap = new LINKED_HASH_MAP();
        // selLineidkeyselLineName
        this._oSelLineIdWrap = {};

        this._aDelSelLineBtn = [];

        if (reportType == 'RTPL_OLAP_CHART') {
            this._uAddLineBtn = ecuiCreate(
                UI_BUTTON, 
                q(css + '-add-line-btn', el)[0], 
                null, 
                { primary: 'ui-button-g' }
            );
        }
    };
    
    /**
     * 
     *
     * @public
     */
    META_CONDITOIN_CLASS.init = function () {
        var me = this;
        
        // 
        this._mMetaConditionModel.attach(
            ['sync.preprocess.META_DATA', this.disable, this, 'META_COND'],
            ['sync.result.META_DATA', this.$renderMain, this],
            ['sync.error.META_DATA', this.$handleMetaError, this],
            ['sync.complete.META_DATA', this.enable, this, 'META_COND'],
            ['sync.preprocess.ADD_SERIES_GROUP', this.disable, this, 'META_COND'],
            ['sync.result.ADD_SERIES_GROUP', this.$renderMain, this],
            ['sync.error.ADD_SERIES_GROUP', this.$handleMetaError, this],
            ['sync.complete.ADD_SERIES_GROUP', this.enable, this, 'META_COND'],
            ['sync.preprocess.REMOVE_SERIES_GROUP', this.disable, this, 'META_COND'],
            ['sync.result.REMOVE_SERIES_GROUP', this.$renderMain, this],
            ['sync.error.REMOVE_SERIES_GROUP', this.$handleMetaError, this],
            ['sync.complete.REMOVE_SERIES_GROUP', this.enable, this, 'META_COND']
        );        
        this._mMetaConditionModel.attach(
            ['sync.preprocess.SELECT', this.disable, this, 'META_COND'],
            ['sync.result.SELECT', this.$refreshStatus, this],
            ['sync.error.SELECT', this.$handleSelectError, this],
            ['sync.complete.SELECT', this.enable, this, 'META_COND']
        );

        if (this._sReportType == 'RTPL_OLAP_CHART') {
            this._uAddLineBtn.onclick = function () {
                me._mMetaConditionModel.sync('ADD_SERIES_GROUP');
            }
        }

        this._mMetaConditionModel.init();
    };

    /**
     * @override
     */
    META_CONDITOIN_CLASS.dispose = function () {
        this.$disposeMeta();
        this._uAddLineBtn && this._uAddLineBtn.dispose();
        META_CONDITOIN.superClass.dispose.call(this);
    };

    /**
     * selline
     *
     * @private
     */
    META_CONDITOIN_CLASS.$disposeMeta = function () {
        var el = this._eMain;
        this._uIndSrc && ecuiDispose(this._uIndSrc);
        this._uDimSrc && ecuiDispose(this._uDimSrc);
        q('q-di-meta-ind', el)[0].innerHTML = '';
        q('q-di-meta-dim', el)[0].innerHTML = '';
        this._oSelLineWrap.foreach(
            function (name, item, index) {
                ecuiDispose(item);
            }
        );
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        for (var i = 0, btn; btn = this._aDelSelLineBtn[i]; i ++) {
            btn.dispose();
        }
        this._aDelSelLineBtn = [];
        this._oSelLineIdWrap = {};
        q('q-di-meta-tar', el)[0].innerHTML = '';
    };

    /**
     * 
     *
     * @public
     */
    META_CONDITOIN_CLASS.sync = function () {
        this._mMetaConditionModel.sync(
            { datasourceId: 'META_DATA' }
        );
    };

    /**
     * Model
     * 
     * @public
     * @return {di.shared.model.MetaConditionModel} metaItem
     */
    META_CONDITOIN_CLASS.getModel = function () {  
        return this._mMetaConditionModel;
    };

    /**
     * 
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$renderMain = function () {
        var me = this;
        var el = this._eMain;

        // 
        this.$disposeMeta();

        // 
        var sourceEcuiId = [
            '\x06_DI_META_COND_IND' + getUID('DI_META_COND'),
            '\x06_DI_META_COND_DIM' + getUID('DI_META_COND')
        ];
        var inddim = this._mMetaConditionModel.getIndDim();
        // 
        var disableSelected = this._sReportType == 'RTPL_OLAP_TABLE';

        // 
        var indSrc = this._uIndSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-ind', el)[0],
            null,
            {
                id: sourceEcuiId[0],
                disableSelected: disableSelected,
                clazz: 'IND'
            }
        );
        inddim.indList.foreach(
            function (uniqName, item) {
                indSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align
                    }
                );
            }
        );

        // 
        var dimSrc = this._uDimSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-dim', el)[0],
            null,
            {
                id: sourceEcuiId[1],
                disableSelected: disableSelected,
                clazz: 'DIM'
            }
        );
        inddim.dimList.foreach(
            function (uniqName, item) {
                dimSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align
                    }
                );
            }
        );

        // selLine
        var selLineDataWrap = this._mMetaConditionModel.getSelLineWrap();
        selLineDataWrap.foreach(
            function (name, selLineData, index) {
                me.$addSelLine(
                    name,
                    me.$getSelLineTitle(name),
                    sourceEcuiId.join(','),
                    selLineData
                );
            }
        );

        // 
        this._uIndSrc.onchange = bind(
            this.$handleSelLineChange, 
            this, 
            this._uIndSrc
        );
        this._uDimSrc.onchange = bind(
            this.$handleSelLineChange, 
            this, 
            this._uDimSrc
        ); 
        this._oSelLineWrap.foreach(
            function (selLineName, selLineCon) {
                selLineCon.onitemclick = bind(
                    me.$handleItemClick, 
                    me, 
                    selLineName
                );
            }
        );

        // 
        this.$refreshStatus();
    };

    /**
     * 
     * 
     * @protected
     * @param {string} selLineName 
     * @param {string} selLineTitle selLine
     */
    META_CONDITOIN_CLASS.$getSelLineTitle = function (selLineName) {
        var text = '';
        if (this._sReportType == 'RTPL_OLAP_TABLE') {
            if (selLineName == 'ROW') {
                text = '';
            }
            else if (selLineName == 'FILTER') {
                text = '';
            } 
            else {
                text = '';
            }
        }
        else {
            if (selLineName == 'ROW') {
                text = '';
            }
            else if (selLineName == 'FILTER') {
                text = '';
            } 
            else {
                text = '';
            }
        }   
        return text;     
    };

    /**
     * 
     * 
     * @protected
     * @param {string} selLineName selLine
     * @param {string} selLineTitle selLine
     * @param {string} source ecuiid
     * @param {xutil.LinkedHashMap=} selLineData selLine
     */
    META_CONDITOIN_CLASS.$addSelLine = function (
        selLineName, selLineTitle, source, selLineData
    ) {
        if (selLineName == null) {
            return;
        }
        var me = this;
        var selLineWrap = this._oSelLineWrap;
        var selLineIdWrap = this._oSelLineIdWrap;
        var useDelBtn = this._sReportType == 'RTPL_OLAP_CHART' 
            && selLineName.indexOf('COLUMN') == 0;

        // selLine
        var o = document.createElement('div');
        o.innerHTML = template(
            TPL_SEL_LINE, 
            { 
                css: 'meta-condition', 
                txt: selLineTitle, 
                selLineName: selLineName,
                delBtn: useDelBtn
                    ? '<span class="ui-button"></span>' 
                    : ''
            }
        );
        q('q-di-meta-tar', this._eMain)[0].appendChild(o = o.firstChild);

        if (useDelBtn) {
            // 
            var btn = ecuiCreate(
                UI_BUTTON, 
                q('ui-button', o)[0], 
                null, 
                { primary: 'ui-button' }
            );

            btn.onclick = function () {
                me._mMetaConditionModel.sync(
                    { 
                        datasourceId: 'REMOVE_SERIES_GROUP', 
                        args: { selLineName: selLineName } 
                    }
                );
            }

            this._aDelSelLineBtn.push(btn);
        }

        selLineWrap.addLast(
            ecuiCreate(
                UI_DROPPABLE_LIST, 
                q('q-di-meta-sel-line', o)[0],
                null,
                {
                    id: selLineIdWrap[selLineName] = 
                        '\x06_DI_META_COND_SEL' + getUID('DI_META_COND'),
                    source: source,
                    configBtn: true
                }
            ),
            selLineName
        );

        // targetselLinetarget
        for (var name in selLineIdWrap) {
            if (name != selLineName) {
                selLineWrap.get(name).addTarget(selLineIdWrap[selLineName]);
            }
            selLineWrap.get(selLineName).addTarget(selLineIdWrap[name]);
        }
        this._uIndSrc.addTarget(selLineIdWrap[selLineName]);
        this._uDimSrc.addTarget(selLineIdWrap[selLineName]);

        // 
        if (selLineData) {
            selLineData.foreach( 
                function (uniqName, item, index) {
                    selLineWrap.get(selLineName).addItem(
                        {
                            value: item.uniqName, 
                            text: item.caption,
                            clazz: item.clazz,
                            fixed: item.fixed,
                            align: item.align
                        }
                    );
                }
            );
        }
    };

    /**
     * 
     *
     * @protected
     */
    META_CONDITOIN_CLASS.$refreshStatus = function () {
        var statusWrap = this._mMetaConditionModel.getStatusWrap();
        this._uIndSrc.setState(
            { 
                disable: statusWrap.indMetas.disabledMetaNames,
                selected: statusWrap.indMetas.selectedMetaNames
            }
        );
        this._uDimSrc.setState(
            { 
                disable: statusWrap.dimMetas.disabledMetaNames,
                selected: statusWrap.dimMetas.selectedMetaNames
            }
        );
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    META_CONDITOIN_CLASS.enable = function (key) {
        // TODO 
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            this._uIndSrc && this._uIndSrc.enable();
            this._uDimSrc && this._uDimSrc.enable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.enable();
                }
            );
            for (var i = 0, btn; btn = this._aDelSelLineBtn[i]; i ++) {
                btn.enable();
            }
            this._uAddLineBtn && this._uAddLineBtn.enable();
            META_CONDITOIN.superClass.enable.call(this);
        }
    };    

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    META_CONDITOIN_CLASS.disable = function (key) {
        objKey.add(this, key);

        // TODO 
        if (!this._bDisabled) {
            this._uIndSrc && this._uIndSrc.disable();
            this._uDimSrc && this._uDimSrc.disable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.disable();
                }
            );
            for (var i = 0, btn; btn = this._aDelSelLineBtn[i]; i ++) {
                btn.disable();
            }
            this._uAddLineBtn && this._uAddLineBtn.disable();
        }
        META_CONDITOIN.superClass.disable.call(this);
    };    

    /**
     * 
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$handleSelLineChange = function () {
        var wrap = {};
        this._oSelLineWrap.foreach(
            function (k, o, index) {
                wrap[k] = o.getValue();
            }
        );
        var changeWrap = this._mMetaConditionModel.diffSelected(wrap);

        this._mMetaConditionModel.sync(
            {
                datasourceId: 'SELECT',
                args: {
                    uniqNameList: wrap[name],
                    changeWrap: changeWrap
                }
            }
        );
    };

    /**
     * selLine
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$handleItemClick = function (
        selLineName, event, itemData
    ) {
        var metaItem = 
            this._mMetaConditionModel.getMetaItem(itemData.value);

        // --
        if (metaItem && metaItem.clazz == 'DIM') {
            DIM_SELECT_PANEL().open(
                'EDIT',
                {
                    uniqName: itemData.value,
                    reportType: this._sReportType,
                    selLineName: selLineName,
                    dimMode: metaItem.isTimeDim ? 'TIME' : 'NORMAL',
                    commonParamGetter: this._fCommonParamGetter
                }
            );
        }
        // --
        else {
            // TODO
        }
    };

    /**
     * 
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$handleMetaError = function () {
        // TODO
    };

    /**
     * 
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$handleSelectError = function () {
        // TODO
    };

})();
/**
 * di.shared.ui.OlapMetaConfig
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var ecuiDispose = UTIL.ecuiDispose;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var ecuiCreate = UTIL.ecuiCreate;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var getUID = xutil.uid.getIncreasedUID;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {Object} options.reportType 
     *          TABLE()CHART
     * @param {string} options.submitMode 
     *      'IMMEDIATE'
     *      'CONFIRM'
     * @param {boolean} options.needShowCalcInds 
     */
    var OLAP_META_CONFIG = $namespace().OlapMetaConfig = 
        inheritsObject(INTERACT_ENTITY);
    var OLAP_META_CONFIG_CLASS = OLAP_META_CONFIG.prototype;
    
    /**
     * 
     */
    OLAP_META_CONFIG_CLASS.DEF = {
        // interactionapi
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncLiteOlapInds: { datasourceId: 'LITEOLAP_INDS_DATA' },
            clear: {}
        },
        // css
        className: 'olap-meta-config',
        // model
        model: {
            clzPath: 'di.shared.model.OlapMetaConfigModel'
        }
    };

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     * @param {Object} options 
     */
    OLAP_META_CONFIG_CLASS.$createModelInitOpt = function (options) {
        return { reportType: options.reportType };
    };
    
    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    OLAP_META_CONFIG_CLASS.$createView = function (options) {
        /**
         * 
         *
         * @type {boolean}
         * @private
         */
        this._bNeedShowCalcInds = options.needShowCalcInds || false;
        /**
         * datasourceId
         *
         * @type {Object}
         * @private
         */
        var did = this._oDatasourceId = options.datasourceId || {};
        did.DATA = did.DATA || 'DATA';
        did.SELECT = did.SELECT || 'SELECT';
        /**
         * 
         * 
         * @type {string}
         * @private 
         */
        this._sSubmitMode = options.submitMode;

        this._uOlapMetaSelector = this.$di('vuiCreate', 'main');
    };
    
    /**
     * 
     *
     * @public
     */
    OLAP_META_CONFIG_CLASS.init = function () {
        // 
        this.getModel().attach(
            ['sync.preprocess.DATA', this.$syncDisable, this, 'DATA'],
            ['sync.result.DATA', this.$renderMain, this],
            ['sync.error.DATA', this.$handleMetaError, this],
            ['sync.complete.DATA', this.$syncEnable, this, 'DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.LITEOLAP_INDS_DATA', this.$syncDisable, this, 'LITEOLAP_INDS_DATA'],
            ['sync.result.LITEOLAP_INDS_DATA', this.$renderLiteOlapMain, this],
            ['sync.error.LITEOLAP_INDS_DATA', this.$handleMetaError, this],
            ['sync.complete.LITEOLAP_INDS_DATA', this.$syncEnable, this, 'LITEOLAP_INDS_DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleSelected, this],
            ['sync.error.SELECT', this.$handleSelectError, this],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );
        this.getModel().attach(
            ['sync.preprocess.LIST_SELECT', this.$syncDisable, this, 'LIST_SELECT'],
            ['sync.result.LIST_SELECT', this.$handleSelected, this],
            ['sync.error.LIST_SELECT', this.$handleSelectError, this],
            ['sync.complete.LIST_SELECT', this.$syncEnable, this, 'LIST_SELECT']
        );
        this._uOlapMetaSelector.$di(
            'addEventListener',
            'change', 
            this.$handleChange, 
            this
        );

        this._uOlapMetaSelector.$di('init');
        this.getModel().init();
    };

    /**
     * @override
     */
    OLAP_META_CONFIG_CLASS.dispose = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.dispose();
        this.getModel() && this.getModel().dispose();
        OLAP_META_CONFIG.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @public
     */
    OLAP_META_CONFIG_CLASS.sync = function () {
        var datasourceId = this._oDatasourceId.DATA;

        // 
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 
        this.$sync(
            this.getModel(),
            datasourceId,
            {
                needShowCalcInds: this._bNeedShowCalcInds,
                inEditMode: false
            },
            this.$di('getEvent')
        );
    };

    // liteOlap
    OLAP_META_CONFIG_CLASS.syncLiteOlapInds = function () {
        var datasourceId = 'LITEOLAP_INDS_DATA';

        // 
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 
        this.$sync(
            this.getModel(),
            datasourceId,
            {
                needShowCalcInds: this._bNeedShowCalcInds,
                inEditMode: false
            },
            this.$di('getEvent')
        );
    };

    /**
     * 
     * 
     * @public
     */
    OLAP_META_CONFIG_CLASS.clear = function () {  
        // TODO
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$renderMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';
            // 
            imme = true ;
        var model = this.getModel();

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                inddim: model.getIndDim(),
                selLineDataWrap: model.getSelLineWrap(),
                seriesCfg: model.getSeriesCfg(),
                model: model,
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
    };

    /**
     * liteOlap
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$renderLiteOlapMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';
        var model = this.getModel();

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                indList: model.getLiteOlapIndList(),
                model: model,
                selLineName: 'COLUMN',
                renderType: 'liteOlap',
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
    };
    /**
     * 
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleSelected = function () {
        // 
        this._uOlapMetaSelector.$di(
            'updateData',
            this._mModel.getUpdateData()
        );

        if (this._sSubmitMode == 'IMMEDIATE') {
            /**
             * 
             *
             * @event
             */
            this.$di('dispatchEvent', 'submit');
        }else{
            // 
            this.sync();
        }
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleChange = function (wrap) {
        var didSel = this._oDatasourceId.SELECT;

        this.$sync(
            this._mModel,
            didSel,
            null,
            null,
            didSel == 'LIST_SELECT' 
                ? { selectedIndNames: wrap }
                : {
                    changeWrap: this._mModel.diffSelected(wrap),
                    needShowCalcInds: this._bNeedShowCalcInds
                }
        );
    };

    /**
     * 
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.enable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('enable');
        OLAP_META_CONFIG.superClass.enable.call(this);
    };    

    /**
     * 
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.disable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('disable');
        OLAP_META_CONFIG.superClass.disable.call(this);
    };    

    /**
     * 
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleMetaError = function () {
        this.clear();
        DIALOG.errorAlert();
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleSelectError = function () {
        DIALOG.errorAlert();
    };

})();
/**
 * di.console.shared.model.ChartConfigModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.console.shared.model');

(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var stringify = baidu.json.stringify;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var CHART_CONFIG_MODEL = $namespace().ChartConfigModel = 
            inheritsObject(XDATASOURCE, constructor);
    var CHART_CONFIG_MODEL_CLASS = 
            CHART_CONFIG_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
    }

    /**
     * @override
     */
    CHART_CONFIG_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CHART_CONFIG_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            INIT: URL.fn('OLAP_CHART_BASE_CONFIG_INIT'),
            SUBMIT: URL.fn('OLAP_CHART_BASE_CONFIG_INIT')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CHART_CONFIG_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            INIT: function(options) { 
                return '';
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CHART_CONFIG_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            INIT: function(data) {
            }
        }
    );

})();


/**
 * di.console.shared.ui.ChartConfigPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  ecui, xui, xutil
 */

$namespace('di.console.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var q = xutil.dom.q;
    var inheritsObject = xutil.object.inheritsObject;
    var template = xutil.string.template;
    var XVIEW = xui.XView;
    var UI_TEXTAREA = ecui.ui.Textarea;
    var UI_INPUT = ecui.ui.Input;
    var UI_FORM = ecui.ui.Form;
    var UI_BUTTON = ecui.ui.Button;
    var UI_IND_TREE = ecui.ui.IndTree;
    var UI_CALENDAR = ecui.ui.IstCalendar;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var CHART_CONFIG_MODEL;

    $link(function() {
        CHART_CONFIG_MODEL = di.console.shared.model.ChartConfigModel;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * CHART_CONFIG_PANEL()
     * 
     * @class
     * @extends di.shared.ui.BaseConfigPanel
     */
    var CHART_CONFIG_PANEL = $namespace().ChartConfigPanel = 
            inheritsObject(BASE_CONFIG_PANEL, constructor);
    var CHART_CONFIG_PANEL_CLASS = CHART_CONFIG_PANEL.prototype;

    /**
     * 
     */
    CHART_CONFIG_PANEL_CLASS.PANEL_TITLE = '';

    //------------------------------------------
    // override 
    //------------------------------------------

    function constructor() {
        this.DATASOURCE_ID_MAPPING = {
            INIT: 'CHART_CONFIG_INIT',
            SUBMIT: 'CHART_CONFIG_SUBMIT'
        };
    }

    /** 
     * @override
     */
    CHART_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
        // unbind
    };

    /** 
     * @override
     */
    CHART_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /** 
     * @override
     */
    CHART_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        var css = 'chart-config-panel';
        var html = [];
        var series = data.series || {};
        var index4Selected = data.index4Selected || [];
        var gDefs = DICT.GRAPH_DEFS;

        this._data = data;

        // TODO
        // 

        var tplTypeSel = [
                '<div data-series-group="#{serKey}">',
                    '<span>&nbsp;#{serKey}</span>',
                    '<span>&nbsp;</span>',
                    '<select class="#{css}-graph-type-sel">',
                        '#{typeOpt}',
                    '</select>',
                    '<span>&nbsp;</span>',
                    '<select class="#{css}-graph-axis-sel">',
                        '#{axisOpt}',
                    '</select>',
                '</div>'
            ].join('');
        var tplTypeSelOpt = [
                '<option value="#{value}" #{sel}>#{text}#{value}</option>'
            ].join('');

        html.push('<div>');

        // 
        for (var i = 0, serKey, ser; serKey = index4Selected[i]; i ++) {
            if (serKey.indexOf('COLUMN') < 0 || !(ser = series[serKey])) {
                continue; 
            }

            var htmlTypeOpt = [];
            for (var j = 0, sj; sj = gDefs[j]; j ++) {
                htmlTypeOpt.push(
                    template(
                        tplTypeSelOpt, 
                        { 
                            text: gDefs[j].text, 
                            value: gDefs[j].name,
                            sel: gDefs[j].name == ser.type 
                                ? 'selected="selected"' : ''
                        }
                    )
                );
            }

            // pie
            var htmlAxisOpt = [
                template(
                    tplTypeSelOpt, 
                    { 
                        text: '', 
                        value: 'left', 
                        sel: ser.yAxisName == 'left' ? 'selected="selected"' : ''
                    }
                ),
                template(
                    tplTypeSelOpt, 
                    { 
                        text: '', 
                        value: 'right',
                        sel: ser.yAxisName == 'right' ? 'selected="selected"' : ''
                    }
                )
            ];

            html.push(
                template(
                    tplTypeSel,
                    { 
                        serKey: serKey,
                        css: css,
                        typeOpt: htmlTypeOpt.join(''),
                        axisOpt: htmlAxisOpt.join('')
                    }
                )
            );
        }

        html.push('</div>');

        contentEl.innerHTML = html.join('');
    };

    /** 
     * @override
     */
    CHART_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var css = 'chart-config-panel';
        var contentEl = this.getContentEl();
        var data = this._data;
        var series = data.series || (data.series = {});
        var yAxises = data.yAxises || (data.yAxises = {});
        var els = contentEl.getElementsByTagName('DIV');

        for (var i = 0, el; el = els[i]; i ++) {
            var serKey = el.getAttribute('data-series-group');
            if (serKey) {
                var sel;
                sel = q(css + '-graph-type-sel', el)[0];
                series[serKey].type = (
                    sel.options[sel.selectedIndex] || {}
                ).value;
                sel = q(css + '-graph-axis-sel', el)[0];
                series[serKey].yAxisName = (
                    sel.options[sel.selectedIndex] || {}
                ).value;
            }
        }

        return { series: series, yAxises: yAxises };
    };

    function fmtInput(value) {
        if (value == null) {
            return '';
        }
        return trim(String(value));
    }

})();
/**
 * di.console.shared.ui.CubeConfigPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    cubepanel
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.shared.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var bind = xutil.fn.bind;
    var $fastCreate = ecui.$fastCreate;
    var PL_FLOAT_MENU = ecui.ui.PlFloatMenu;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var CUBE_META_MODEL;

    $link(function() {
        CUBE_META_MODEL = di.shared.model.CubeMetaModel;
    });

    /**
     * cubepanel
     *
     * @class
     */
    var CUBE_CONFIG_PANEL = $namespace().CubeConfigPanel = inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this._uParent = options.parent;
                this.DATASOURCE_ID_MAPPING = { INIT: 'INIT' };
            }
        );
    var CUBE_CONFIG_PANEL_CLASS = CUBE_CONFIG_PANEL.prototype;

    /** 
     * @override
     */
    CUBE_CONFIG_PANEL_CLASS.changeReportType = function(reportType) {
        this._mModel.setReportType(reportType);
        this.DATASOURCE_ID_MAPPING.INIT = ({
            RTPL_OLAP_TABLE: 'CUBE_INIT',
            RTPL_OLAP_CHART: 'CUBE_INIT',
            RTPL_PLANE_TABLE: 'DATASOURCE_INIT'
        })[reportType];
    }

    /** 
     * @override
     */
    CUBE_CONFIG_PANEL_CLASS.$doGetContentTPL = function() {
        return [
            '<div class="menu-cube-config">',
                '<div class="ui-menu q-menu"><label>&nbsp;</label></div>',
            '</div>'
        ].join('');
    };

    /** 
     * @override
     */
    CUBE_CONFIG_PANEL_CLASS.$doGetModel = function() {
        return this._mModel;
    };

    /** 
     * @override
     */
    CUBE_CONFIG_PANEL_CLASS.$doCreateView = function(options) {
        this._mModel = new CUBE_META_MODEL(options);
        this._uMenu = $fastCreate(
            PL_FLOAT_MENU, q('q-menu', this.getContentEl())[0], null
        );
    };

    /** 
     * @override
     */
    CUBE_CONFIG_PANEL_CLASS.$doInit = function() {
        // 
        this._uMenu.onchange = bind(
            function (menuItem) {
                this.notify('select', [menuItem]);
                this.close();
            },
            this
        );
    };

    /** 
     * @override
     */
    CUBE_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        var menuTree = this._mModel.getMenuData().menuTree;
        this._uMenu.setData(menuTree.menuList);
        this._uMenu.select(menuTree.selMenuId);
    };

})();
/**
 * di.console.shared.ui.GlobalMenu
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [] 
 * author:  sushuang(sushuang@baidu.com)
 * depend:  ecui
 */

$namespace('di.console.shared.ui');

/**
 * [ (@see ecui.util.ref)]
 * {di.shared.model.GlobalMenuManager} globalMenuManager 
 */
(function () {
    
    /*  */
    var util = ecui.util;
    var ui = ecui.ui;
    var inheritsControl = ecui.inherits;
    var $fastCreate = ecui.$fastCreate;
    var createDom = ecui.dom.create;;
    var setStyle = ecui.dom.setStyle;
    var getStyle = ecui.dom.getStyle;
    var extend = xutil.object.extend; 
    var template = xutil.string.template;
    var URL = di.config.URL;
    var UI_CONTROL = ui.Control;
        
    /*  */
    var GLOBAL_MENU = $namespace().GlobalMenu = 
        inheritsControl(
            UI_CONTROL, 
            'global-menu', 
            null,
            function (el, options) {
                el.innerHTML = template(TPL_MAIN, {type: this.getType()});
                this._eInner = el.firstChild;
                this._aItems = [];
                this._uCurrSel;
            }
        );
    var GLOBAL_MENU_CLASS = GLOBAL_MENU.prototype;
    
    var GLOBAL_MENU_ITEM_CLASS = (GLOBAL_MENU_CLASS.Item = inheritsControl(
            UI_CONTROL, 
            'global-menu-item', 
            null, 
            function(el, options) {
                var data = options.data;
                var parent = options.parent;
                var selMenu = options.selMenu;
                    
                setStyle(el, 'display', 'inline-block');
                el.innerHTML = template(
                    TPL_ITEM, 
                    {
                        type: this.getType(), 
                        text: data.menuName,
                        url: URL.getWebRoot() + '/' + data.menuUrl
                    }
                );
                
                if (selMenu.menuId == (this._sMenuId = data.menuId)) {
                    parent._uCurrSel = this;
                    this.alterClass('+selected');
                }
            }        
        )).prototype;

    /*  */
    var TPL_MAIN = '<div class="#{type}-items"></div>';
    var TPL_ITEM = ''
        + '<a href="#{url}" target="_blank">'
        + '<div class="#{type}-ledge"></div>'
        + '<div class="#{type}-text">#{text}</div>'
        + '<div class="#{type}-redge"></div>'
        + '</a>';
                
    /**
     * 
     * @protected
     */
    GLOBAL_MENU_CLASS.init = function () {
        this.$resetItems();
    };
    
    /**
     * 
     * @protected
     */
    GLOBAL_MENU_CLASS.$dispose = function () {
        this._aCurrSel = null;
        this.$disposeItems();
        GLOBAL_MENU.superClass.$dispose.call(this);
    };
    
    /**
     * 
     * @protected
     */
    GLOBAL_MENU_CLASS.$resetItems = function () {
        this._aCurrSel = null;
        this.$disposeItems();
        
        var datasource = this._mGlobalMenuManager.getMenuData();
        var selMenu = this._mGlobalMenuManager.getSelected();
        
        for (var i = 0, date, el, item; data = datasource[i]; i++) {
            this._eInner.appendChild(el = createDom('global-menu-item'));
            this._aItems.push(
                item = $fastCreate(
                    this.Item, 
                    el, 
                    this, 
                    {
                        data: data, 
                        selMenu: selMenu,
                        parent: this
                    }
                )
            );
        }
    };
    
    /**
     * 
     * @protected
     */
    GLOBAL_MENU_CLASS.$disposeItems = function () {
        var i, o;
        for (i = 0; o = this._aItems[i]; i ++) {
            o.dispose();
        }
        this._aItem = [];
        this._eInner.innerHTML = '';
    };

    /**
     * GlobalMenuManager
     * @public
     */
    GLOBAL_MENU_CLASS.setGlobalMenuManager = function(mgr) {
        this._mGlobalMenuManager = mgr;
    };

})();


/**
 * di.console.shared.ui.PreviewConfigPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.shared.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var alert = di.helper.Dialog.alert;
    var confirm = di.helper.Dialog.confirm;
    var template = xutil.string.template;
    var getUID = xutil.uid.getUID;
    var ecuiCreate = UTIL.ecuiCreate;
    var foreachDoOri = UTIL.foreachDoOri;
    var textParam = xutil.url.textParam;
    var replaceIntoParam = xutil.url.replaceIntoParam;
    var assert = UTIL.assert;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.BaseConfigPanel
     * @param {Object} options @see di.shared.ui.BaseConfigPanel
     */
    var PREVIEW_CONFIG_PANEL = $namespace().PreviewConfigPanel
        = inheritsObject(BASE_CONFIG_PANEL);
    var PREVIEW_CONFIG_PANEL_CLASS = PREVIEW_CONFIG_PANEL.prototype;

    /**
     * @override
     *
     * @param {string} vtplKey
     * @param {Function} onconfirm 
     *      
     *          {string} options.reportURL
     *          {string} options.data data
     */ 
    PREVIEW_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
        this._vtplKey = options.vtplKey;
        this._onconfirm = options.onconfirm;
    };

    /** 
     * @override
     */
    PREVIEW_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
    };

    /** 
     * 
     * 
     * @override
     */
    PREVIEW_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        var html = [
            '<span class="vtpl-preview-config-phase">',
                '<input type="radio" name="vtpl-preview" value="dev" checked="checked" /><span>dev</span>',
                '<input type="radio" name="vtpl-preview" value="pre" /><span>pre</span>',
                '<input type="radio" name="vtpl-preview" value="release" /><span>release</span>',
            '</span>',
            '<div>',
                'URL',
            '</div>',
            '<div>',
                '<textarea class="vtpl-preview-config-report-url"></textarea>',
            '</div>',
            '<div>',
                '&',
            '</div>',
            '<div>',
                '<textarea class="vtpl-preview-config-data"></textarea>',
            '</div>'
        ];
        contentEl.innerHTML = html.join('');

        // 
        var radios = q('vtpl-preview-config-phase', contentEl)[0]
            .getElementsByTagName('INPUT');
        for (var i = 0, ra; ra = radios[i]; i ++) {
            ra.onclick = bind(this.$urlAddPhase, this);
        }

        this.$urlGen();
    };

    /**
     * urlurl
     *
     * @private
     */ 
    PREVIEW_CONFIG_PANEL_CLASS.$urlGen = function () {
        var url = URL('REPORT_PREVIEW');
        
        var urlEl = q('vtpl-preview-config-report-url', this.getContentEl())[0];
        urlEl.value = replaceIntoParam(
            url, 'reportTemplateId', this._vtplKey
        );

        this.$urlAddPhase();
    };

    /**
     * URLphase
     *
     * @private
     */ 
    PREVIEW_CONFIG_PANEL_CLASS.$urlAddPhase = function () {
        var contentEl = this.getContentEl();
        var pEl = q('vtpl-preview-config-phase', contentEl)[0];
        var urlEl = q('vtpl-preview-config-report-url', contentEl)[0];

        // (dev/pre/release)
        var radios = pEl.getElementsByTagName('INPUT');
        var phase = 'dev';
        for (var i = 0, ra; ra = radios[i]; i ++) {
            if (ra.checked) { phase = ra.value; }
        }

        urlEl.value = replaceIntoParam(urlEl.value, 'phase', phase);
    };

    /**
     * 
     * 
     * @protected
     */
    PREVIEW_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var contentEl = this.getContentEl();
        var url = q('vtpl-preview-config-report-url', contentEl)[0].value;
        var data = q('vtpl-preview-config-data', contentEl)[0].value;
        if (!url || !trim(url)) {
            return 'URL';
        }
        else {
            return { reportURL: url, data: data };
        }
    };

    /**
     * tab
     * 
     * @protected
     */
    PREVIEW_CONFIG_PANEL_CLASS.$doSubmitSuccess = function(
        contentEl, data, ejsonObj, options
    ) {
        this._onconfirm(
            { 
                reportURL: options.args.reportURL, 
                data: options.args.data
            }
        );
    };

})();
/**
 * di.console.shared.ui.ReportPreview
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var addEventListener = ecui.addEventListener;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var encodeHTML = xutil.string.encodeHTML;
    var getUID = xutil.uid.getUID;
    var alert = di.helper.Dialog.alert;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var template = xutil.string.template;
    var textParam = xutil.url.textParam;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var PREVIEW_CONFIG_PANEL = di.console.shared.ui.PreviewConfigPanel;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.reportType
     * @param {string} options.schemaName
     * @param {string} options.cubeTreeNodeName
     */
    var REPORT_MOLD_LIST_PAGE = $namespace().ReportMoldListPage = 
        inheritsObject(
            PANEL_PAGE,
            function (options) {
                var el = options.el;
                addClass(el, 'report-release');
                el.innerHTML = TPL_MAIN;
                this._reportURL = options.reportURL;
                this._data = options.data;
                this._vtplModel = options.vtplModel;
                this._globalPanelPageManager = options.globalPanelPageManager;
                this._phase = options.phase;
                createView.call(this, el, options);
            }
        );
    var REPORT_MOLD_LIST_PAGE_CLASS = REPORT_MOLD_LIST_PAGE.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="report-release-list">',
        '</div>'
    ].join('');
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
         // 
        this._uPreviewConfig = new PREVIEW_CONFIG_PANEL(
            { parent: this, panelTitle: '' }
        );
    }
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @public
     */
    REPORT_MOLD_LIST_PAGE_CLASS.init = function() {
        
         this._uPreviewConfig.init();
    };
    
    /**
     * @override
     */
    REPORT_MOLD_LIST_PAGE_CLASS.render = function() {
        var phase = this._phase;
        var molds = this._vtplModel.getMolds();
        var mainEl = this.getEl();
        var me = this;
        var html;
        html = appendHTML(phase,molds);
        
        mainEl.innerHTML = html;
        
        
        var imgs = mainEl.getElementsByTagName('IMG');
        for (var i = 0, img; img = imgs[i]; i ++) {
            
            var vtpl = molds.get(img.getAttribute('data-index'));
            img.title = vtpl.snippet.fileName;
            img.onclick = handleClick;
            // img.onerror = function (img) {
            //      img.src = '../asset/css/img/demo.jpg';
            // }
        }

        
        function handleClick() {
            var vtpl = molds.get(this.getAttribute('data-index'));
            var vtplKey = vtpl.vtplKey;
            var fileName = vtpl.snippet.fileName;
            me._globalPanelPageManager.openByURI(
                'di.console.editor.ui.VTplPanelPage?'
                    + [
                        'pageId=' + fileName,
                        'pageTitle=' + ' [' + fileName + ']',
                        'moldKey=' + fileName,
                        'act=CREATE#QUICK',
                        'forceCreate=true'
                    ].join('&'),
                { vtplModel: me._vtplModel, forceActive: true }
            );   
        };
        
    };    

    function appendHTML(phase,list){
        var html = [];
        var onerrorHtml="this.src='../asset/css/img/demo.jpg'";
        list.foreach(
            function (key, vtplInfo, i) {
                var descs = vtplInfo.desc.split('||');
                html.push('<div class="report-release-block">');
               // html.push(' <img data-index="', encodeHTML(key), '" class="report-release-img" src="../asset/css/img/demo.jpg"/>');
                html.push(' <img data-index="', encodeHTML(key), '" class="report-release-img" onerror='+onerrorHtml+'   src="../report-img/mold-img/'+ vtplInfo.snippet.fileName +'.png"/>');
                html.push(' <span data-index="', encodeHTML(key), '">');
                for (var i = 0; i < descs.length; i++) {
                    var descStr= descs[i];
                    html.push('<li>' + descStr +'</li>');
                };
                html.push('</span>');
                html.push('</div>');
            }
        );
        return  html.join('');
    }
    /**
     * @override
     */
    REPORT_MOLD_LIST_PAGE_CLASS.dispose = function() {
        REPORT_MOLD_LIST_PAGE.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    REPORT_MOLD_LIST_PAGE_CLASS.$active = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    REPORT_MOLD_LIST_PAGE_CLASS.$inactive = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };
    

})();
/**
 * di.console.shared.ui.ReportPreview
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var alert = di.helper.Dialog.alert;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var ecuiCreate = UTIL.ecuiCreate;
    var UI_BUTTON = ecui.ui.Button;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var addEventListener = ecui.addEventListener;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var template = xutil.string.template;
    var textParam = xutil.url.textParam;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var VTPL_MODEL ;
        
    $link(function() {
        VTPL_MODEL = di.console.editor.model.VTplModel;
    });    

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.reportType
     * @param {string} options.schemaName
     * @param {string} options.cubeTreeNodeName
     */
    var REPORT_PREVIEW = $namespace().ReportPreview = 
        inheritsObject(
            PANEL_PAGE,
            function (options) {
                var el = options.el;
                addClass(el, 'page-preview');
                el.innerHTML = TPL_MAIN;
                this._reportURL = options.reportURL;
                this._data = options.data;
                this.vtplKey = options.vtplKey;
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var REPORT_PREVIEW_CLASS = REPORT_PREVIEW.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    var TPL_MAIN = [
        '<div><span class="q-btn-screenshot ui-button ui-button-g"></span></div>',
        '<div class="q-di-stub"></div>'
    ].join('');
    

      /**
     * Model
     *
     * @private
     * @param {Object} options 
     */
    function createModel(el, options) {
        this._mVTplModel = new VTPL_MODEL();
    }
    //------------------------------------------
    // 
    //------------------------------------------

     /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        // 
        this._uScreenShotBtn = ecuiCreate(
                UI_BUTTON, 
                q('q-btn-screenshot', el)[0],
                null, 
                { primary: 'ui-button-g' }
            );
    }

    /**
     * 
     *
     * @public
     */
    REPORT_PREVIEW_CLASS.init = function() {
        var stub = new $DataInsight$(
            q('q-di-stub', this.getEl())[0],
            { 
                // widthMode: 'FULLFILL',
                widthMode: 'ADAPT',
                heightMode: 'ADAPT'
            }
        );
        stub.load(
            { 
                // method: 'POST',
                url: this._reportURL,
                data: this._data
            }
        );

        this._uScreenShotBtn.onclick=bind(this.doScreenShot, this);
        // this._mVTplModel.attach(
        //    ['sync.result.PAHNTOMJS_INFO', this.$requestPhantomjsServer, this]
        // );
        this._mVTplModel.init();
    };

    /**
     * Phantomjs
     */
    REPORT_PREVIEW_CLASS.doScreenShot = function() {
        var perviewUrl = this._reportURL+this._data;
        var imgName = this.vtplKey;
        this._mVTplModel.sync(
            {
                datasourceId: 'PAHNTOMJS_INFO',
                args: {
                    perviewUrl:perviewUrl,
                    imgName:imgName
                },
                result: $requestPhantomjsServer
            }
        );
  
    };

    /**
    *phantomjs
    */
     function $requestPhantomjsServer (data, ejsonObj, options) {
        // url
        var reportPerviewUrl = data.perviewUrl;
        // phantomjsurl
        var phantomjsServerUrl = data.phantomjsServerUrl;
        // 
        var imgName = data.imgName;
        // 
        var bizKey = data.bizKey;
        // 
        var imgLocation = data.imgLocation;
        //+'&url='+encodeURIComponent(reportPerviewUrl);
        //alert(perviewUrl);
        // ajax
        var oAjax=null; 
        if(window.XMLHttpRequest){ 
            oAjax = new XMLHttpRequest(); 
        }else{ 
            oAjax = new ActiveXObject('Microsoft.XMLHTTP');    
        } 
        oAjax.open('POST',phantomjsServerUrl,true); 
        oAjax.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        oAjax.onreadystatechange = function()
        {
            if (oAjax.readyState == 4)
            {
                // @TODO 
            }
        }
        var param = [
                        'resultType=html',
                        'imgType=png',
                        'imgName='+imgName,
                        'imgLocation='+imgLocation,
                        'bizKey='+bizKey,
                        'url=' + encodeURIComponent(reportPerviewUrl)
                    ].join('&')
        // alert(param)
        oAjax.send(param); 

        // window.open(perviewUrl);

        alert("30") 
    }
    /**
     * @override
     */
    REPORT_PREVIEW_CLASS.dispose = function() {
        REPORT_PREVIEW.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    REPORT_PREVIEW_CLASS.$active = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    REPORT_PREVIEW_CLASS.$inactive = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };

})();
/**
 * di.console.shared.ui.ReportPreview
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.shared.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var addEventListener = ecui.addEventListener;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var encodeHTML = xutil.string.encodeHTML;
    var getUID = xutil.uid.getUID;
    var alert = di.helper.Dialog.alert;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var template = xutil.string.template;
    var textParam = xutil.url.textParam;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var PREVIEW_CONFIG_PANEL = di.console.shared.ui.PreviewConfigPanel;
        
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.reportType
     * @param {string} options.schemaName
     * @param {string} options.cubeTreeNodeName
     */
    var REPORT_RELEASE_PAGE = $namespace().ReportReleasePage = 
        inheritsObject(
            PANEL_PAGE,
            function (options) {
                var el = options.el;
                addClass(el, 'report-release');
                el.innerHTML = TPL_MAIN;
                this._reportURL = options.reportURL;
                this._data = options.data;
                this._vtplModel = options.vtplModel;
                this._globalPanelPageManager = options.globalPanelPageManager;
                this._phase = options.phase;
                createView.call(this, el, options);
            }
        );
    var REPORT_RELEASE_PAGE_CLASS = REPORT_RELEASE_PAGE.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="report-release-list">',
        '</div>'
    ].join('');
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
    	 // 
        this._uPreviewConfig = new PREVIEW_CONFIG_PANEL(
            { parent: this, panelTitle: '' }
        );
    }
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @public
     */
    REPORT_RELEASE_PAGE_CLASS.init = function() {
    	
    	 this._uPreviewConfig.init();
    };
    
    /**
     * @override
     */
    REPORT_RELEASE_PAGE_CLASS.render = function() {
    	var phase = this._phase;
    	var vtplSet = this._vtplModel.getVTpls(phase);
    	var mainEl = this.getEl();
    	var me = this;
        var bizKey =this._vtplModel.getBizKey();
    	var html;
		html = appendHTML(bizKey,phase,vtplSet);
    	
    	mainEl.innerHTML = html;
    	
    	
    	var imgs = mainEl.getElementsByTagName('IMG');
    	for (var i = 0, img; img = imgs[i]; i ++) {
            
            var vtpl = vtplSet.get(img.getAttribute('data-index'));
            img.title = vtpl.vtplName;
            if (phase == 'dev'){
                img.onclick = handleDevPhaseClick;
            } else {
                img.onclick = handleImgClick;
            }
    	}
    	
    	function handleImgClick() {
			var vtpl = vtplSet.get(this.getAttribute('data-index'));
			var vtplKey = vtpl.vtplKey;
			me._uPreviewConfig.open(
		        'EDIT', 
		        { 
		        	vtplKey: vtplKey, 
		        	onconfirm: function (options) {
		                me._globalPanelPageManager.openByURI(
		                        'di.console.editor.ui.VTplPanelPage?'
		                            + [
		                               // 'pageId=' + vtplKey + getUID(),
                                        'pageId=' + vtplKey,
		                                'pageTitle=' + vtplKey,
		                                'vtplKey=' + vtplKey,
		                                'act=PREVIEW#PREVIEW',
		                                'phase=' + phase
		                            ].join('&'),
		                    	{ 
                                    vtplModel: me._vtplModel, 
                                    forceActive: true,
                                    extraOpt: {
                                        reportURL: options.reportURL,
                                        data: options.data,
                                        vtplKey: vtplKey
                                    }
                                }
		                   );		
		        	}
		        }
		    );
		};
		
		function handleDevPhaseClick() {
            var vtpl = vtplSet.get(this.getAttribute('data-index'));
            var vtplKey = vtpl.vtplKey;
            me._globalPanelPageManager.openByURI(
                'di.console.editor.ui.VTplPanelPage?'
                    + [
                        'pageId=' + vtplKey,
                        'pageTitle=' + vtplKey,
                        'vtplKey=' + vtplKey,
                        'act=EDIT#QUICK',
                        'phase=' + phase
                    ].join('&'),
                { vtplModel: me._vtplModel, forceActive: true }
            );   
        };
    	
    };    

    function appendHTML(bizKey,phase,list){
    	var html = [];
        var onerrorHtml="this.src='../asset/css/img/demo.jpg'";
        //
        if (list.size() == 0){
            html.push('<div');
            html.push(' <span > </span>');
            html.push('</div>');
        } else {
        	list.foreach(
        		function (key, vtplInfo, i) {
    	    		html.push('<div class="report-release-block">');
    	    		//html.push('	<img data-index="', encodeHTML(key), '" class="report-release-img" src="../asset/css/img/demo.jpg"/>');
    	    		html.push(' <img data-index="', encodeHTML(key), '" class="report-release-img" onerror='+onerrorHtml+'   src="'+URL.getWebRoot()+'/asset-d/'+bizKey+'/imgs/'+ vtplInfo.snippet.fileName +'.png"/>');
                    html.push('	<span data-index="', encodeHTML(key), '">' + vtplInfo.vtplName +'</span>');
    	    		html.push('</div>');
        		}
        	);
        }
    	return  html.join('');
    }
    /**
     * @override
     */
    REPORT_RELEASE_PAGE_CLASS.dispose = function() {
        REPORT_RELEASE_PAGE.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    REPORT_RELEASE_PAGE_CLASS.$active = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    REPORT_RELEASE_PAGE_CLASS.$inactive = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };
    

})();
/**
 * di.console.model.OLAPEditorModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.console.editor.model');

(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var stringify = baidu.json.stringify;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;
    var COMMON_PARAM_FACTORY;
        
    $link(function() {
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });


    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var OLAP_EDITOR_MODEL = 
            $namespace().OLAPEditorModel = 
            inheritsObject(XDATASOURCE, constructor);
    var OLAP_EDITOR_MODEL_CLASS = 
            OLAP_EDITOR_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     * @param {Object} options.reportType 
     *          TABLE()CHART
     * @param {string} options.schemaName
     * @param {string} options.cubeTreeNodeName
     */
    function constructor(options) {
        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        this._sSchemaName = options.schemaName;
        this._sCubeTreeNodeName = options.cubeTreeNodeName;

        this._fCommonParamGetter = (new COMMON_PARAM_FACTORY()).getGetter(
            { reportTemplateId: options.reportTemplateId }
        );
    }

    /**
     * @override
     */
    OLAP_EDITOR_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_EDITOR_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            INIT: URL.fn('OLAP_REPORT_INIT'),
            SAVE: URL.fn('OLAP_SAVE'),
            COL_CONFIG_GET: URL.fn('META_CONDITION_COL_CONFIG_GET'),
            COL_CONFIG_SUBMIT: URL.fn('META_CONDITION_COL_CONFIG_SUBMIT')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_EDITOR_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            INIT: function (options) { 
                var paramArr = [];
                paramArr.push('type=' + textParam(this._sReportType));
                paramArr.push('schemaName=' + textParam(this._sSchemaName));
                paramArr.push('treeNodeName=' + textParam(this._sCubeTreeNodeName));
                // reporttempateid
                paramArr.push('reportTemplateId=' + textParam(
                    this._fCommonParamGetter.getReportTemplateId()
                ));
                return paramArr.join('&');
            },
            SAVE: function (options) { 
                var param = [];
                param.push(
                    'reportTemplateName=' + textParam(
                        options.args.reportTemplateName
                    ),
                    'reportTemplateId=' + textParam(
                        this._fCommonParamGetter.getReportTemplateId()
                    )
                );
                return param.join('&');
            },
            COL_CONFIG_GET: function () {
                return ''; // TODO
            },
            COL_CONFIG_SUBMIT: function () {
                return ''; // TODO
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_EDITOR_MODEL_CLASS.result = new XDATASOURCE.Set(
        {
            INIT: function(data) {
                this._fCommonParamGetter.update(
                    { reportTemplateId: data ? data['reportTemplateId'] : '' }
                );
            },
            SAVE: function(data) {
                this._fCommonParamGetter.update(
                    { reportTemplateId: data ? data['reportTemplateId'] : '' }
                );
            },
            COL_CONFIG_GET: function () {
                // TODO
            },
            COL_CONFIG_SUBMIT: function () {
                // TODO
            }
        }
    );

    /**
     * @public
     */
    OLAP_EDITOR_MODEL_CLASS.getCommonParamGetter = function() {
        return this._fCommonParamGetter;
    };

})();


/**
 * di.console.model.PlaneEditorModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.console.editor.model');

(function() {

    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var stringify = baidu.json.stringify;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;
    var COMMON_PARAM_FACTORY;
        
    $link(function() {
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var PLANE_EDITOR_MODEL = $namespace().PlaneEditorModel = 
        inheritsObject(XDATASOURCE, constructor);
    var PLANE_EDITOR_MODEL_CLASS = PLANE_EDITOR_MODEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    function constructor(options) {
        options = options || {};
        this._fCommonParamGetter = (new COMMON_PARAM_FACTORY()).getGetter();
        this._sDatasourceName = options.datasourceName;
        this._sReportTemplateId = options.reportTemplateId;
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    PLANE_EDITOR_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            INIT: URL.fn('PLANE_TABLE_INIT'),
            // SQL
            // @param sqlString: selec {a.col1}, {b.col2} from table1 as a, table2 as b where [a.col1=:col1 ] and [b.col2 =:cols2 ]
            // @param templateName
            // @param datasourceName
            // @param reportTemplateId
            // @return  { reportTemplateId: sadsafasdfasdfas }
            // sql10010
            // sql
            SQL_SAVE: URL.fn('PLANE_TABLE_SQL_SAVE'),
            // columncolumn
            // @param reportTemplateId
            // @return [{sqlKey: "a.col1", showName: "", paramKey: "AAAformURLformat: "I,III", orderby: "asc", isDefaultShow: true}, { ... }, {}]
            COL_DATA: URL.fn('PLANE_TABLE_COL_DATA'),
            // columncolumn
            // @param reportTemplateId
            // @param columnJson=[{sqlKey: "a.col1", showName: "", paramKey: "AAAformURLformat: "I,III", orderby: "asc", isDefaultShow: true}, { ... }, {}]
            COL_SAVE: URL.fn('PLANE_TABLE_COL_SAVE'),
            // conditioncondition
            // @param reportTemplateId
            // @return [{sqlKey: "a.col1", paramKey: "AAAformURL }, { ... }, {}]
            COND_DATA: URL.fn('PLANE_TABLE_COND_DATA'),
            // conditioncondition
            // @param reportTemplateId
            // @param condJson=[{sqlKey: "a.col1", paramKey: "AAAformURL }, { ... }, {}]
            COND_SAVE: URL.fn('PLANE_TABLE_COND_SAVE'),
            PREVIEW_DATA: URL.fn('PLANE_TABLE_PREVIEW_DATA')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    PLANE_EDITOR_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            INIT: function (options) {
                // reporttempateid
                return 'reportTemplateId=' + textParam(this._sReportTemplateId);
            },
            SQL_SAVE: function (options) {
                var param = [];
                param.push('sqlString=' + textParam(options.args.sqlString));
                param.push('reportTemplateName=' + textParam(options.args.reportTemplateName));
                param.push('reportTemplateId=' + textParam(this._sReportTemplateId));
                param.push('datasourceName=' + textParam(this._sDatasourceName));
                return param.join('&');
            },
            COL_DATA: handleDataParam,
            COL_SAVE: handleSaveParam,
            COND_DATA: handleDataParam,
            COND_SAVE: handleSaveParam,
            PREVIEW_DATA: handleDataParam
        }
    );

    function handleDataParam() {
        return 'reportTemplateId=' + textParam(this._sReportTemplateId);
    }

    function handleSaveParam() {
        var param = [];
        param.push('reportTemplateId=' + textParam(this._sReportTemplateId));
        param.push('columnJson=' + textParam(stringify(this._oMappingConfig)));
        return param.join('&');
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    PLANE_EDITOR_MODEL_CLASS.result = new XDATASOURCE.Set(
        {
            INIT: handleInitResult,
            SQL_SAVE: handleSubmitResult,
            COL_DATA: handleDataResult,
            COL_SAVE: handleSubmitResult,
            COND_DATA: handleDataResult,
            COND_SAVE: handleSubmitResult,
            PREVIEW_DATA: handlePreviewResult
        }
    );

    function handleInitResult(data) {
        var datasourceName = data.datasourceName;
        if (datasourceName) {
            this._sDatasourceName = datasourceName;
        }
    }

    function handleSubmitResult(data) {
        var reportTemplateId = data.reportTemplateId;
        if (reportTemplateId) {
            this._sReportTemplateId = reportTemplateId;
            this._fCommonParamGetter.update(
                { reportTemplateId: reportTemplateId }
            );
        }
    }

    function handleDataResult(data) {
        this._sReportTemplateId = data.reportTemplateId;
        this._oMappingConfig = data.columnJson || [];
    }

    function handlePreviewResult(data) {
        this._oMappingConfig = data.condJson || [];
        this._oColShow = data.columnJson || [];
    }

    PLANE_EDITOR_MODEL_CLASS.getMappingConfig = function () {
        return this._oMappingConfig;
    };

    PLANE_EDITOR_MODEL_CLASS.getColShow = function () {
        return this._oColShow;
    };

    PLANE_EDITOR_MODEL_CLASS.getCommonParamGetter = function() {
        return this._fCommonParamGetter;
    };

})();


/**
 * di.console.model.PlaneTableEditorModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.console.editor.model');

(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var stringify = baidu.json.stringify;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var PLANE_TABLE_EDITOR_MODEL = 
            $namespace().PlaneTableEditorModel = 
            inheritsObject(XDATASOURCE, constructor);
    var PLANE_TABLE_EDITOR_MODEL_CLASS = 
            PLANE_TABLE_EDITOR_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     * @param {Object} options.reportType 
     *          TABLE()CHART
     * @param {string} options.schemaName
     * @param {string} options.cubeTreeNodeName
     */
    function constructor(options) {
        // this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        // this._sSchemaName = options.schemaName;
        // this._sCubeTreeNodeName = options.cubeTreeNodeName;
        // this._sReportTemplateId;
    }

    /**
     * @override
     */
    PLANE_TABLE_EDITOR_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    PLANE_TABLE_EDITOR_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            // SQL
            // @param sqlString: selec {a.col1}, {b.col2} from table1 as a, table2 as b where [a.col1=:col1 ] and [b.col2 =:cols2 ]
            // @param templateName
            // @param datasourceName
            // @param reportTemplateId
            // @return  { reportTemplateId: sadsafasdfasdfas }
            // sql10010
            // sql
            SQL_SAVE: URL('PLANE_TABLE_SQL_SAVE'),
            // columncolumn
            // @param reportTemplateId
            // columnJson=[{sqlKey: "a.col1", showName: "", paramKey: "AAAformURLformat: "I,III", orderby: "asc", isDefaultShow: true}, { ... }, {}]
            COL_DATA: URL('PLANE_TABLE_COL_DATA'),
            // columncolumn
            // @param reportTemplateId
            // columnJson=[{sqlKey: "a.col1", showName: "", paramKey: "AAAformURLformat: "I,III", orderby: "asc", isDefaultShow: true}, { ... }, {}]
            COL_SAVE: URL('PLANE_TABLE_COL_SAVE'),
            // conditioncondition
            // @param reportTemplateId
            // condJson=[{sqlKey: "a.col1", paramKey: "AAAformURL }, { ... }, {}]
            COND_DATA: URL('PLANE_TABLE_COND_DATA'),
            // conditioncondition
            // @param reportTemplateId
            // condJson=[{sqlKey: "a.col1", paramKey: "AAAformURL }, { ... }, {}]
            COND_SAVE: URL('PLANE_TABLE_COND_SAVE')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    PLANE_TABLE_EDITOR_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            SQL_SAVE: function(options) { 
            //     var paramArr = [];
            //     paramArr.push('schemaName=' + textParam(this._sSchemaName));
            //     paramArr.push('treeNodeName=' + textParam(this._sCubeTreeNodeName));
            //     return paramArr.join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    PLANE_TABLE_EDITOR_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            SQL_SAVE: function(data) {
            //     this._sReportTemplateId = data ? data['reportTemplateId'] : '';
            }
        }
    );

})();


/**
 * di.console.model.VTplModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.console.editor.model');

(function() {
    
    //------------------------------------------
    // 
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var jsonStringify = di.helper.Util.jsonStringify;
    var assign = xutil.object.assign;
    var stringifyParam = xutil.url.stringifyParam;
    var parse = baidu.json.parse;
    var assert = UTIL.assert;
    var parseFileName = UTIL.parseFileName;
    var ajaxRequest = baidu.ajax.request;
    var stringify = baidu.json.stringify;
    var hasValue = xutil.lang.hasValue;
    var getUID = xutil.uid.getUID;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var travelTree = xutil.collection.travelTree;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;
    var VTPL;
    var GLOBAL_MODEL;

    $link(function () {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
        VTPL = di.console.editor.model.VTpl;
    });

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var VTPL_MODEL = 
            $namespace().VTplModel = 
            inheritsObject(XDATASOURCE, constructor);
    var VTPL_MODEL_CLASS = 
            VTPL_MODEL.prototype;
  
    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
//        this._vtpls = new LINKED_HASH_MAP();
        this._molds = new LINKED_HASH_MAP();
        this._vtplMap = {
            release: new LINKED_HASH_MAP(),
        	pre: new LINKED_HASH_MAP(),
            dev: new LINKED_HASH_MAP(),
            all: new LINKED_HASH_MAP()
        };
    }

    /**
     * @override
     */
    VTPL_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    VTPL_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            VTPL_LIST: URL.fn('CONSOLE_VTPL_LIST'),
            // MOLD_LIST: URL.fn('CONSOLE_MOLD_LIST'),
            SAVE_TPL: URL.fn('CONSOLE_SAVE_TPL'),
            GET_COND: URL.fn('CONSOLE_GET_COND'),
            EXIST_COND: URL.fn('CONSOLE_EXIST_COND'),
            DS_LIST: URL.fn('CONSOLE_DS_LIST'),
            TO_PRE: URL.fn('CONSOLE_TO_PRE'),
            TO_RELEASE: URL.fn('CONSOLE_TO_RELEASE'),
            REPORT_QUERY:URL.fn('REPORT_QUERY'),
            MOLD_QUERY:URL.fn('MOLD_QUERY'),
            PAHNTOMJS_INFO:URL.fn('PAHNTOMJS_INFO')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    VTPL_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            SAVE_TPL: function (options) {
                var param = [];
                var vtpl = options.args.vtpl;

                param.push(
                    'virtualTemplateName=' + textParam(vtpl.vtplName),
                    'virtualTemplateId=' + textParam(vtpl.vtplKey),
                    'doCreate=' + (vtpl.status == 'MOLD')
                );
                // FIXME
                // 
                assert(!!vtpl.snippet.content, 'SNIPPET ');
                assert(!!vtpl.depict.content, 'DEPICT ');

                param.push(
                    // reportTemplate
                    'condConf=' + textParam(jsonStringify(vtpl.condSubmitGet())),
                    // 'snippetName=' + textParam(vtpl.vtplKey + '.vm'),
                    'snippetContent=' + textParam(vtpl.snippet.content),
                    // 'depictName=' + textParam(vtpl.vtplKey + '.json'),
                    'depictContent=' + textParam(vtpl.depict.content)
                );
                return param.join('&');
            },
            // cond
            GET_COND: function (options) {
                return stringifyParam(
                    assign({}, options.args, ['reportTemplateIdList', 'virtualTemplateId']),
                    true
                ).join('&');
            },
            // cond
            EXIST_COND: function (options) {
                return stringifyParam(
                    assign({}, options.args, ['reportTemplateIdList', 'virtualTemplateId']),
                    true
                ).join('&');
            },
            DS_LIST: function (options) {
                return 'reportTemplateType=' + textParam(options.args.reportTemplateType);
            },
            TO_PRE: function (options) {
                return 'reportTemplateIdList=' + options.args.vtpl.vtplKey;
            },
            TO_RELEASE: function (options) {
                return 'reportTemplateIdList=' + options.args.vtpl.vtplKey;
            },
            REPORT_QUERY: function (options) {
                return stringifyParam(
                    assign({}, options.args, ['reportName']),
                    true
                ).join('&');
            },
            MOLD_QUERY: function (options) {
                return stringifyParam(
                    assign({}, options.args, ['reportName']),
                    true
                ).join('&');
            },
            PAHNTOMJS_INFO: function (options) {
                return stringifyParam(
                    assign({}, options.args, ['perviewUrl','imgName']),
                    true
                ).join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    VTPL_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            VTPL_LIST: function (data, ejsonObj, options) {
                var list = data.vtplInfo || [];
                for (var i = 0, item, vtpl, vtplKey; i < list.length; i ++) {
                    if ((item = list[i]) && (vtplKey = item.id)) {
                        vtpl = this._vtpls.get(vtplKey);
                        if (!vtpl) {
                            vtpl = new VTPL({
                                vtplKey: vtplKey,
                                vtplName: item.name 
                                    || (item.name = ''),
                                snippet: {
                                    fileName: item.id,
                                    extName: 'vm',
                                    fullName: item.id + '.vm'
                                },
                                depict: {
                                    fileName: item.id,
                                    extName: 'json',
                                    fullName: item.id + '.json'
                                }
                            });
                            vtpl.status = 'SAVED';
                            this._vtpls.set(vtplKey, vtpl);
                        }
                    }
                }
                return data;
            },
            MOLD_LIST: function (data, ejsonObj, options) {
                var list = data.moldFiles || [];
                for (var i = 0, file, vtpl; i < list.length; i ++) {
                    if ((file = parseFileName(list[i])).fileName) {
                        vtpl = this._molds.get(file.fileName) || new VTPL();
                        vtpl[
                            { vm: 'snippet', json: 'depict' }[file.extName]
                        ] = file;
                        // vtplKeyfake
                        vtpl.vtplKey = 'RTPL_VIRTUAL_ID';
                        vtpl.status = 'MOLD';
                        this._molds.set(file.fileName, vtpl);
                    }
                }
                return data;
            },
            PAHNTOMJS_INFO: function (data, ejsonObj, options) {
                return data;
            },
            DS_LIST: function (data, ejsonObj, options) {
                dsList = this._reportTemplateList 
                    = data.reportTemplateList = data.reportTemplateList || [];

                // RTPL_VIRTUAL
                for (j = 0; dso = dsList[j]; ) {
                    dso.reportTemplateType == 'RTPL_VIRTUAL'
                        ? dsList.splice(j, 1)
                        : j ++;
                }

                // fake RTPL_VIRTUAL
                dsList.splice(
                    0, 0, 
                    { 
                        reportTemplateId: 'RTPL_VIRTUAL_ID',
                        reportTemplateType: 'RTPL_VIRTUAL'
                    }
                );
                return data;
            },
            REPORT_QUERY: function (data, ejsonObj, options) {
                //_vtplMap
                this._vtplMap['dev'].clean();
                this._vtplMap['pre'].clean();
                this._vtplMap['release'].clean();
                var releaseList = data.releaseReportInfo;
                var preList = data.preReportInfo;
                var savedList = data.savedReportInfo;
                var reportArray = [
                                   {list:releaseList,	status:'release'},
                                   {list:preList,		status:'pre'},
                                   {list:savedList,		status:'dev'}
                                   ];
                for(var k = 0 ; k < reportArray.length; k ++){
                	var list = reportArray[k].list;
                	var reportStatus = reportArray[k].status;
	                for (var i = 0, item, vtpl, vtplKey; i < list.length; i ++) {
	                    if ((item = list[i]) && (vtplKey = item.id)) {
	                    	
                            vtpl = this._vtplMap[reportStatus].get(vtplKey);
                            
	                        if (!vtpl) {
	                            vtpl = new VTPL({
	                            	// vtplkeyid
	                                vtplKey: vtplKey,
	                                vtplName: item.name 
	                                    || (item.name = ''),
	                                snippet: {
	                                    fileName: item.id,
	                                    extName: 'vm',
	                                    fullName: item.id + '.vm'
	                                },
	                                depict: {
	                                    fileName: item.id,
	                                    extName: 'json',
	                                    fullName: item.id + '.json'
	                                }
	                            });
	                             vtpl.status = reportStatus;
	                             this._vtplMap[reportStatus].set(vtplKey, vtpl);
//	                            this._vtpls.set(vtplKey, vtpl);
	                        }
	                    }
	                }
            	}
                return data;
            },
            MOLD_QUERY:function (data, ejsonObj, options) {
                this._molds.clean();
                var list = data.moldFiles || [];
                for (var i = 0, file, vtpl; i < list.length; i ++) {
                    if ((file = parseFileName(list[i].fileName)).fileName) {
                        vtpl = this._molds.get(file.fileName) || new VTPL();
                        vtpl[
                            { vm: 'snippet', json: 'depict' }[file.extName]
                        ] = file;
                        // vtplKeyfake
                        vtpl.vtplKey = 'RTPL_VIRTUAL_ID';
                        vtpl.status = 'MOLD';
                        vtpl.desc = list[i].desc ;
                        this._molds.set(file.fileName, vtpl);
                    }
                }
                return data;
            },
            SAVE_TPL: defaultParse,
            GET_COND: defaultParse,
            EXIST_COND: defaultParse,
            TO_PRE: defaultParse,
            TO_RELEASE: defaultParse
        }
    );

    function defaultParse(data) { return data; } 

    /**
     * vtpl
     */
    VTPL_MODEL_CLASS.fetchRemoteVTpl = function(vtpl, callback) {
        var me = this;
        var got = 0;
        var url;
        var content = {};

        function getURL(fullName) {
            var path = [URL.getWebRoot()];
            if (vtpl.status == 'MOLD') {
                path.push(
                    DICT.MOLD_PATH,
                    fullName
                );
            }
            else {
                path.push(
                    DICT.VTPL_ROOT,
                    GLOBAL_MODEL().getBizKey(),
                    'dev',
                    fullName
                );
            }
            return path.join('/') + '?__v__=' + Math.random();
        }

        // xxx.vm (snippet)
        ajaxRequest(
            url = getURL(vtpl.snippet.fullName),
            {
                method: 'GET',
                onsuccess: bind(onsuccess, this, url, 'snippet'),
                onfailure: bind(onfailure, this, url)
            }
        );
        // xxx.json (depict)
        ajaxRequest(
            url = getURL(vtpl.depict.fullName),
            {
                method: 'GET',
                onsuccess: bind(onsuccess, this, url, 'depict'),
                onfailure: bind(onfailure, this, url)
            }
        );

        // function requestCondSelected() {
        //     me.sync({
        //         datasourceId: 'EXIST_COND',
        //         args: {
        //             reportTemplateList: vtpl.rtplIdGet(true),
        //             virtualTemplateId: vtpl.vtplKey
        //         },
        //         result: function (data, ejsonObj, options) {
        //             vtpl.rtplCond = data.templateDims || {};
        //             // 
        //             callback();
        //         },
        //         error: function (status, ejsonObj, options) {
        //             me.disable();
        //             alert('status=' + status);
        //         }
        //     });
        // }

        function onsuccess(url, vtplType, xhr, rspText) {
            got ++;

            content[vtplType] = rspText;

            // 
            if (got === 2) {
                // 
                vtpl.contentSet(content.snippet, content.depict, true);
                // ""
                // requestCondSelected();
                callback();
            }
        }

        function onfailure(url, xhr, rspText) {
            me.disable();
            alert('vtplurl=' + url + ' status=' + xhr.status);
        }
    };

    /**
     * @public
     */
    VTPL_MODEL_CLASS.getVTpls = function(phase) {
        return this._vtplMap[phase];
    };

    /**
     * @public
     */
    VTPL_MODEL_CLASS.getVTpl = function(phase, vtplKey) {
        return this._vtplMap[phase].get(vtplKey);
    };

    /**
     * @public
     */
    VTPL_MODEL_CLASS.getMolds = function() {
        return this._molds;
    };


    VTPL_MODEL_CLASS.getBizKey = function() {
        return GLOBAL_MODEL().getBizKey();
    };
    
    /**
     * @public
     */
    VTPL_MODEL_CLASS.getMold = function(moldKey) {
        return this._molds.get(moldKey);
    };

    /**
     * @public
     */
    VTPL_MODEL_CLASS.getReportTemplateList = function() {
        return this._reportTemplateList;
    };

    /**
     * menu(vtpl)
     *
     * @public
     */
    VTPL_MODEL_CLASS.getVTplMenuData = function() {
        var menuList = [];
        var menuTree = { menuList: menuList };
        var selMenuId;
        var chList = [];
        var prefix = 'MENU_ID_VTPL';

        menuList.push(
            {
                text: '',
                value: prefix + '1',
                children: chList
            }
        );

        this._vtpls.foreach(
            function (vtplKey, vtpl, index) {
                var pageId = vtplKey + getUID();
                chList.push(
                    {
                        text: vtpl.vtplName,
                        prompt: '[reportTemplateId]: ' + vtpl.vtplKey,
                        floatTree: [
                            {
                                children: [
                                    {
                                        text: '',
                                        // value: prefix + getUID(),
                                        url: 'di.console.editor.ui.VTplPanelPage?'
                                            + [
                                                'pageId=' + pageId,
                                                'pageTitle=' + vtplKey,
                                                'vtplKey=' + vtplKey,
                                                'act=EDIT#QUICK'
                                            ].join('&')
                                    },
                                    {
                                        text: '',
                                        // value: prefix + getUID(),
                                        url: 'di.console.editor.ui.VTplPanelPage?'
                                            + [
                                                'pageId=' + pageId,
                                                'pageTitle=' + vtplKey,
                                                'vtplKey=' + vtplKey,
                                                'act=EDIT#CODE'
                                            ].join('&')
                                    }
                                ]
                            }
                        ]
                    }
                );
            }
        );

        menuTree.selMenuId = prefix + '1';

        return { menuTree: menuTree };
    };

    /**
     * menu(vtpl)
     *
     * @public
     */
    VTPL_MODEL_CLASS.getMoldMenuData = function() {
        var menuList = [];
        var menuTree = { menuList: menuList };
        var selMenuId;
        var chList = [];
        var prefix = 'MENU_ID_MOLD';

        menuList.push(
            {
                text: '',
                value: prefix + '1',
                children: chList
            }
        );

        this._molds.foreach(
            function (moldKey, mold, index) {
                chList.push(
                    {
                        text: moldKey,
                        // FIXME
                        value: prefix + (10000 + index),
                        floatTree: [
                            {
                                value: prefix + String(Math.random()),
                                children: [
                                    {
                                        text: '',
                                        value: prefix + String(Math.random()),
                                        url: 'di.console.editor.ui.VTplPanelPage?'
                                            + [
                                                'pageTitle=' + ' [' + moldKey + ']',
                                                'moldKey=' + moldKey,
                                                'act=CREATE#QUICK',
                                                'forceCreate=true'
                                            ].join('&')
                                    }
                                ]
                            }
                        ]
                    }
                );
            }
        );

        menuTree.selMenuId = prefix + '1';

        return { menuTree: menuTree };
    };

})();


/**
 * di.console.model.VTpl
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    Model
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil, jsl, htmlClean
 */

$namespace('di.console.editor.model');

(function() {

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var clone = xutil.object.clone;
    var parseFileName = UTIL.parseFileName;
    var ajaxRequest = baidu.ajax.request;
    var jsonStringify = baidu.json.stringify;
    var jsonParse = baidu.json.parse;
    var jsonFormat = jsl.format.formatJson;
    var jsonValidate = jsl.parser.parse;
    var hasClass = xutil.dom.hasClass;
    var getByPath = xutil.object.getByPath;
    var setByPath = xutil.object.setByPath;    
    var isString = xutil.lang.isString;
    var isArray = xutil.lang.isArray;
    var isNumber = xutil.lang.isNumber;
    var indexOf = UTIL.indexOf;
    var hasValue = xutil.lang.hasValue;
    var getUID = xutil.uid.getUID;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var travelTree = xutil.collection.travelTree;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var assert = UTIL.assert;

    /**
     * 
     * 
     *      depict.objsnippet.el
     *      stringifydepict.contentsnippect.content
     *      vtplcontentcontentSet
     *
     * vtpl
     * {
     *     vtplKey: virtualTemplateId, snippetdepict,
     *     vtplName: ,
     *     status: 
     *         'MOLD'mold, 
     *         'SAVED', 
     *         'CHANGED'
     *     snippet: {
     *         fileName: vtplKey,
     *         extName: 'vm',
     *         fullName: vtplKey + '.vm'
     *         content: ,
     *         oriContent: 
     *     },
     *     depict: {
     *         fileName: vtplKey,
     *         extName: 'vm',
     *         fullName: vtplKey + '.vm'
     *         content: ,
     *         oriContent: ,
     *         obj: json
     *     },
     *     rtplCond: {
     *         xxxxxreportTemplateId1: { {name: 'aaa', ...}, {}, ... },
     *         xxxxxreportTemplateId2: { ... }
     *     }
     * }
     *
     * @class
     * @extends xui.XDatasource
     */
    var VTPL = $namespace().VTpl = function (obj) {
        extend(this, obj || {});
        this.depict = this.depict || {};
        this.snippet = this.snippet || {};
        this.rtplCond = this.rtplCond || {};
    };
    var VTPL_CLASS = VTPL.prototype;

    /**
     * entityId
     * 
     * id
     *
     *
     * @public
     */
    VTPL_CLASS.genId = function () {
        var entityDefs = this.getEntityDefs();
        var idSet = {};
        for (var i = 0; i < entityDefs.length; i ++) {
            idSet[entityDefs[i]] = 1;
        }
        var newId;
        do {
            newId = (new Date()).getTime() + '_' + getUID();
        }
        while (newId in idSet);
        return newId;
    };

    /**
     * 
     *
     * @public
     */
    VTPL_CLASS.clone = function () {
        var newObj = new VTPL();
        // extend
        // 
        newObj.vtplKey = this.vtplKey;
        newObj.vtplName = this.vtplName;
        newObj.status = this.status;
        newObj.depict = clone(this.depict);
        newObj.snippet = clone(this.snippet);
        newObj.rtplCond = clone(this.rtplCond);

        // HTMLElementclone
        var el = this.snippet.el;
        if (el) {
            newObj.snippet.el = document.createElement('div');
            newObj.snippet.el.innerHTML = el.innerHTML;
        }

        return newObj;
    };

    /**
     * conent
     * 
     * @public
     * @param {boolean} force content
     * @return {string} errorMsg setjson.parse
     *      
     */
    VTPL_CLASS.contentSet = function(snippetContent, depictContent, force) {
        // ie
        // format
        // FIXME
        var errorMsg = [];
        var res;

        try {
            // json parse
            depictContent = jsonFormat(depictContent);
            jsonValidate(depictContent);

            // parse
            res = parseContent(snippetContent, depictContent);
            errorMsg.push.apply(errorMsg, res.errorMsg);
        }
        catch (e) {
            // FIXME
            // 
            errorMsg.push('JSON\n' + e.message);
        }

        if (force || !errorMsg.length) {
            // 
            this.depict.content = depictContent;
            this.snippet.content = snippetContent;
        }

        if (!errorMsg.length) {
            // 
            this.depict.obj = res.depict.obj;
            this.snippet.el = res.snippet.el;
        }

        // depict content
        // contentStringifycontent
        this.$fixDepict();

        return errorMsg;
    };

    /**
     * vtpl.depict.objvtpl.snippet.elcontent
     * 
     * @public
     */
    VTPL_CLASS.contentStringify = function() {
        var errorMsg = [];
        var depictContent;
        var snippetContent;
        var depict = this.depict;
        var snippet = this.snippet;

        try {
            // stringify depict
            depictContent = jsonFormat(jsonStringify(depict.obj));

            // stringify snippet
            var pos = parseFlagPos(snippet.content);
            if (pos) {
                var bstr = snippet.content.slice(0, pos.start);
                var estr = snippet.content.slice(pos.end);
                snippetContent = [
                    bstr, 
                    ' \n ', 
                    formatSnippet(snippet.el.innerHTML),
                    ' \n ', 
                    estr
                ].join('');
            }
            else {
                errorMsg.push('DOM FLAG, SNIPPET');
            }
        }
        catch (e) {
            errorMsg.push('StringifyJSON\n' + e.message);
        }

        if (!errorMsg.length) {
            // 
            errorMsg.concat(this.contentSet(snippetContent, depictContent));
        }

        return errorMsg;
    };   

    /**
     * vtplOther
     * 
     * @public
     */
    VTPL_CLASS.replaceWith = function(vtplOther) {
        // 
        for (var i in this) {
            if (this.hasOwnProperty(i)) {
                this[i] = void 0;
            }
        }
        // 
        extend(this, vtplOther);
    }; 

    /**
     * vtplcontent
     * 
     * @private
     * @return {Object} parse
     */
    function parseContent(snippetContent, depictContent) {
        var snippet = {};
        var depict = {};
        var errorMsg = [];
        
        // depict
        try {
            depict.obj = jsonParse(depictContent);
        }
        catch (e) {
            errorMsg.push('JSON' + e);
        }

        // snippet
        var el = snippet.el = document.createElement('div');
        var pos = parseFlagPos(snippetContent);
        if (pos) {
            el.innerHTML = snippetContent.slice(pos.start, pos.end);
        }
        else {
            snippet.invalid = true;
            errorMsg.push('SNIPPET');
        }

        return {
            snippet: snippet,
            depict: depict,
            errorMsg: errorMsg
        };
    };

    function parseFlagPos(snippetContent) {
        var start = snippetContent.indexOf(DICT.DOM_FLAG_BEGIN);
        var end = snippetContent.indexOf(DICT.DOM_FLAG_END);
        return (start < 0 || end < 0)
            ? null
            : { 
                start: start + DICT.DOM_FLAG_BEGIN.length, 
                end: end 
            };
    };

    /**
     * virtualTemplate"RTPL_VIRTUAL_ID"
     * reportTypeentityreportTemplateId
     * reportType
     * 
     * @private
     */
    VTPL_CLASS.$fixDepict = function () {
        this.forEachEntity(
            'COMPONENT',
            function (def) {
                if (!def.reportType) {
                    def.reportTemplateId = void 0;
                }
                if (def.reportType == 'RTPL_VIRTUAL') {
                    def.reportTemplateId = 'RTPL_VIRTUAL_ID';
                }
            }
        );
    };

    /**
     * rtplCondrtplCond
     * 
     * @public
     */
    VTPL_CLASS.condClean = function (cpntId, vuiId) {
        var rtplCond = this.rtplCond;
        var rtplIdMap = {};
        var rtplId;
        var i;
        var j;

        this.forEachEntity(
            'COMPONENT',
            function (def) {
                var rtplId;
                if (def.reportType == 'RTPL_VIRTUAL' 
                    || def.reportTemplateId == 'RTPL_VIRTUAL_ID'
                ) {
                    rtplId = 'RTPL_VIRTUAL_ID';
                }
                else if (def.reportTemplateId) {
                    rtplId = def.reportTemplateId;
                }
                if (!rtplIdMap[rtplId]) {
                    rtplIdMap[rtplId] = [];
                }
                rtplIdMap[rtplId].push(def);
            }
        );

        // rtplCondrtplIdvtplrtplId
        for (rtplId in rtplIdMap) {
            if (!rtplCond[rtplId]) {
                // 
                rtplCond[rtplId] = [];
            }
        }
        for (rtplId in rtplCond) {
            if (!rtplIdMap[rtplId]) {
                delete rtplCond[rtplId];
            }
        }

        // cond
        for (rtplId in rtplCond) {
            var cpntDefArr = rtplIdMap[rtplId];

            // rtplIdnamertplcpntDefvuiRefname
            var nameSet = {};
            var cpntDef;
            for (i = 0; cpntDef = cpntDefArr[i]; i ++) {
                var vuiRef = this.getVUIRef(cpntDef.id, 'input');
                for (j = 0; j < vuiRef.length; j ++) {
                    var vuiDef = this.findEntityById(vuiRef[j]);
                    vuiDef && vuiDef.name && (nameSet[vuiDef.name] = 1);
                }
            }

            // 
            var rtplConds = rtplCond[rtplId];
            for (i = 0; i < rtplConds.length; ) {
                if (!nameSet.hasOwnProperty((rtplConds[i] || {}).name)) {
                    rtplConds.splice(i, 1);
                }
                else {
                    i ++;
                }
            }
        }
    };

    /**
     * cond
     * virtualTempalteIdtplKey=="RTPL_VIRTUAL_ID"
     * 
     * @public
     */
    VTPL_CLASS.condGet = function (tplKey, name) {
        if (!tplKey || !name) {
            return null;
        }
        var rtplConds = this.rtplCond[tplKey] || [];
        for (var i = 0, cond; i < rtplConds.length; i ++) {
            if ((cond = rtplConds[i]) && name == cond.name) {
                return cond;
            }
        }
    };

    /**
     * TODO
     * virtualTemplate
     * 
     * virtualTemplateclone
     * 
     * virtualTemplate
     * cond-config-panel
     * 
     * @public
     */
    VTPL_CLASS.condSubmitGet = function () {
        // var rtplIdMap = this.rtplIdGet(false, true);
        var rtplCond = clone(this.rtplCond);
        if (!rtplCond) {
            // 
            return {};
        }

        // ridRTPL_VIRTUAL_ID
        var rid;
        var vCond = rtplCond['RTPL_VIRTUAL_ID'];
        if (vCond) {
            for (rid in rtplCond) {
                var c = rtplCond[rid];
                if (c != vCond) {
                    // name
                    c.push.apply(c, vCond);
                }
            }
        }

        return rtplCond;
    };

    /**
     * condmerge
     * 
     * @public
     * @return {boolean} 
     */
    VTPL_CLASS.condAdd = function(tplKey, cond) {
        if (this.condGet(tplKey, cond.name)) {
            return false;
        }
        var o = this.rtplCond[tplKey];
        if (!o) {
            o = this.rtplCond[tplKey] = [];
        }
        o.push(cond);
        return true;
    };   

    /**
     * @public
     */
    VTPL_CLASS.findEntityByClzType = function(clzType) {
        var ret = [];
        var entityDefs = this.getEntityDefs();
        if (entityDefs) {
            for (var i = 0, o; i < entityDefs.length; i ++) {
                if ((o = entityDefs[i]) && o.clzType == clzType) {
                    ret.push(o);
                }
            }
        }

        return ret;
    };

    /**
     * @public
     */
    VTPL_CLASS.findEntityById = function(id) {
        var entityDefs = this.getEntityDefs();
        if (entityDefs) {
            for (var i = 0, o; i < entityDefs.length; i ++) {
                if ((o = entityDefs[i]) && o.id == id) {
                    return o;
                }
            }
        }
    };

    /**
     * vui, component
     *
     * @public
     */
    VTPL_CLASS.findCPNTByVUI = function (vuiId) {
        var cpnt;
        var me = this;

        this.forEachEntity(
            'COMPONENT',
            function (def) {
                var refIds = me.getVUIRef(def.id);
                for (var i = 0; i < refIds.length; i ++) {
                    if (refIds[i] == vuiId) {
                        cpnt = def;
                    }
                }
            }
        );

        return cpnt;
    };

    /**
     * data-di-o_o-iddomcomponent
     *
     * @public
     */
    VTPL_CLASS.findCPNTByDom = function (targetEl, rootEl) {
        var diId = targetEl.getAttribute(DICT.DI_ATTR);
        if (!diId) {
            return [];
        }
        rootEl = rootEl || this.snippet.el;

        var def = this.findEntityById(diId);
        var cpnt;

        if (def.clzType == 'VUI') {
            cpnt = this.findCPNTByVUI(def.id);
        }        
        else if (def.clzType == 'COMPONENT') {
            cpnt = def;
        }

        return cpnt;
    };  

    /**
     * cpntIdcomponententityvuiRefdom
     *
     * @public
     */
    VTPL_CLASS.findCPNTDoms = function (cpntId, rootEl) {
        return this.findDomsByIds(
            this.getVUIRef(cpntId).concat([cpntId]),
            rootEl
        );
    };     

    /**
     * diIddom
     *
     * @public
     * @param {array} diIds 
     * @param {HTMLElement} rootEl dom
     * @return {array} domdiIds
     */
    VTPL_CLASS.findDomsByIds = function (diIds, rootEl) {
        var ret = [];
        rootEl = rootEl || this.snippet.el;
        var els = rootEl.getElementsByTagName('*');

        for (var i = 0, el; el = els[i]; i ++) {
            var domId = el.getAttribute(DICT.DI_ATTR);
            for (var j = 0; j < diIds.length; j ++) {
                if (domId == diIds[j]) {
                    ret[j] = el;
                }
            }
        }
        return ret;    
    };

    /**
     * entity
     *
     * @public
     * @param {(string|Array)=} clzType 
     *      entity
     * @param {Function} callback 
     *              {Object} def
     */
    VTPL_CLASS.forEachEntity = function (clzType, callback) {
        var entityDefs = this.getEntityDefs();
        if (entityDefs) {
            for (var i = 0, o; i < entityDefs.length; i ++) {
                if ((o = entityDefs[i]) && (!clzType || o.clzType == clzType)) {
                    callback(o);
                }
            }
        }
    };

    /**
     * rtplId
     *
     * @public
     * @param {boolean} excludeVirtual reportTypedef
     *      reportTypeRTPL_VIRTUALvtpl, 
     * @param {booelan} returnMap truemapfalsearray
     * @return {Array} rtplIdList
     */
    VTPL_CLASS.rtplIdGet = function (excludeVirtual, returnMap) {
        // 
        var idSet = {};
        var entityDefs = this.getEntityDefs() || [];
        for (var i = 0, def, rid; def = entityDefs[i]; i ++) {
            if ((rid = def.reportTemplateId)
                && (
                    !excludeVirtual 
                    || (
                        def.reportType 
                        && def.reportType != 'RTPL_VIRTUAL'
                    )
                )
            ) {
                idSet[rid] = 1;
            }
        }

        if (!returnMap) {
            var ret = [];
            for (var rtplId in idSet) {
                ret.push(rtplId);
            }
            return ret;
        }
        else {
            return idSet;
        }
    };

    /**
     * entityinneHTML
     *
     * @public
     * @param {(string|Array)} rid entityid
     *      arrayrid[0]entityidrid[1]flagCSScss
     *      innerHTML
     * @param {string} html
     * @return {string} html
     */
    VTPL_CLASS.innerHTML = function (rid, html) {
        var flagCSS;
        if (isArray(rid)) {
            flagCSS = rid[1];
            rid = rid[0];
        }

        var target;
        var el = this.snippet.el;

        if (!el) {
            return null;
        }

        if (!rid) {
            target = el;
        }
        else {
            var els = el.getElementsByTagName('*');
            for (var i = 0, o; o = els[i]; i ++) {
                if (o.getAttribute(DICT.DI_ATTR) == rid) {
                    target = o;
                    break;
                }
            }
            
            if (!target) { return null; }

            // flagCSStargetflagCSS
            if (flagCSS && !hasClass(target, flagCSS)) {
                target = q(flagCSS, target)[0];
            }
        }

        if (!target) { return null; }


        if (html) {
            target.innerHTML = html;
        }
        return target.innerHTML;
    };

    /**
     * @public
     */
    VTPL_CLASS.getEntityDefs = function () {
        return (this.depict.obj || {}).entityDefs || [];
    };   

    /**
     * @public
     */
    VTPL_CLASS.addEntityDef = function (entityDef) {
        var obj = this.depict.obj;
        if (obj && entityDef) {
            // FIXME
            // 
            obj.entityDefs.push(entityDef);
        }
    };

    /**
     * @public
     */
    VTPL_CLASS.removeEntityDef = function (entityId) {
        var entityDefs = this.getEntityDefs();
        for (var i = 0, ett; i < entityDefs.length; ) {
            if (ett = entityDefs[i]) {
                ett.id === entityId
                    ? entityDefs.splice(i, 1)
                    : i ++;
            }
        }
    };

    /**
     * @public
     */
    VTPL_CLASS.removeVUIRef = function (cpntId, vuiId) {
        var cpntDef = this.findEntityById(cpntId);
        if (cpntDef) {
            var arr = getByPath('vuiRef.input', cpntDef) || [];
            for (var i = 0; i < arr.length; ) {
                arr[i] === vuiId
                    ? arr.splice(i, 1)
                    : i ++;
            }
        }
    };

    /**
     * @public
     */
    VTPL_CLASS.removeVUIRefAll = function (vuiId) {
        var me = this;
        this.forEachEntity(
            null,
            function (def) {
                me.removeVUIRef(def.id, vuiId);
            }
        );
    };

    /**
     * @public
     */
    VTPL_CLASS.addVUIRef = function (cpntId, vuiId) {
        var cpntDef = this.findEntityById(cpntId);
        if (cpntDef) {
            var arr = getByPath('vuiRef.input', cpntDef);
            if (!arr) {
                setByPath('vuiRef.input', arr = []);
            }
            // 
            indexOf(arr, vuiId) < 0 && arr.push(vuiId);
        }
    };  

    /**
     * @public
     * @param {string} cpntId
     * @param {string} attrName 
     */
    VTPL_CLASS.getVUIRef = function (cpntId, attrName) {
        var cpntDef = this.findEntityById(cpntId);
        if (cpntDef) {
            if (attrName) {
                return getByPath('vuiRef.' + attrName, cpntDef) || [];
            }
            else {
                var ref = [];
                var travel = function (o) {
                    if (isString(o) || isNumber(o)) {
                        ref.push(o);
                        return;
                    }
                    for (var i in o) {
                        travel(o[i]);
                    }
                };
                travel(cpntDef.vuiRef);
                return ref;
            }
        }
        return [];
    };

    /**
     * vtplKeyvirtualTemplateId
     * statusMOLDvtplKeyRTPL_VIRTUAL_ID
     * vtplKey
     *
     * @public
     */
    // VTPL_CLASS.vtplKeyUpdate = function (vtplKey) {
    //     assert(vtplKey != null, 'vtplKey');
    //     var defaultKey = 'RTPL_VIRTUAL_ID';

    //     if (vtplKey != this.vtplKey) {
    //         this.vtplKey = vtplKey;

    //         // rtplCond
    //         var rtplCond;
    //         this.rtplCond[vtplKey] = rtplCond[defaultKey];
    //         this.rtplCond[defaultKey] = null;

    //         // depictentityDefs
    //         var entityDefs = this.getEntityDefs();
    //         if (entityDefs) {
    //             for (var i = 0; i < entityDefs.length; i ++) {
    //                 if (entityDefs[i].reportType == 'RTPL_VIRTUAL') {
    //                     entityDefs[i].reportTemplateId = vtplKey;
    //                 }
    //             }
    //             // stringify depict
    //             this.depict.content = jsonStringify(this.depict.obj)
    //         }
    //     }
    // };

    /**
     * 
     *
     * @public
     */
    VTPL_CLASS.statusUpdate = function (status) {
        status && (this.status = status);
    };

    /**
     * snippet
     *
     * @public
     */
    function formatSnippet(html) {
        // jquery
        return $.htmlClean(
            html,
            {
                format: true ,
                allowedAttributes: [
                    ["data-o_o-di"],
                    ["id"],
                    ["class"],
                    ["style"],
                    ["data-toggle"],
                    ["data-target"],
                    ["data-parent"],
                    ["role"],
                    ["data-dismiss"],
                    ["aria-labelledby"],
                    ["aria-hidden"],
                    ["data-slide-to"],
                    ["data-slide"]
                ]
            }
        );
    }

})();


/**
 * di.console.editor.ui.ColConfigPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    olap
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var textSubstr = xutil.string.textSubstr;
    var encodeHTML = xutil.string.encodeHTML;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var htmlText = xutil.string.htmlText;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * olap
     *
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var COL_CONFIG_PANEL = $namespace().ColConfigPanel =
        inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this._mModel = options.model;
                this._mDITableModel = options.diTableModel;
                this.DATASOURCE_ID_MAPPING = {
                    // INIT: 'GET_COND'
                    // SUBMIT: ''
                };
            }
        );
    var COL_CONFIG_PANEL_CLASS = COL_CONFIG_PANEL.prototype;

    var CUT_NUMBER = 30;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    COL_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
        // unbind
    };

    /** 
     * @override
     */
    COL_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
        // openopen
        
        this._reportTemplateId = options.reportTemplateId;
    };

    /** 
     * @override
     */
    COL_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        // dispose
        contentEl.innerHTML = ''
        
        var css = 'cond-config-panel';
        var tableData = (this._mDITableModel.getData() || {}).tableData || {};
        var colFields = tableData.colFields || [];
        var colDefine = tableData.colDefine || [];
        var i;
        var j;
        var line;
        var wrap;
        var leftLock = 1;

        var html = [];
        html.push('<table cellpadding="0" cellspacing="0" width="100%" class="', css, '-table ', 'ui-table"><thead>');

        // render head
        for (i = 0; line = colFields[i]; i ++) {
            html.push('<tr>');

            // 
            html.push('<th>&nbsp;</th>');

            for (j = 0; j < line.length; j ++) {
                if (isPlaceholder(wrap = line[j])) {
                    continue;
                }
                this.$renderHCell(
                    html,
                    // colField
                    i == colFields.length - 1 ? colDefine[j] : null,
                    wrap,
                    j,
                    i
                );
            }
            html.push('</tr>');
        }

        html.push('</thead><tbody>');

        // render body

        html.push('</tbody></table>');

        contentEl.innerHTML = html.join('');



        var entityId = this._entityId;
        var isCreate = this._isCreate;
        var vtpl = this._vtplFork;
        var entityDef = !isCreate
            ? this._vtplFork.findEntityById(entityId)
            : {
                id: entityId,
                clzType: 'VUI'
            };
        var candidateCond = (data.templateDims || {})[this._tplKey] || [];
        var rtplCond = vtpl.condGet(this._tplKey, entityDef.name) || {};
        var html = [];
        var contentEl = this.getContentEl();
        var condEl = this._condEl;

        html.push('<div>');
        html.push('<span></span>');
        makeClzKeySel(html);
        html.push('<span></span>');
        makeParamNameSel(html);
        html.push('<span></span>');
        makeLevelSel(html);
        html.push('</div>');

        html.push('<div>');
        // 
        html.push(
            '<span title="">fetchURL: </span>',
            '<input class="', css + '-fetch-url" value="', 
                rtplCond.fetchURL || '','" />'
        );
        html.push(
            '<span title="">: </span>',
            '<input class="', css + '-default-value" value="', 
                rtplCond.defaultValue || '','" />'
        );
        makeRequiredSelect(html);
        makeHandlerSelect(html);
        html.push('</div>');

        contentEl.innerHTML = html.join('');

        // thisdom
        this._clzKeySel = q(css + '-clz-key-sel', contentEl)[0];
        this._handlerSel = q(css + '-handler-sel', contentEl)[0];
        this._paramNameSel = q(css + '-param-name-sel', contentEl)[0];
        this._levelSel = q(css + '-level-sel', contentEl)[0];

        // 
        var clzKeyChange = bind(
            function (rtplCond, DICT) {
                var cSel = this._clzKeySel;
                var hSel = this._handlerSel;
                var clzKey = (cSel.options[cSel.selectedIndex] || {}).value;
                // arghandler
                var handlers = clzKey
                    ? DICT.findClzDef(clzKey, 'VUI').rtplParamHandler
                    : [];
                var htm = [];
                for (var i = 0, h, sel; h = handlers[i]; i ++) {
                    sel = h == rtplCond.handler ? ' selected="selected" ' : ''
                    htm.push(
                        '<option value="', h, '" ', sel, '>', h, '</option>'
                    );
                }
                hSel.innerHTML = htm.join('');
            }, 
            this, 
            rtplCond,
            DICT
        );
        this._clzKeySel.onchange = clzKeyChange;

        // 
        var paramNameChange = bind(
            function (rtplCond, DICT) {
                var pSel = this._paramNameSel;
                var lSel = this._levelSel;
                var paramName = (pSel.options[pSel.selectedIndex] || {}).value;
                var htm = [];
                for (var i = 0, o, sel; o = candidateCond[i]; i ++) {
                    if (o.name == paramName && o.levels && o.levels.length) {
                        for (var j = 0; j < o.levels.length; j ++) {
                            var l = o.levels[j];
                            sel = l == rtplCond.level ? ' selected="selected" ' : '';
                            htm.push(
                                '<option value="', l, '" ', sel, '>', l, '</option>'
                            );
                        }
                    }
                }
                lSel.innerHTML = htm.join('');
            }, 
            this, 
            rtplCond,
            DICT
        );
        this._paramNameSel.onchange = paramNameChange;

        // 
        clzKeyChange();
        paramNameChange();

        return;

        // clzKey sel
        function makeClzKeySel(html) {
            var formDef = DICT.findClzDef('DI_FORM', 'COMPONENT');

            html.push('<select class="', css, '-clz-key-sel">');
            for (
                var i = 0, clzKey, sel, vuiDef;
                clzKey = formDef.vuiRefCandidate.input[i];
                i ++
            ) {
                vuiDef = DICT.findClzDef(clzKey, 'VUI');
                if (vuiDef.editorDisable) {
                    continue;
                }
                
                // 
                sel = entityDef.clzKey == clzKey
                    ? sel = ' selected="selected" ' : ' ';
                html.push('<option value="', clzKey, '" ', sel, '>', vuiDef.caption, '</option>')
            }
            html.push('</select>');
        }

        // param name selparam nameschema
        function makeParamNameSel(html) {
            html.push('<select class="', css, '-param-name-sel">');
            for (var i = 0, o, sel; o = candidateCond[i]; i ++) {
                // 
                sel = entityDef.name == o.name 
                    ? sel = ' selected="selected" ' : ' ';
                html.push('<option value="', o.name, '" ', sel, '>', o.caption, '', o.name, '</option>')
            }
            html.push('</select>');
        }

        function makeLevelSel(html) {
            // handlerparamNameSel
            html.push(
                '<select class="', css, '-level-sel">',
                '</select>'
            );
        }

        function makeRequiredSelect(html) {
            html.push('<span></span>');
            var sel = { 'true': '', 'false': '' };
            // 
            sel[String(!!rtplCond.required)] = ' selected="selected" ';
            html.push(
                '<select class="', css, '-required-sel">',
                    '<option value="true" ', sel['true'], '></option>',
                    '<option value="false" ', sel['false'], '></option>',
                '</select>'
            );
        }

        function makeHandlerSelect(html) {
            // handlerclzKeySel
            html.push(
                '<select class="', css, '-handler-sel">',
                '</select>'
            );
        }
    };

    /**
     * 
     *
     * @protected
     */
    COL_CONFIG_PANEL_CLASS.$renderHCell = function(
        // colField
        html, colDefItem, wrap, x, y
    ) {
        var type = this.getType();
        var classStr = [type + '-hcell'];
        var styleStr = [];
        var attrStr = [];
        var span = [];
        var innerStr;

        wrap = objWrap(wrap);

        span.push(wrap.colspan ? ' colspan="' + wrap.colspan + '" ' : '');
        span.push(wrap.rowspan ? ' rowspan="' + wrap.rowspan + '" ' : '');

        if (colDefItem && colDefItem.width) {
            styleStr.push('width:' + colDefItem.width + 'px;');
        }
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');
        innerStr = this.$renderCellInner(
            'HCELL', null, wrap, attrStr, classStr, styleStr
        );
        html.push(
            '<th ', 
                span.join(' '), ' ',
                attrStr.join(' '), ' ',
                ' class="', classStr.join(' '), 
                '" style="', styleStr.join(' '), 
            '">', 
                innerStr, 
            '</th>'
        );
    }; 

    /**
     * 
     *
     * @private
     * @param {string} cellType 'ROWHCELL', 'HCELL', 'CCELL'
     * @param {Object=} defItem 
     * @param {Object} wrap 
     * @param {Array} attrStr 
     * @param {Array} classStr css class
     * @param {Array} styleStr css style
     * @return {string} html
     */
    COL_CONFIG_PANEL_CLASS.$renderCellInner = function(
        cellType, defItem, wrap, attrStr, classStr, styleStr
    ) {
        var indentStyle = '';
        var clz = '';
        var type = this.getType();
        var value = getWrapValue(cellType, wrap);
        var prompt = value.prompt;
        value = value.value;

        if (prompt) {
            attrStr.push('title="' + prompt + '"');
        }
        return value;
    };

    /** 
     * @override
     */
    COL_CONFIG_PANEL_CLASS.$doGetInitArgs = function() {
        if (this._reportType == 'RTPL_VIRTUAL') {
            return {
                virtualTemplateId: 'RTPL_VIRTUAL_ID',
                reportTemplateIdList: this._vtplFork.rtplIdGet(true) 
            };
        }
        else {
            return {
                reportTemplateIdList: [this._tplKey]
            };
        }
    };

    /** 
     * @override
     */
    COL_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var css = 'cond-config-panel';
        var cpntId = this._cpntId;
        var entityId = this._entityId;
        var vtpl = this._vtplFork;
        var tplKey = this._tplKey;
        var isCreate = this._isCreate;
        var mainEl = this.getEl();
        var el;

        // vtplFork.rtplCond
        el = q(css + '-param-name-sel', mainEl)[0];
        var name = (el.options[el.selectedIndex] || {}).value;
        el = q(css + '-clz-key-sel', mainEl)[0];
        var clzKey = (el.options[el.selectedIndex] || {}).value;
        var fetchURL = q(css + '-fetch-url', mainEl)[0].value;
        var defaultValue = q(css + '-default-value', mainEl)[0].value;
        el = q(css + '-required-sel', mainEl)[0];
        var required = strToBoolean((el.options[el.selectedIndex] || {}).value);
        el = q(css + '-handler-sel', mainEl)[0];
        var handler = (el.options[el.selectedIndex] || {}).value
        el = q(css + '-level-sel', mainEl)[0];
        var level = (el.options[el.selectedIndex] || {}).value

        // 
        // if (isCreate && vtpl.condGet(this._tplKey, name)) {
        //     return '' + entityDef.name + '';
        // }

        // entityDef
        var entityDef;
        if (isCreate) {
            // entityDef
            vtpl.addEntityDef(entityDef = { id: entityId, clzType: 'VUI' } );
            // DI_FORMVUI
            vtpl.addVUIRef(cpntId, entityId);
        }
        else {
            entityDef = vtpl.findEntityById(entityId);
        }
        entityDef.name = name;
        entityDef.clzKey = clzKey;      

        // rtplCond
        var rtplCond;
        if (name && !(rtplCond = vtpl.condGet(tplKey, name))) {
            vtpl.condAdd(tplKey, rtplCond = {});
        }
        if (rtplCond) {
            rtplCond.name = name;
            rtplCond.fetchURL = fetchURL;
            rtplCond.defaultValue = defaultValue;
            rtplCond.required = required;
            rtplCond.handler = handler;
            rtplCond.level = level;
        }

        // hideelstyle
        return {
            // 
            hide: entityDef.clzKey == 'HIDDEN_INPUT'
        }
    };

    COL_CONFIG_PANEL_CLASS.getType = function() {
        return 'ui-table';
    };    

    /**
     * 
     *
     * @private
     * @param {string} cellType 'ROWHCELL', 'HCELL', 'CCELL'
     * @param {Object} wrap 
     * @return {Object} valueprompt
     */
    function getWrapValue(cellType, wrap) {
        var value = String(wrap.v == null ? ' - ' : wrap.v);
        var prompt = value;
        value = textSubstr(value, 0, CUT_NUMBER);
        if (value.length < prompt.length) {
            value += '...';
        }
        else {
            prompt = null;
        }
        return { 
            value: encodeHTML(value), 
            prompt: prompt && encodeHTML(prompt) 
        };
    }

    /**
     * wrap
     *
     * @private 
     * @param {*} wrap 
     */
    function objWrap(wrap) {
        if (wrap !== Object(wrap)) {
            wrap = { v: wrap };
        }
        return wrap;
    }    

    /**
     * placeholderplaceholder
     */
    function isPlaceholder(o) {
        if (o !== Object(o)) {
            return false;
        }
        for (var i in o) {
            return false;
        }
        return true;
    }

    function fmtInput(value) {
        if (value == null) {
            return '';
        }
        return trim(String(value));
    }

})();
/**
 * di.console.editor.ui.CondConfigPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    condition config
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var encodeHTML = xutil.string.encodeHTML;
    var jsonParse = baidu.json.parse;
    var jsonStringify = baidu.json.stringify;
    var jsonFormat = jsl.format.formatJson;
    var jsonValidate = jsl.parser.parse;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var isArray = xutil.lang.isArray;
    var htmlText = xutil.string.htmlText;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var COND_CONFIG_PANEL = $namespace().CondConfigPanel =
        inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this.DATASOURCE_ID_MAPPING = {
                    INIT: 'GET_COND'
                };
            }
        );
    var COND_CONFIG_PANEL_CLASS = COND_CONFIG_PANEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    COND_CONFIG_PANEL_CLASS.$doDispose = function() {
        this._vtplFork = null;
        this._condEl = null;
        this._optSetEl = null;
        this._clzKeySel = null;
        this._handlerSel = null;
        this._paramNameSel = null;
        this._levelSel = null;
        this.getContentEl().innerHTML = '';
        // FIXME
        // unbind
    };

    /** 
     * @override
     */
    COND_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
        // openopen
        this._cpntId = options.cpntId;
        this._entityId = options.entityId;
        this._reportType = options.reportType;
        this._reportTemplateId = options.reportTemplateId;
        this._vtplFork = options.vtplFork;
        this._isCreate = options.isCreate;
        this._condEl = options.condEl;

        // RTPL_VIRTUALreportTemplateId
        // virtualTemplateId
        this._tplKey = this._reportType == 'RTPL_VIRTUAL'
            ? 'RTPL_VIRTUAL_ID' : this._reportTemplateId;
    };

    /** 
     * @override
     */
    COND_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        var css = 'cond-config-panel';
        var me = this;
        var entityId = this._entityId;
        var isCreate = this._isCreate;
        var vtpl = this._vtplFork;
        var entityDef = !isCreate
            ? this._vtplFork.findEntityById(entityId)
            : {
                id: entityId,
                clzType: 'VUI'
            };
        var candidateCond = (data.templateDims || {})[this._tplKey] || [];
        var rtplCond = vtpl.condGet(this._tplKey, entityDef.name) || {};
        var html = [];

        html.push('<div>');
        makeClzKeySel(html);
        makeParamNameSel(html);
        // makeLevelSel(html);
        html.push('</div>');

        html.push('<div>');
        // 
        html.push(
            '<span class="vtpl-quick-text-label" title="">fetchURL: </span>',
            '<input placeholder="" class="', css + '-fetch-url" value="', 
                rtplCond.fetchURL || '','" />'
        );
        html.push(
            '<span class="vtpl-quick-text-label" title="">: </span>',
            '<input placeholder="" class="', css + '-default-value" value="', 
                rtplCond.defaultValue || '','" />'
        );
        makeRequiredSelect(html);
        html.push('<br />');
        makeHandlerSelect(html);
        html.push('</div>');

        // 
        html.push('<div class="', css, '-opt-set"></div>');

        contentEl.innerHTML = html.join('');

        // thisdom
        this._clzKeySel = q(css + '-clz-key-sel', contentEl)[0];
        this._handlerSel = q(css + '-handler-sel', contentEl)[0];
        this._paramNameSel = q(css + '-param-name-sel', contentEl)[0];
        this._levelSel = q(css + '-level-sel', contentEl)[0];
        this._optSetEl = q(css + '-opt-set', contentEl)[0];

        // 
        var clzKeyChange = function () {
            var cSel = me._clzKeySel;
            var clzKey = (cSel.options[cSel.selectedIndex] || {}).value;

            // handlerclzKey
            makeHandlerOption(me._handlerSel, rtplCond, clzKey);

            // optclzKey
            var htm = [];
            htm.push('<div>');
            makeOptTree(htm, entityDef, clzKey);
            makeOptIstCalendar(htm, entityDef, clzKey);
            makeOptXCalendar(htm, entityDef, clzKey);
            htm.push('</div>');
            //  ...
            me._optSetEl.innerHTML = htm.join('');
            me.center();
        };
        this._clzKeySel.onchange = clzKeyChange;

        // 
        // level
        // name dimName#level
        /* var paramNameChange = bind(
            function (rtplCond, DICT) {
                var pSel = this._paramNameSel;
                var lSel = this._levelSel;
                var paramName = (pSel.options[pSel.selectedIndex] || {}).value;
                var htm = [];
                for (var i = 0, o, sel; o = candidateCond[i]; i ++) {
                    if (o.name == paramName && o.levels && o.levels.length) {
                        for (var j = 0; j < o.levels.length; j ++) {
                            var l = o.levels[j];
                            sel = l == rtplCond.level ? ' selected="selected" ' : '';
                            htm.push(
                                '<option value="', l, '" ', sel, '>', l, '</option>'
                            );
                        }
                    }
                }
                lSel.innerHTML = htm.join('');
            }, 
            this, 
            rtplCond,
            DICT
        );
        this._paramNameSel.onchange = paramNameChange;*/

        // 
        clzKeyChange();
        // paramNameChange();

        // 
        contentEl = null;
        clzKeyChange = null;
        return;

        //--------------------------------
        // 
        //--------------------------------

        // clzKey sel
        function makeClzKeySel(html) {
            var formDef = DICT.findClzDef('DI_FORM', 'COMPONENT');
            
            html.push('<span class="vtpl-quick-text-label"></span>');
            html.push('<select class="', css, '-clz-key-sel">');
            for (
                var i = 0, clzKey, sel, vuiDef;
                clzKey = formDef.vuiRefCandidate.input[i];
                i ++
            ) {
                vuiDef = DICT.findClzDef(clzKey, 'VUI');
                if (vuiDef.editorDisable) {
                    continue;
                }
                
                // 
                sel = entityDef.clzKey == clzKey
                    ? sel = ' selected="selected" ' : ' ';
                html.push('<option value="', clzKey, '" ', sel, '>', vuiDef.caption, '</option>')
            }
            html.push('</select>');
        }

        // param name selparam nameschema
        function makeParamNameSel(html) {
            html.push('<span class="vtpl-quick-text-label"></span>');
            html.push('<select class="', css, '-param-name-sel">');
            for (var i = 0, o, sel; o = candidateCond[i]; i ++) {
                // 
                sel = entityDef.name == o.name 
                    ? sel = ' selected="selected" ' : ' ';
                html.push('<option value="', o.name, '" ', sel, '>', o.caption, '', o.name, '</option>')
            }
            html.push('</select>');
        }

        /*function makeLevelSel(html) {
            // handlerparamNameSel
            html.push('<span></span>');
            html.push(
                '<select class="', css, '-level-sel">',
                '</select>'
            );
        }*/

        function makeRequiredSelect(html) {
            html.push('<span class="vtpl-quick-text-label"></span>');
            var sel = { 'true': '', 'false': '' };
            // 
            sel[String(!!rtplCond.required)] = ' selected="selected" ';
            html.push(
                '<select class="', css, '-required-sel">',
                    '<option value="true" ', sel['true'], '></option>',
                    '<option value="false" ', sel['false'], '></option>',
                '</select>'
            );
        }

        function makeHandlerSelect(html) {
            // handlerclzKeySel
            html.push('<span class="vtpl-quick-text-label"></span>');
            html.push(
                '<select class="', css, '-handler-sel">',
                '</select>'
            );
        }

        function makeHandlerOption(handlerSel, rtplCond, clzKey) {
            var handlers = clzKey
                ? DICT.findClzDef(clzKey, 'VUI').rtplParamHandler
                : [];
            var htm = [];
            for (var i = 0, h, sel; h = handlers[i]; i ++) {
                sel = h == rtplCond.handler ? ' selected="selected" ' : ''
                htm.push(
                    '<option value="', h, '" ', sel, '>', h, '</option>'
                );
            }
            handlerSel.innerHTML = htm.join('');
        }

        //-------------------------------------
        // 
        // 
        //-------------------------------------

        // ECUI_INPUT_TREEsync
        function makeOptTree(html, entityDef, clzKey) {
            if (clzKey != 'ECUI_INPUT_TREE') { return; }
            var cfgOpt = entityDef.cfgOpt || {};

            html.push('<span class="vtpl-quick-text-label"></span>');
            var sel = { 'true': '', 'false': '' };
            // 
            sel[String(!!cfgOpt.async)] = ' selected="selected" ';
            html.push(
                '<select class="', css, '-async-sel">',
                    '<option value="false" ', sel['false'], '></option>',
                    '<option value="true" ', sel['true'], '></option>',
                '</select>'
            );
        }

        function makeOptIstCalendar(html, entityDef, clzKey) {
            if (clzKey != 'RANGE_POP_CALENDAR' && clzKey != 'DAY_POP_CALENDAR') {
                return;
            }
            var dataOpt = entityDef.dataOpt || {};

            html.push(
                '<div>',
                    '<span class="vtpl-quick-text-label"></span>',
                    '<input type="input" value="', encodeHTML(stringifyTimeUnit(dataOpt.defaultTime)), '" class="', css, '-ist-cal-default"/>',
                    '<span class="vtpl-quick-text-label"></span>',
                '</div>',
                '<div>',
                    '<span class="vtpl-quick-text-label"></span>',
                    '<input type="input" value="', encodeHTML(stringifyTimeUnit(dataOpt.range)), '" class="', css, '-ist-cal-range"/>',
                    '<span class="vtpl-quick-text-label"></span>',
                '</div>',
                LANG.TIME_DESC
            );
        }

        function makeOptXCalendar(html, entityDef, clzKey) {
            if (clzKey != 'X_CALENDAR') {
                return;
            }
            var dataSetOpt = entityDef.dataSetOpt || {};

            html.push(
                '<div class="', css, '-x-cal-set">',
                    '<span class="vtpl-quick-text-label"></span>',
                    '<textarea class="', css, '-x-cal-opt"/>',
                        encodeHTML(stringifyXCalOpt(dataSetOpt)),
                    '</textarea>',
                '</div>',
                LANG.X_CALENDAR_DESC
            );
        }        
    };

    /** 
     * @override
     */
    COND_CONFIG_PANEL_CLASS.$doGetInitArgs = function() {
        if (this._reportType == 'RTPL_VIRTUAL') {
            return {
                virtualTemplateId: 'RTPL_VIRTUAL_ID',
                reportTemplateIdList: this._vtplFork.rtplIdGet(true) 
            };
        }
        else {
            return {
                reportTemplateIdList: [this._tplKey]
            };
        }
    };

    /** 
     * @override
     */
    COND_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var css = 'cond-config-panel';
        var cpntId = this._cpntId;
        var entityId = this._entityId;
        var vtpl = this._vtplFork;
        var tplKey = this._tplKey;
        var isCreate = this._isCreate;
        var mainEl = this.getEl();
        var el;
        var errorMsg;

        // entityDef
        var entityDef;
        if (isCreate) {
            // entityDef
            vtpl.addEntityDef(entityDef = { id: entityId, clzType: 'VUI' } );
            // DI_FORMVUI
            vtpl.addVUIRef(cpntId, entityId);
        }
        else {
            entityDef = vtpl.findEntityById(entityId);
        }

        // vtplFork.rtplCond
        // 
        el = q(css + '-param-name-sel', mainEl)[0];
        var name = (el.options[el.selectedIndex] || {}).value;
        el = q(css + '-clz-key-sel', mainEl)[0];
        var clzKey = (el.options[el.selectedIndex] || {}).value;
        var fetchURL = q(css + '-fetch-url', mainEl)[0].value;
        var defaultValue = q(css + '-default-value', mainEl)[0].value;
        el = q(css + '-required-sel', mainEl)[0];
        var required = strToBoolean((el.options[el.selectedIndex] || {}).value);
        el = q(css + '-handler-sel', mainEl)[0];
        var handler = (el.options[el.selectedIndex] || {}).value
        // el = q(css + '-level-sel', mainEl)[0];
        // var level = (el.options[el.selectedIndex] || {}).value

        // opt
        if (errorMsg = makeOpt()) {
            return errorMsg;
        }

        // entityDef
        entityDef.name = name;
        entityDef.clzKey = clzKey;      

        // rtplCond
        var rtplCond;
        if (name && !(rtplCond = vtpl.condGet(tplKey, name))) {
            vtpl.condAdd(tplKey, rtplCond = {});
        }
        if (rtplCond) {
            rtplCond.name = name;
            rtplCond.fetchURL = fetchURL;
            rtplCond.defaultValue = defaultValue;
            rtplCond.required = required;
            rtplCond.handler = handler;
            // rtplCond.level = level;
        }

        // hideelstyle
        return {
            // 
            hide: entityDef.clzKey == 'HIDDEN_INPUT'
        }

        // 
        function makeOpt() {
            var cfgOpt;
            var dataOpt;
            var dataInitOpt;
            var dataSetOpt;
            var valueGetOpt;
            var el;
            var val;

            if (clzKey == 'ECUI_INPUT_TREE') {
                cfgOpt = cfgOpt || {};
                if (el = q(css + '-async-sel', mainEl)[0]) {
                    cfgOpt.async = strToBoolean(
                        (el.options[el.selectedIndex] || {}).value
                    );
                }
            }

            if (clzKey == 'ECUI_SUGGEST') {
                cfgOpt = cfgOpt || {};
                cfgOpt.async = true;
            }


            if (clzKey == 'RANGE_POP_CALENDAR' || clzKey == 'DAY_POP_CALENDAR') {
                dataOpt = dataOpt || {};
                if (el = q(css + '-ist-cal-default', mainEl)[0]) {
                    if ((val = parseTimeUnit(el.value)) === false) {
                        return '';
                    }
                    dataOpt.defaultTime = val || void 0;
                }
                if (el = q(css + '-ist-cal-range', mainEl)[0]) {
                    if ((val = parseTimeUnit(el.value)) === false) {
                        return '';
                    }
                    dataOpt.range = val || void 0;
                }
            }

            if (clzKey == 'X_CALENDAR') {
                dataSetOpt = dataSetOpt || {};
                if (el = q(css + '-x-cal-opt', mainEl)[0]) {
                    if ((val = parseXCalOpt(el.value)) === false) {
                        return '';
                    }
                    dataSetOpt = val || void 0;
                }
            }

            //  ...

            // Opt
            entityDef.cfgOpt = cfgOpt;
            entityDef.dataOpt = dataOpt;
            entityDef.dataInitOpt = dataInitOpt;
            entityDef.dataSetOpt = dataSetOpt;
            entityDef.valueGetOpt = valueGetOpt;
        }
    };

    function stringifyTimeUnit(obj) {
        if (!obj) {
            return '';
        }
        try {
            return jsonStringify(obj);
        }
        catch (e) {
            arguments.callee.errorMsg = e.message;
            return '';
        }
    }

    function parseTimeUnit(str) {
        if (!str) { return void 0; }

        try {
            str = jsonParse(str);
            if (!isArray(str)) {
                return false;
            }
            return str;
        }
        catch (e) {
            // 
            arguments.callee.errorMsg = e.message;
            return false;
        }
    }

    function stringifyXCalOpt(obj) {
        if (!obj) {
            return '';
        }
        try {
            return jsonFormat(jsonStringify(obj));
        }
        catch (e) {
            arguments.callee.errorMsg = e.message;
            return '';
        }
    }

    function parseXCalOpt(str) {
        if (!str) { return void 0; }

        try {
            str = jsonFormat(str);
            jsonValidate(str);
            return jsonParse(str);
        }
        catch (e) {
            // 
            arguments.callee.errorMsg = e.message;
            return false;
        }
    }

    function fmtInput(value) {
        if (value == null) {
            return '';
        }
        return trim(String(value));
    }

})();
/**
 * di.console.editor.ui.DefaultDataFormatPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  chenxiaoming01(chenxiaoming01@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var textSubstr = xutil.string.textSubstr;
    var encodeHTML = xutil.string.encodeHTML;
    var htmlText = xutil.string.htmlText;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     *
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var DATA_FORMAT_CONFIG_PANEL = $namespace().DataFormatPanel =
        inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this._mModel = options.model;
                this.DATASOURCE_ID_MAPPING = {
                    INIT: 'GET_TEMPLATE_INFO',
                    SUBMIT: 'DATA_FORMAT_SET'
                };
            }
        );
    var DATA_FORMAT_CONFIG_PANEL_CLASS = DATA_FORMAT_CONFIG_PANEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    DATA_FORMAT_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
    };

    /** 
     * @override
     */
    DATA_FORMAT_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /** 
     * @override
     */
    DATA_FORMAT_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        // dispose
        contentEl.innerHTML = ''

        var format = data.defaultFormat || 'I,III.DD';
        var html = [
                '<div class="data-format-config">',
                '<div>',
                '<label>:</label>',
                '<select class="data_format_select">',
                    '<option value="I,III.DD">,</option>',
                    '<option value="I,III"></option>',
                    '<option value="III"></option>',
                    '<option value="I.DD%"></option>',
                    '<option value="HH:mm:ss"></option>',
                '</select>',
                '</div>',
                '<div><label class="data-format-config-charactor">:</label></div>',
               // '#{measureFormats}',
                '</div>',
                '<div></div>'
            ].join('');
        
        contentEl.innerHTML = html;
        q('data_format_select',contentEl)[0].value = format; 

        q('data_format_select',contentEl)[0].onchange = bindDefaultFormatChange;

        bindDefaultFormatChange();
        appendChildToContent(data.measures);

        function appendChildToContent(measures){
            if(measures){
                var dataFormatDiv = q('data-format-config',contentEl)[0];
                for(var i = 0; i<measures.length;i++){
                    var measure = measures[i];
                    var divElement = document.createElement('div');
                    var divHtml = [
                        '<div class="data-format-config-item">',
                        '<label>#{MeasureName}</label>',
                        '<select class="measure-format"  name="#{uniqueName}">',
                            '<option value="I,III.DD">,</option>',
                            '<option value="I,III"></option>',
                            '<option value="I.DD%"></option>',
                            '<option value="HH:mm:ss"></option>',
                            '<option value="D HH:mm:ss">()</option>',
                        '</select>',
                        '</div>'
                    ].join('')
                    divHtml = template(
                                divHtml,
                                {
                                MeasureName : measure.name,
                                uniqueName : measure.uniqueName
                                }
                                    
                                );
                    divElement.innerHTML = divHtml;
                    if(!measure.format){
                        measure.format = format;
                    }
                    q('measure-format',divElement)[0].value = measure.format; 

                    dataFormatDiv.appendChild(divElement);
                }
                
            }
        }

        function bindDefaultFormatChange(){
            var defaultFormatEl = q('data_format_select',contentEl)[0];

            var measureFormats = q('measure-format',contentEl);
            if(measureFormats){
                for(var i=0;i<measureFormats.length; i++){
                    measureFormats[i].value = defaultFormatEl.value;
                }
            }
        }

    };

    
    /** 
     * @override
     */
    DATA_FORMAT_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var contentEl = this.getContentEl();
        var defaultFormat = q('data_format_select',contentEl)[0].value;

        var measures = q('measure-format',contentEl);

        var formatMap = {};
        if(measures){
            for(var i=0;i<measures.length;i++){
                var measure = measures[i];
                if(measure.value == defaultFormat){
                    continue;
                }else{
                    var uniqueNameList = formatMap[measure.value];
                    if(!uniqueNameList){
                        uniqueNameList = [];
                        formatMap[measure.value] = uniqueNameList;
                    }
                    uniqueNameList.push(measure.name);
                }
            }
        }


        return {
            formatDto: {
                defaultFormat:defaultFormat,
                measureFormatMap : formatMap
            }
        };
        
    };

    DATA_FORMAT_CONFIG_PANEL_CLASS.$doGetInitArgs = function(){
        return {
            key : 'DATA_FORMAT'
        };
    };


})();
/**
 * di.console.editor.ui.DefaultDataFormatPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  chenxiaoming01(chenxiaoming01@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var textSubstr = xutil.string.textSubstr;
    var encodeHTML = xutil.string.encodeHTML;
    var htmlText = xutil.string.htmlText;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     *
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var DEFAULT_DATA_FORMAT_CONFIG_PANEL = $namespace().DefaultDataFormatPanel =
        inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this._mModel = options.model;
                this.DATASOURCE_ID_MAPPING = {
                    INIT: 'GET_TEMPLATE_INFO',
                    SUBMIT: 'DEFAULT_DATA_FORMAT_SUBMIT'
                };
            }
        );
    var DEFAULT_DATA_FORMAT_CONFIG_PANEL_CLASS = DEFAULT_DATA_FORMAT_CONFIG_PANEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    DEFAULT_DATA_FORMAT_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
    };

    /** 
     * @override
     */
    DEFAULT_DATA_FORMAT_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /** 
     * @override
     */
    DEFAULT_DATA_FORMAT_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        // dispose
        contentEl.innerHTML = ''

        var format = data.format || 'I,III.DD';
        var html = [
                '<label>:</label>',
                '<select class="data_format_select">',
                    '<option value="I,III.DD">,</option>',
                    '<option value="I,III"></option>',
                    '<option value="I.DD%"></option>',
                '</select>',
                '<div></div>',
                '<div></div>'
            ].join('');
        
        contentEl.innerHTML = html;
        q('data_format_select',contentEl)[0].value = format; 

    };

    
    /** 
     * @override
     */
    DEFAULT_DATA_FORMAT_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var contentEl = this.getContentEl();
        var defaultFormat = q('data_format_select',contentEl)[0].value;
        return {
            format: defaultFormat
        };
        
    };

    DEFAULT_DATA_FORMAT_CONFIG_PANEL_CLASS.$doGetInitArgs = function(){
        return {
            key : 'DEFAULT_DATA_KEY'
        };
    };


})();
/**
 * di.console.editor.ui.MetaCandidateConfigPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 *           cube
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var textSubstr = xutil.string.textSubstr;
    var encodeHTML = xutil.string.encodeHTML;
    var htmlText = xutil.string.htmlText;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     *
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var META_CANDIDATE_CONFIG_PANEL = $namespace().MetaCandidateConfigPanel =
        inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this._mModel = options.model;
                this.DATASOURCE_ID_MAPPING = {
                    INIT: 'CANDIDATE_INIT',
                    SUBMIT: 'CANDIDATE_SUBMIT'
                };
            }
        );
    var META_CANDIDATE_CONFIG_PANEL_CLASS = META_CANDIDATE_CONFIG_PANEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    META_CANDIDATE_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
    };

    /** 
     * @override
     */
    META_CANDIDATE_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /** 
     * @override
     */
    META_CANDIDATE_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        // dispose
        contentEl.innerHTML = ''

        var css = 'meta-candidate';
        var metaData = data.metaData || {};
        var indSel = makeSet(data.validMeasureName);
        var dimSel = makeSet(data.validDimensionNames);

        var tplMain = [
            '<div>',
                '<div class="#{css}-line-label"></div>',
                '<div class="#{css}-btns">',
                    '<input class="#{css}-ind-all-sel" type="button" value="" />',
                    '<input class="#{css}-ind-revert-sel" type="button" value="" />',
                '</div>',
                '<div class="#{css}-inds">#{inds}</div>',
                '<div class="#{css}-line-label #{css}-sep"></div>',
                '<div class="#{css}-btns">',
                    '<input class="#{css}-dim-all-sel" type="button" value="" />',
                    '<input class="#{css}-dim-revert-sel" type="button" value="" />',
                '</div>',
                '<div class="#{css}-dims">#{dims}</div>',
            '</div>'
        ].join('');

        var tplItem = [
            '<span class="#{css}-item">',
                '<input type="checkbox" #{checked} value="#{value}"/>',
                '<span class="#{css}-text-label">#{name}</span>',
            '</span>'
        ].join('');

        var htmlInd = [];
        var htmlDim = [];
        var i;
        var item;

        for (i = 0; item = (metaData.inds || [])[i]; i ++) {
            htmlInd.push(template(
                tplItem, 
                { 
                    css: css, 
                    name: htmlText(item.caption),
                    value: htmlText(item.uniqName),
                    checked: indSel[item.uniqName] ? ' checked="checked" ' : ''
                }
            ));
        }

        for (i = 0; item = (metaData.dims || [])[i]; i ++) {
            htmlDim.push(template(
                tplItem, 
                { 
                    css: css, 
                    name: htmlText(item.caption), 
                    value: htmlText(item.uniqName), 
                    checked: dimSel[item.uniqName] ? ' checked="checked" ' : ''
                }
            ));
        }

        contentEl.innerHTML = template(
            tplMain, 
            { css: css, inds: htmlInd.join(''), dims: htmlDim.join('') }
        );

        // 
        this.$bindEvent();
    };

    /**
     * @private
     */
    META_CANDIDATE_CONFIG_PANEL_CLASS.$bindEvent = function() {
        var css = 'meta-candidate';
        var contentEl = this.getContentEl();

        q(css + '-ind-all-sel', contentEl)[0].onclick =
            getAllSelFn(this, css + '-inds');
        q(css + '-ind-revert-sel', contentEl)[0].onclick = 
            getRevertSelFn(this, css + '-inds');
        q(css + '-dim-all-sel', contentEl)[0].onclick =
            getAllSelFn(this, css + '-dims');
        q(css + '-dim-revert-sel', contentEl)[0].onclick =
            getRevertSelFn(this, css + '-dims');

        // 
        function getAllSelFn(me, cssName) {
            return function () {
                var el = q(cssName, me.getContentEl())[0];
                var inputs = el.getElementsByTagName('INPUT');
                for (var i = 0, input; input = inputs[i]; i ++) {
                    input.checked = true;
                }
            };
        }

        // 
        function getRevertSelFn(me, cssName) {
            return function () {
                var el = q(cssName, me.getContentEl())[0];
                var inputs = el.getElementsByTagName('INPUT');
                for (var i = 0, input; input = inputs[i]; i ++) {
                    input.checked 
                        ? (input.checked = false) 
                        : (input.checked = true);
                }
            };
        }
    };

    /** 
     * @override
     */
    META_CANDIDATE_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var css = 'meta-candidate';
        var contentEl = this.getContentEl();
        var indSel = [];
        var dimSel = [];

        fillSel(css + '-inds', indSel);
        fillSel(css + '-dims', dimSel);
       
        return {
            validMeasureName: indSel,
            validDimensionNames: dimSel
        };

        function fillSel(cssName, list) {
            var inputs = q(cssName, contentEl)[0].getElementsByTagName('INPUT');
            for (var i = 0, input; input = inputs[i]; i ++) {
                if (input.checked) {
                    list.push(input.value);
                }
            }
        }
    };

    function makeSet(list) {
        list = list || [];
        var ret = {};
        for (var i = 0; i < list.length; i ++) {
            ret[list[i]] = 1;
        }
        return ret;
    }

    function fmtInput(value) {
        if (value == null) {
            return '';
        }
        return trim(String(value));
    }

})();
/**
 * 
 * @file:    
 * @author:  
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var textSubstr = xutil.string.textSubstr;
    var encodeHTML = xutil.string.encodeHTML;
    var htmlText = xutil.string.htmlText;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     *
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var META_DIMSHOW_CONFIG_PANEL = $namespace().MetaDimShowConfigPanel =
        inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this._mModel = options.model;
                this.DATASOURCE_ID_MAPPING = {
                    INIT: 'DIMSHOW_CONFIG_INIT',
                    SUBMIT: 'DIMSHOW_CONFIG_SUBMIT'
                };
            }
        );
    var META_DIMSHOW_CONFIG_PANEL_CLASS = META_DIMSHOW_CONFIG_PANEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    META_DIMSHOW_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
    };

    /** 
     * @override
     */
    META_DIMSHOW_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /** 
     * @override
     */
    META_DIMSHOW_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        // dispose
        contentEl.innerHTML = ''

        var css = 'meta-candidate';
        var childrenShowConfig = data.childrenShowConfig || {};
        var fatherShowConfig = data.fatherShowConfig || {};
        var childrenType = data.childrenType;
        var fatherType = data.fatherType;

        var tplMain = [
            '<div>',
                '<div class="#{css}-dimshow-label"></div>',
                '<div>#{dimShowConfigShow}</div>',
            '</div>'
        ].join('');

        var dimShowOptionItem = [
            '<option class="#{css}-showTypeItem" value="#{value}" #{selected}>#{name}',
            '</option>'
        ].join('');

        var tplItem = [
            '<span class="#{css}-item">',
                '<p>#{index}: </p>',
                '<span><select class="#{css}-dimShowFatherSelect" name="fatherShow" >',
                '#{fatherShow}',
                '</select></span>',
                '<span><select class="#{css}-dimShowChildrenSelect" name="childrenShow" >',
                '#{childrenShow}',
                '</select></span>',
            '</span>'
        ].join('');

        var dimShowConfigShow = [];
        for(var key in childrenShowConfig){
            var dimFatherShowTypes = [];
            var dimChildrenShowTypes = [];
            for(var i in childrenType){
                var candicate = childrenType[i];
                var selected;
                if(candicate==childrenShowConfig[key]){
                    selected = 'selected';
                }else{
                    selected = '';
                }
                var name;
                if(candicate=='SINGLE_NODE'){
                    name = '';
                }else{
                    name = '';
                }
                dimChildrenShowTypes.push(template(
                    dimShowOptionItem,
                    {
                        css: css,
                        value: candicate,
                        name: name,
                        selected: selected
                    }
                ));
            }
            for(var i in fatherType){
                var candicate = fatherType[i];
                var selected;
                if(candicate==fatherShowConfig[key]){
                    selected = 'selected';
                }else{
                    selected = '';
                }
                var name;
                if(candicate=='INCLUDE'){
                    name = '';
                }else{
                    name = '';
                }
                dimFatherShowTypes.push(template(
                    dimShowOptionItem,
                    {
                        css: css,
                        value: candicate,
                        name: name,
                        selected: selected
                    }
                ));
            }
            dimShowConfigShow.push(template(
                tplItem,
                {
                    css: css,
                    index: (parseInt(key)+1),
                    fatherShow: dimFatherShowTypes,
                    childrenShow: dimChildrenShowTypes
                }
            ));
        }

        contentEl.innerHTML = template(
            tplMain, 
            { 
                css: css,
                dimShowConfigShow: dimShowConfigShow.join('')
            }
        );

        // 
        this.$bindEvent();
    };

    /**
     * @private
     */
    META_DIMSHOW_CONFIG_PANEL_CLASS.$bindEvent = function() {
    };

    /** 
     * @override
     */
    META_DIMSHOW_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var css = 'meta-candidate';
        var contentEl = this.getContentEl();
        
        var fatherShowConfig = [];
        var childrenShowConfig = [];

        fillSel(css + '-dimShowChildrenSelect', childrenShowConfig);
        fillSel(css + '-dimShowFatherSelect', fatherShowConfig);
       
        return {
            fatherShowConfig: fatherShowConfig,
            childrenShowConfig: childrenShowConfig
        };

        function fillSel(cssSelectName, list) {
            var selects = q(cssSelectName, contentEl);
            for (var i = 0, select; select = selects[i]; i ++) {
                list.push(select.value);
            }
        }
    };

    function makeSet(list) {
        list = list || [];
        var ret = {};
        for (var i = 0; i < list.length; i ++) {
            ret[list[i]] = 1;
        }
        return ret;
    }

    function fmtInput(value) {
        if (value == null) {
            return '';
        }
        return trim(String(value));
    }

})();
/**
 * 
 * @file:    
 * @author:  
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var textSubstr = xutil.string.textSubstr;
    var encodeHTML = xutil.string.encodeHTML;
    var htmlText = xutil.string.htmlText;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     *
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var META_ROWHEAD_CONFIG_PANEL = $namespace().MetaRowHeadConfigPanel =
        inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this._mModel = options.model;
                this.DATASOURCE_ID_MAPPING = {
                    INIT: 'ROWHEAD_CONFIG_INIT',
                    SUBMIT: 'ROWHEAD_CONFIG_SUBMIT'
                };
            }
        );
    var META_ROWHEAD_CONFIG_PANEL_CLASS = META_ROWHEAD_CONFIG_PANEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    META_ROWHEAD_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
    };

    /** 
     * @override
     */
    META_ROWHEAD_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /** 
     * @override
     */
    META_ROWHEAD_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        // dispose
        contentEl.innerHTML = ''

        var css = 'meta-candidate';
        var drillTypeConfig = data.drillTypeConfig || {};
        var candicates = data.candicates;

        var tplMain = [
            '<div>',
                '<div class="#{css}-rowhead-label"></div>',
                '<div>#{drillTypeConfig}</div>',
            '</div>'
        ].join('');

        var drillTypeOptionItem = [
            '<option class="#{css}-drillTypeItem" value="#{value}" #{selected}>#{name}',
            '</option>'
        ].join('');

        var tplItem = [
            '<span class="#{css}-item">',
                '<p>#{index}<select class="#{css}-drillTypeSelect" name="drillTypes">',
                '#{drillTypes}',
                '</select></p>',
            '</span>'
        ].join('');

        var drillTypeConfigShow = [];
        for(var key in drillTypeConfig){
            var drillTypes = [];
            for(var i in candicates){
                var candicate = candicates[i];
                var selected;
                if(candicate==drillTypeConfig[key]){
                    selected = 'selected';
                }else{
                    selected = '';
                }
                var name;
                if(candicate=='LINK'){
                    name = '';
                }else if(candicate=='PLUS_MINUS'){
                    name = '';
                }else{
                    name = '';
                }
                drillTypes.push(template(
                    drillTypeOptionItem,
                    {
                        css: css,
                        value: candicate,
                        name: name,
                        selected: selected
                    }
                ));
            }
            drillTypeConfigShow.push(template(
                tplItem,
                {
                    css: css,
                    index: (parseInt(key)+1),
                    drillTypes: drillTypes.join('')
                }
            ));
        }

        contentEl.innerHTML = template(
            tplMain, 
            { 
                css: css,
                drillTypeConfig: drillTypeConfigShow.join('')
            }
        );

        // 
        this.$bindEvent();
    };

    /**
     * @private
     */
    META_ROWHEAD_CONFIG_PANEL_CLASS.$bindEvent = function() {
    };

    /** 
     * @override
     */
    META_ROWHEAD_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var css = 'meta-candidate';
        var contentEl = this.getContentEl();
        
        var drillTypeConfig = [];
        fillSel(css + '-drillTypeSelect', drillTypeConfig);
       
        return {
            drillTypeCfg: drillTypeConfig
        };

        function fillSel(cssSelectName, list) {
            var selects = q(cssSelectName, contentEl);
            for (var i = 0, select; select = selects[i]; i ++) {
                list.push(select.value);
            }
        }
    };

    function makeSet(list) {
        list = list || [];
        var ret = {};
        for (var i = 0; i < list.length; i ++) {
            ret[list[i]] = 1;
        }
        return ret;
    }

    function fmtInput(value) {
        if (value == null) {
            return '';
        }
        return trim(String(value));
    }

})();
/**
 * di.console.editor.ui.VTplPanelPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    mold
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var addEventListener = ecui.addEventListener;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var parseParam = xutil.url.parseParam;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var $fastCreate = ecui.$fastCreate;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var alert = di.helper.Dialog.alert;
    var confirm = di.helper.Dialog.confirm;
    var template = xutil.string.template;
    var getUID = xutil.uid.getUID;
    var ecuiCreate = UTIL.ecuiCreate;
    var foreachDoOri = UTIL.foreachDoOri;
    var ajaxRequest = baidu.ajax.request;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var textParam = xutil.url.textParam;
    var jsonParse = baidu.json.parse;
    var replaceIntoParam = xutil.url.replaceIntoParam;
    var UI_BUTTON = ecui.ui.Button;
    var UI_INPUT = ecui.ui.Input;
    var assert = UTIL.assert;
    var PANEL_PAGE_MANAGER;
    var PANEL_PAGE_TAB_ADAPTER;
    var UI_TAB_CONTAINER = ecui.ui.TabContainer;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;
    var CUBE_CONFIG_PANEL;
    var PREVIEW_CONFIG_PANEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
        PANEL_PAGE_MANAGER = di.shared.model.PanelPageManager;
        PANEL_PAGE_TAB_ADAPTER = di.shared.model.PanelPageTabAdapter;
        CUBE_CONFIG_PANEL = di.console.shared.ui.CubeConfigPanel;
        PREVIEW_CONFIG_PANEL = di.console.shared.ui.PreviewConfigPanel;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     *      1. panelPagepanelPageeditorquickEidtorcodeEidtor
     *      2. vtplPanelPagevtpleidtordoRefreshFork
     *      vtplPanelPageclonevtpl
     *      editordoRefreshForkvtpl
     *      3. editoreidtor
     *      vtplPanelPagedoRefreshForkeditordoRefrefhFork
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.dsId 
     */
    var MOLDLIST_PANEL_PAGE = $namespace().MoldListPanelPage =
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                addClass(el, 'vtpl-panel-page');
                el.innerHTML = HTML_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
                this._globalPanelPageManager = options.panelPageManager;
            }
        );
    var MOLDLIST_PANEL_PAGE_CLASS = MOLDLIST_PANEL_PAGE.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    var HTML_MAIN = [
        '<div class="vtpl-panel-page-btns">',
             '<span></span>',
             '<input class="vtpl-name-input q-mold-name"/>',
             '<span class="q-btn-query"></span>',
        '</div>',
        '<div class="q-main"></div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._mPanelPageManager = new PANEL_PAGE_MANAGER(
            { adapter: PANEL_PAGE_TAB_ADAPTER }
        );
        this._mVTplModel = options.vtplModel;
    }

    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        this._uQueryBtn = ecuiCreate(
                UI_BUTTON, 
                q('q-btn-query', el)[0],
                null, 
                { primary: 'ui-button-g' }
            );
         this._uNameInput = ecuiCreate(
                    UI_INPUT,
                    q('q-mold-name', el)[0]
                );
        this._uMainContainer = $fastCreate(
            UI_TAB_CONTAINER,
            q('q-main', this.getEl())[0],
            null,
            { primary: 'ui-tab' }
        );
    }

    /**
     * 
     *
     * @public
     */
    MOLDLIST_PANEL_PAGE_CLASS.init = function() {
        var me = this;

        // vtpl mgr functions
        //extend(this, this.vtplMgrGet(this));

        this._mPanelPageManager.inject(this._uMainContainer);
        this._mPanelPageManager.attach(
            ['page.active', this.$pageActiveHandler, this]
        );
        this._uQueryBtn.onclick=bind(this.doQuery, this);

        // toPretoReleasedisable
        // toPretoRlease

        this._mPanelPageManager.init();
        this._mVTplModel.attach(
                ['sync.result.MOLD_QUERY', this.$renderTab, this]
            );
        
        //3tab
        //active3tab
        var pg = me.openTab({ editorType: 'all' });
        //me.openTab({ editorType: 'pre' });
        //me.openTab({ editorType: 'dev' });
        me._mPanelPageManager.select(pg.getPageId());     
        //
        this.doQuery();
    };


    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    MOLDLIST_PANEL_PAGE_CLASS.$active = function(options) {

    };

   

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    MOLDLIST_PANEL_PAGE_CLASS.$renderTab = function(options) {
        this._mPanelPageManager.forEachPage(
            function (pageId, page, index) {
                page.render();
            }
        );
        
    };
    

    /**
     * 
     * (panel page)
     * 
     * @public
     * @param {Object} options
     * @param {string} act
     * @param {string} reportType
     * @param {string=} reportTemplateId
     * @param {string=} vtplKey
     */
    MOLDLIST_PANEL_PAGE_CLASS.openTab = function(options) {
        var editorType = options.editorType;
        var pageOpt = extend({}, options);
        var panelPageManager = this._mPanelPageManager;
        var vtpl = this._vtpl;

        extend(
            pageOpt, 
            {
                pageId: 'moldlist_' + getUID(),
                pageClz: 'di.console.shared.ui.ReportMoldListPage',
                pageTitle: ({
                        all: ''
                    })[editorType],
                phase: editorType,
                vtplModel: this._mVTplModel,
                panelPageManager: panelPageManager,
                globalPanelPageManager: this._globalPanelPageManager,
                vtplPanelPage: this
            }
        );

        assert(pageOpt.pageId, 'reportTempalteId is null')

        var page = panelPageManager.openByURI(pageOpt.pageClz, pageOpt, oncreate);
        // 
        page.attach('rtpl.created', this.doCreated, this);

        return page;

        function oncreate(page) {
            //alert(' '+page+' oncreate')
            //page.doRefreshFork && page.doRefreshFork(vtpl.clone());
        }
    };


    /**
     * rtpl created
     */
    MOLDLIST_PANEL_PAGE_CLASS.doCreated = function(menuItem) {
        this._mPanelPageManager.forEachPage(function (pageId, page, index) {
            page.doCreated && page.doCreated();
        });
    };


    /**
     * 
     */
    MOLDLIST_PANEL_PAGE_CLASS.doQuery = function() {
        var reportName=this._uNameInput.getValue();
        this._mVTplModel.sync(
            {
                datasourceId: 'MOLD_QUERY',
                args: {
                    reportName:reportName
                }
            }
        );
    };
    
    

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    MOLDLIST_PANEL_PAGE_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) === 0 && this._bDisabled) {
            this._mPanelPageManager.forEachPage(
                function (pageId, page, index) {
                    page.enable(key);
                }
            );
            foreachDoOri(
                [
                    this._uQueryBtn,
                ],
                'enable',
                key
            );
            MOLDLIST_PANEL_PAGE.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    MOLDLIST_PANEL_PAGE_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            this._mPanelPageManager.forEachPage(
                function (pageId, page, index) {
                    page.disable(key);
                }
            );
            foreachDoOri(
                [
                    this._uQueryBtn,
                ],
                'disable',
                key
            );
        }
        MOLDLIST_PANEL_PAGE.superClass.disable.call(this);
    };
    /**
     * @override
     */
    MOLDLIST_PANEL_PAGE_CLASS.dispose = function() {
        this._mPanelPageManager.dispose();
        // TODO
        foreachDoOri(
            [
                this._uQueryBtn,
            ],
            'dispose'
        );
        // this._uNameInput = null;
        MOLDLIST_PANEL_PAGE.superClass.dispose.call(this);
    };
    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    MOLDLIST_PANEL_PAGE_CLASS.$inactive = function(options) {
        // TODO
    };
    /**
     * 
     */
    MOLDLIST_PANEL_PAGE_CLASS.$pageActiveHandler = function(menuId) {
        // TODO
    };
})();
/**
 * di.console.editor.ui.VTplPanelPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var addEventListener = ecui.addEventListener;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var parseParam = xutil.url.parseParam;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var $fastCreate = ecui.$fastCreate;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var alert = di.helper.Dialog.alert;
    var confirm = di.helper.Dialog.confirm;
    var template = xutil.string.template;
    var getUID = xutil.uid.getUID;
    var ecuiCreate = UTIL.ecuiCreate;
    var foreachDoOri = UTIL.foreachDoOri;
    var ajaxRequest = baidu.ajax.request;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var textParam = xutil.url.textParam;
    var jsonParse = baidu.json.parse;
    var replaceIntoParam = xutil.url.replaceIntoParam;
    var UI_BUTTON = ecui.ui.Button;
    var UI_INPUT = ecui.ui.Input;
    var assert = UTIL.assert;
    var PANEL_PAGE_MANAGER;
    var PANEL_PAGE_TAB_ADAPTER;
    var UI_TAB_CONTAINER = ecui.ui.TabContainer;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;
    var CUBE_CONFIG_PANEL;
    var PREVIEW_CONFIG_PANEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
        PANEL_PAGE_MANAGER = di.shared.model.PanelPageManager;
        PANEL_PAGE_TAB_ADAPTER = di.shared.model.PanelPageTabAdapter;
        CUBE_CONFIG_PANEL = di.console.shared.ui.CubeConfigPanel;
        PREVIEW_CONFIG_PANEL = di.console.shared.ui.PreviewConfigPanel;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     *      1. panelPagepanelPageeditorquickEidtorcodeEidtor
     *      2. vtplPanelPagevtpleidtordoRefreshFork
     *      vtplPanelPageclonevtpl
     *      editordoRefreshForkvtpl
     *      3. editoreidtor
     *      vtplPanelPagedoRefreshForkeditordoRefrefhFork
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.dsId 
     */
    var MYVIEW_PANEL_PAGE = $namespace().MyViewPanelPage =
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                addClass(el, 'vtpl-panel-page');
                el.innerHTML = HTML_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
                this._globalPanelPageManager = options.panelPageManager;
            }
        );
    var MYVIEW_PANEL_PAGE_CLASS = MYVIEW_PANEL_PAGE.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    var HTML_MAIN = [
        '<div class="vtpl-panel-page-btns">',
             '<span>(ididPERSISTENT^_^virtualdatasource^_^^_^12345671234567)</span>',
             '<input class="vtpl-name-input q-report-name"/>',
             '<span class="q-btn-query"></span>',
        '</div>',
        '<div class="q-main"></div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._mPanelPageManager = new PANEL_PAGE_MANAGER(
            { adapter: PANEL_PAGE_TAB_ADAPTER }
        );
        this._mVTplModel = options.vtplModel;
    }

    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
    	this._uQueryBtn = ecuiCreate(
                UI_BUTTON, 
                q('q-btn-query', el)[0],
                null, 
                { primary: 'ui-button-g' }
            );
    	 this._uNameInput = ecuiCreate(
    	            UI_INPUT,
    	            q('q-report-name', el)[0]
    	        );
        this._uMainContainer = $fastCreate(
            UI_TAB_CONTAINER,
            q('q-main', this.getEl())[0],
            null,
            { primary: 'ui-tab' }
        );
    }

    /**
     * 
     *
     * @public
     */
    MYVIEW_PANEL_PAGE_CLASS.init = function() {
        var me = this;

        // vtpl mgr functions
        //extend(this, this.vtplMgrGet(this));

        this._mPanelPageManager.inject(this._uMainContainer);
        this._mPanelPageManager.attach(
            ['page.active', this.$pageActiveHandler, this]
        );
        this._uQueryBtn.onclick=bind(this.doQuery, this);

        // toPretoReleasedisable
        // toPretoRlease

        this._mPanelPageManager.init();
        this._mVTplModel.attach(
                ['sync.result.REPORT_QUERY', this.$renderTab, this]
            );
        
        //3tab
        //active3tab
        var pg = me.openTab({ editorType: 'dev' });
        me.openTab({ editorType: 'pre' });
        me.openTab({ editorType: 'release' });
        me._mPanelPageManager.select(pg.getPageId());     
        //
        // this.doQuery();
    };


    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    MYVIEW_PANEL_PAGE_CLASS.$active = function(options) {
//        var vtplModel = this._mVTplModel;
//        var me = this;
//
//        var act = options.act;
//        if (act) {
//            // TODO
//            // act[0]  EDIT/CREATE,  VIEW
//
//            // "EDIT#QUICK", "VIEW#QUICK", "CREATE#VTPL"
//            act = act.split('#');
//            var actName = act[0];
//            var editorType = act[1];
//
//            var vtpl;
//            if (actName == 'EDIT' || actName == 'VIEW') {
//                vtpl = this._vtpl = vtplModel.getVTpl(options.vtplKey);
//                // this._uNameInput.value = this._vtpl.vtplName;
//            }
//            else if (actName == 'CREATE') {
//                vtpl = this._vtpl = vtplModel.getMold(options.moldKey);
//            }
//            function doOpen() {
//            }
//        }

        // 
        this.doQuery();
    };

   

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    MYVIEW_PANEL_PAGE_CLASS.$renderTab = function(options) {
    	this._mPanelPageManager.forEachPage(
    		function (pageId, page, index) {
    			page.render();
    		}
    	);
    	
    };
    

    /**
     * 
     * (panel page)
     * 
     * @public
     * @param {Object} options
     * @param {string} act
     * @param {string} reportType
     * @param {string=} reportTemplateId
     * @param {string=} vtplKey
     */
    MYVIEW_PANEL_PAGE_CLASS.openTab = function(options) {
        var editorType = options.editorType;
        var pageOpt = extend({}, options);
        var panelPageManager = this._mPanelPageManager;
        var vtpl = this._vtpl;

        extend(
            pageOpt, 
            {
                pageId: 'myview_' + getUID(),
                pageClz: 'di.console.shared.ui.ReportReleasePage',
                pageTitle: ({
                        release: '',
                        pre: '',
                        dev: ''
                    })[editorType],
                phase: editorType,
                vtplModel: this._mVTplModel,
                panelPageManager: panelPageManager,
                globalPanelPageManager: this._globalPanelPageManager,
                vtplPanelPage: this
            }
        );

        assert(pageOpt.pageId, 'reportTempalteId is null')

        var page = panelPageManager.openByURI(pageOpt.pageClz, pageOpt, oncreate);
        // 
        page.attach('rtpl.created', this.doCreated, this);

        return page;

        function oncreate(page) {
        	//alert(' '+page+' oncreate')
            //page.doRefreshFork && page.doRefreshFork(vtpl.clone());
        }
    };


    /**
     * rtpl created
     */
    MYVIEW_PANEL_PAGE_CLASS.doCreated = function(menuItem) {
        this._mPanelPageManager.forEachPage(function (pageId, page, index) {
            page.doCreated && page.doCreated();
        });
    };


    /**
     * 
     */
    MYVIEW_PANEL_PAGE_CLASS.doQuery = function() {
    	var reportName=this._uNameInput.getValue();
    	//alert(reportName);
        this._mVTplModel.sync(
            {
                datasourceId: 'REPORT_QUERY',
                args: {
                	reportName:reportName
                }
            }
        );
    };
    
    

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    MYVIEW_PANEL_PAGE_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) === 0 && this._bDisabled) {
            this._mPanelPageManager.forEachPage(
                function (pageId, page, index) {
                    page.enable(key);
                }
            );
            foreachDoOri(
                [
                    this._uQueryBtn,
                ],
                'enable',
                key
            );
            MYVIEW_PANEL_PAGE.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    MYVIEW_PANEL_PAGE_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            this._mPanelPageManager.forEachPage(
                function (pageId, page, index) {
                    page.disable(key);
                }
            );
            foreachDoOri(
                [
                    this._uQueryBtn,
                ],
                'disable',
                key
            );
        }
        MYVIEW_PANEL_PAGE.superClass.disable.call(this);
    };
    /**
     * @override
     */
    MYVIEW_PANEL_PAGE_CLASS.dispose = function() {
        this._mPanelPageManager.dispose();
        // TODO
        foreachDoOri(
            [
             	this._uQueryBtn,
            ],
            'dispose'
        );
        // this._uNameInput = null;
        MYVIEW_PANEL_PAGE.superClass.dispose.call(this);
    };
    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    MYVIEW_PANEL_PAGE_CLASS.$inactive = function(options) {
        // TODO
    };
    /**
     * 
     */
    MYVIEW_PANEL_PAGE_CLASS.$pageActiveHandler = function(menuId) {
        // tabdoQuery()
        // this.doQuery();
    };
})();
/**
 * di.console.editor.ui.OlapEditor
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  ecui, xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var getUID = xutil.uid.getUID;
    var children = xutil.dom.children;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var foreachDoOri = UTIL.foreachDoOri;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var META_CONDITION;
    var OLAP_EDITOR_MODEL;
    var DI_TABLE;
    var DI_CHART;
    var CHART_CONFIG_PANEL;
    var META_CANDIDATE_CONFIG_PANEL;
    var META_ROWHEAD_CONFIG_PANEL;
    var META_DIMSHOW_CONFIG_PANEL;
    var DEFAULT_DATA_FORMAT_CONFIG_PANEL;
    var DATA_FORMAT_CONFIG_PANEL;
    var CHART_CONFIG_PANEL;
    var UI_INPUT = ecui.ui.Input;
    var DI_FACTORY;

    var REPORT_DATA_MERGE_CONFIG_PANEL;

    var QUERY_PARAM_FIX_PANEL;


        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        META_CONDITION = di.shared.ui.MetaCondition;
        OLAP_EDITOR_MODEL = di.console.editor.model.OLAPEditorModel;
        META_CANDIDATE_CONFIG_PANEL = di.console.editor.ui.MetaCandidateConfigPanel;
        META_ROWHEAD_CONFIG_PANEL = di.console.editor.ui.MetaRowHeadConfigPanel;
        META_DIMSHOW_CONFIG_PANEL = di.console.editor.ui.MetaDimShowConfigPanel;
        CHART_CONFIG_PANEL = di.console.shared.ui.ChartConfigPanel;
        DI_TABLE = di.shared.ui.DITable;
        DI_CHART = di.shared.ui.DIChart;

        DATA_FORMAT_CONFIG_PANEL = di.console.editor.ui.DataFormatPanel;
        REPORT_DATA_MERGE_CONFIG_PANEL = di.console.editor.ui.ReportDataMergeConfigPanel;
        QUERY_PARAM_FIX_PANEL = di.console.editor.ui.QueryParamFix;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.reportType
     * @param {string} options.schemaName
     * @param {string} options.cubeTreeNodeName
     */
    var OLAP_EDITOR = $namespace().OLAPEditor = 
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                var css = 'olap-editor';
                addClass(el, css);
                el.innerHTML = template(
                    SNIPPET_MAIN, 
                    { css: css }
                );
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var OLAP_EDITOR_CLASS = OLAP_EDITOR.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    var SNIPPET_MAIN = [
        '<div class="#{css}-name">',
            '<span></span>',
            '<span></span>',
        '</div>',
        '<div class="#{css}-meta-condition q-di-meta-condition">',
        '</div>',
        '<div class="#{css}-data">',
            '<div class="#{css}-operation q-di-operation">',
            '</div>',
            '<div class="#{css}-data q-di-data">',
            '</div>',
        '</div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    function createDIEntity(reportType, el, commonParamGetter) {
        // pivot
        var dataOpt = {};
        var cmptEl = q('q-di-data', el)[0];
        var depict;

        if (reportType == 'RTPL_OLAP_TABLE') {
            createTable();
        }
        else if (reportType == 'RTPL_OLAP_CHART') {
            createChart();
        }

        return cmptCreate4Console(DI_FACTORY(), depict, commonParamGetter);

        // 
        function createTable() {
            var cmptId = "snpt-CONSOLE.cpnt-CONSOLE-table-" + getUID();
            var vuiBreadcrumbId = "snpt-CONSOLE.vu-CONSOLE-breadcrumb-" + getUID();
            var vuiTableId = "snpt-CONSOLE.vu-CONSOLE-table-" + getUID();
            
            cmptEl.innerHTML = [
                '<div class="q-di-table-area di-table-area">',
                    '<div class="q-di-breadcrumb"></div>',
                    '<div class="q-di-table pivot-table"></div>',
                '</div>'
            ].join('');
            var chDom = children(cmptEl.firstChild);

            depict = [
                {
                    "id": cmptId,
                    "clzType": "COMPONENT",
                    "clzKey": "DI_TABLE",
                    "el": cmptEl,
                    "vuiRef": {
                        "mainTable": vuiTableId,
                        "breadcrumb": vuiBreadcrumbId
                    }
                },
                { 
                    "id": vuiBreadcrumbId,
                    "clzType": "VUI",
                    "clzKey": "BREADCRUMB",
                    "el": chDom[0],
                    "dataOpt": {
                        "maxShow": 6
                    }
                },
                { 
                    "id": vuiTableId, 
                    "clzType": "VUI",
                    "clzKey": "OLAP_TABLE",
                    "el": chDom[1],
                    "dataOpt": {
                        "rowHCellCut": 30,
                        "hCellCut": 30,
                        "cCellCut": 30,
                        "vScroll": true,
                        "rowCheckMode": "CHECK"
                    }
                }
            ]
        }

        // PIVOT
        function createChart() {
            var cmptId = "snpt-CONSOLE.cpnt-CONSOLE-chart-" + getUID();
            var vuiChartId = "snpt-CONSOLE.vu-CONSOLE-chart-" + getUID();
            
            cmptEl.innerHTML = '<div class="q-di-chart"></div>';
            depict = [
                {
                    "id": cmptId,
                    "clzType": "COMPONENT",
                    "clzKey": "DI_CHART",
                    "el": cmptEl,
                    "vuiRef": {
                        "mainChart": vuiChartId
                    }
                },
                { 
                    "id": vuiChartId, 
                    "clzType": "VUI",
                    "clzKey": "H_CHART",
                    "el": cmptEl.firstChild,
                    "dataOpt": {
                        "height": 300,
                        "legend": { "xMode": "pl" }
                    }
                }
            ]
        }
    }

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        /**
         * TABLE  CHART
         *
         * @type {string}
         * @private
         */
        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';

        this._mOLAPEditorModel = new OLAP_EDITOR_MODEL(
            {
                reportType: this._sReportType,
                schemaName: options.schemaName,
                cubeTreeNodeName: options.cubeTreeNodeName,
                reportTemplateId: options.reportTemplateId
            }
        );

        this._sStatus = options.reportTemplateId ? 'EXIST' : 'NEW';
    };
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        var commonParamGetter = this._mOLAPEditorModel.getCommonParamGetter();

        this._uNameInput = ecuiCreate(
            UI_INPUT, 
            q('olap-editor-name', el)[0].lastChild
        );

        // 
        this._uMetaCondition = new META_CONDITION(
            {
                el: q('q-di-meta-condition', el)[0],
                reportType: this._sReportType,
                commonParamGetter: commonParamGetter
            }
        );
        this._mMetaConditionModel = this._uMetaCondition.getModel();

        //
        this._uDefaultDataPanel = new DATA_FORMAT_CONFIG_PANEL(
            {
                parent : this,
                model : this._mMetaConditionModel,
                cssName : 'default-data-format',
                panelTitle : ''
            }
        );

        // 
        this._uCandidatePanel = new META_CANDIDATE_CONFIG_PANEL(
            { 
                parent: this,
                model: this._mMetaConditionModel,
                cssName: 'meta-candidate',
                panelTitle: ''
            }
        );

        //
        this._uExtendParamPanel = new QUERY_PARAM_FIX_PANEL(
            {
                parent: this,
                model: this._mMetaConditionModel,
                cssName: 'query-extend-param',
                panelTitle: ''
            }
        );

        if (!useChartCfg) {
            // 
            this._uRowHeadPanel = new META_ROWHEAD_CONFIG_PANEL(
                { 
                    parent: this,
                    model: this._mMetaConditionModel,
                    cssName: 'meta-candidate',
                    panelTitle: ''
                }
            );
        }

        // 
        this._uDimShowPanel = new META_DIMSHOW_CONFIG_PANEL(
            { 
                parent: this,
                model: this._mMetaConditionModel,
                cssName: 'meta-candidate',
                panelTitle: ''
            }
        );

        var useChartCfg = this._sReportType == 'RTPL_OLAP_CHART';
        // 
        if (useChartCfg) {
            this._uChartCfgPanel = new CHART_CONFIG_PANEL(
                { 
                    parent: this,
                    model: this._mMetaConditionModel,
                    cssName: 'meta-chart-cfg',
                    panelTitle: ''
                }
            );
        }

        this._uDataMergePanel = new REPORT_DATA_MERGE_CONFIG_PANEL(
            {
                parent : this,
                model : this._mMetaConditionModel,
                cssName : 'report-data-merge-config',
                panelTitle : ''
            }
        );

        // 
        this._uQueryBtn = createBtn('');
        this._uSaveBtn = createBtn('')
        this._uCandidateBtn = createBtn('');
        if (useChartCfg) {
            this._uChartCfgBtn = createBtn('');
        }
        if (!useChartCfg){
            this._uRowHeadCfgBtn = createBtn('');
        }
        this._uDimShowCfgBtn = createBtn('');

        this._uDefaultDataFormatBtn = createBtn('');

        this._uDataMergeBtn = createBtn('');

        // 
        this._uDIData = createDIEntity(this._sReportType, el, commonParamGetter);
        this._mDIDataModel = this._uDIData.getModel();

        function createBtn(text) {
            var opEl = q('q-di-operation', el)[0];
            var o = document.createElement('div');
            o.innerHTML = '<div class="ui-button-g ui-button">' + text + '</div>';
            opEl.appendChild(o.firstChild);
            return ecuiCreate(
                UI_BUTTON, 
                opEl.lastChild, 
                null, 
                { primary: 'ui-button-g' }
            );
        }
    };
    
    /**
     * 
     *
     * @public
     */
    OLAP_EDITOR_CLASS.init = function() {

        // 
        this._mOLAPEditorModel.attach(
            ['sync.preprocess.INIT', this.disable, this, 'OLAP_EDIROT'],
            ['sync.complete.INIT', this.enable, this, 'OLAP_EDIROT'],
            ['sync.result.INIT', this.$handleInit, this]
        );
        this._mMetaConditionModel.attach(
            ['sync.preprocess.META_DATA', this.disable, this, 'OLAP_EDIROT'],
            ['sync.complete.META_DATA', this.enable, this, 'OLAP_EDIROT'],
            ['sync.error.META_DATA', this.$handleFatalError, this]
        );
        this._mOLAPEditorModel.attach(
            ['sync.preprocess.SAVE', this.disable, this, 'OLAP_EDIROT'],
            ['sync.complete.SAVE', this.enable, this, 'OLAP_EDIROT'],
            ['sync.result.SAVE', this.$handleSaved, this, 'OLAP_EDIROT']
        );

        // 
        this._uQueryBtn.onclick = bind(this.$handleQuery, this);
        this._uSaveBtn.onclick = bind(this.$handleSave, this);
        this._uCandidateBtn.onclick = bind(this.$handleCandidateConf, this);
        // _uRowHeadCfgBtn
        //  add by majun   2013-9-22 
        var useChartCfg = this._sReportType == 'RTPL_OLAP_CHART';
        if (!useChartCfg){
            this._uRowHeadCfgBtn.onclick = bind(this.$handleRowHeadConf, this);
        }
        this._uDimShowCfgBtn.onclick = bind(this.$handleDimShowConf, this);
        this._uChartCfgBtn 
            && (this._uChartCfgBtn.onclick = bind(this.$handleChartCfg, this));

        //onclick
        this._uDefaultDataFormatBtn.onclick = bind(this.$handleSetDefaultDataFormat,this);
        //
        this._uDataMergeBtn.onclick = bind(this.$hadleDataMergeSet,this);

        // 
        this._mDIDataModel.attach(
            ['sync.preprocess.DATA', this.disable, this, 'OLAP_EDIROT'],
            ['sync.complete.DATA', this.enable, this, 'OLAP_EDIROT']
        );

        this._uCandidatePanel && this._uCandidatePanel.init();
        this._uChartCfgPanel && this._uChartCfgPanel.init();
        this._uRowHeadPanel && this._uRowHeadPanel.init();
        this._uDimShowPanel && this._uDimShowPanel.init();

        this._uDefaultDataPanel && this._uDefaultDataPanel.init();
        this._uDataMergePanel && this._uDataMergePanel.init();
        this._uExtendParamPanel && this._uExtendParamPanel.init();

        // init
        this._uMetaCondition.init();
        this._uDIData.init();

        // 
        this._mOLAPEditorModel.sync(
            { datasourceId: 'INIT' }
        );
    };



    /**
     * @override
     */
    OLAP_EDITOR_CLASS.dispose = function() {
        foreachDoOri(
            [
                this._uNameInput,
                this._uMetaCondition,
                this._uCandidatePanel,
                this._uChartCfgPanel,
                this._uDefaultDataPanel,
                this._uDefaultDataFormatBtn,
                this._uDataMergeBtn,
                this._uDataMergePanel,
                this._uRowHeadPanel,
                this._uDimShowPanel,
                this._uRowHeadCfgBtn,
		        this._uDimShowCfgBtn,
                this._uExtendParamPanel
            ],
            'dispose'
        );
        this._uDIData && this._uDIData.$di('dispose');

        // TODO
        // FIXME
        // button dispose

        OLAP_EDITOR.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    OLAP_EDITOR_CLASS.$active = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    OLAP_EDITOR_CLASS.$inactive = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    OLAP_EDITOR_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            foreachDoOri(
                [
                    this._uDIData,
                    this._uQueryBtn,
                    this._uSaveBtn,
                    this._uCandidateBtn,
                    this._uMetaCondition,
                    this._uChartCfgBtn,
                    this._uRowHeadCfgBtn,
                    this._uDimShowCfgBtn,
                    this._uDataMergeBtn,
                    this._uDefaultDataFormatBtn
                ],
                'enable',
                key
            );
            OLAP_EDITOR.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    OLAP_EDITOR_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            foreachDoOri(
                [
                    this._uDIData,
                    this._uQueryBtn,
                    this._uSaveBtn,
                    this._uCandidateBtn,
                    this._uMetaCondition,
                    this._uChartCfgBtn,
                    this._uRowHeadCfgBtn,
                    this._uDimShowCfgBtn,
                    this._uDefaultDataPanel,
                    this._uDataMergePanel,
                    this._uDataMergeBtn,
                    this._uDefaultDataFormatBtn
                ],
                'disable',
                key
            );
        }
        OLAP_EDITOR.superClass.disable.call(this);
    };    

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleInit = function(data) {
        this._uNameInput.setValue(data.reportTemplateName || '');
        // 
        this._uMetaCondition.sync();
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleFatalError = function(status) {
        this.disable();
        // 
        if (status == 1001) {
            DIALOG.alert(LANG.SAD_FACE + LANG.PARAM_ERROR);
        }
        else {
            DIALOG.alert(LANG.SAD_FACE + LANG.FATAL_DATA_ERROR);
        }
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleQuery = function() {
        //cmptSync4Console(DI_FACTORY(), this._uDIData);
        this._uExtendParamPanel.open('EDIT',{data:this._uDIData});
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleSave = function() {
        var name = this._uNameInput.getValue();

        this._mOLAPEditorModel.sync(
            { 
                datasourceId: 'SAVE',
                args: { reportTemplateName: name }
            }
        );
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleCandidateConf = function() {
        this._uCandidatePanel.open('EDIT');
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleRowHeadConf = function() {
        this._uRowHeadPanel.open('EDIT');
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleDimShowConf = function() {
        this._uDimShowPanel.open('EDIT');
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleChartCfg = function() {
        this._uChartCfgPanel.open('EDIT');
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleSaved = function(data, ejsonObj, options) {
        if (this._sStatus == 'NEW') {
            this.notify('rtpl.created');
        }
        this._sStatus = 'EXIST';
        this.notify('rtpl.saved');
    };

    /**
     * 
     * 
     * @protected
     */
    OLAP_EDITOR_CLASS.$handleSetDefaultDataFormat = function(){
        this._uDefaultDataPanel.open('EDIT');
    }

    OLAP_EDITOR_CLASS.$hadleDataMergeSet = function(){
        this._uDataMergePanel.open('EDIT');
    }

})();
/**
 * di.console.editor.ui.PlaneEditor
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var getUID = xutil.uid.getUID;
    var htmlText = xutil.string.htmlText;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var foreachDoOri = UTIL.foreachDoOri;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var UI_SELECT = ecui.ui.Select;
    var UI_INPUT = ecui.ui.Input;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var PLANE_EDITOR_MODEL;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        PLANE_EDITOR_MODEL = di.console.editor.model.PlaneEditorModel;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.dsId 
     */
    var PLANE_EDITOR = $namespace().PlaneEditor =
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                var css = 'plane-editor';
                addClass(el, css);
                el.innerHTML = template(SNIPPET_MAIN, { css: css });
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var PLANE_EDITOR_CLASS = PLANE_EDITOR.prototype;

    /**
     * 
     */
    var MAPPING_CONFIG = inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this.DATASOURCE_ID_MAPPING = options.dsMapping;
                this._sConfigType = options.configType;
            }
        );
    var MAPPING_CONFIG_CLASS = MAPPING_CONFIG.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    var SNIPPET_MAIN = [
        '<div class="#{css}-sql">',
            '<div class="#{css}-name">',
                '<span></span>',
                '<span></span>',
            '</div>',
            '<div class="#{css}-desc">SQLselec {a.col1}, {b.col2} from table1, table2 where [a.col1=:col1 ] and [b.col2 =:cols2 ]</div>',
            '<div class="#{css}-sql-input"></div>',
            '<div class="#{css}-btns">',
                '<span class="ui-button"></span>',
                '<span class="ui-button"></span>',
                '<span class="ui-button"></span>',
                '<span class="ui-button"></span>',
            '</div>',
            '<div>',
            '<div class="#{css}-label-line">SQL</div>',
            '<div class="#{css}-sql-actual"></div>',
        '</div>',
        '<div class="#{css}-preview">',
            '<div class="#{css}-data q-di-data"></div>',
        '</div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

   function createDIEntity(el, commonParamGetter) {
        // pivot
        var dataOpt = {};
        var cmptEl = q('q-di-data', el)[0];
        var depict;

        createTable();

        return cmptCreate4Console(DI_FACTORY(), depict, commonParamGetter);

        // plane
        function createTable() {
            var cmptId = "snpt-CONSOLE.cpnt-CONSOLE-plane-table-" + getUID();
            var vuiTableId = "snpt-CONSOLE.vu-CONSOLE-plane-table-" + getUID();
            var vuiPagerId = "snpt-CONSOLE.vu-CONSOLE-pager-" + getUID();
            var vuiDownloadId = "snpt-CONSOLE.vu-CONSOLE-download-" + getUID();
            var vuiDownloadExcelId = "snpt-CONSOLE.vu-CONSOLE-downloadExcel-" + getUID();
            
            cmptEl.innerHTML = [
                '<div class="q-di-table-area di-table-area">',
                    '<div class="q-di-download"></div>',
                    '<div class="q-di-downloadExcel"></div>',
                    '<div class="q-di-table plane-table"></div>',
                    '<div class="q-di-pager"></div>',
                '</div>'
            ].join('');

            depict = [
                {
                    "id": cmptId,
                    "clzType": "COMPONENT",
                    "clzKey": "DI_PLANE_TABLE",
                    "el": cmptEl,
                    "vuiRef": {
                        "mainTable": vuiTableId,
                        "pager": vuiPagerId,
                        "download": vuiDownloadId,
                        "downloadExcel": vuiDownloadExcelId
                    }
                },
                { 
                    "id": vuiPagerId,
                    "clzType": "VUI",
                    "clzKey": "ECUI_PAGER",
                    "el": q('q-di-pager', cmptEl)[0]
                },
                {
                    "id": vuiDownloadId,
                    "clzType": "VUI",
                    "clzKey": "H_BUTTON",
                    "el": q('q-di-download', cmptEl)[0],
                    "dataOpt": { 
                        "skin": "ui-download-btn",
                        "text": "CSV"
                    }
                },
                {
                    "id": vuiDownloadExcelId,
                    "clzType": "VUI",
                    "clzKey": "H_BUTTON",
                    "el": q('q-di-downloadExcel', cmptEl)[0],
                    "dataOpt": { 
                        "skin": "ui-download-btn",
                        "text": "Excel"
                    }
                },
                { 
                    "id": vuiTableId, 
                    "clzType": "VUI",
                    "clzKey": "ECUI_SLOW_PLANE_TABLE",
                    "el": q('q-di-table', cmptEl)[0],
                    "dataOpt": {
                        "rowHCellCut": 30,
                        "hCellCut": 30,
                        "cCellCut": 30,
                        "vScroll": false,
                        "rowCheckMode": "SELECT"
                    }
                }
            ];
        }
    }

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._mModel = new PLANE_EDITOR_MODEL(options);

        //    
        this._mModel.ajaxOptions = {
            defaultFailureHandler:
                bind(this.$defaultFailureHandler, this)
        };

        this._sStatus = options.reportTemplateId ? 'EXIST' : 'NEW';
    }

    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        var model = this._mModel;
        var me = this;
        var css = 'plane-editor';

        this._uNameInput = ecuiCreate(
            UI_INPUT, 
            q(css + '-name', el)[0].lastChild
        );

        this._uSqlInput = CodeMirror(
            q(css + '-sql-input', el)[0],
            {
                theme: "rubyblue",
                mode:  "text/x-mysql",
                lineNumbers: true,
                matchBrackets: true,
                indentUnit: 4,
                smartIndent: false
            }            
        );

        this._uSqlActual = CodeMirror(
            q(css + '-sql-actual', el)[0],
            {
                theme: "rubyblue",
                mode:  "text/x-mysql",
                lineNumbers: true,
                matchBrackets: true,
                indentUnit: 4,
                smartIndent: false
            }            
        );

        var els = children(q(css + '-btns', el)[0]);
        this._uSqlSaveBtn = ecuiCreate(UI_BUTTON, els[0], null, { primary: 'ui-button-g' });
        this._uColBtn = ecuiCreate(UI_BUTTON, els[1], null, { primary: 'ui-button' });
        this._uCondBtn = ecuiCreate(UI_BUTTON, els[2], null, { primary: 'ui-button' });
        this._uPreviewBtn = ecuiCreate(UI_BUTTON, els[3], null, { primary: 'ui-button' });

        this._uColConfig = new MAPPING_CONFIG(cfg('COL_DATA', 'COL_SAVE', 'col'));
        this._uCondConfig = new MAPPING_CONFIG(cfg('COND_DATA', 'COND_SAVE', 'cond'));
        this._uPreviewConfig = new MAPPING_CONFIG(cfg('PREVIEW_DATA', void 0, 'preview'));

        function cfg(init, submit, configType) {
            return { 
                dsMapping: { INIT: init, SUBMIT: submit },
                configType: configType, 
                model: model,
                parent: me
            };
        }

        this.$switchConfigBtns('disable');

        // 
        this._uDIData = createDIEntity(el, model.getCommonParamGetter());
        this._mDIDataModel = this._uDIData.getModel();
    }

    /**
     * 
     *
     * @public
     */
    PLANE_EDITOR_CLASS.init = function() {
        this._mModel.attach(
            ['sync.preprocess.SQL_SAVE', this.disable, this, 'PLANE_EDITOR'],
            ['sync.complete.SQL_SAVE', this.enable, this, 'PLANE_EDITOR'],
            ['sync.result.SQL_SAVE', handleSaved, this],
            ['sync.result.INIT', handleInit, this],
            ['sync.error.INIT', handleInitError, this]
        );

        // 
        this._mDIDataModel.attach(
            ['sync.preprocess.DATA', this.disable, this, 'PLANE_EDIROT'],
            ['sync.complete.DATA', this.enable, this, 'PLANE_EDIROT']
        );

        var me = this;
        this._uSqlSaveBtn.onclick = function() {
            var txt = me._uSqlInput.getValue();
            var name = me._uNameInput.getValue();
            if (!(txt = trim(txt))) {
                return;
            }

            me._mModel.sync(
                {
                    datasourceId: 'SQL_SAVE',
                    args: { sqlString: txt, reportTemplateName: name }
                }
            );
        };
        function handleSaved () {
            //             
            me.$switchConfigBtns('enable');
            if (me._sStatus == 'NEW') {
                me.notify('rtpl.created');
            }
            me._sStatus = 'EXIST';
            me.notify('rtpl.saved');
        }
        function handleInit (data) {
            me._uSqlInput.setValue(data.sqlString || '');
            me._uNameInput.setValue(data.reportTemplateName || '');
        }
        function handleInitError (status) {
            me.disable();
        }

        this._uColBtn.onclick = function () {
            me._uColConfig.open();
        };
        this._uCondBtn.onclick = function () {
            me._uCondConfig.open();
        };
        this._uPreviewBtn.onclick = function () {
            me._uPreviewConfig.open();
        };

        this._uSqlInput.on(
            'change',
            function () {
                // sql
                me.$switchConfigBtns('disable');
            }
        );

        this._uDIData.$di(
            'addEventListener',
            'outputexecinfo',
            function (result) {
                // sql
                this._uSqlActual.setValue(result.data.actualSql);
                if(result.data.exception){
                    DIALOG.alert(LANG.SAD_FACE + "SQL<br>" +result.data.exception);
                }
            },
            this
        );

        foreachDoOri(
            [
                // this._uSqlInput,
                this._uColBtn,
                this._uCondBtn,
                this._uPreviewBtn,
                this._uColConfig,
                this._uCondConfig,
                this._uPreviewConfig
            ],
            'init'
        );
        this._uDIData.$di('init');

        // init
        this._mModel.sync({ datasourceId: 'INIT' });
    };

    /**
     * @override
     */
    PLANE_EDITOR_CLASS.dispose = function() {
        foreachDoOri(
            [
                // this._uSqlInput,
                this._uNameInput,
                this._uSqlSaveBtn,
                this._uColBtn,
                this._uCondBtn,
                this._uPreviewBtn,
                this._uColConfig,
                this._uCondConfig,
                this._uPreviewConfig
            ],
            'dispose'
        );
        this._uDIData.$di('dispose');
        PLANE_EDITOR.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    PLANE_EDITOR_CLASS.$active = function() {
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    PLANE_EDITOR_CLASS.$inactive = function() {
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    PLANE_EDITOR_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) === 0 && this._bDisabled) {
            // this._uSqlInput.enable();
            this._uSqlSaveBtn.enable();
            this.$switchConfigBtns('enable');
            PLANE_EDITOR.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    PLANE_EDITOR_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            // this._uSqlInput.disable();
            this._uSqlSaveBtn.disable();
            this.$switchConfigBtns('disable');
        }
        PLANE_EDITOR.superClass.disable.call(this);
    };

    /**
     * 
     * 
     * @protected
     */
    PLANE_EDITOR_CLASS.$handleFatalError = function(status) {
        this.disable();
        // 
        if (status == 1001) {
            DIALOG.alert(LANG.SAD_FACE + LANG.PARAM_ERROR);
        }
        else {
            DIALOG.alert(LANG.SAD_FACE + LANG.FATAL_DATA_ERROR);
        }
    };

    PLANE_EDITOR_CLASS.$switchConfigBtns = function(method) {
        this._uColBtn[method]();
        this._uCondBtn[method]();
        this._uPreviewBtn[method]();
    };


    /**
     * 
     *
     * @protected
     */
    PLANE_EDITOR_CLASS.$defaultFailureHandler = function (status, ejsonObj) {
        if (status == AJAX.ERROR_RTPL_ID) {
            alert(LANG.SAD_FACE + LANG.ERROR_RTPL_ID);
        }
        else {
            alert(LANG.SAD_FACE + LANG.ERROR);
        }
    };    

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @protected
     */
    MAPPING_CONFIG_CLASS.$doSubmit = function() {
        if (this._sConfigType == 'preview') {
            // preview mappingdata
            var par = this._uParent;
            var data = {};

            var args = this.$doGetSubmitArgs();
            if (isString(args)) {
                // 
                alert(args);
                return;
            }

            var json = par._mModel.getMappingConfig();
            for (var i = 0, o; o = json[i]; i ++) {
                data[o.paramKey] = o.paramValue;
            }
            data.showColumns = args.showColumns;

            // plane table component sync
            cmptSync4Console(DI_FACTORY(), par._uDIData, data);
        }
        else {
            // colcond
            MAPPING_CONFIG.superClass.$doSubmit.apply(this, arguments);
        }
        this.close();
    };

    /** 
     * @override
     */
    MAPPING_CONFIG_CLASS.$doRender = function(contentEl, data) {
        var i;
        var item;
        var json = this._mModel.getMappingConfig() || [];
        var colSel = this._mModel.getColShow() || [];
        var configType = this._sConfigType;
        var html = [];
        var p = 'plane-editor';
        var qp = 'q-plane-editor';

        // previewcol show select
        function renderColSel() {
            html.push('');
            var dele = '&nbsp;&nbsp;';
            html.push(
                '<div style="margin-bottom:10px;" class="' + qp + '-col-show-sel">' 
            );
            for (var i = 0, item; item = colSel[i]; i ++) {
                if (item.paramKey) {
                    html.push(
                        '<div>' + htmlText(item.sqlKey) 
                        + dele + htmlText(item.paramKey) 
                        + dele + htmlText(item.showName) 
                        + '<input data-col-show-sel="' + htmlText(item.paramKey) + '" type="checkbox" /></div>'
                    );
                }
            }
            html.push('</div>');
        }

        // 
        var fillHead = {
            // col mapping
            col: function () {
                html.push('<th>sqlKey</th>');
                html.push('<th>paramKey</th>');
                html.push('<th></th>');
                html.push('<th>I,III.DD%</th>');
                html.push('<th></th>');
                html.push('<th></th>');
            },
            // cond mapping
            cond: function () {
                html.push('<th>sqlKey</th>');
                html.push('<th>paramKey</th>');
            },
            // col mapping
            preview: function () {
                html.push('<th>sqlKey</th>');
                html.push('<th>paramKey</th>');
                html.push('<th></th>');
            }
        };

        var fillBody = {
            col: function (line) {
                html.push('<td class="', qp, '-sql-key" data-sql-key="' + line.sqlKey + '">', htmlText(line.sqlKey), '</td>');
                html.push('<td><input class="', qp, '-param-key" type="input" value="', htmlText(line.paramKey), '"/></td>');
                html.push('<td><input class="', qp, '-show-name" type="input" value="', htmlText(line.showName), '"/></td>');
                html.push('<td><input class="', qp, '-format" type="input" value="', htmlText(line.format), '"/></td>');
                html.push('<td>', makeOrderbySelect(line), '</td>');
                html.push('<td>', makeIsDefaultShowSelect(line), '</td>');
            },
            cond: function (line) {
                html.push('<td class="', qp, '-sql-key" data-sql-key="' + line.sqlKey + '">', htmlText(line.sqlKey), '</td>');
                html.push('<td><input class="', qp, '-param-key" type="input" value="', htmlText(line.paramKey), '"/></td>');
            },
            preview: function (line) {
                html.push('<td class="', qp, '-sql-key" data-sql-key="' + line.sqlKey + '">', htmlText(line.sqlKey), '</td>');
                html.push('<td class="', qp, '-param-key">', htmlText(line.paramKey), '</td>');
                html.push('<td><input class="', qp, '-param-value" type="input" /></td>');
            }
        };

        // orderby 
        function makeOrderbySelect(line) {
            var sel = {'': '', 'NONE': ''};
            sel[line.orderby] = ' selected="selected" ';
            return [
                '<select class="', qp, '-orderby">',
                    '<option value="" ', sel[''], '></option>',
                    '<option value="NONE" ', sel['NONE'], '></option>',
                '</select>'
            ].join('');
        }

        // 
        function makeIsDefaultShowSelect(line) {
            var sel = {'true': '', 'false': ''};
            sel[String(!!line.isDefaultShow)] = ' selected="selected" ';
            return [
                '<select class="', qp, '-default-show">',
                    '<option value="true" ', sel['true'], '></option>',
                    '<option value="false" ', sel['false'], '></option>',
                '</select>'
            ].join('');
        }

        if (this._sConfigType == 'preview') {
            renderColSel();
            html.push('<div></div>');
        }

        // 
        html.push('<table cellspacing="0"><thead><tr>');
        fillHead[this._sConfigType]();
        html.push('<tr></thead>');

        // 
        html.push('<tbody class="', p, '-mapping-tbody">');
        for (i = 0; item = json[i]; i ++) {
            html.push('<tr>');
            fillBody[this._sConfigType](item);
            html.push('</tr>');
        }
        html.push('</tbody></table>');

        this.getContentEl().innerHTML = html.join('');
    };

    /** 
     * @override
     */
    MAPPING_CONFIG_CLASS.$doGetSubmitArgs = function() {
        var json = this._mModel.getMappingConfig() || [];
        var p = 'plane-editor';
        var qp = 'q-plane-editor';
        var ret = {};
        var ERROR_MSG_COMMA = 'paramKey';
        var ERROR_MSG_EMPTY = 'paramKey';

        // modeljson
        var updateJson = {
            col: function (line, jsonItem) {
                var sel;
                var pk = fmtInput(q(qp + '-param-key', line)[0].value);
                if (pk.indexOf(',') >= 0) {
                    return ERROR_MSG_COMMA;
                }
                if (!pk) {
                    return ERROR_MSG_EMPTY;
                }
                jsonItem.paramKey = pk;
                jsonItem.showName = fmtInput(q(qp + '-show-name', line)[0].value);
                jsonItem.format = fmtInput(q(qp + '-format', line)[0].value);
                sel = q(qp + '-orderby', line)[0];
                jsonItem.orderby = sel.options[sel.selectedIndex].value;
                sel = q(qp + '-default-show', line)[0];
                jsonItem.isDefaultShow = sel.options[sel.selectedIndex].value;
            },
            cond: function (line, jsonItem) {
                var pk = fmtInput(q(qp + '-param-key', line)[0].value);
                if (pk.indexOf(',') >= 0) {
                    jsonItem.paramKey = null;
                    return ERROR_MSG_COMMA;
                }
                if (!pk) {
                    return ERROR_MSG_EMPTY;
                }
                jsonItem.paramKey = pk;
            },
            preview: function (line, jsonItem) {
                var sel;
                jsonItem.paramValue = fmtInput(q(qp + '-param-value', line)[0].value);
            }
        };

        var lines = q(
                'plane-editor-mapping-tbody', this.getContentEl()
            )[0].getElementsByTagName('tr');
        var i;
        var j;
        var line;
        var o;
        var sel;
        var msg;

        for (i = 0; line = lines[i]; i ++) {
            var sqlKey = q(qp + '-sql-key', line)[0].getAttribute('data-sql-key');
            // jsonsqlKey
            for (j = 0; o = json[j]; j ++) {
                if (o.sqlKey == sqlKey) {
                    // modeljson
                    if (isString(msg = updateJson[this._sConfigType](line, o))) {
                        return msg;
                    }
                }
            }
        }

        if (this._sConfigType == 'preview') {
            ret.showColumns = [];
            var eColSel = q(qp + '-col-show-sel', this.getContentEl())[0];
            var colSelCheckbox = eColSel.getElementsByTagName('input');
            for (i = 0, o; o = colSelCheckbox[i]; i ++) {
                o.checked
                    && ret.showColumns.push(o.getAttribute('data-col-show-sel'));
            }
            ret.showColumns = ret.showColumns.join(',');
        }

        return ret;
    };

    function fmtInput(value) {
        if (value == null) {
            return '';
        }
        return trim(String(value));
    }

    // function cutParamPrefix(value) {
    //     if (value != null) {
    //         return String(value).slice(DICT.PARAM_PREFIX.length);
    //     }
    // }

})();
/**
 * di.console.editor.ui.DefaultDataFormatPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  chenxiaoming01(chenxiaoming01@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var textSubstr = xutil.string.textSubstr;
    var encodeHTML = xutil.string.encodeHTML;
    var htmlText = xutil.string.htmlText;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var parseParam = xutil.url.parseParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     *
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var QUERY_PARAM_FIX_PANEL = $namespace().QueryParamFix =
        inheritsObject(
            BASE_CONFIG_PANEL
        );
    var QUERY_PARAM_FIX_PANEL_CLASS = QUERY_PARAM_FIX_PANEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    QUERY_PARAM_FIX_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
    };



    QUERY_PARAM_FIX_PANEL_CLASS.$doOpen = function(mode, options) {
        this._uDIData = options.data;
    };

    /** 
     * @override
     */
    QUERY_PARAM_FIX_PANEL_CLASS.$doRender = function(contentEl, data) {
        // dispose
        contentEl.innerHTML = ''

        var html = [
            '<span><span>',
            '<div>',
                '<textarea class="query-extend-param"></textarea>',
            '</div>',
            '<div>',
                '&param1param2, param1V  param2V<br>',
                'paramArrayparamArrayV1paramArrayV2,<br>',
                '<font color="red">param1</font>=',
                '<font color="green">param1v</font>',
                '<font color="blue">&amp;</font>',
                '<font color="red">param2</font>=',
                '<font color="green">param2v</font>',
                '<font color="blue">&amp;</font>',
                '<font color="red">paramArray</font>=',
                '<font color="green">paramArrayV1</font>',
                '<font color="blue">&amp;</font>',
                '<font color="red">paramArray</font>=',
                '<font color="green">paramArrayV2</font>',
            '</div>'
        ].join('');
        contentEl.innerHTML = html;
    };

   QUERY_PARAM_FIX_PANEL_CLASS.$doSubmit = function(){
        var args = this.$doGetSubmitArgs();
       
        
        this.$handleSubmitSuccess(null, null, null);
        cmptSync4Console(DI_FACTORY(), this._uDIData,args);
        
   }

   /** 
    * @override
    */
   QUERY_PARAM_FIX_PANEL_CLASS.$doGetSubmitArgs = function() {
       var contentEl = this.getContentEl();
       var extendParam = q('query-extend-param',contentEl)[0].value;

       return parseParam(extendParam);
   };



})();
/**
 * di.console.editor.ui.DefaultDataFormatPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    ,,,
 * @author:  chenxiaoming01(chenxiaoming01@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var textSubstr = xutil.string.textSubstr;
    var encodeHTML = xutil.string.encodeHTML;
    var htmlText = xutil.string.htmlText;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var ecuiCreate = UTIL.ecuiCreate;
    var $fastCreate = ecui.$fastCreate;
    var isString = xutil.lang.isString;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var strToBoolean = UTIL.strToBoolean;
    var UI_CONTROL = ecui.ui.Control;
    var alert = di.helper.Dialog.alert;
    var UI_BUTTON = ecui.ui.Button;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;

    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     *
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var REPORT_DATA_MERGE_CONFIG_PANEL = $namespace().ReportDataMergeConfigPanel =
        inheritsObject(
            BASE_CONFIG_PANEL,
            function(options) {
                this._mModel = options.model;
                this.DATASOURCE_ID_MAPPING = {
                    INIT: 'GET_TEMPLATE_INFO',
                    SUBMIT: 'REPORT_ROWMERGE_KEY_SUBMIT'
                };
            }
        );
    var REPORT_DATA_MERGE_CONFIG_PANEL_CLASS = REPORT_DATA_MERGE_CONFIG_PANEL.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    /** 
     * @override
     */
    REPORT_DATA_MERGE_CONFIG_PANEL_CLASS.$doDispose = function() {
        this.getContentEl().innerHTML = '';
        // FIXME
    };

    /** 
     * @override
     */
    REPORT_DATA_MERGE_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /** 
     * @override
     */
    REPORT_DATA_MERGE_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
        // dispose
        contentEl.innerHTML = ''

        var type = data.type || 'SIMPLE';
        var html = [
            '   <div>',
            '       <label>:</label>',
            '       <select class="merge_type">',
            '           <option value="SIMPLE"></option>',
            '           <option value="ROWMERGE"></option>',
            '           <option value="COLUMNMERGE"></option>',
            '       </select>',
                    '<span class="row-merge-span">',
            '       <label>:</label>',
            '       <select class="row_merge_key">',
            '       </select>',
                    '</span>',
            '   </div>',
            '   <ul>',
            '       <li>:</li>',
            '           <li>1.:</li>',
            '           <li>2.:,,',
            '                       ,</li>',
            '           <li>3.:</li>',
            '   </ul>',
            '</div>'
            ].join('');
        
        contentEl.innerHTML = html;
       q('merge_type',contentEl)[0].value = type;
       var rowMergeSpan = q('row-merge-span',contentEl)[0];
       var mergeKey = q('row_merge_key',contentEl)[0];
       if(data.dimList){
                mergeKey.innerHTML = '';
                data.dimList.foreach(function(key, item, index){
                    mergeKey.add(new Option(item.caption,item.name));
               });
               
           } 
       if(type == 'ROWMERGE'){
            rowMergeSpan.style.display = '';
            mergeKey.value = data.rmKey;
       }else{
            rowMergeSpan.style.display = 'none';
       }

       

       this.$bindEvent();

    };

    REPORT_DATA_MERGE_CONFIG_PANEL_CLASS.$bindEvent = function(){
        var contentEl = this.getContentEl();
        var mergeType = q('merge_type',contentEl)[0];
        var rowMergeSpan = q('row-merge-span',contentEl)[0];

        mergeType.onchange = bind(mergeTypeChange,mergeType);
        
        
        function mergeTypeChange(){
            if(this.value == 'ROWMERGE'){
                rowMergeSpan.style.display = '';
            }else{
                rowMergeSpan.style.display = 'none';
            }
        }
    }

    
    /** 
     * @override
     */
    REPORT_DATA_MERGE_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        var contentEl = this.getContentEl();
        var mergeType = q('merge_type',contentEl)[0].value;
        var  param = [];
        param.push("pivottableModelBuilderStyle,"+mergeType);
        if(mergeType == 'ROWMERGE'){
            var mergeDim =  q('row_merge_key',contentEl)[0].value;
            param.push("pivottableModelBuilderStyleRMKey," + mergeDim);
        }
        return {
            updateTemplateProperty: param
        };
        
    };

    REPORT_DATA_MERGE_CONFIG_PANEL_CLASS.$doGetInitArgs = function(){
        return {
            key : 'DATA_MERGE_TYPE'
        };
    };


})();
/**
 * di.console.editor.ui.VTplCodeEditor
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    vtpl
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  codemirror, xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var children = xutil.dom.children;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var UI_INPUT = ecui.ui.Input;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var DI_FACTORY;
        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * vtpl
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var VTPL_CODE_EDITOR = $namespace().VTplCodeEditor = 
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                addClass(el, 'vtpl-code-editor');
                el.innerHTML = HTML_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var VTPL_CODE_EDITOR_CLASS = VTPL_CODE_EDITOR.prototype;
    
    //------------------------------------------
    // 
    //------------------------------------------

    var HTML_MAIN = [
        '<div class="vtpl-panel-page-btns">',
            '<span></span>',
            '<input class="vtpl-name-input q-vtpl-name"/>',
            '<span class="q-btn-save"></span>',
        '</div>',
        '<div class="vtpl-quick-btn-phase">',
            '<span class="vtpl-quick-btn-phase-item">',
                '<input type="radio" name="di-editor-code" checked="checked" />',
            '</span>',
            '<span class="vtpl-quick-btn-phase-item" style="margin-left:10px;">',
                '<input type="radio" name="di-editor-code" />',
            '</span>',
        '</div>',
        '<div class="vtpl-code">',
            '<div class="vtpl-code-snippet"></div>',
            '<div class="vtpl-code-depict"></div>',
        '</div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._vtplPanelPage = options.vtplPanelPage;
        this._mVTplModel = options.vtplModel;
        extend(this, this._vtplPanelPage.vtplMgrGet(this));
    };
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        this._uSaveBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-save', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uNameInput = ecuiCreate(
            UI_INPUT,
            q('q-vtpl-name', el)[0]
        );

        var opt = {
            theme: "rubyblue",
            lineNumbers: true,
            matchBrackets: true,
            indentUnit: 4,
            lineWrapping: false,
            height: 700,
            smartIndent: false
        };
        var snippetOpt = extend({ snippet: 'htmlmixed' }, opt);
        var depictOpt = extend({ snippet: 'javascript' }, opt);

        var eps = this._eps = { snippet: {}, depict: {} };
        eps.snippet.el = q('vtpl-code-snippet', el)[0];
        eps.snippet.el.appendChild(document.createElement('div'));
        eps.snippet.input = CodeMirror(eps.snippet.el.firstChild, snippetOpt);
        eps.depict.el = q('vtpl-code-depict', el)[0];
        eps.depict.el.appendChild(document.createElement('div'));
        eps.depict.input = CodeMirror(eps.depict.el.firstChild, depictOpt);

        var vtplType = ['snippet', 'depict'];
        var ch = children(q('vtpl-quick-btn-phase', el)[0]);
        var me = this;
        for (var i = 0, o; o = ch[i]; i ++) {
            o.onclick = (function (ph) {
                return function () {
                    if (me.$changeEditPhase(ph)) {
                        this.getElementsByTagName('input')[0].checked = true;
                    }
                    else {
                        return false;
                    }
                };
            })(vtplType[i]);
        }
    };

    /**
     * vtplPanelPage
     * 
     * @public
     */
    VTPL_CODE_EDITOR_CLASS.doRefreshFork = function (vtplFork) {
        var vtpl = this._vtplFork = vtplFork;

        this._eps.snippet.input.$__setValue(vtpl.snippet.content);
        this._eps.depict.input.$__setValue(vtpl.depict.content);

        this._uNameInput.setValue(vtpl.vtplName || '');

        // depict
        !this._currEPKey && this.$changeEditPhase('snippet');
    };
    
    /**
     * 
     *
     * @public
     */
    VTPL_CODE_EDITOR_CLASS.init = function() {
        var editFn = this.bindEditFn(new Function(), this);
        var eps = this._eps;
        var snippetInput = eps.snippet.input;
        var depictInput = eps.depict.input;
        var vtplPanelPage = this._vtplPanelPage;

        // 
        snippetInput.$__setValue = $__setValue;
        depictInput.$__setValue = $__setValue;

        // 
        this._uSaveBtn.onclick = bind(vtplPanelPage.doSave, vtplPanelPage, this);
        this._uNameInput.onchange = this.bindEditFn(new Function(), this);

        this._eps.snippet.input.on(
            'change', 
            snippetInput.$__changeFn = getChangeFn(editFn)
        );
        this._eps.depict.input.on(
            'change', 
            depictInput.$__changeFn = getChangeFn(editFn)
        );

        // this._uSaveBtn.disable('SELF_START_EDIT');

        function getChangeFn(editFn) {
            var fn = function () {
                // code mirrorchangesetValue
                if (!fn.notUserEvent) {
                    return editFn([].slice.call(arguments));
                }
            };

            return fn;
        }

        function $__setValue(str) {
            var changeFn = this.$__changeFn;
            changeFn.notUserEvent = true;
            var ret = this.setValue(str);
            changeFn.notUserEvent = false;
            return ret;
        }
    };

    /**
     * @override
     */
    VTPL_CODE_EDITOR_CLASS.dispose = function() {
        // TODO
        this._uSaveBtn && this._uSaveBtn.dispose();
        this._uNameInput && this._uNameInput.dispose();
        this._eps = null;
        VTPL_CODE_EDITOR.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    VTPL_CODE_EDITOR_CLASS.$active = function() {
        // TODO
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    VTPL_CODE_EDITOR_CLASS.$inactive = function() {
        // TODO
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_CODE_EDITOR_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            var el = this.getEl();
            q('vtpl-code-depict', el)[0]
                .getElementsByTagName('TEXTAREA')[0].disabled = false;
            q('vtpl-code-snippet', el)[0]
                .getElementsByTagName('TEXTAREA')[0].disabled = false;
            this._uSaveBtn && this._uSaveBtn.enable(key);
            VTPL_CODE_EDITOR.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_CODE_EDITOR_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            var el = this.getEl();
            q('vtpl-code-depict', el)[0]
                .getElementsByTagName('TEXTAREA')[0].disabled = true;
            q('vtpl-code-snippet', el)[0]
                .getElementsByTagName('TEXTAREA')[0].disabled = true;
            this._uSaveBtn && this._uSaveBtn.disable(key);
        }
        VTPL_CODE_EDITOR.superClass.disable.call(this);
    };    

    /**
     * 
     * 
     * @protected
     */
    VTPL_CODE_EDITOR_CLASS.doStartEdit = function() {
        // this._uSaveBtn.enable('SELF_START_EDIT');
    };

    /**
     * , vtplPanelPage
     *
     * @protected
     * @return {Array.<string>} errorMsg 
     */
    VTPL_CODE_EDITOR_CLASS.doSave = function() {
        var vtpl = this._vtplFork;

        // 
        vtpl.vtplName = this._uNameInput.getValue();

        var errorMsg = vtpl.contentSet(
            this._eps.snippet.input.getValue(),
            this._eps.depict.input.getValue()
        );

        // (!errorMsg || !errorMsg.length)
        //     && this._uSaveBtn.disable('SELF_START_EDIT');

        return {
            vtplFork: vtpl,
            errorMsg: errorMsg
        }
    };

    /**
     * editphase
     * 
     * @protected
     */
    VTPL_CODE_EDITOR_CLASS.$changeEditPhase = function(epKey) {
        var currEPKey = this._currEPKey;

        if (!currEPKey || currEPKey != epKey) {
            for (var key in this._eps) {
                this._eps[key].el.style.display = key == epKey ? '' : 'none';
            }
            this._currEPKey = epKey;
        }

        return true;
    };

})();
/**
 * di.console.editor.ui.VTplGuiEditor
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    vtpl
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var children = xutil.dom.children;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var DI_FACTORY;
        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * vtpl
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.reportType
     * @param {string} options.schemaName
     * @param {string} options.cubeTreeNodeName
     */
    var VTPL_GUI_EDITOR = $namespace().VTplGuiEditor = 
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                addClass(el, 'vtpl-gui-editor');
                el.innerHTML = HTML_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var VTPL_GUI_EDITOR_CLASS = VTPL_GUI_EDITOR.prototype;
    
    var HTML_MAIN = [
        '<div class="">',
            '<div class="vtpl-gui-btn">',
                '<span class="q-vtpl-gui-btn-phase"></span>',
            '</div>',
            // TODO 
            '<div class="vtpl-gui-snippet"></div>',
            '<div class="vtpl-gui-ep">',
                '<div class="vtpl-gui-ep-ds">dsdsds</div>',
                '<div class="vtpl-gui-ep-cond">condcond</div>',
            '</div>',
        '</div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._vtpl = options.vtpl;
        this._mVTplModel = options.vtplModel;
    }
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        this._eSnippet = q('vtpl-gui-snippet', el)[0];

        resetEditPhaseRadio.call(this);

        this._eps = {
            EP_DS: { el: q('vtpl-gui-ep-ds', el)[0] },
            EP_COND: { el: q('vtpl-gui-ep-cond', el)[0] }
        };

        // this.$initSnippet();

        // layout
        this.$changeEditPhase('EP_DS');

        // TODO
        // radio
        function resetEditPhaseRadio() {
            var ee = q('q-vtpl-gui-btn-phase', el)[0];
            ee.innerHTML = [
                // '<input type="radio" name="di-editor-phase" />&nbsp;&nbsp;',
                '<input type="radio" name="di-editor-phase" checked="checked" />&nbsp;&nbsp;',
                '<input type="radio" name="di-editor-phase" />&nbsp;&nbsp;'//,
                // '<input type="radio" name="di-editor-phase" />&nbsp;&nbsp;',
                // '<input type="radio" name="di-editor-phase" />&nbsp;&nbsp;'
            ].join('');
            // var editPhases = ['EP_LAYOUT', 'EP_DATASOURCE', 'EP_ATTR', 'EP_INTERACTION'];
            var editPhases = ['EP_DS', 'EP_COND'];
            var ch = children(ee);
            for (var i = 0, o; o = ch[i]; i ++) {
                o.onclick = bind(this.$changeEditPhase, this, editPhases[i]);
            }
        }

        this.$preview();
    }
    
    /**
     * 
     *
     * @public
     */
    VTPL_GUI_EDITOR_CLASS.init = function() {

        // // 
        // this._mOLAPEditorModel.attach(
        //     'sync.result.INIT', 
        //     this.$handleInit, 
        //     this
        // );
        // this._mMetaConditionModel.attach(
        //     ['sync.complete.META_DATA', this.enable, this, 'OLAP_EDIROT'],
        //     ['sync.error.META_DATA', this.$handleFatalError, this]
        // );

        // // 
        // this._uQueryBtn.onclick = bind(this.$handleQuery, this);
        // this._uChartConfigBtn.onclick = bind(this.$openChartConfig, this);

        // // 
        // this._mDIDataModel.attach(
        //     ['sync.preprocess.DATA', this.disable, this, 'OLAP_EDIROT'],
        //     ['sync.complete.DATA', this.enable, this, 'OLAP_EDIROT']
        // );

        // // init
        // this._uMetaCondition.init();
        // this._uDIData.init();

        // this.disable();

        // // 
        // this._mOLAPEditorModel.sync({ datasourceId: 'INIT' });
    };

    /**
     * @override
     */
    VTPL_GUI_EDITOR_CLASS.dispose = function() {
        // TODO
        this._eSnippet = null;
        VTPL_GUI_EDITOR.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    VTPL_GUI_EDITOR_CLASS.$active = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    VTPL_GUI_EDITOR_CLASS.$inactive = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_GUI_EDITOR_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            // this._uDIData.enable(key);
            // this._uQueryBtn.enable();
            // this._uMetaCondition.enable(key);
            VTPL_GUI_EDITOR.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_GUI_EDITOR_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            // this._uDIData.disable(key);
            // this._uQueryBtn.disable();
            // this._uMetaCondition.disable(key);
        }
        VTPL_GUI_EDITOR.superClass.disable.call(this);
    };

    /**
     * 
     * 
     * @protected
     */
    VTPL_GUI_EDITOR_CLASS.$initSnippet = function() {
        var snippetContent = this._vtpl.snippet.content;
        var eSnippet = this._eSnippet;

        // 
        if (!this.$checkEditable()) {
            eSnippet.innerHTML = '';
            this.disable();
            return;
        }

        // 
    };

    /**
     * snippet
     * 
     * @protected
     */
    VTPL_GUI_EDITOR_CLASS.$checkEditable = function() {
        var snippetContent = this._vtpl.snippet.content;
        if (snippetContent.indexOf(DOM_FLAG_BEGIN) >= 0
            && snippetContent.indexOf(DOM_FLAG_END) >= 0
        ) {
            return true;
        }
        return false;
    };    

    /**
     * 
     * 
     * @protected
     */
    VTPL_GUI_EDITOR_CLASS.$preview = function(epKey) {

    };

    /**
     * editphase
     * 
     * @protected
     */
    VTPL_GUI_EDITOR_CLASS.$changeEditPhase = function(epKey) {
        var currEPKey = this._currEPKey;

        if (!currEPKey || currEPKey != epKey) {
            for (var key in this._eps) {
                this._eps[key].el.style.display = key == epKey ? '' : 'none';
            }
            this._currEPKey = epKey;
        }
    };

    /**
     * 
     * 
     * @protected
     */
    VTPL_GUI_EDITOR_CLASS.$handleFatalError = function(status) {
        this.disable();
        // // 
        // if (status == 1001) {
        //     DIALOG.alert(LANG.SAD_FACE + LANG.PARAM_ERROR);
        // }
        // else {
        //     DIALOG.alert(LANG.SAD_FACE + LANG.FATAL_DATA_ERROR);
        // }
    };

})();
/**
 * di.console.editor.ui.VTplPanelPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var addEventListener = ecui.addEventListener;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var parseParam = xutil.url.parseParam;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var $fastCreate = ecui.$fastCreate;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var alert = di.helper.Dialog.alert;
    var confirm = di.helper.Dialog.confirm;
    var template = xutil.string.template;
    var getUID = xutil.uid.getUID;
    var ecuiCreate = UTIL.ecuiCreate;
    var foreachDoOri = UTIL.foreachDoOri;
    var ajaxRequest = baidu.ajax.request;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var textParam = xutil.url.textParam;
    var jsonParse = baidu.json.parse;
    var replaceIntoParam = xutil.url.replaceIntoParam;
    var UI_BUTTON = ecui.ui.Button;
    var assert = UTIL.assert;
    var PANEL_PAGE_MANAGER;
    var PANEL_PAGE_TAB_ADAPTER;
    var UI_TAB_CONTAINER = ecui.ui.TabContainer;
    var BASE_CONFIG_PANEL = di.shared.ui.BaseConfigPanel;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;
    var CUBE_CONFIG_PANEL;
    var PREVIEW_CONFIG_PANEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
        PANEL_PAGE_MANAGER = di.shared.model.PanelPageManager;
        PANEL_PAGE_TAB_ADAPTER = di.shared.model.PanelPageTabAdapter;
        CUBE_CONFIG_PANEL = di.console.shared.ui.CubeConfigPanel;
        PREVIEW_CONFIG_PANEL = di.console.shared.ui.PreviewConfigPanel;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     *      1. panelPagepanelPageeditorquickEidtorcodeEidtor
     *      2. vtplPanelPagevtpleidtordoRefreshFork
     *      vtplPanelPageclonevtpl
     *      editordoRefreshForkvtpl
     *      3. editoreidtor
     *      vtplPanelPagedoRefreshForkeditordoRefrefhFork
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.dsId 
     */
    var VTPL_PANEL_PAGE = $namespace().VTplPanelPage =
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                addClass(el, 'vtpl-panel-page');
                el.innerHTML = HTML_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var VTPL_PANEL_PAGE_CLASS = VTPL_PANEL_PAGE.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    var HTML_MAIN = [
        '<div class="vtpl-panel-page-btns">',
            // '<span></span>',
            // '<input class="q-vtpl-name"/>',
            // '<span class="q-btn-save"></span>',
            '<span class="q-btn-pre"></span>',
            '<span class="q-btn-release"></span>',
            '<span class="q-btn-preview"></span>',
        '</div>',
        '<div class="q-main"></div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._mPanelPageManager = new PANEL_PAGE_MANAGER(
            { adapter: PANEL_PAGE_TAB_ADAPTER }
        );
        this._mVTplModel = options.vtplModel;
    }

    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        this._uPreBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-pre', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uReleaseBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-release', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uPreviewBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-preview', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uMainContainer = $fastCreate(
            UI_TAB_CONTAINER,
            q('q-main', this.getEl())[0],
            null,
            { primary: 'ui-tab' }
        );

        // 
        this._uPreviewConfig = new PREVIEW_CONFIG_PANEL(
            { parent: this, panelTitle: '' }
        );

        // cube
        this._uCubeConfigPanel = new CUBE_CONFIG_PANEL(
            { parent: this }
        );
    }

    /**
     * 
     *
     * @public
     */
    VTPL_PANEL_PAGE_CLASS.init = function() {
        var me = this;

        // vtpl mgr functions
        extend(this, this.vtplMgrGet(this));

        this._mPanelPageManager.inject(this._uMainContainer);
        this._mPanelPageManager.attach(
            ['page.active', this.$pageActiveHandler, this]
        );
        this._uCubeConfigPanel.attach(
            'select', this.$openEditor, this
        );

        this._uPreviewBtn.onclick = bind(this.doPreview, this);
        this._uPreBtn.onclick = bind(this.doPre, this);
        this._uReleaseBtn.onclick = bind(this.doRelease, this);

        // toPretoReleasedisable
        // toPretoRlease

        this._mPanelPageManager.init();
        this._uCubeConfigPanel.init();
        this._uPreviewConfig.init();
    };

    /**
     * @override
     */
    VTPL_PANEL_PAGE_CLASS.dispose = function() {
        this._mPanelPageManager.dispose();
        // TODO
        foreachDoOri(
            [
                this._uPreviewBtn,
                this._uPreBtn,
                this._uReleaseBtn,
                this._uPreviewConfig
            ],
            'dispose'
        );
        // this._uNameInput = null;
        VTPL_PANEL_PAGE.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     *
     * @param {Object} options
     * @param {Object} options.extraOpt 
     */
    VTPL_PANEL_PAGE_CLASS.$active = function(options) {
        function doOpen() {
                if (actName == 'CREATE' || actName == 'EDIT') {
                    var pg = me.openTab({ editorType: 'QUICK' });
                    me.openTab({ editorType: 'CODE' });
                    me._mPanelPageManager.select(pg.getPageId());
                    
                    //  tab$getSecondConditionConfig
                    //      
                    me.$getSecondConditionConfig();
                }
                else {
                    me.openTab(
                        extend({ editorType: editorType }, options.extraOpt)
                    );
                }
        }
        
        var vtplModel = this._mVTplModel;
        var me = this;

        var act = options.act;
        var phase = options.phase;
        if (act) {
            // TODO
            // act[0]  EDIT/CREATE,  VIEW

            // "EDIT#QUICK", "VIEW#QUICK", "CREATE#VTPL"
            act = act.split('#');
            var actName = act[0];
            var editorType = act[1];

            var vtpl;
            if (actName == 'EDIT' || actName == 'VIEW' || actName == 'PREVIEW') {
                vtpl = this._vtpl = vtplModel.getVTpl(phase, options.vtplKey);
                // this._uNameInput.value = this._vtpl.vtplName;
            }
            else if (actName == 'CREATE') {
                vtpl = this._vtpl = vtplModel.getMold(options.moldKey);
            }

            if (actName != 'PREVIEW' && !this._vtplGot) {
                // vtpl
                this._mVTplModel.fetchRemoteVTpl(this._vtpl, doOpen);
                this._vtplGot = true;
            }
            else {
                doOpen();
            }

        }
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    VTPL_PANEL_PAGE_CLASS.$inactive = function(options) {
        // TODO
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_PANEL_PAGE_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) === 0 && this._bDisabled) {
            this._mPanelPageManager.forEachPage(
                function (pageId, page, index) {
                    page.enable(key);
                }
            );
            foreachDoOri(
                [
                    this._uPreviewBtn,
                    this._uPreBtn,
                    this._uReleaseBtn
                ],
                'enable',
                key
            );
            VTPL_PANEL_PAGE.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_PANEL_PAGE_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            this._mPanelPageManager.forEachPage(
                function (pageId, page, index) {
                    page.disable(key);
                }
            );
            foreachDoOri(
                [
                    this._uPreviewBtn,
                    this._uPreBtn,
                    this._uReleaseBtn
                ],
                'disable',
                key
            );
        }
        VTPL_PANEL_PAGE.superClass.disable.call(this);
    };

    /**
     * 
     */
    VTPL_PANEL_PAGE_CLASS.$pageActiveHandler = function(menuId) {
        // TODO
    };

    /**
     * cube
     */
    VTPL_PANEL_PAGE_CLASS.openCubeConfigPanel = function(reportType) {
        this._uCubeConfigPanel.changeReportType(reportType);
        this._uCubeConfigPanel.open();
    };

    /**
     * 
     * (panel page)
     * 
     * @public
     * @param {Object} options
     * @param {string} act
     * @param {string} reportType
     * @param {string=} reportTemplateId
     * @param {string=} vtplKey
     */
    VTPL_PANEL_PAGE_CLASS.openTab = function(options) {
        var editorType = options.editorType;
        var reportTemplateId = options.reportTemplateId;
        var pageOpt = extend({}, options);
        var panelPageManager = this._mPanelPageManager;
        var vtpl = this._vtpl;

        extend(
            pageOpt, 
            {
                pageId: ({
                        CODE: editorType,
                        QUICK: editorType,
                        RTPL_OLAP_TABLE: reportTemplateId || editorType + getUID(),
                        RTPL_OLAP_CHART: reportTemplateId || editorType + getUID(),
                        RTPL_PLANE_TABLE: reportTemplateId || editorType + getUID(),
                        PREVIEW: reportTemplateId || editorType + getUID()
                    })[editorType],
                pageClz: ({
                        CODE: 'di.console.editor.ui.VTplCodeEditor',
                        QUICK: 'di.console.editor.ui.VTplQuickEditor',
                        RTPL_OLAP_TABLE: 'di.console.editor.ui.OLAPEditor',
                        RTPL_OLAP_CHART: 'di.console.editor.ui.OLAPEditor',
                        RTPL_PLANE_TABLE: 'di.console.editor.ui.PlaneEditor',
                        PREVIEW: 'di.console.shared.ui.ReportPreview'
                    })[editorType],
                pageTitle: ({
                        CODE: '()',
                        QUICK: '',
                        RTPL_OLAP_TABLE: '',
                        RTPL_OLAP_CHART: '',
                        RTPL_PLANE_TABLE: '',
                        PREVIEW: ''
                    })[editorType],
                reportType: editorType,
                vtplModel: this._mVTplModel,
                panelPageManager: panelPageManager,
                vtplPanelPage: this
            }
        );

        assert(pageOpt.pageId, 'reportTempalteId is null')

        var page = panelPageManager.openByURI(pageOpt.pageClz, pageOpt, oncreate);
        // 
        page.attach('rtpl.created', this.doCreated, this);

        return page;

        function oncreate(page) {
            page.doRefreshFork && page.doRefreshFork(vtpl.clone());
        }
    };

    /**
     * tab
     */
    VTPL_PANEL_PAGE_CLASS.$openEditor = function(menuItem) {
        var arr = menuItem.menuUrl.split('?');
        this.openTab(parseParam(arr[1]));
    };

    /**
     * rtpl created
     */
    VTPL_PANEL_PAGE_CLASS.doCreated = function(menuItem) {
        this._mPanelPageManager.forEachPage(function (pageId, page, index) {
            page.doCreated && page.doCreated();
        });
    };

    /**
     * 
     */
    VTPL_PANEL_PAGE_CLASS.doSave = function(who) {
        var me = this;
        var vtplBase = this._vtpl;
        var vtplModel = this._mVTplModel;
        var panelPageManager = this._mPanelPageManager;

        var otherEditing = this.$getOtherEditing(who);
        if (otherEditing.length) {
            // 
            confirm(
                LANG.OTHER_EDITING(otherEditing),
                $doSave
            );
        }
        else {
            $doSave();
        }

        function $doSave() {
            try {
                var result = who.doSave();
                if (result.errorMsg.length) {
                    alert(LANG.SAD_FACE + result.errorMsg.join(' | '));
                    return;
                }
                
                //  -------------------- xlst  [begin] --------------------
                //  handler
                /*
                 * 
                 * 
                 *  
                 * 
                 */
                var secondConditionConfig = me._mVTplModel._oSecondConditionConfig;
                //  bugif
                if (secondConditionConfig) {
                    var isArray = xutil.lang.isArray;
                    
                    var rtplId;
                    var rtplCond = result.vtplFork.rtplCond;
                    //  hasOwnProperty
                    for (rtplId in rtplCond) {
                        //  if 
                        if (isArray(rtplCond[rtplId])) {
                            //    
                            result.vtplFork.rtplCond[rtplId] = secondConditionConfig[rtplId];
                        }
                    }
                    //  vtpl.jscondSubmitGet'RTPL_VIRTUAL_ID'for
                    //      forifsecondConditionConfig'RTPL_VIRTUAL_ID'
                    //       
                }
                //  -------------------- xlst [end] --------------------

                // 
                me.disable('VTPL_PANEL_PAGE#DO_SAVE');

                vtplModel.sync(
                    {
                        datasourceId: 'SAVE_TPL',
                        args: { vtpl: result.vtplFork },
                        result: $saveSuccess,
                        error: $saveFail,
                        complete: $saveComplete
                    }
                );
            }
            catch (e) {
                alert(LANG.SOME_ERROR + ' info: ' + e.message);
            }
        }

        function $saveSuccess(data, ejsonObj, options) {
            // 
            vtplBase.replaceWith(options.args.vtpl);

            // 
            vtplBase.statusUpdate('SAVED');
            if (data.virtualTemplateId) {
                // vtplvritualTemplateId"RTPL_VIRTUAL_ID"
                // fork
                // vtplKey
                vtplBase.vtplKey = data.virtualTemplateId;
            }

            // fork
            panelPageManager.forEachPage(
                function (pageId, page) {
                    panelPageManager.mark(page.getPageId(), false);
                    page.doRefreshFork && page.doRefreshFork(vtplBase.clone());
                    page.$__editing = false;
                }
            );

            alert(LANG.SMILE_FACE + LANG.SAVE_SUCCESS);
        }

        function $saveFail(status) {
            alert(LANG.SAD_FACE + LANG.SAVE_FAIL + ' ' + status + '');
        }

        function $saveComplete() {
            me.enable('VTPL_PANEL_PAGE#DO_SAVE')
        }
    };

    /**
     * 
     */
    VTPL_PANEL_PAGE_CLASS.doPre = function() {
        var vtpl = this._vtpl;

        if (vtpl.status == 'MOLD') {
            alert(LANG.NEED_CREATE);
            return;
        } 

        this._mVTplModel.sync(
            {
                datasourceId: 'TO_PRE',
                args: { vtpl: vtpl },
                result: function () {
                    alert(LANG.SMILE_FACE + LANG.OPT_SUCCESS);
                }
            }
        );
    };

    /**
     * 
     */
    VTPL_PANEL_PAGE_CLASS.doRelease = function() {
        var vtpl = this._vtpl;

        if (vtpl.status == 'MOLD') {
            alert(LANG.NEED_CREATE);
            return;
        } 

        this._mVTplModel.sync(
            {
                datasourceId: 'TO_RELEASE',
                args: { vtpl: vtpl },
                result: function () {
                    alert(LANG.SMILE_FACE + LANG.OPT_SUCCESS);
                }
            }
        );
    };

    /**
     * 
     */
    VTPL_PANEL_PAGE_CLASS.doPreview = function() {
        var me = this;
        var vtpl = this._vtpl;
        if (vtpl.status == 'MOLD') {
            // preview
            alert('Preview');
            return;
        }
        this._uPreviewConfig.open(
            'EDIT', 
            { 
                vtplKey: vtpl.vtplKey,
                onconfirm: function (options) {
                    me.openTab(
                        { 
                            editorType: 'PREVIEW', 
                            reportURL: options.reportURL,
                            data: options.data,
                            vtplKey: vtpl.vtplKey
                        }
                    );
                }
            }
        );
    };

    /**
     * vtpl
     */
    VTPL_PANEL_PAGE_CLASS.vtplMgrGet = function(editor) {
        var vtplPanelPage = this;
        var pageMgr = this._mPanelPageManager;

        // 
        function startEdit(who) {
            // 
            pageMgr.mark(who.getPageId(), true);
            // 
            who.$__editing = true;
            who.doStartEdit && who.doStartEdit();

            //TODO
            // 
        }

        return {
            /**
             * editor
             */
            bindEditFn: function (fn, scope, args) {
                args = Array.prototype.slice.call(arguments, 2);

                return function () {
                    // try catch
                    // catch
                    try {
                        startEdit(editor);
                        fn.apply(scope || this, Array.prototype.concat.call(args, arguments));
                    }
                    catch (e) {
                        vtplPanelPage.disable();
                        alert(LANG.SOME_ERROR + ' \n' + (e.message || ''));
                        throw e;
                    }
                }
            }
        }
    };

    /**
     * tab
     */
    VTPL_PANEL_PAGE_CLASS.$getOtherEditing = function(who) {
        var others = [];
        this._mPanelPageManager.forEachPage(
            function (pageId, page) {
                if (who != page && page.$__editing) {
                    others.push(page.getPageTitle());
                }
            }
        );
        return others;
    };
    
    /**
     * handler
     * vtplModel
     * vtpl-quick-editor.js$startCondPhase
     * TODO vtpl-model.js
     */
    VTPL_PANEL_PAGE_CLASS.$getSecondConditionConfig = function () {
        var me = this;
        var vtplFork = this._vtpl;
        
        this._mVTplModel.sync({
            //  datasourceIdargs $startCondPhase
            datasourceId: 'EXIST_COND',
            args: {
                reportTemplateIdList: vtplFork.rtplIdGet(true),
                virtualTemplateId: vtplFork.vtplKey
            },
            //  resultvtplModel
            result: function (data, ejsonObj, options) {
                me._mVTplModel._oSecondConditionConfig = data.templateDims || {};
            },
            //  handler
            error: function (status, ejsonObj, options) {
                alert('');
            }
        });
    };

})();
/**
 * di.console.editor.ui.VTplQuickEditorCond
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    vtpl
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var remove = xutil.dom.remove;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var jsonParse = baidu.json.parse;
    var getUID = xutil.uid.getUID;
    var encodeHTML = xutil.string.encodeHTML;
    var children = xutil.dom.children;
    var foreachDoOri = UTIL.foreachDoOri;
    var template = xutil.string.template;
    var getParent = xutil.dom.getParent;
    var getPosition = ecui.dom.getPosition;
    var addConsoleCSS = UTIL.addConsoleCSS;
    var clearConsoleCSS = UTIL.clearConsoleCSS;
    var preInit = UTIL.preInit;
    var forEachCSSFlag = UTIL.forEachCSSFlag;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var getView = ecui.util.getView;
    var baiduOn = baidu.on;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var XVIEW = xui.XView;
    var DI_FACTORY;
    var COND_CONFIG_PANEL;
        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COND_CONFIG_PANEL = di.console.editor.ui.CondConfigPanel;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * vtpl
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var VTPL_QUICK_EDITOR_COND = $namespace().VTplQuickEditorCond = 
        inheritsObject(
            XVIEW,
            function(options) {
                var el = options.el;
                addClass(el, 'vtpl-quick-editor-cond');
                el.innerHTML = HTML_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var VTPL_QUICK_EDITOR_COND_CLASS = VTPL_QUICK_EDITOR_COND.prototype;
    
    var HTML_MAIN = [
        '<div class="vtpl-quick-editor-cond-btns">',
            '<span class="vtpl-quick-editor-cond-add-line"></span>',
        '</div>',
        '<div class="vtpl-quick-editor-cond-layout">',
        '</div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._def = options.def;
        this.bindEditFn = options.bindEditFn;
        this._vtplPanelPage = options.vtplPanelPage;
        this._mVTplModel = options.vtplModel;
        this._mPanelPageManager = options.panelPageManager;
        // FIXME
        // fork
        this._vtplFork = options.vtplFork;
    }
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        this._uAddLineBtn = ecuiCreate(
            UI_BUTTON,
            q('vtpl-quick-editor-cond-add-line', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._eLayout = q('vtpl-quick-editor-cond-layout', el)[0];

        this.$createFloater();

        this._uCondConfigPanel = new COND_CONFIG_PANEL(
            {
                model: this._mVTplModel,
                parent: this
            }
        );
    }
    
    /**
     * 
     *
     * @public
     */
    VTPL_QUICK_EDITOR_COND_CLASS.init = function () {
        this._uAddLineBtn.onclick = this.bindEditFn(this.$addLine, this);

        // floater
        this._uAddTextBtn.onclick = this.bindEditFn(function () {
            this.$addTextItem(this._lineFloater.trigger);
            this.$showFloater(false);
        }, this);
        this._uAddVUIBtn.onclick = this.bindEditFn(function () {
            this.$addVUIItem(this._lineFloater.trigger);
            this.$showFloater(false);
        }, this);
        this._uRemoveLineBtn.onclick = this.bindEditFn(function () {
            this.$removeLine(this._lineFloater.trigger);
            this.$showFloater(false);
        }, this);

        // 
        this._eLayout.onclick = this.bindEditFn(new Function());

        this._uCondConfigPanel.init();

        this.$resetLayout();
    };

    /**
     * @override
     */
    VTPL_QUICK_EDITOR_COND_CLASS.dispose = function () {
        this._eLayout = null;
        foreachDoOri(
            [
                this._uAddLineBtn,
                this._uAddVUIBtn,
                this._uAddTextBtn,
                this._uRemoveLineBtn,
                this._uCondConfigPanel
            ],
            'dispose'
        );
        if (this._lineFloater) {
            document.body.removeChild(this._lineFloater);
            this._lineFloater = null;
        }
        // FIXME 
        // baidu.un
        VTPL_QUICK_EDITOR_COND.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    VTPL_QUICK_EDITOR_COND_CLASS.$active = function () {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    VTPL_QUICK_EDITOR_COND_CLASS.$inactive = function () {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_QUICK_EDITOR_COND_CLASS.enable = function (key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            foreachDoOri(
                [
                    this._uAddLineBtn,
                    this._uAddVUIBtn,
                    this._uAddTextBtn,
                    this._uRemoveLineBtn
                ],
                'enable'
            );
            VTPL_QUICK_EDITOR_COND.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_QUICK_EDITOR_COND_CLASS.disable = function (key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            foreachDoOri(
                [
                    this._uAddLineBtn,
                    this._uAddVUIBtn,
                    this._uAddTextBtn,
                    this._uRemoveLineBtn
                ],
                'disable'
            )
        }
        VTPL_QUICK_EDITOR_COND.superClass.disable.call(this);
    };

    /**
     * 
     *
     * @public
     */
    VTPL_QUICK_EDITOR_COND_CLASS.doSave = function () {
        // 
        var html = clearConsoleCSS(this._eLayout.innerHTML);
        // doSavedomvtplFork
        // depict
        this._vtplFork.innerHTML(this._def.id, html);
    };

    /**
     * 
     *
     * @protected
     */
    VTPL_QUICK_EDITOR_COND_CLASS.$resetLayout = function () {
        var me = this;
        var vtpl = this._vtplFork;
        var def = this._def;
        var eLayout = this._eLayout;
        var i;
        var o;
        
        var html = vtpl.innerHTML(def.id);

        // 
        if (html == null) {
            this.disable();
            eLayout.innerHTML = ''
            return;
        }

        eLayout.innerHTML = html;

        // console css
        addConsoleCSS(eLayout);

        forEachCSSFlag(
            this._eLayout, 
            'di-o_o-line',
            function (el, css) {
                me.$bindShowFloater(el, true);
            }
        );

        // 
        var els = q('di-o_o-item', this._eLayout);
        for (var i = 0, eItem; eItem = els[i]; i ++) {
            if (eItem.getAttribute(DICT.DI_ATTR)) {
                this.$initVUIItem(eItem);
            }
        }
    };

    VTPL_QUICK_EDITOR_COND_CLASS.$addTextItem = function (eLine) {
        var eItem = document.createElement('div');
        eItem.innerHTML = '';
        addClass(eItem, 'di-o_o-item c-di-o_o-item');
        eItem.setAttribute('contentEditable', true);
        eLine.appendChild(eItem);
    };

    VTPL_QUICK_EDITOR_COND_CLASS.$addVUIItem = function (eLine) {
        var me = this;
        // entity id
        var id = this._def.id + '-vu-' + this._vtplFork.genId();
        this.$openCondConfig(id, null, true, addItem);

        function addItem(data, ejsonObj, options) {
            var eItem = document.createElement('div');
            addClass(eItem, 'di-o_o-item c-di-o_o-item c-di-o_o-cond-vui');
            eItem.setAttribute(DICT.DI_ATTR, id);
            if (options.args.hide) {
                addClass(eItem, 'di-o_o-hide c-di-o_o-hide');
            }
            eLine.appendChild(eItem);
            me.$initVUIItem(eItem);
        }
    };

    VTPL_QUICK_EDITOR_COND_CLASS.$initVUIItem = function (eItem) {
        var me = this;
        // 
        eItem.onclick = function () {
            var id = this.getAttribute(DICT.DI_ATTR);
            me.$openCondConfig(id, this, false, bind(me.$refreshVUIItem, me, this));
        }
        // 
        this.$refreshVUIItem(eItem);
    };

    VTPL_QUICK_EDITOR_COND_CLASS.$refreshVUIItem = function (vuiItem) {
        // TODO
    };

    VTPL_QUICK_EDITOR_COND_CLASS.$openCondConfig = function (entityId, condEl, isCreate, onclose) {
        this._uCondConfigPanel.attachOnce('submit.close', onclose, this);
        this._uCondConfigPanel.open(
            'EDIT',
            {
                cpntId: this._def.id,
                entityId: entityId,
                reportType: this._def.reportType,
                vtplFork: this._vtplFork,
                reportTemplateId: this._def.reportTemplateId,
                isCreate: isCreate,
                condEl: condEl
            }
        );
    };

    /**
     * 
     *
     * @protected
     */
    VTPL_QUICK_EDITOR_COND_CLASS.$addLine = function () {
        var line = document.createElement('div');
        addClass(line, 'di-o_o-line c-di-o_o-line');
        this._eLayout.appendChild(line);
        this.$bindShowFloater(line, true);
    };

    /**
     * 
     *
     * @protected
     */
    VTPL_QUICK_EDITOR_COND_CLASS.$removeLine = function (eLine) {
        if (!eLine) {
            return;
        }

        var vtpl = this._vtplFork;
        var els = eLine.getElementsByTagName('*');
        for (var i = 0, eItem, id; eItem = els[i]; i ++) {
            if (id = eItem.getAttribute(DICT.DI_ATTR)) {
                // vuiRef
                // 
                vtpl.removeVUIRefAll(id);
                // depict
                vtpl.removeEntityDef(id);
                // rtplConf
                // rtplConfrtplConf
            }
        }

        this._eLayout.removeChild(eLine);
    };

    //--------------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------------

    /**
     * 
     *
     * @protected
     */
    VTPL_QUICK_EDITOR_COND_CLASS.$createFloater = function () {
        var me = this;

        if (!this._lineFloater) {
            var lineFloater = this._lineFloater = document.createElement('div');
            addClass(lineFloater, 'console-floater');
            document.body.appendChild(lineFloater);

            lineFloater.innerHTML = [
                '<div></div>',
                '<div></div>',
                '<div></div>'
            ].join('');

            var ch = children(lineFloater);
            var btnOpt = { primary: 'ui-button-g' };

            this._uAddTextBtn = ecuiCreate(UI_BUTTON, ch[0], null, btnOpt);
            this._uAddVUIBtn = ecuiCreate(UI_BUTTON, ch[1], null, btnOpt);
            this._uRemoveLineBtn = ecuiCreate(UI_BUTTON, ch[2], null, btnOpt);

            lineFloater.style.display = 'none';
            this.$bindShowFloater(lineFloater);
        }
    };

    /**
     * 
     *
     * @protected
     */
    VTPL_QUICK_EDITOR_COND_CLASS.$bindShowFloater = function (el, isTrigger) {
        var me = this;
        var lineFloater = this._lineFloater;

        baiduOn(
            el,
            'mouseenter', 
            function (e) {
                if (!lineFloater) { return; }
                
                lineFloater.needShow = true;
                var trigger = lineFloater.trigger;
                if (isTrigger) {
                    trigger && removeClass(trigger, 'c-di-o_o-line-hover');
                    trigger = lineFloater.trigger = el;
                    addClass(el, 'c-di-o_o-line-hover');
                }
                // floater
                me.$showFloater(true);
                // floater
                var pos = getPosition(trigger);
                var st = lineFloater.style;
                st.left = (pos.left + trigger.offsetWidth - lineFloater.offsetWidth) + 'px';
                st.top = (pos.top + 2 - lineFloater.offsetHeight) + 'px';
            }
        );
        baiduOn(
            el, 
            'mouseleave', 
            function (e) {
                if (!lineFloater) { return; }

                lineFloater.needShow = false;
                setTimeout(function () {
                    if (lineFloater && !lineFloater.needShow) {
                        removeClass(lineFloater.trigger, 'c-di-o_o-line-hover');
                        me.$showFloater(false);
                    }
                }, 800);
            }
        );
    };    

    /**
     * 
     *
     * @protected
     */
    VTPL_QUICK_EDITOR_COND_CLASS.$showFloater = function (toShow) {
        var lineFloater = this._lineFloater;
        if (!lineFloater) { return; }
        
        var st = lineFloater.style;
        if (toShow && st.display == 'none') {
            st.display = '';
            st.position = 'absolute';
        }
        else if (!toShow && st.display == '') {
            st.display = 'none';
        }
    };

})();
/**
 * di.console.editor.ui.VTplQuickEditor
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    vtpl
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var objKey = xutil.object.objKey;
    var alert = di.helper.Dialog.alert;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var jsonParse = baidu.json.parse;
    var encodeHTML = xutil.string.encodeHTML;
    var trim = xutil.string.trim;
    var getParent = xutil.dom.getParent;
    var children = xutil.dom.children;
    var extend = xutil.object.extend;
    var foreachDoOri = UTIL.foreachDoOri;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var UI_INPUT = ecui.ui.Input;
    var SELECT = UTIL.select;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var DI_FACTORY;
    var VTPL_QUICK_EDITOR_COND;
        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        VTPL_QUICK_EDITOR_COND = di.console.editor.ui.VTplQuickEditorCond;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * vtpl
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var VTPL_QUICK_EDITOR = $namespace().VTplQuickEditor = 
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                addClass(el, 'vtpl-quick-editor');
                el.innerHTML = HTML_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var VTPL_QUICK_EDITOR_CLASS = VTPL_QUICK_EDITOR.prototype;
    
    var HTML_MAIN = [
        '<div class="vtpl-panel-page-btns">',
            '<span></span>',
            '<input class="vtpl-name-input q-vtpl-name"/>',
            '<span class="q-btn-save"></span>',
        '</div>',
        '<div class="vtpl-quick-btn-phase">',
            '<span class="vtpl-quick-btn-phase-item">',
                '<input type="radio" name="di-editor-phase" checked="checked" />',
                '<span></span>',
            '</span>',
            '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;',
            '<span class="vtpl-quick-btn-phase-item">',
                '<input type="radio" name="di-editor-phase" />',
                '<span></span>',
            '</span>',
            '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;',
            '<span class="vtpl-quick-btn-phase-item">',
                '<input type="radio" name="di-editor-phase" />',
                '<span></span>',
            '</span>',
        '</div>',
        // TODO 
        '<div class="vtpl-quick-snippet"></div>',
        '<div class="vtpl-quick-ep">',
            // 
            '<div class="vtpl-quick-ep-ds">',
                '<div class="vtpl-quick-ep-ds-line1"></div>',
                '<div class="vtpl-quick-ep-ds-line2">',
                    '<span></span>',
                    '<span class="q-btn-olap-table"></span>',
                    '<span class="q-btn-plane-table"></span>',
                    '<span class="q-btn-olap-chart"></span>',
                '</div>',
                '<div><span class="vtpl-quick-ep-ds-refresh"></span></div>',
                '<div class="vtpl-quick-ep-ds-list"></div>',
            '</div>',
            // 
            '<div class="vtpl-quick-ep-cond">',
                '<div class="vtpl-quick-ep-cond-area"></div>',
            '</div>',
            // 
            '<div class="vtpl-quick-ep-auth">',
                '<div class="vtpl-quick-ep-auth-area"></div>',
            '</div>',
        '</div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._vtplPanelPage = options.vtplPanelPage;
        this._mVTplModel = options.vtplModel;
        this._mPanelPageManager = options.panelPageManager;
        extend(this, this._vtplPanelPage.vtplMgrGet(this));
    }
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        this._eSnippet = q('vtpl-quick-snippet', el)[0];
        this._eDS = q('vtpl-quick-ep-ds-list', this.getEl())[0];

        this._uSaveBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-save', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uNameInput = ecuiCreate(
            UI_INPUT,
            q('q-vtpl-name', el)[0]
        );

        resetEditPhaseRadio.call(this);

        this._eps = {
            EP_DS: { el: q('vtpl-quick-ep-ds', el)[0] },
            EP_COND: { el: q('vtpl-quick-ep-cond', el)[0] },
            EP_AUTH: { el: q('vtpl-quick-ep-auth', el)[0] }
        };

        this._eCond = q('vtpl-quick-ep-cond-area', this.getEl())[0];

        // TODO
        // radio 
        function resetEditPhaseRadio() {
            var ee = q('vtpl-quick-btn-phase', el)[0];
            var editPhases = ['EP_DS', 'EP_COND', 'EP_AUTH'];
            var ch = children(ee);
            var me = this;
            for (var i = 0, o; o = ch[i]; i ++) {
                o.onclick = (function (ph) {
                    return function () {
                        if (me.$changeEditPhase(ph)) {
                            this.getElementsByTagName('input')[0].checked = true;
                        }
                        else {
                            return false;
                        }
                    };
                })(editPhases[i]);
            }
        }

        // DS
        // FIXME
        // 
        this._uRefreshBtn = ecuiCreate(
            UI_BUTTON,
            q('vtpl-quick-ep-ds-refresh', el)[0],
            null,
            { primary: 'ui-button-g' }
        );
        this._uOlapTableBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-olap-table', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uOlapChartBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-olap-chart', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uPlaneTableBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-plane-table', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
    }
    
    /**
     * vtplPanelPage
     *
     * @public
     */
    VTPL_QUICK_EDITOR_CLASS.doRefreshFork = function (vtplFork) {
        var vtpl = this._vtplFork = vtplFork;

        this._uNameInput.setValue(vtpl.vtplName || '');

        if (vtpl.snippet.invalid) {
            alert('snippet');
            this.disable();
            // FIXME
            // enable
            return;
        }

        this.$refreshPanelDS();
        this.$refreshPanelCond();
        this.$refreshPanelAuth();

        // layout
        !this._currEPKey && this.$changeEditPhase('EP_DS');
    }

    /**
     * 
     *
     * @public
     */
    VTPL_QUICK_EDITOR_CLASS.init = function() {
        var vtplPanelPage = this._vtplPanelPage;

        this._uSaveBtn.onclick = bind(vtplPanelPage.doSave, vtplPanelPage, this);
        this._uNameInput.onchange = this.bindEditFn(new Function(), this);

        this._uRefreshBtn.onclick = bind(this.$refreshPanelDS, this)
        this._uOlapTableBtn.onclick = function () {
            vtplPanelPage.openCubeConfigPanel('RTPL_OLAP_TABLE');
        };
        this._uOlapChartBtn.onclick = function () {
            vtplPanelPage.openCubeConfigPanel('RTPL_OLAP_CHART');
        };
        this._uPlaneTableBtn.onclick = function () {
            vtplPanelPage.openCubeConfigPanel('RTPL_PLANE_TABLE');
        };

        // 
        this._eDS.onclick = function (e) {
            var rid;
            var target = event.target || event.srcElement;
            if (target.tagName == 'INPUT') {
                // inputreportTemplate
                var eSel = getParent(target).getElementsByTagName('SELECT')[0];
                var opt = SELECT.getSelected(eSel);
                var reportType = opt.reportTemplateType;

                if (opt.reportTemplateId == LANG.NO_SEL) {
                    // 
                    return;
                }

                // FIXME
                if (reportType == 'RTPL_VIRTUAL') {
                    alert('');
                    return false;
                }
                vtplPanelPage.openTab({
                    editorType: reportType,
                    reportTemplateId: opt.reportTemplateId
                });
            }
        };

        // this._uSaveBtn.disable('SELF_START_EDIT');
    };

    /**
     * @override
     */
    VTPL_QUICK_EDITOR_CLASS.dispose = function() {
        this._eSnippet = null;
        this._eDS = null;
        this._eCond = null;
        this._eps = null;
        foreachDoOri(
            [
                this._uSaveBtn,
                this._uRefreshBtn,
                this._uOlapTableBtn,
                this._uOlapChartBtn,
                this._uPlaneTableBtn,
                this._uNameInput
            ],
            'dispose',
            true
        );
        VTPL_QUICK_EDITOR.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    VTPL_QUICK_EDITOR_CLASS.$active = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    VTPL_QUICK_EDITOR_CLASS.$inactive = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_QUICK_EDITOR_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            foreachDoOri(
                [
                    this._uSaveBtn,
                    this._uRefreshBtn,
                    this._uPlaneTableBtn,
                    this._uOlapChartBtn,
                    this._uOlapTableBtn
                ],
                'enable',
                key
            );
            this.$enablePanelCond();
            VTPL_QUICK_EDITOR.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_QUICK_EDITOR_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            foreachDoOri(
                [
                    this._uSaveBtn,
                    this._uRefreshBtn,
                    this._uPlaneTableBtn,
                    this._uOlapChartBtn,
                    this._uOlapTableBtn
                ],
                'disable',
                key
            );
            this.$disablePanelCond();
        }
        VTPL_QUICK_EDITOR.superClass.disable.call(this);
    };

    /**
     * 
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$refreshPanelDS = function() {
        this._mVTplModel.sync(
            {
                datasourceId: 'DS_LIST',
                preprocess: bind(this.disable, this, 'QUICK_EDIROT'),
                complete: bind(this.enable, this, 'QUICK_EDIROT'),
                result: bind(this.$renderDSList, this)
            }
        );
    };

    /**
     * 
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$renderDSList = function() {
        dsList = this._mVTplModel.getReportTemplateList().slice();

        // dispose

        var html = [];

        // snippet
        var cmpts = this._vtplFork.findEntityByClzType('COMPONENT');
        for (var i = 0, cmpt, j, dso; cmpt = cmpts[i]; i ++) {
            // 
            if(cmpt['needDsSelect'] && cmpt['needDsSelect'] == 'true'){
                // 
            }else{
                html = layoutDsDiv(html,cmpt);    
            }
        }
        this._eDS.innerHTML = html.join('');

        // change
        // vtplPanelPage
        var sels = this._eDS.getElementsByTagName('SELECT');
        for (var k = 0, se; se = sels[k]; k ++) {
            se.onchange = this.bindEditFn(function (editor) {
                // reportTemplateIdvtplFork
                var rid = this.getAttribute('data-cmpt-id');
                var entityDef = editor._vtplFork.findEntityById(rid);
                var opt = SELECT.getSelected(this);

                if (opt.reportTemplateId != LANG.NO_SEL) {
                    entityDef.reportTemplateId = opt.reportTemplateId;
                    entityDef.reportType = opt.reportTemplateType;
                }
                else {
                    entityDef.reportTemplateId = void 0;
                    entityDef.reportType = void 0;
                }
            }, null, this);
        }
    };

    // div
    function layoutDsDiv (html,cmpt){
            html.push(
                '<div>',
                '<span>', encodeHTML(cmpt.id), '</span>&nbsp;&nbsp;&nbsp;&nbsp;'//,
            );

            // componentreportTemplateId
            SELECT.create(html, {
                attr: { 'data-cmpt-id': encodeHTML(cmpt.id) },
                datasource: dsList,
                textAttr: function (o) { 
                    var rid = o['reportTemplateId'];
                    var rname = o['reportTemplateName'];
                    var showName ='';
                    if (rid == 'RTPL_VIRTUAL_ID') {
                        showName = 'RTPL_VIRTUAL_ID';
                    } else if(rid == ''){
                        showName = '';
                    } else {
                        if (rname == null){
                            showName ='' + '(' + rid + ')' ;
                        }else {
                            showName = rname + '(' + rid + ')' ;
                        }
                    }
                    return showName;
                },
                valueAttr: 'reportTemplateId',
                extraAttr: 'reportTemplateType',
                first: { reportTemplateId: LANG.NO_SEL},
                selected: function (item) {  
                    return item.reportTemplateId == cmpt.reportTemplateId
                        // RTPL_VIRTUAL
                        // || (item.reportTemplateId == 'RTPL_VIRTUAL_ID' 
                        //     && cmpt.reportTemplateId == 
                        // ) 
                },
                filter: function (item) {
                    return DICT.hasReportTemplateType(
                        cmpt.clzKey,
                        item.reportTemplateType
                    )
                }
            });

            html.push(
                '<input type="button" value=""/>'
            );
            html.push('</div>');
            return html;
    }

    /**
     * 
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.doStartEdit = function() {
        // this._uSaveBtn.enable('SELF_START_EDIT');
    };

    /**
     * vtpl panel page
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.doSave = function() {
        var sels = document.getElementsByTagName('SELECT', this._eDS);
        var i;
        var item;
        var errorMsg;
        var vtpl = this._vtplFork;

        for (i in this._condMap) {
            this._condMap[i].doSave();
        }

        this.$saveAuth();

        // rtplCond
        vtpl.condClean();

        // 
        vtpl.vtplName = this._uNameInput.getValue();

        // stringifyvtplcontent
        errorMsg = vtpl.contentStringify();

        // (!errorMsg || !errorMsg.length)
        //     && this._uSaveBtn.disable('SELF_START_EDIT');

        return {
            vtplFork: vtpl,
            errorMsg: errorMsg
        }
    };

    /**
     * rtplvtpl panel page
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.doCreated = function() {
        // 
        // if (this.$ch
        this.$refreshPanelDS();
    };

    /**
     * ds
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$checkAllDSLinked = function() {
        var ok = true;
        this._vtplFork.forEachEntity(
            'COMPONENT',
            function (def) {
                if (!def.reportTemplateId) {
                    ok = false;
                }
            }
        );
        return ok;
    };

    /**
     * editphase
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$changeEditPhase = function(epKey) {
        var currEPKey = this._currEPKey;

        if (currEPKey == 'EP_DS') {
            // componentreporttemplateid
            if (!this.$checkAllDSLinked()) {
                DIALOG.alert(LANG.NEED_DS_ALL_LINKED);
                return false;
            }
        }

        if (currEPKey == 'EP_AUTH') {
            this.$saveAuth();
        }

        if (!currEPKey || currEPKey != epKey) {
            for (var key in this._eps) {
                this._eps[key].el.style.display = key == epKey ? '' : 'none';
            }
            this._currEPKey = epKey;

            epKey == 'EP_COND' && this.$startCondPhase();
            epKey == 'EP_AUTH' && this.$refreshPanelAuth();
        }

        return true;
    };

    /**
     * condphase
     * condvtpl.rtplCond
     * vtplreportTemplateId
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$startCondPhase = function() {
        /*
         *  
         * _mVTplModel_oSecondConditionConfig
         * 
         * _oSecondConditionConfighandler
         * 
         */
        delete this._mVTplModel._oSecondConditionConfig;
        
        var me = this;
        var vtplFork = this._vtplFork;
        // 
        this.$disablePanelCond();
        this._mVTplModel.sync({
            datasourceId: 'EXIST_COND',
            args: {
                reportTemplateIdList: vtplFork.rtplIdGet(true),
                virtualTemplateId: vtplFork.vtplKey
            },
            result: function (data, ejsonObj, options) {
                // 
                // merge
                var existCond = vtplFork.rtplCond;
                var rtplCond = vtplFork.rtplCond = data.templateDims || {};
                // 
                // 
                // 
                for (var rid in existCond) {
                    if (rtplCond[rid] && existCond[rid]) {
                        rtplCond[rid] = existCond[rid];
                    }
                }
                // 
                me.$enablePanelCond();
            },
            error: function (status, ejsonObj, options) {
                me.$disablePanelCond();
                alert('status=' + status);
            }
        });
    };

    /**
     * ep cond
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$enablePanelCond = function() {
        var condMap = this._condMap;
        for (var id in condMap) {
            condMap[id].enable('QUICK_EDITOR');
        }
    };

    /**
     * ep cond
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$disablePanelCond = function() {
        var condMap = this._condMap;
        for (var id in condMap) {
            condMap[id].disable('QUICK_EDITOR');
        }
    };

    /**
     * ep cond
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$disposePanelCond = function() {
        var condMap = this._condMap;
        for (var id in condMap) {
            condMap[id].dispose();
        }
        this._condMap = {};
        this._eCond.innerHTML = '';
    };

    /**
     * ep cond
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$refreshPanelCond = function() {
        // dispose
        this.$disposePanelCond();
        
        var eCond = this._eCond;
        var el;
        var condMap = this._condMap;
        if (!condMap) {
            condMap = this._condMap = {};
        }

        // 
        var opt = {
            vtplFork: this._vtplFork,
            bindEditFn: this.bindEditFn,
            vtplPanelPage: this._vtplPanelPage,
            vtplModel: this._mVTplModel,
            panelPageManager: this._mPanelPageManager
        };
        this._vtplFork.forEachEntity(
            'COMPONENT',
            function (def) {
                if (def.clzKey == 'DI_FORM') {
                    el = document.createElement('div');
                    eCond.appendChild(el);
                    condMap[def.id] = new VTPL_QUICK_EDITOR_COND(
                        extend({ el: el, def: def }, opt)
                    );
                }
            }
        );

        for (var id in this._condMap) {
            this._condMap[id].init();
        }
    };

    /**
     * ep auth
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$refreshPanelAuth = function() {
        var entityDefs = this._vtplFork.findEntityByClzType('VUI');
        var html = [];

        html.push('<div>');
        html.push('<span></span>');
        this._vtplFork.forEachEntity(
            'VUI',
            function (def) {
                html.push(
                    '<div>',
                        '<span>', encodeHTML(def.id), 'funcAuth</span>',
                        '<input type="input" data-def-id="', encodeHTML(def.id), '" value="', encodeHTML(def.funcAuth || ''), '" />',
                    '</div>'
                );
            }
        );
        html.push('</div>');

        this._eps['EP_AUTH'].el.innerHTML = html.join('');
    };

    /**
     * 
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$saveAuth = function() {
        var html = [];

        var els = this._eps['EP_AUTH'].el.getElementsByTagName('INPUT');
        for (var i = 0, e, id, def, val; e = els[i]; i ++) {
            if ((id = e.getAttribute('data-def-id'))
                && (def = this._vtplFork.findEntityById(id))
            ) {
                if (val = trim(e.value)) {
                    def.funcAuth = val;
                }
                else {
                    delete def.funcAuth;
                }
            }
        }
    };

    /**
     * 
     * 
     * @protected
     */
    VTPL_QUICK_EDITOR_CLASS.$handleFatalError = function(status) {
        this.disable();
        // // 
        // if (status == 1001) {
        //     DIALOG.alert(LANG.SAD_FACE + LANG.PARAM_ERROR);
        // }
        // else {
        //     DIALOG.alert(LANG.SAD_FACE + LANG.FATAL_DATA_ERROR);
        // }
    };

})();
/**
 * di.console.editor.ui.VTplSoQuickAuth
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    vtplSoQuickEditor
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var objKey = xutil.object.objKey;
    var alert = di.helper.Dialog.alert;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var jsonParse = baidu.json.parse;
    var encodeHTML = xutil.string.encodeHTML;
    var trim = xutil.string.trim;
    var getParent = xutil.dom.getParent;
    var children = xutil.dom.children;
    var extend = xutil.object.extend;
    var foreachDoOri = UTIL.foreachDoOri;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var UI_INPUT = ecui.ui.Input;
    var SELECT = UTIL.select;
    var XVIEW = xui.XView;
    var DI_FACTORY;
        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * vtplSoQuickEditor
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var VTPL_SO_QUICK_EDITOR_AUTH = $namespace().VTplSoQuickEditorAuth = 
        inheritsObject(XVIEW, constructor);
    var VTPL_SO_QUICK_EDITOR_AUTH_CLASS = VTPL_SO_QUICK_EDITOR_AUTH.prototype;
    
    var HTML_MAIN = [
        // 
        '<div class="vtpl-quick-ep-auth-area"></div>',
        // ...
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @construtor
     * @private
     */
    function constructor(options) {
        var editor = this._editor = options.editor;
        var vtplPanelPage = editor._vtplPanelPage;

        var el = this._el = options.el;
        el.innerHTML = HTML_MAIN;
        this._eAuthList = q('vtpl-quick-ep-auth-area', editor.getEl())[0]
    }
    
    /**
     * @override
     */
    VTPL_SO_QUICK_EDITOR_AUTH_CLASS.dispose = function() {
        // foreachDoOri(
        //     [
        //         this._uSaveBtn,
        //         this._uRefreshBtn,
        //         this._uOlapTableBtn,
        //         this._uOlapChartBtn,
        //         this._uPlaneTableBtn,
        //         this._uNameInput,
        //         this._ds,
        //         this._layout
        //     ],
        //     'dispose',
        //     true
        // );
        this._eAuthList.innerHTML = '';
        this._eAuthList = null;
        VTPL_SO_QUICK_EDITOR_AUTH.superClass.dispose.call(this);
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_SO_QUICK_EDITOR_AUTH_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            // foreachDoOri(
                // [
                    // this._uSaveBtn,
                    // this._uRefreshBtn,
                    // this._uPlaneTableBtn,
                    // this._uOlapChartBtn,
                    // this._uOlapTableBtn
                // ],
                // 'enable',
                // key
            // );
            VTPL_SO_QUICK_EDITOR_AUTH.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_SO_QUICK_EDITOR_AUTH_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            // foreachDoOri(
            //     [
            //         // this._uSaveBtn,
            //         // this._uRefreshBtn,
            //         // this._uPlaneTableBtn,
            //         // this._uOlapChartBtn,
            //         // this._uOlapTableBtn
            //     ],
            //     'disable',
            //     key
            // );
        }
        VTPL_SO_QUICK_EDITOR_AUTH.superClass.disable.call(this);
    };

    /**
     * @public
     */
    VTPL_SO_QUICK_EDITOR_AUTH_CLASS.active = function () {
        return this._el.style.display = '';
        // ...
    };    

    /**
     * @public
     */
    VTPL_SO_QUICK_EDITOR_AUTH_CLASS.inactive = function () {
        return this._el.style.display = 'none';
        // ...
    };    

    /**
     * ep auth
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_AUTH_CLASS.refreshPanelAuth = function() {
        var vtplFork = this._editor._vtplFork;
        var entityDefs = vtplFork.findEntityByClzType('VUI');
        var html = [];

        html.push('<div>');
        html.push('<span></span>');
        vtplFork.forEachEntity(
            'VUI',
            function (def) {
                html.push(
                    '<div>',
                        '<span>', encodeHTML(def.id), 
                            'funcAuth</span>',
                        '<input type="input" data-def-id="', encodeHTML(def.id), 
                            '" value="', encodeHTML(def.funcAuth || ''), '" />',
                    '</div>'
                );
            }
        );
        html.push('</div>');

        // html
        this._eAuthList.innerHTML = html.join('');
    };

    /**
     * 
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_AUTH_CLASS.saveAuth = function() {
        var html = [];

        var els = this._eAuthList.getElementsByTagName('INPUT');
        for (var i = 0, e, id, def, val; e = els[i]; i ++) {
            if ((id = e.getAttribute('data-def-id'))
                && (def = this._editor._vtplFork.findEntityById(id))
            ) {
                if (val = trim(e.value)) {
                    def.funcAuth = val;
                }
                else {
                    delete def.funcAuth;
                }
            }
        }
    };

})();
/**
 * di.console.editor.ui.VTplSoQuickEditorDS
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    vtplSoQuickEditor
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var objKey = xutil.object.objKey;
    var alert = di.helper.Dialog.alert;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var jsonParse = baidu.json.parse;
    var encodeHTML = xutil.string.encodeHTML;
    var trim = xutil.string.trim;
    var getParent = xutil.dom.getParent;
    var children = xutil.dom.children;
    var extend = xutil.object.extend;
    var foreachDoOri = UTIL.foreachDoOri;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var baiduOn = baidu.on;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var UI_INPUT = ecui.ui.Input;
    var SELECT = UTIL.select;
    var XVIEW = xui.XView;
    var DI_FACTORY;
        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * vtpl
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var VTPL_SO_QUICK_EDITOR_DS = $namespace().VTplSoQuickEditorDS = 
        inheritsObject(XVIEW, constructor);
    var VTPL_SO_QUICK_EDITOR_DS_CLASS = VTPL_SO_QUICK_EDITOR_DS.prototype;
    
    var HTML_MAIN = [
        // 
        '<div class="vtpl-quick-ep-ds-line1"></div>',
        '<div class="vtpl-quick-ep-ds-line2">',
            '<span></span>',
            '<span class="q-btn-olap-table"></span>',
            '<span class="q-btn-plane-table"></span>',
            '<span class="q-btn-olap-chart"></span>',
        '</div>',
        '<div><span class="vtpl-quick-ep-ds-refresh"></span></div>',
        '<div class="vtpl-quick-ep-ds-list"></div>',
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @constructor
     * @private
     */
    function constructor(options) {
        var editor = this._editor = options.editor;
        var vtplPanelPage = editor._vtplPanelPage;

        var el = this._el = options.el;
        el.innerHTML = HTML_MAIN;
        this._eDS = q('vtpl-quick-ep-ds-list', el)[0];

        // DS
        // FIXME
        // 
        this._uRefreshBtn = ecuiCreate(
            UI_BUTTON,
            q('vtpl-quick-ep-ds-refresh', el)[0],
            null,
            { primary: 'ui-button-g' }
        );
        this._uOlapTableBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-olap-table', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uOlapChartBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-olap-chart', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        this._uPlaneTableBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-plane-table', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );

        this._uRefreshBtn.onclick = bind(this.refreshPanelDS, this)
        this._uOlapTableBtn.onclick = function () {
            vtplPanelPage.openCubeConfigPanel('RTPL_OLAP_TABLE');
        };
        this._uOlapChartBtn.onclick = function () {
            vtplPanelPage.openCubeConfigPanel('RTPL_OLAP_CHART');
        };
        this._uPlaneTableBtn.onclick = function () {
            vtplPanelPage.openCubeConfigPanel('RTPL_PLANE_TABLE');
        };


        // 
        // FIXME
        // 
        this._eDS.onclick = function (e) {
            var rid;
            var target = event.target || event.srcElement;
            if (target.tagName == 'INPUT') {
                // inputreportTemplate
                var eSel = getParent(target).getElementsByTagName('SELECT')[0];
                var opt = SELECT.getSelected(eSel);
                var reportType = opt.reportTemplateType;

                if (opt.reportTemplateId == LANG.NO_SEL) {
                    // 
                    return;
                }

                // FIXME
                if (reportType == 'RTPL_VIRTUAL') {
                    alert('');
                    return false;
                }
                vtplPanelPage.openTab({
                    editorType: reportType,
                    reportTemplateId: opt.reportTemplateId
                });
            }
        };
    }

    /**
     * @override
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.dispose = function() {
        this._eDS = null;
        foreachDoOri(
            [
                this._uRefreshBtn,
                this._uOlapTableBtn,
                this._uOlapChartBtn,
                this._uPlaneTableBtn
            ],
            'dispose',
            true
        );
        VTPL_SO_QUICK_EDITOR_DS.superClass.dispose.call(this);
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            foreachDoOri(
                [
                    this._uRefreshBtn,
                    this._uPlaneTableBtn,
                    this._uOlapChartBtn,
                    this._uOlapTableBtn
                ],
                'enable',
                key
            );
            VTPL_SO_QUICK_EDITOR_DS.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            foreachDoOri(
                [
                    this._uRefreshBtn,
                    this._uPlaneTableBtn,
                    this._uOlapChartBtn,
                    this._uOlapTableBtn
                ],
                'disable',
                key
            );
        }
        VTPL_SO_QUICK_EDITOR_DS.superClass.disable.call(this);
    };

    /**
     * @public
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.active = function () {
        return this._el.style.display = '';
        // ...
    };    

    /**
     * @public
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.inactive = function () {
        return this._el.style.display = 'none';
        // ...
    };    

    /**
     * 
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.refreshPanelDS = function() {
        this._editor._mVTplModel.sync(
            {
                datasourceId: 'DS_LIST',
                // FIXME
                // disable editor
                preprocess: bind(this.disable, this, 'QUICK_EDIROT_DS'),
                complete: bind(this.enable, this, 'QUICK_EDIROT_DS'),
                result: bind(this.$renderDSList, this)
            }
        );
    };

    /**
     * 
     * 
     * @protected
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.$renderDSList = function() {
        var editor = this._editor;
        dsList = editor._mVTplModel.getReportTemplateList().slice();

        // dispose

        var html = [];

        // snippet
        var cmpts = editor._vtplFork.findEntityByClzType('COMPONENT');
        for (var i = 0, cpnt, j, dso; cpnt = cmpts[i]; i ++) {
            html.push(
                '<div class="vtpl-quick-ep-ds-item" data-cpnt-id="', cpnt.id, '">',
                '<span>', encodeHTML(cpnt.id), '</span>&nbsp;&nbsp;&nbsp;&nbsp;'//,
            );

            // componentreportTemplateId
            SELECT.create(html, {
                attr: { 'data-cpnt-id': encodeHTML(cpnt.id) },
                datasource: dsList,
                textAttr: 'reportTemplateId',
                valueAttr: 'reportTemplateId',
                extraAttr: 'reportTemplateType',
                first: { reportTemplateId: LANG.NO_SEL},
                selected: function (item) {  
                    return item.reportTemplateId == cpnt.reportTemplateId
                        // RTPL_VIRTUAL
                        // || (item.reportTemplateId == 'RTPL_VIRTUAL_ID' 
                        //     && cpnt.reportTemplateId == 
                        // ) 
                },
                filter: function (item) {
                    return DICT.hasReportTemplateType(
                        cpnt.clzKey,
                        item.reportTemplateType
                    )
                }
            });

            html.push(
                '<input type="button" value=""/>'
            );
            html.push('</div>');
        }
        this._eDS.innerHTML = html.join('');

        // hover
        this.$bindHover();

        // change
        // vtplPanelPage
        var sels = this._eDS.getElementsByTagName('SELECT');
        for (var k = 0, se; se = sels[k]; k ++) {
            se.onchange = editor.bindEditFn(function (editor) {
                // reportTemplateIdvtplFork
                var rid = this.getAttribute('data-cpnt-id');
                var entityDef = editor._vtplFork.findEntityById(rid);
                var opt = SELECT.getSelected(this);

                if (opt.reportTemplateId != LANG.NO_SEL) {
                    entityDef.reportTemplateId = opt.reportTemplateId;
                    entityDef.reportType = opt.reportTemplateType;
                }
                else {
                    entityDef.reportTemplateId = void 0;
                    entityDef.reportType = void 0;
                }
            }, null, editor);
        }
    };

    /**
     * ds
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.checkAllDSLinked = function() {
        var ok = true;
        this._editor._vtplFork.forEachEntity(
            'COMPONENT',
            function (def) {
                if (!def.reportTemplateId) {
                    ok = false;
                }
            }
        );
        return ok;
    };

    /**
     * 
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.$bindHover = function() {
        var layout = this._editor._layout;
        var items = q('vtpl-quick-ep-ds-item', this._el);
        for (var i = 0, item; item = items[i]; i ++) {
            baiduOn(
                item,
                'mouseenter',
                function (e) {
                    addClass(e.target, 'vtpl-quick-ep-ds-item-hover');
                    layout && layout.highlightCPNT(
                        this.getAttribute('data-cpnt-id'), 
                        true
                    );
                    // e.stopPropagation();
                }
            );
            baiduOn(
                item, 
                'mouseleave', 
                function (e) {
                    removeClass(e.target, 'vtpl-quick-ep-ds-item-hover');
                    layout && layout.highlightCPNT(
                        this.getAttribute('data-cpnt-id'), 
                        false
                    );
                    // e.stopPropagation();
                }
            );
        }
    };

    /**
     * 
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_DS_CLASS.highlight = function(cpntId, willHighlight) {
        // highlight
        var items = q('vtpl-quick-ep-ds-item', this._el);
        for (var i = 0, item; item = items[i]; i ++) {
            removeClass(item, 'vtpl-quick-ep-ds-item-hover');

            // highlight
            if (cpntId && willHighlight
                && item.getAttribute('data-cpnt-id') == cpntId
            ) {
                addClass(item, 'vtpl-quick-ep-ds-item-hover');
            }
        }
    };

})();
/**
 * di.console.editor.ui.VTplSoQuickEditorLayout
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var hasClass = xutil.dom.hasClass;
    var remove = xutil.dom.remove;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var jsonParse = baidu.json.parse;
    var getUID = xutil.uid.getUID;
    var encodeHTML = xutil.string.encodeHTML;
    var children = xutil.dom.children;
    var foreachDoOri = UTIL.foreachDoOri;
    var template = xutil.string.template;
    var getParent = xutil.dom.getParent;
    var getPosition = ecui.dom.getPosition;
    var addConsoleCSS = UTIL.addConsoleCSS;
    var clearConsoleCSS = UTIL.clearConsoleCSS;
    var domData = UTIL.domData;
    var preInit = UTIL.preInit;
    var forEachCSSFlag = UTIL.forEachCSSFlag;
    var forEachDom = UTIL.forEachDom;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var getView = ecui.util.getView;
    var baiduOn = baidu.on;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var XVIEW = xui.XView;
    var DI_FACTORY;
    var COND_CONFIG_PANEL;
        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        COND_CONFIG_PANEL = di.console.editor.ui.CondConfigPanel;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var VTPL_SO_QUICK_EDITOR_LAYOUT = $namespace().VTplSoQuickEditorLayout = 
        inheritsObject(XVIEW, constructor);
    var VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS = VTPL_SO_QUICK_EDITOR_LAYOUT.prototype;
    
    // var HTML_MAIN = [
        // '<div class="vtpl-quick-editor-cond-btns">',
        //     '<span class="vtpl-quick-editor-cond-add-line"></span>',
        // '</div>',
        // '<div class="vtpl-quick-editor-cond-layout">',
        // '</div>'
    // ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * 
     *
     * @constructor
     * @private
     */
    function constructor(options) {
        this._editor = options.editor;
        var el = this._el = options.el;

        // FIXME
        // this._uAddLineBtn = ecuiCreate(
        //     UI_BUTTON,
        //     q('vtpl-quick-editor-cond-add-line', el)[0],
        //     null, 
        //     { primary: 'ui-button-g' }
        // );
        // this._eLayout = q('vtpl-quick-editor-cond-layout', el)[0];

        // 
        this.$createFloater();

        // panel
        this._uCondConfigPanel = new COND_CONFIG_PANEL(
            {
                model: this._mVTplModel,
                parent: this
            }
        );

        this.$initFloater();

        // 
        el.onclick = this._editor.bindEditFn(new Function());

        this._uCondConfigPanel.init();
    }
    
    /**
     * @override
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.dispose = function () {
        foreachDoOri(
            [
                this._uAddLineBtn,
                this._uAddVUIBtn,
                this._uAddTextBtn,
                this._uRemoveLineBtn,
                this._uCondConfigPanel
            ],
            'dispose'
        );
        if (this._lineFloater) {
            document.body.removeChild(this._lineFloater);
            this._lineFloater = null;
        }
        // FIXME 
        // baidu.un
        VTPL_SO_QUICK_EDITOR_LAYOUT.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$active = function () {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$inactive = function () {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.enable = function (key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            foreachDoOri(
                [
                    this._uAddLineBtn,
                    this._uAddVUIBtn,
                    this._uAddTextBtn,
                    this._uRemoveLineBtn
                ],
                'enable'
            );
            VTPL_SO_QUICK_EDITOR_LAYOUT.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.disable = function (key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            foreachDoOri(
                [
                    this._uAddLineBtn,
                    this._uAddVUIBtn,
                    this._uAddTextBtn,
                    this._uRemoveLineBtn
                ],
                'disable'
            )
        }
        VTPL_SO_QUICK_EDITOR_LAYOUT.superClass.disable.call(this);
    };

    /**
     * @public
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.active = function () {
        // ...
    };    

    /**
     * @public
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.inactive = function () {
        // ...
    };    

    /**
     * 
     *
     * @public
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.doSave = function () {
        // 
        var html = clearConsoleCSS(this.el.innerHTML);
        // doSavedomvtplFork
        // depict
        this._editor._vtplFork.innerHTML(this._def.id, html);
    };

    /**
     * edit phaselayout
     *
     * @public
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.changeEditPhase = function (epKey) {
        if (!this._currEPKey || this._currEPKey != epKey) {

            this.$inactiveFloater(null, true);
            this.$highlightCPNT(null, false);

            this._currEPKey = epKey;

            if (epKey == 'EP_DS') {
                // FIXME
                // visiblity: false
                // ...
            }
            else if (epKey == 'EP_AUTH') {
                // ...
            }
            else if (epKey == 'EP_DETAIL') {
                // ...
            }
        }
    };

    /**
     * 
     *
     * @public
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.resetLayout = function () {
        var me = this;
        var vtpl = this._editor._vtplFork;
        var eLayout = this._el;
        var html = vtpl.innerHTML();

        // FIXME
        //  ...

        // 
        if (html == null) {
            this.disable();
            eLayout.innerHTML = ''
            return;
        }

        eLayout.innerHTML = html;

        // console css
        addConsoleCSS(eLayout);

        forEachDom(
            eLayout, 
            function (el) {
                if (hasClass(el, 'di-o_o-line')
                    || el.getAttribute(DICT.DI_ATTR)
                ) {
                    me.$bindHover(el);
                }
            }
        );

        // 
        var els = q('di-o_o-item', eLayout);
        for (var i = 0, eItem; eItem = els[i]; i ++) {
            if (eItem.getAttribute(DICT.DI_ATTR)) {
                // FIXME
                // itemcomponentdefcondition
                this.$initVUIItem(eItem);
            }
        }
    };

    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$addTextItem = function (eLine) {
        var eItem = document.createElement('div');
        eItem.innerHTML = '';
        addClass(eItem, 'di-o_o-item c-di-o_o-item');
        eItem.setAttribute('contentEditable', true);
        eLine.appendChild(eItem);
    };

    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$addVUIItem = function (eLine) {
        var me = this;
        // entity id
        var id = this._def.id + '-vu-' + this._vtplFork.genId();
        this.$openCondConfig(id, null, true, addItem);

        function addItem(data, ejsonObj, options) {
            var eItem = document.createElement('div');
            addClass(eItem, 'di-o_o-item c-di-o_o-item c-di-o_o-cond-vui');
            eItem.setAttribute(DICT.DI_ATTR, id);
            if (options.args.hide) {
                addClass(eItem, 'di-o_o-hide c-di-o_o-hide');
            }
            eLine.appendChild(eItem);
            me.$initVUIItem(eItem);
        }
    };

    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$initVUIItem = function (eItem) {
        var me = this;
        // 
        eItem.onclick = function () {
            var id = this.getAttribute(DICT.DI_ATTR);
            me.$openCondConfig(
                id, 
                this, 
                false, 
                bind(me.$refreshVUIItem, me, this)
            );
        }
        // 
        this.$refreshVUIItem(eItem);
    };

    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$refreshVUIItem = function (vuiItem) {
        // TODO
    };

    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$openCondConfig = function (
        entityId, condEl, isCreate, onclose
    ) {
        this._uCondConfigPanel.attachOnce('submit.close', onclose, this);
        this._uCondConfigPanel.open(
            'EDIT',
            {
                // FIXME
                // componentdef
                cpntId: this._def.id,
                entityId: entityId,
                reportType: this._def.reportType,
                vtplFork: this._vtplFork,
                reportTemplateId: this._def.reportTemplateId,
                isCreate: isCreate,
                condEl: condEl
            }
        );
    };

    /**
     * 
     *
     * @protected
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$addLine = function () {
        var line = document.createElement('div');
        addClass(line, 'di-o_o-line c-di-o_o-line');
        this.el.appendChild(line);
        this.$bindHover(line);
    };

    /**
     * 
     *
     * @protected
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$removeLine = function (eLine) {
        if (!eLine) {
            return;
        }

        var vtpl = this._vtplFork;
        var els = eLine.getElementsByTagName('*');
        for (var i = 0, eItem, id; eItem = els[i]; i ++) {
            if (id = eItem.getAttribute(DICT.DI_ATTR)) {
                // vuiRef
                // 
                vtpl.removeVUIRefAll(id);
                // depict
                vtpl.removeEntityDef(id);
                // rtplConf
                // rtplConfrtplConf
            }
        }

        this.el.removeChild(eLine);
    };

    /**
     * hover
     *
     * @protected
     * @param {HTMLElement} el 
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$bindHover = function (el) {
        var me = this;

        if (domData(el, 'boundHover')) {
            // 
            return;
        }
        domData(el, 'boundHover', true);

        baiduOn(
            el,
            'mouseenter',
            function (e) {
                var currEPKey = me._currEPKey;

                if (currEPKey == 'EP_DS') {
                    // 
                    // hoverCOMPONENT
                    // data-di-o_o-idCOMPONENT
                    // di-o_o-blockcss
                    // DIdi-o_o-blockCOMPONENT
                    // COMPONENTdi-o_o-blockcss
                    if (!domData(el, 'isFloater')) {
                        me.$highlightCPNT(el, true);
                    }
                }
                else if (currEPKey == 'EP_DETAIL') {
                    // 
                    // 
                    me.$activeFloater(el);
                }
                else if (currEPKey == 'EP_AUTH') {
                    // DO NOTHING
                }
                // e.stopPropagation();
            }
        );
        baiduOn(
            el, 
            'mouseleave', 
            function (e) {
                var currEPKey = me._currEPKey;

                if (currEPKey == 'EP_DS') {
                    !domData(el, 'isFloater') && me.$highlightCPNT(el, false);
                }
                else if (currEPKey == 'EP_DETAIL') {
                    // 
                    // 
                    me.$inactiveFloater(el, false);
                }
                else if (currEPKey == 'EP_AUTH') {
                    // DO NOTHING
                }
                // e.stopPropagation();
            }
        );
    };

    /**
     * componentvui
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$highlightCPNT = function (el, willHighlight) {
        var cpntId;
        var doms = [];
        var vtplFork = this._editor._vtplFork;

        if (willHighlight) {
            cpntId = (vtplFork.findCPNTByDom(el, this._el) || {}).id;
        }
        this.highlightCPNT(cpntId, willHighlight);

        // 
        // 
        var ds = this._editor._ds;
        ds && ds.highlight(cpntId, willHighlight);
    };

    /**
     * @public
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.highlightCPNT = function (cpntId, willHighlight) {
        var els = this._el.getElementsByTagName('*');
        var vtplFork = this._editor._vtplFork;

        for (var i = 0; i < els.length; i ++) {
            if (els[i].getAttribute(DICT.DI_ATTR)) {
                this.$removeHoverStyle(els[i]);
            }
        }

        if (cpntId && willHighlight) {
            var doms = vtplFork.findCPNTDoms(cpntId, this._el);
            for (var i = 0; i < doms.length; i ++) {
                this.$addHoverStyle(doms[i]);
            }
        }
    };

    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$addHoverStyle = function (el) {
        // FIXME
        // ellineitem, block
        el && addClass(el, 'c-di-o_o-hover');
    };

    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$removeHoverStyle = function (el) {
        // FIXME
        // ellineitem, block
        el && removeClass(el, 'c-di-o_o-hover');
    };

    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$belongTo = function (el) {

    };

    //--------------------------------------------------------------------------------
    // 
    //--------------------------------------------------------------------------------

    /**
     * 
     *
     * @protected
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$createFloater = function () {
        var me = this;

        if (!this._lineFloater) {
            var lineFloater = this._lineFloater = document.createElement('div');
            addClass(lineFloater, 'console-floater');
            document.body.appendChild(lineFloater);

            lineFloater.innerHTML = [
                '<div></div>',
                '<div></div>',
                '<div></div>'
            ].join('');

            var ch = children(lineFloater);
            var btnOpt = { primary: 'ui-button-g' };

            this._uAddTextBtn = ecuiCreate(UI_BUTTON, ch[0], null, btnOpt);
            this._uAddVUIBtn = ecuiCreate(UI_BUTTON, ch[1], null, btnOpt);
            this._uRemoveLineBtn = ecuiCreate(UI_BUTTON, ch[2], null, btnOpt);

            lineFloater.style.display = 'none';
            domData(lineFloater, 'isFloater', true);
            this.$bindHover(lineFloater);
        }
    };

    /**
     * 
     *
     * @protected
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$initFloater = function () {
        var editor = this._editor;
        // floater
        this._uAddTextBtn.onclick = editor.bindEditFn(function () {
            this.$addTextItem(this._lineFloater.trigger);
            this.$showFloater(false);
        }, this);
        this._uAddVUIBtn.onclick = editor.bindEditFn(function () {
            this.$addVUIItem(this._lineFloater.trigger);
            this.$showFloater(false);
        }, this);
        this._uRemoveLineBtn.onclick = editor.bindEditFn(function () {
            this.$removeLine(this._lineFloater.trigger);
            this.$showFloater(false);
        }, this);
    };

    /**
     * active floater
     *
     * @protected
     * @param {HTMLElement=} trigger 
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$activeFloater = function (el) {
        var lineFloater = this._lineFloater;

        if (!lineFloater) { return; }

        // FIXME
        // di-o_o-itemhover
        if (!hasClass(el, 'di-o_o-line')
            && !domData(el, 'isFloater')
        ) { 
            return; 
        }

        // 
        lineFloater.needShow = true;

        var currTrigger = lineFloater.trigger;
        if (!domData(el, 'isFloater')) {
            this.$removeHoverStyle(currTrigger)
            currTrigger = lineFloater.trigger = el;
            this.$addHoverStyle(currTrigger)
        }

        // floater
        this.$showFloater(true);
        // floater
        var pos = getPosition(currTrigger);
        var st = lineFloater.style;
        st.left = (pos.left + currTrigger.offsetWidth - lineFloater.offsetWidth) + 'px';
        st.top = (pos.top + 2 - lineFloater.offsetHeight) + 'px';
    };

    /**
     * inactive floater
     *
     * @protected
     * @param {boolean} force 
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$inactiveFloater = function (el, force) {
        var me = this;
        var lineFloater = this._lineFloater;

        if (!lineFloater) { return; }

        // FIXME
        // di-o_o-itemhover
        if (el && !hasClass(el, 'di-o_o-line')
            && !domData(el, 'isFloater')
        ) { 
            return; 
        }
        // 
        lineFloater.needShow = false;

        force 
            ? inact() 
            : setTimeout(
                function () {
                    lineFloater && !lineFloater.needShow && inact();
                }, 
                600
            );

        function inact() {
            lineFloater.trigger && me.$removeHoverStyle(lineFloater.trigger);
            me.$showFloater(false);
        }
    };  

    /**
     * 
     *
     * @protected
     */
    VTPL_SO_QUICK_EDITOR_LAYOUT_CLASS.$showFloater = function (toShow) {
        var lineFloater = this._lineFloater;
        if (!lineFloater) { return; }
        
        var st = lineFloater.style;
        if (toShow && st.display == 'none') {
            st.display = '';
            st.position = 'absolute';
        }
        else if (!toShow && st.display == '') {
            st.display = 'none';
        }
    };

})();
/**
 * di.console.editor.ui.VTplSoQuickEditor
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    vtpl
 *           VTplQuickEditor
 * @author:  xxx(xxx@baidu.com)
 * @depend:  xui, xutil
 */

$namespace('di.console.editor.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var objKey = xutil.object.objKey;
    var alert = di.helper.Dialog.alert;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var jsonParse = baidu.json.parse;
    var encodeHTML = xutil.string.encodeHTML;
    var trim = xutil.string.trim;
    var getParent = xutil.dom.getParent;
    var children = xutil.dom.children;
    var extend = xutil.object.extend;
    var foreachDoOri = UTIL.foreachDoOri;
    var template = xutil.string.template;
    var preInit = UTIL.preInit;
    var stringifyParam = xutil.url.stringifyParam;
    var ecuiCreate = UTIL.ecuiCreate;
    var cmptCreate4Console = UTIL.cmptCreate4Console;
    var cmptSync4Console = UTIL.cmptSync4Console;
    var textParam = xutil.url.textParam;
    var UI_BUTTON = ecui.ui.Button;
    var UI_INPUT = ecui.ui.Input;
    var SELECT = UTIL.select;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var DI_FACTORY;
    var VTPL_SO_QUICK_EDITOR_LAYOUT;
    var VTPL_SO_QUICK_EDITOR_DS;
    var VTPL_SO_QUICK_EDITOR_AUTH;
        
    $link(function() {
        DI_FACTORY = di.shared.model.DIFactory;
        VTPL_SO_QUICK_EDITOR_LAYOUT = di.console.editor.ui.VTplSoQuickEditorLayout;
        VTPL_SO_QUICK_EDITOR_DS = di.console.editor.ui.VTplSoQuickEditorDS;
        VTPL_SO_QUICK_EDITOR_AUTH = di.console.editor.ui.VTplSoQuickEditorAuth;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * vtpl
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     */
    var VTPL_SO_QUICK_EDITOR = $namespace().VTplSoQuickEditor = 
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                addClass(el, 'vtpl-quick-editor');
                el.innerHTML = HTML_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var VTPL_SO_QUICK_EDITOR_CLASS = VTPL_SO_QUICK_EDITOR.prototype;
    
    var HTML_MAIN = [
        '<div class="vtpl-panel-page-btns">',
            '<span></span>',
            '<input class="vtpl-name-input q-vtpl-name"/>',
            '<span class="q-btn-save"></span>',
        '</div>',
        '<div class="vtpl-quick-btn-phase">',
            '<span class="vtpl-quick-btn-phase-item">',
                '<input type="radio" name="di-editor-phase" checked="checked" />',
                '<span></span>',
            '</span>',
            '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;',
            '<span class="vtpl-quick-btn-phase-item">',
                '<input type="radio" name="di-editor-phase" />',
                '<span></span>',
            '</span>',
            '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;',
            '<span class="vtpl-quick-btn-phase-item">',
                '<input type="radio" name="di-editor-phase" />',
                '<span></span>',
            '</span>',
        '</div>',
        '<div class="vtpl-quick-snippet"></div>',
        '<div class="vtpl-quick-ep">',
            '<div class="vtpl-quick-ep-ds" style="display:none">',
            '</div>',
            '<div class="vtpl-quick-ep-auth" style="display:none">',
            '</div>',
            '<div class="vtpl-quick-ep-layout">',
            '</div>',
        '</div>'
    ].join('');

    var EDIT_PHASE = ['EP_DS', 'EP_DETAIL', 'EP_AUTH'];    

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._vtplPanelPage = options.vtplPanelPage;
        this._mVTplModel = options.vtplModel;
        this._mPanelPageManager = options.panelPageManager;
        extend(this, this._vtplPanelPage.vtplMgrGet(this));
    }
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {

        // 
        this._uSaveBtn = ecuiCreate(
            UI_BUTTON, 
            q('q-btn-save', el)[0],
            null, 
            { primary: 'ui-button-g' }
        );
        // 
        this._uSaveBtn.disable('SELF_START_EDIT');

        // 
        this._uNameInput = ecuiCreate(
            UI_INPUT,
            q('q-vtpl-name', el)[0]
        );

        // 
        this._layout = new VTPL_SO_QUICK_EDITOR_LAYOUT(
            { editor: this, el: q('vtpl-quick-ep-layout', el)[0] }
        );
        // 
        this._ds = new VTPL_SO_QUICK_EDITOR_DS(
            { editor: this, el: q('vtpl-quick-ep-ds', el)[0] }
        );
        // 
        this._auth = new VTPL_SO_QUICK_EDITOR_AUTH(
            { editor: this, el: q('vtpl-quick-ep-auth', el)[0] }
        );

        // 
        this.$resetEditPhaseRadio();
    }

    /**
     * 
     *
     * @public
     */
    VTPL_SO_QUICK_EDITOR_CLASS.init = function() {
        var vtplPanelPage = this._vtplPanelPage;

        this._uSaveBtn.onclick = bind(vtplPanelPage.doSave, vtplPanelPage, this);

        // bindEditFnvtplPanelPage
        // editor
        // nameInptonchange
        // bindEditFnnew Function
        this._uNameInput.onchange = this.bindEditFn(new Function(), this);
    };
    
    /**
     * vtplPanelPageeditor(vtplFork)
     *
     * @public
     */
    VTPL_SO_QUICK_EDITOR_CLASS.doRefreshFork = function (vtplFork) {
        var vtpl = this._vtplFork = vtplFork;

        this._uNameInput.setValue(vtpl.vtplName || '');

        if (vtpl.snippet.invalid) {
            alert('snippet');
            this.disable('VTPL_INVALID');
            // FIXME
            // enable
            return;
        }

        // 
        this._layout.resetLayout();
        this._ds.refreshPanelDS();
        this._auth.refreshPanelAuth();

        // DS
        !this._currEPKey && this.$changeEditPhase('EP_DS');
    };

    /**
     * @override
     */
    VTPL_SO_QUICK_EDITOR_CLASS.dispose = function() {
        foreachDoOri(
            [
                this._uSaveBtn,
                this._uRefreshBtn,
                this._uOlapTableBtn,
                this._uOlapChartBtn,
                this._uPlaneTableBtn,
                this._uNameInput,
                this._ds,
                this._layout
            ],
            'dispose',
            true
        );
        VTPL_SO_QUICK_EDITOR.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    VTPL_SO_QUICK_EDITOR_CLASS.$active = function() {
        // ...
    };    

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    VTPL_SO_QUICK_EDITOR_CLASS.$inactive = function() {
        // ...
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_SO_QUICK_EDITOR_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            foreachDoOri(
                [
                    this._uSaveBtn,
                    this._uRefreshBtn,
                    this._uPlaneTableBtn,
                    this._uOlapChartBtn,
                    this._uOlapTableBtn,
                    this._layout,
                    this._ds,
                    this._auth
                ],
                'enable',
                key
            );
            VTPL_SO_QUICK_EDITOR.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    VTPL_SO_QUICK_EDITOR_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            foreachDoOri(
                [
                    this._uSaveBtn,
                    this._uRefreshBtn,
                    this._uPlaneTableBtn,
                    this._uOlapChartBtn,
                    this._uOlapTableBtn,
                    this._layout,
                    this._ds,
                    this._auth
                ],
                'disable',
                key
            );
        }
        VTPL_SO_QUICK_EDITOR.superClass.disable.call(this);
    };

    /**
     * vtplPanelPage
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_CLASS.doStartEdit = function() {
        // 
        this._uSaveBtn.enable('SELF_START_EDIT');
    };

    /**
     * vtplPanelPage
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_CLASS.doSave = function() {
        var vtpl = this._vtplFork;

        this._layout.doSave();

        // FIXME
        // saveAuth
        this._auth.saveAuth();

        // rtplCond
        vtpl.condClean();

        // 
        vtpl.vtplName = this._uNameInput.getValue();

        // stringifyvtplcontent
        var errorMsg = vtpl.contentStringify();

        // FIXME
        // save
        // (!errorMsg || !errorMsg.length)
        //     && this._uSaveBtn.disable('SELF_START_EDIT');

        return {
            vtplFork: vtpl,
            errorMsg: errorMsg
        }
    };

    /**
     * rtplvtplPanelPage
     * 
     * @public
     */
    VTPL_SO_QUICK_EDITOR_CLASS.doCreated = function() {
        // 
        // FIXME 
        // datasource
        this._ds.refreshPanelDS();
    };

    /**
     * condphase
     * condvtpl.rtplCond
     * vtplreportTemplateId
     * 
     * @private
     */
    VTPL_SO_QUICK_EDITOR_CLASS.$syncCond = function (callback) {
        var me = this;
        var vtplFork = this._vtplFork;
        var key = 'VTPL_SO_QUICK_EDITOR';

        // condition
        this._mVTplModel.sync(
            {
                datasourceId: 'EXIST_COND',
                args: {
                    reportTemplateIdList: vtplFork.rtplIdGet(true),
                    virtualTemplateId: vtplFork.vtplKey
                },
                preprocess: function () {
                    // 
                    me.disable(key);
                },
                result: function (data, ejsonObj, options) {
                    // 
                    // merge
                    var existCond = vtplFork.rtplCond;
                    var rtplCond = vtplFork.rtplCond = data.templateDims || {};
                    // 
                    // 
                    // 
                    for (var rid in existCond) {
                        if (rtplCond[rid] && existCond[rid]) {
                            rtplCond[rid] = existCond[rid];
                        }
                    }
                    // 
                    me.enable(key);
                    callback.call(me);
                },
                error: function (status, ejsonObj, options) {
                    me.disable(key);
                    alert('status=' + status);
                    callback.call(me);
                }
            }
        );
    };

    /**
     * edit phase
     * 
     * @protected
     */
    VTPL_SO_QUICK_EDITOR_CLASS.$changeEditPhase = function(epKey) {
        var currEPKey = this._currEPKey;
        var me = this;

        if (currEPKey == 'EP_DS') {
            // datasource
            // componentreporttemplateid
            if (!this._ds.checkAllDSLinked()) {
                DIALOG.alert(LANG.NEED_DS_ALL_LINKED);
                return false;
            }
        }

        if (currEPKey == 'EP_AUTH') {
            // authauthvtpl
            //save
            // FIXME
            // saveAuth
            this._auth.saveAuth();
        }

        if (!currEPKey || currEPKey != epKey) {
            this._currEPKey = epKey;

            if (epKey == 'EP_DS') {
                changePhaseView();
            }
            else if (epKey == 'EP_AUTH') {
                this._auth.refreshPanelAuth();
                changePhaseView();
            }
            else if (epKey == 'EP_DETAIL') {
                this.$syncCond(changePhaseView);
            }
        }

        return true;

        function changePhaseView() {
            me._layout.changeEditPhase(epKey);

            if (epKey == 'EP_DS') {
                me._ds.active();
                me._auth.inactive();
            }
            else if (epKey == 'EP_AUTH') {
                me._ds.inactive();
                me._auth.active();
            }
            else if (epKey == 'EP_DETAIL') {
                me._ds.inactive();
                me._auth.inactive();
            }
        }
    };

    // TODO
    // radio
    VTPL_SO_QUICK_EDITOR_CLASS.$resetEditPhaseRadio = function () {
        var ee = q('vtpl-quick-btn-phase', this.getEl())[0];
        var ch = children(ee);
        var me = this;

        for (var i = 0, o; o = ch[i]; i ++) {
            o.onclick = (function (ph) {
                return function () {
                    if (me.$changeEditPhase(ph)) {
                        this.getElementsByTagName('input')[0].checked = true;
                    }
                    else {
                        return false;
                    }
                };
            })(EDIT_PHASE[i]);
        }
    };

    /**
     * 
     * 
     * @protected
     */
    VTPL_SO_QUICK_EDITOR_CLASS.$handleFatalError = function(status) {
        this.disable();
        // // 
        // if (status == 1001) {
        //     DIALOG.alert(LANG.SAD_FACE + LANG.PARAM_ERROR);
        // }
        // else {
        //     DIALOG.alert(LANG.SAD_FACE + LANG.FATAL_DATA_ERROR);
        // }
    };

})();

/**
 * di.console.mgr.ui.CmdPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui, xutil
 */
$namespace('di.console.editor.ui');

(function() {

    //------------------------------------------
    //  
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var addEventListener = ecui.addEventListener;
    var extend = xutil.object.extend;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var parseParam = xutil.url.parseParam;
    var q = xutil.dom.q;
    var children = xutil.dom.children;
    var $fastCreate = ecui.$fastCreate;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var getUID = xutil.uid.getUID;
    var ecuiCreate = UTIL.ecuiCreate;
    var ajaxRequest = baidu.ajax.request;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var textParam = xutil.url.textParam;
    var jsonParse = baidu.json.parse;
    var UI_BUTTON = ecui.ui.Button;
    var PANEL_PAGE_MANAGER;
    var PANEL_PAGE_TAB_ADAPTER;
    var UI_TAB_CONTAINER = ecui.ui.TabContainer;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;
    var CUBE_CONFIG_PANEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
        PANEL_PAGE_MANAGER = di.shared.model.PanelPageManager;
        PANEL_PAGE_TAB_ADAPTER = di.shared.model.PanelPageTabAdapter;
        CUBE_CONFIG_PANEL = di.console.shared.ui.CubeConfigPanel;
    });

    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     * @param {Object} options
     * @param {string} options.dsId 
     */
    var CMD_PAGE = $namespace().CmdPage =
        inheritsObject(
            PANEL_PAGE,
            function(options) {
                var el = options.el;
                addClass(el, 'cmd-page');
                el.innerHTML = SNIPPET_MAIN;
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var CMD_PAGE_CLASS = CMD_PAGE.prototype;

    //------------------------------------------
    // 
    //------------------------------------------

    var SNIPPET_MAIN = [
        '<div class="cmd-page-btns"></div>',
        '<div class="q-main"></div>'
    ].join('');

    //------------------------------------------
    // 
    //------------------------------------------

    /**
     * Model
     *
     * @private
     */
    function createModel(el, options) {
        this._mPanelPageManager = new PANEL_PAGE_MANAGER(
            { adapter: PANEL_PAGE_TAB_ADAPTER }
        );
        this._mVTplModel = options.vtplModel;
    }

    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        this._uMainContainer = $fastCreate(
            UI_TAB_CONTAINER,
            q('q-main', this.getEl())[0],
            null,
            { primary: 'ui-tab' }
        );

        this._uCubeConfigPanel = new CUBE_CONFIG_PANEL({ parent: this });
    }

    /**
     * 
     *
     * @public
     */
    CMD_PAGE_CLASS.init = function() {
        var me = this;

        this._mPanelPageManager.inject(this._uMainContainer);
        this._mPanelPageManager.attach(
            'page.active',
            this.$pageActiveHandler,
            this
        );
        this._uCubeConfigPanel.attach(
            'select',
            this.$openEditor,
            this
        )

        this._mPanelPageManager.init();
        this._uCubeConfigPanel.init();

        // FIXME
        // 
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        var eee = document.createElement('div');
        var btns = q('cmd-page-btns', this.getEl())[0]
        eee.innerHTML = '<input type="button" value="" />';
        eee = eee.firstChild;
        btns.appendChild(eee);
        eee.onclick = function () {
            me.openCubeConfigPanel('RTPL_OLAP_TABLE');
        };
        eee.innerHTML = '<input type="button" value="" />';
        eee = eee.firstChild;
        btns.appendChild(eee);
        eee.onclick = function () {
            me.openCubeConfigPanel('RTPL_OLAP_CHART');
        };
        eee.innerHTML = '<input type="button" value="" />';
        eee = eee.firstChild;
        btns.appendChild(eee);
        eee.onclick = function () {
            var reportTemplateId = q('q-cmd-page-rtpl-input', btns)[0].value;
            if (!reportTemplateId) {
                // 
                me.openCubeConfigPanel('RTPL_PLANE_TABLE');
            }
            else {
                // 
                var reportType = 'RTPL_PLANE_TABLE';
                me._mPanelPageManager.openByURI(
                    'di.console.editor.ui.PlaneEditor?'
                        + [
                            'reportTemplateId=' + reportTemplateId,
                            'reportType=' + reportType,
                            'pageId=' + reportType + '_' + reportTemplateId + '_' + getUID(),
                            'pageTitle=[] ' + reportType + '_' + reportTemplateId,
                            'act=EDIT'
                        ].join('&')
                );
            }
        };
        eee.innerHTML = '<input type="button" value="tmp snippet code" />';
        eee = eee.firstChild;
        btns.appendChild(eee);
        eee.onclick = function () {
            me.$openEditor(
                {
                    menuId: Math.random(), 
                    menuUrl: 'di.console.editor.ui.SnippetCodeEditor?'
                        + [
                            'pageTitle=[Code]'
                        ].join('&')
                }
            );
        };
        eee.innerHTML = '<input class="q-cmd-page-rtpl-input" type="input" />';
        btns.appendChild(eee.firstChild);
    };

    /**
     * @override
     */
    CMD_PAGE_CLASS.dispose = function() {
        this._mPanelPageManager.dispose();
        CMD_PAGE.superClass.dispose.call(this);
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage
     */
    CMD_PAGE_CLASS.$active = function() {
        // TODO
    };

    /**
     * @override
     * @see di.shared.ui.PanelPage     
     */
    CMD_PAGE_CLASS.$inactive = function() {
        // TODO
    };

   /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    CMD_PAGE_CLASS.enable = function(key) {
        objKey.remove(this, key);

        if (objKey.size(this) === 0 && this._bDisabled) {
            // TODO
            CMD_PAGE.superClass.enable.call(this);
        }
    };

    /**
     * 
     *
     * @protected
     * @param {string} key 
     */
    CMD_PAGE_CLASS.disable = function(key) {
        objKey.add(this, key);

        if (!this._bDisabled) {
            // TODO
        }
        CMD_PAGE.superClass.disable.call(this);
    };

    /**
     * 
     */
    CMD_PAGE_CLASS.$pageActiveHandler = function(menuId) {
        // TODO
    };

    /**
     * cube
     */
    CMD_PAGE_CLASS.openCubeConfigPanel = function(reportType) {
        this._uCubeConfigPanel.changeReportType(reportType);
        this._uCubeConfigPanel.open();
    };

    /**
     * tab
     */
    CMD_PAGE_CLASS.$openEditor = function(menuItem) {
        this._mPanelPageManager.openByURI(
            menuItem.menuUrl,
            { vtplModel: this._mVTplModel }
        );
    };

})();
/**
 * di.console.mgr.ui.ReportListPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    
 * @author:  xxx(xxx@baidu.com)
 * @depend:  ecui, xui, xutil
 */

$namespace('di.console.mgr.ui');

(function() {
    
    //------------------------------------------
    //  
    //------------------------------------------

    var inheritsControl = ecui.inherits;
    var blank = new Function();
    var addClass = ecui.dom.addClass;
    var removeClass = ecui.dom.removeClass;
    var addEventListener = ecui.addEventListener;
    var extend = xutil.object.extend;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var template = xutil.string.template;
    var preInit = di.helper.Util.preInit;
    var ecuiCreate = di.helper.Util.ecuiCreate;
    var PANEL_PAGE = di.shared.ui.PanelPage;
    var UI_CONTROL = ecui.ui.Control;
    var UI_SELECT = ecui.ui.Select;
    var UI_RADIO_CONTAINER = ecui.ui.RadioContainer;
    var DICT = di.config.Dict;
    var PANEL_PAGE_MANAGER;
        
    $link(function() {
        PANEL_PAGE_MANAGER = di.shared.model.PanelPageManager;
    });
    
    //------------------------------------------
    //  
    //------------------------------------------

    /**
     * 
     * 
     * @class
     * @extends di.shared.ui.PanelPage
     */
    var REPORT_LIST_PAGE = $namespace().ReportListPage = 
        inheritsControl(
            PANEL_PAGE,
            'report-list-page',
            function(el, options) {
                preInit(this, el, options);
                el.innerHTML = template(TPL_MAIN);
            },
            function(el, options) {
                createModel(el, options);
                createView(el, options);
            }
        );
    var REPORT_LIST_PAGE_CLASS = REPORT_LIST_PAGE.prototype;
    
    /*  */       
    var TPL_MAIN = [
        '<div class="olap-condition">',
            '',
        '</div>',
        '<div class="olap-table">',
            '',
        '</div>'
    ].join('');
    
    //------------------------------------------
    // 
    //------------------------------------------

    /* $setSize */
    REPORT_LIST_PAGE_CLASS.$setSize = blank;

    /**
     * Model
     *
     * @private
     */
    function createModel() {
        // TODO
        // this._mXXXModel = new XXXModel();
        // this._mXXXModel = new XXXModel();
    };
    
    /**
     * View
     *
     * @private
     */
    function createView(el, options) {
        // TODO
        // this._uXXXControl = ecuiCreate(
        //     XXXCONTROL, 
        //     q('q-some-el-class', el)[0], 
        //     this
        // );
        // this._uXXXControl = ecuiCreate(
        //     XXXCONTROL, 
        //     q('q-some-el-class', el)[0], 
        //     this
        // );
    };
    
    /**
     * 
     *
     * @public
     */
    REPORT_LIST_PAGE_CLASS.init = function() {

        // 
        // commonModelUpdateHandler = bind(this.$commonModelUpdateHandler, this);
        // addEventListener(this._uAccountRangeType, 'change', bind(this.$accountRangTypeChangeHandler, this));
        // addEventListener(this._uAccountRangeType, 'change', commonModelUpdateHandler);
        // addEventListener(this._uAccountRange, 'change', commonModelUpdateHandler);
        // addEventListener(this._uOpenAccountDuration, 'change', commonModelUpdateHandler);
        // this._eInherit.onclick = commonModelUpdateHandler;

        // init
        // this._mXXXModel.init();
        // this._uXXXControl.init();

        // 
        // this._mXXXModel.sync('INIT');
    };

    /**
     * @override
     */
    REPORT_LIST_PAGE_CLASS.$active = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.active();
    };    

    /**
     * @override
     */
    REPORT_LIST_PAGE_CLASS.$inactive = function() {
        // var page = this._mTimeTypePageManager.getCurrentPage();
        // page && page.inactive();
    };

    /**
     * @override
     */
    REPORT_LIST_PAGE_CLASS.$dispose = function() {
        // this._eAnalysisArea = null;
        // this._eCondtionArea = null;
        // this._mTimeTypePageManager.dispose();
        // this._eInherit = null;
        REPORT_LIST_PAGE.superClass.$dispose.call(this);
    };
    
})();
/**
 * di.console.frame.ui.ConsoleFrame
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:     / 
 * author:  sushuang(sushuang@baidu.com)
 * depend:  ecui
 */

$namespace('di.console.frame.ui');

(function() {
    
    //-----------------------------------------
    // 
    //-----------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var MENU_MAIN_PAGE = di.console.shared.ui.MenuMainPage;
    var DICT = di.config.Dict;
    var URL = di.config.URL;
    var CUBE_META_MODEL;
    var GLOBAL_MODEL;
    var q = xutil.dom.q;
    var preInit = ecui.util.preInit;
    var $fastCreate = ecui.$fastCreate;
    var template = xutil.string.template;
    var parseParam = xutil.url.parseParam;
    var isString = xutil.lang.isString;
    var getByPath = xutil.object.getByPath;
    var bind = xutil.fn.bind;
    var XVIEW = xui.XView;
    var PL_FLOAT_MENU = ecui.ui.PlFloatMenu;
    var UI_TAB_CONTAINER = ecui.ui.TabContainer;
    var DICT = di.config.Dict;
    var URL = di.config.URL;
    var MENU_PAGE_MANAGER;
    var PANEL_PAGE_MANAGER;
    var PANEL_PAGE_TAB_ADAPTER;
    var VTPL_MODEL;

    $link(function() {
        var sharedNS = di.shared;
        CUBE_META_MODEL = sharedNS.model.CubeMetaModel;
        GLOBAL_MODEL = sharedNS.model.GlobalModel;
        PANEL_PAGE_MANAGER = sharedNS.model.PanelPageManager;
        PANEL_PAGE_TAB_ADAPTER = sharedNS.model.PanelPageTabAdapter;
        MENU_PAGE_MANAGER = sharedNS.model.MenuPageManager;
        VTPL_MODEL = di.console.editor.model.VTplModel;
    });    

    //-----------------------------------------
    // 
    //-----------------------------------------

    var CONSOLE_FRAME = $namespace().ConsoleFrame = 
        inheritsObject(
            XVIEW, 
            function(options) {
                var el = options.el;
                el.innerHTML = template(TPL_MAIN);
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );
    var CONSOLE_FRAME_CLASS = CONSOLE_FRAME.prototype;
    
    /*  */    
    var TPL_MAIN = [
            '<div class="main-left">', 
	            '<div class="menu-mgr menu-sep">',
		            '<div class="ui-menu q-menu-myview"><label>&nbsp;</label></div>',
		        '</div>',
                '<div class="menu-mgr menu-sep">',
                    '<div class="ui-menu q-menu-createbymold"><label>&nbsp;</label></div>',
                '</div>',
               // '<div class="menu-vtpl">',
               //     '<div class="ui-menu q-menu-vtpl"><label>&nbsp;</label></div>',
               // '</div>',
               // '<div class="menu-mold menu-sep">',
               //     '<div class="ui-menu q-menu-mold"><label>&nbsp;</label></div>',
               // '</div>',
                '<div class="menu-mgr menu-sep">',
                    '<div class="ui-menu q-menu-mgr"><label>&nbsp;</label></div>',
                '</div>',
                '<div class="menu-mgr menu-sep">',
                   '<div class="ui-menu q-menu-dimgr"><label>&nbsp;</label></div>',
                '</div>',
            '</div>',
            '<div class="main-right">',
                '<div class="ui-tab q-main"></div>',
            '</div>',
            '<div class="clear"></div>'
        ].join('');

    //-----------------------------------------
    // 
    //-----------------------------------------

    /**
     * Model
     *
     * @private
     * @param {Object} options 
     */
    function createModel(el, options) {
        // tabContainer
        this._mPanelPageManager = new PANEL_PAGE_MANAGER(
            { adapter: PANEL_PAGE_TAB_ADAPTER }
        );
        this._mVTplModel = new VTPL_MODEL();
    }

    /**
     * View
     * 
     * @private
     * @param {Object} options 
     */
    function createView(el, options) {
    	this._uMyViewMenu = $fastCreate(PL_FLOAT_MENU, q('q-menu-myview', el)[0], null);
        this._uCreateByMoldMenu = $fastCreate(PL_FLOAT_MENU, q('q-menu-createbymold', el)[0], null);
        //this._uVTplMenu = $fastCreate(PL_FLOAT_MENU, q('q-menu-vtpl', el)[0], null);
        //this._uMoldMenu = $fastCreate(PL_FLOAT_MENU, q('q-menu-mold', el)[0], null);
        this._uMgrMenu = $fastCreate(PL_FLOAT_MENU, q('q-menu-mgr', el)[0], null);
        this._diMgrMenu = $fastCreate(PL_FLOAT_MENU, q('q-menu-dimgr', el)[0], null);
        this._uMainContainer = $fastCreate(
            UI_TAB_CONTAINER,
            q('q-main', el)[0],
            null,
            { primary: 'ui-tab' }
        );
    }

    /**
     * @override
     */
    CONSOLE_FRAME_CLASS.init = function () {
        this._mPanelPageManager.inject(this._uMainContainer);
        this._uMyViewMenu.onchange = bind(this.$menuChangeHandler, this);
        this._uCreateByMoldMenu.onchange = bind(this.$menuChangeHandler, this);
        //this._uVTplMenu.onchange = bind(this.$menuChangeHandler, this);
        //this._uMoldMenu.onchange = bind(this.$menuChangeHandler, this);
        this._uMgrMenu.onchange = bind(this.$menuChangeHandler, this);
        this._diMgrMenu.onchange = bind(this.$openDataSourcePage, this);
        this._mPanelPageManager.attach(
            'page.active',
            this.$pageActiveHandler,
            this
        );

       // this._mVTplModel.attach(
       //     ['sync.result.VTPL_LIST', this.$renderVTplList, this],
       //     ['sync.result.MOLD_LIST', this.$renderMoldList, this]
       //     // TODO
       //     // disable / enable
       // );
        this.$renderDiMgrList();
        this.$renderCreateByMold();
        this.$renderMgrList();
        this.$renderMyViewList();
       // this.$renderDiMgrList();
       
        this._mPanelPageManager.init();
        this._mVTplModel.init();

        // 
       // this._mVTplModel.sync({ datasourceId: 'VTPL_LIST' });
       // this._mVTplModel.sync({ datasourceId: 'MOLD_LIST' });
        
    };
    
    /**
     * @override
     */
    CONSOLE_FRAME_CLASS.dispose = function () {
        this._mPanelPageManager.dispose();
        CONSOLE_FRAME.superClass.dispose.call(this);
    };


    /**
     * @override
     */
    CONSOLE_FRAME_CLASS.$openDataSourcePage = function () {
        window.open('manage/showdatasource.action');
    };
    
    /**
     * 
     * @protected
     * 
     * @param {Object} menuItem 
     *          {string} menuId ID
     *          {string} menuName 
     *          {string} menuUrl URL
     */
    CONSOLE_FRAME_CLASS.$menuChangeHandler = function(menuItem) {
        this._mPanelPageManager.openByURI(
            menuItem.menuUrl,
            { vtplModel: this._mVTplModel, forceActive: true }
        );
    };
    
    /**
     * 
     */
    CONSOLE_FRAME_CLASS.$pageActiveHandler = function(menuId) {
        // vtplmold
        // if (menuId.indexOf('MENU_ID_VTPL') > -1) {
        //    //this._uVTplMenu.select(menuId);
        //    //this._uMoldMenu.select(null);
        //     this._uMgrMenu.select(null);
        //     this._uMyViewMenu.select(null);
        //     this._uCreateByMoldMenu.select(null);
        // }
        // else if (menuId.indexOf('MENU_ID_MOLD') > -1) {
        //    this._uVTplMenu.select(null);
        //    this._uMoldMenu.select(menuId);
        //     this._uMgrMenu.select(null);
        //     this._uMyViewMenu.select(null);
        //     this._uCreateByMoldMenu.select(null);
        // }
        if (menuId.indexOf('MENU_ID_MGR') > -1) {
            this._uMgrMenu.select(menuId);
            this._uMyViewMenu.select(null);
            this._uCreateByMoldMenu.select(null);
            this._diMgrMenu.select(null);
        }
        else if (menuId.indexOf('MENU_ID_MYVIEW') > -1) {
            this._uMgrMenu.select(null);
            this._uMyViewMenu.select(menuId);
            this._uCreateByMoldMenu.select(null);
            this._diMgrMenu.select(null);
        }
        else if (menuId.indexOf('MENU_ID_CREATEBYMOLD') > -1) {
            this._uMgrMenu.select(null);
            this._uMyViewMenu.select(null);
            this._uCreateByMoldMenu.select(menuId);
            this._diMgrMenu.select(null);
        }
        else if (menuId.indexOf('MENU_ID_DIMGR') > -1) {
            this._uMgrMenu.select(null);
            this._uMyViewMenu.select(null);
            this._uCreateByMoldMenu.select(menuId);
            this._diMgrMenu.select(null);
        }
        else {
            this._uMgrMenu.select(null);
            this._uMyViewMenu.select(null);
            this._uCreateByMoldMenu.select(null);
            this._diMgrMenu.select(null);
        }
    };
    
    /**
     * @private
     */
    CONSOLE_FRAME_CLASS.$renderVTplList = function() {
       // var menuTree = this._mVTplModel.getVTplMenuData().menuTree;
       // this._uVTplMenu.setData(menuTree.menuList);
       // this._uVTplMenu.select(menuTree.selMenuId);
    };

    CONSOLE_FRAME_CLASS.$renderDiMgrList = function() {
       var menuTree = this.getVTplMenuData().menuTree;
       this._diMgrMenu.setData(menuTree.menuList);
       this._diMgrMenu.select(menuTree.selMenuId);
    };


    CONSOLE_FRAME_CLASS.getVTplMenuData = function() {
        var menuList = [];
        var menuTree = { menuList: menuList };
        var selMenuId;
        var chList = [];
        var prefix = 'MENU_ID_DIMGR';

        menuList.push(
            {
                text: '',
                value: prefix + '1',
                children: chList
            }
        );
        for(var i=0; i < 1; i++ ) {
            var pageId = 'test' + 'getUID';
            chList.push(
                {
                    text: '',
                    prompt: '',
                    floatTree: [
                            {
                                value: prefix + String(Math.random()),
                                children: [
                                    {
                                        text: '',
                                        value: prefix + String(Math.random())
                                    }
                                ]
                            }
                        ]
                }
            );
        }

        menuTree.selMenuId = prefix + '1';

        return { menuTree: menuTree };
    };
    

    /**
     * @private
     */
    CONSOLE_FRAME_CLASS.$renderMoldList = function() {
       // var menuTree = this._mVTplModel.getMoldMenuData().menuTree;
       // this._uMoldMenu.setData(menuTree.menuList);
       // this._uMoldMenu.select(menuTree.selMenuId);
    };

    /**
     * @private
     */
    CONSOLE_FRAME_CLASS.$renderMgrList = function() {
        var prefix = 'MENU_ID_MGR'
        var cmdMenuId = prefix + 1;
        var menuList = [];

        menuList.push(
            {
                text: '',
                value: cmdMenuId,
                url: 'di.console.editor.ui.CmdPage?pageId=' 
                    + cmdMenuId + '&pageTitle=' + ''
            }
        );

        this._uMgrMenu.setData(menuList);
        this._uMgrMenu.select(cmdMenuId);
    };

     /**
     * @private
     */
    CONSOLE_FRAME_CLASS.$renderCreateByMold = function() {
        var prefix = 'MENU_ID_CREATEBYMOLD'
        var cmdMenuId = prefix + 1;
        var menuList = [];

        menuList.push(
            {
                text: '()',
                value: cmdMenuId,
                url: 'di.console.editor.ui.MoldListPanelPage?pageId=' 
                    + cmdMenuId + '&pageTitle=' + ''
            }
        );

        this._uCreateByMoldMenu.setData(menuList);
        this._uCreateByMoldMenu.select(cmdMenuId);
    };
    
    
    /**
     * @private
     */
    CONSOLE_FRAME_CLASS.$renderMyViewList = function() {
        var prefix = 'MENU_ID_MYVIEW'
        var cmdMenuId = prefix;
        var menuList = [];
        var myViewUrl = 'di.console.editor.ui.MyViewPanelPage?pageId=' 
            + cmdMenuId + '&pageTitle=' + ''+ '&act=' + 'EDIT#QUICK';
        menuList.push(
            {
                text: '',
                value: cmdMenuId,
                url: myViewUrl
            }
        );

        this._uMyViewMenu.setData(menuList);
        this._uMyViewMenu.select(cmdMenuId);
        
        this._mPanelPageManager.openByURI(
        		myViewUrl,
                { vtplModel: this._mVTplModel, forceActive: true }
            ); 
    };

})();


/**
 * di.console.frame.ui.MainPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    [] Data Insight
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  ecui
 */

$namespace('di.console.frame.ui');

(function() {
    
    //-----------------------------------------------
    // 
    //-----------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var getByPath = xutil.object.getByPath;
    var XVIEW = xui.XView;
    var ecuiCreate = di.helper.Util.ecuiCreate;
    var DICT = di.config.Dict;
    var URL = di.config.URL;
    var DOM = xutil.dom;
    var q = DOM.q;
    var LANG = di.config.Lang;
    var GLOBAL_MENU;
    var GLOBAL_MODEL;
    var DI_FACTORY;
        
    $link(function() {
        GLOBAL_MENU = di.console.shared.ui.GlobalMenu;
        GLOBAL_MODEL = di.shared.model.GlobalModel;
        DI_FACTORY = di.shared.model.DIFactory;
    });
        
    //-----------------------------------------------
    // 
    //-----------------------------------------------

    /**
     * 
     *
     * @class
     * @extends xui.XView
     */
    var MAIN_PAGE = $namespace().MainPage = 
        inheritsObject(
            XVIEW,
            function(options) {
                checkEnv();
                consoleInit.call(this, options);
                createView.call(this, options);
            }
        );
    var MAIN_PAGE_CLASS = MAIN_PAGE.prototype;

    var canInit = true;
        
    //-----------------------------------------------
    // 
    //-----------------------------------------------

    /**
     * @override
     */
    XVIEW.$domReady = ecui.dom.ready;

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function checkEnv() {
        // FIXME
        // ie8
        // 
        if (DOM.ieVersion < 8
            || DOM.firefoxVersion < 10
            || DOM.chromeVersion < 10
        ) {
            canInit = false;
            document.body.innerHTML = [
                '<div style="color: #0DA823; font-size:16px; font-weight: 2px; text-align: center; margin-top: 50px">',
                    LANG.SAD_FACE,
                    '<span style="border:1px #17E734 solid; padding: 5px 10px;">ie8+, chrome10+, firefox10+</span>',
                '</div>'
            ].join('');
            return;
        }
    }

    /**
     * 
     *
     * @private
     * @param {Object} options 
     */
    function consoleInit(options) {
        if (!canInit) { return; }

        // web
        URL.setWebRoot(options.webRoot);

        // global model
        GLOBAL_MODEL(options);

        // repoclass
        DI_FACTORY().installClz();
    }

    /**
     * View
     *
     * @private
     * @param {Object} options 
     */
    function createView(options) {
        if (!canInit) { return; }

        // 
        var o;
        options = options || {};
        q('q-global-main')[0].appendChild(o = document.createElement('div'));
        this._uGlobalMenu = ecuiCreate(
            GLOBAL_MENU, 
            q('q-global-menu')[0], 
            null
        );
        if (options.pageClass) {
            this._uMainContainer = 
                new (
                    getByPath(options.pageClass, $getNamespaceBase())
                )({ el: o });
        }
    };
    
    /**
     * @override
     */
    MAIN_PAGE_CLASS.init = function() {
        if (!canInit) { return; }

        MAIN_PAGE.superClass.init.call(this);

        // 
        var o = GLOBAL_MODEL().getGlobalMenuManager();
        this._uGlobalMenu.setGlobalMenuManager(o);
        o.setGlobalMenu(this._uGlobalMenu);

        // 
        this._uGlobalMenu.init();
        this._uMainContainer && this._uMainContainer.init();
    }

    /**
     * @override
     */
    MAIN_PAGE_CLASS.dispose = function() {
        GLOBAL_MODEL().dispose();
        MAIN_PAGE.superClass.$dispose.call(this);
    };

})();


/**
 * project link
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    
 * @author:  sushuang(sushuang@baidu.com)
 * @depend:  xui.XProject
 */

// 
xui.XProject.doLink();
// 
xui.XProject.doEnd()